# Comparing `tmp/FiberFusing-0.3.9-py3-none-any.whl.zip` & `tmp/FiberFusing-0.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,68 @@
-Zip file size: 31905 bytes, number of entries: 27
--rw-r--r--  2.0 unx      446 b- defN 23-Mar-13 02:33 FiberFusing/__init__.py
--rw-r--r--  2.0 unx     5183 b- defN 23-Mar-13 02:33 FiberFusing/axes.py
--rw-r--r--  2.0 unx     7169 b- defN 23-Mar-13 02:33 FiberFusing/baseclass.py
--rw-r--r--  2.0 unx    18556 b- defN 23-Mar-13 02:33 FiberFusing/buffer.py
--rw-r--r--  2.0 unx    13342 b- defN 23-Mar-13 02:33 FiberFusing/connection.py
--rw-r--r--  2.0 unx    14235 b- defN 23-Mar-13 02:33 FiberFusing/fiber_base_class.py
--rw-r--r--  2.0 unx     7032 b- defN 23-Mar-13 02:33 FiberFusing/fiber_catalogue.py
--rw-r--r--  2.0 unx    13611 b- defN 23-Mar-13 02:33 FiberFusing/geometry.py
--rw-r--r--  2.0 unx      264 b- defN 23-Mar-13 02:33 FiberFusing/plot_style.py
--rw-r--r--  2.0 unx     3799 b- defN 23-Mar-13 02:33 FiberFusing/rings.py
--rw-r--r--  2.0 unx     5124 b- defN 23-Mar-13 02:33 FiberFusing/utils.py
--rw-r--r--  2.0 unx      773 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused1.py
--rw-r--r--  2.0 unx     1019 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused10.py
--rw-r--r--  2.0 unx     1127 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused12.py
--rw-r--r--  2.0 unx     1153 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused19.py
--rw-r--r--  2.0 unx     1085 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused2.py
--rw-r--r--  2.0 unx     1092 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused3.py
--rw-r--r--  2.0 unx     1148 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused4.py
--rw-r--r--  2.0 unx     1144 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused5.py
--rw-r--r--  2.0 unx     1148 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused6.py
--rw-r--r--  2.0 unx     1156 b- defN 23-Mar-13 02:33 FiberFusing/instances/Fused7.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-13 02:33 FiberFusing/instances/__init__.py
--rw-r--r--  2.0 unx     1072 b- defN 23-Mar-13 02:34 FiberFusing-0.3.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     3681 b- defN 23-Mar-13 02:34 FiberFusing-0.3.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-13 02:34 FiberFusing-0.3.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 23-Mar-13 02:34 FiberFusing-0.3.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2265 b- defN 23-Mar-13 02:34 FiberFusing-0.3.9.dist-info/RECORD
-27 files, 106728 bytes uncompressed, 28259 bytes compressed:  73.5%
+Zip file size: 82395 bytes, number of entries: 66
+-rw-r--r--  2.0 unx        6 b- defN 23-May-03 21:22 FiberFusing/VERSION
+-rw-r--r--  2.0 unx      446 b- defN 23-May-03 21:22 FiberFusing/__init__.py
+-rw-r--r--  2.0 unx     6065 b- defN 23-May-03 21:22 FiberFusing/axes.py
+-rw-r--r--  2.0 unx     7170 b- defN 23-May-03 21:22 FiberFusing/baseclass.py
+-rw-r--r--  2.0 unx    18410 b- defN 23-May-03 21:22 FiberFusing/buffer.py
+-rw-r--r--  2.0 unx    13342 b- defN 23-May-03 21:22 FiberFusing/connection.py
+-rw-r--r--  2.0 unx    19084 b- defN 23-May-03 21:22 FiberFusing/fiber_base_class.py
+-rw-r--r--  2.0 unx     8421 b- defN 23-May-03 21:22 FiberFusing/fiber_catalogue.py
+-rw-r--r--  2.0 unx    14184 b- defN 23-May-03 21:22 FiberFusing/geometry.py
+-rw-r--r--  2.0 unx      264 b- defN 23-May-03 21:22 FiberFusing/plot_style.py
+-rw-r--r--  2.0 unx     3799 b- defN 23-May-03 21:22 FiberFusing/rings.py
+-rw-r--r--  2.0 unx     5775 b- defN 23-May-03 21:22 FiberFusing/utils.py
+-rw-r--r--  2.0 unx      733 b- defN 23-May-03 21:23 FiberFusing/__pycache__/__init__.cpython-310.pyc
+-rw-r--r--  2.0 unx     7174 b- defN 23-May-03 21:23 FiberFusing/__pycache__/axes.cpython-310.pyc
+-rw-r--r--  2.0 unx     7394 b- defN 23-May-03 21:23 FiberFusing/__pycache__/baseclass.cpython-310.pyc
+-rw-r--r--  2.0 unx    20681 b- defN 23-May-03 21:23 FiberFusing/__pycache__/buffer.cpython-310.pyc
+-rw-r--r--  2.0 unx    13389 b- defN 23-May-03 21:23 FiberFusing/__pycache__/connection.cpython-310.pyc
+-rw-r--r--  2.0 unx    12851 b- defN 23-May-03 21:23 FiberFusing/__pycache__/geometry.cpython-310.pyc
+-rw-r--r--  2.0 unx      340 b- defN 23-May-03 21:23 FiberFusing/__pycache__/plot_style.cpython-310.pyc
+-rw-r--r--  2.0 unx     3747 b- defN 23-May-03 21:23 FiberFusing/__pycache__/rings.cpython-310.pyc
+-rw-r--r--  2.0 unx     5178 b- defN 23-May-03 21:23 FiberFusing/__pycache__/utils.cpython-310.pyc
+-rw-r--r--  2.0 unx       49 b- defN 23-May-03 21:22 FiberFusing/examples/clad/README.rst
+-rw-r--r--  2.0 unx      176 b- defN 23-May-03 21:22 FiberFusing/examples/clad/plot_clad01x01.py
+-rw-r--r--  2.0 unx      217 b- defN 23-May-03 21:22 FiberFusing/examples/clad/plot_clad02x02.py
+-rw-r--r--  2.0 unx      214 b- defN 23-May-03 21:22 FiberFusing/examples/clad/plot_clad03x03.py
+-rw-r--r--  2.0 unx      216 b- defN 23-May-03 21:22 FiberFusing/examples/clad/plot_clad04x04.py
+-rw-r--r--  2.0 unx      217 b- defN 23-May-03 21:22 FiberFusing/examples/clad/plot_clad07x07.py
+-rw-r--r--  2.0 unx      220 b- defN 23-May-03 21:22 FiberFusing/examples/clad/plot_clad12x12.py
+-rw-r--r--  2.0 unx      220 b- defN 23-May-03 21:22 FiberFusing/examples/clad/plot_clad19x19.py
+-rw-r--r--  2.0 unx       57 b- defN 23-May-03 21:22 FiberFusing/examples/geometry/README.rst
+-rw-r--r--  2.0 unx      524 b- defN 23-May-03 21:22 FiberFusing/examples/geometry/plot_geometry1x1.py
+-rw-r--r--  2.0 unx      543 b- defN 23-May-03 21:22 FiberFusing/examples/geometry/plot_geometry2x2.py
+-rw-r--r--  2.0 unx      543 b- defN 23-May-03 21:22 FiberFusing/examples/geometry/plot_geometry3x3.py
+-rw-r--r--  2.0 unx      543 b- defN 23-May-03 21:22 FiberFusing/examples/geometry/plot_geometry4x4.py
+-rw-r--r--  2.0 unx      557 b- defN 23-May-03 21:22 FiberFusing/examples/geometry/plot_geometry7x7.py
+-rw-r--r--  2.0 unx       61 b- defN 23-May-03 21:22 FiberFusing/examples/validation/README.rst
+-rw-r--r--  2.0 unx      165 b- defN 23-May-03 21:22 FiberFusing/examples/validation/SZ_fusion_degree.py
+-rw-r--r--  2.0 unx      773 b- defN 23-May-03 21:22 FiberFusing/instances/Fused1.py
+-rw-r--r--  2.0 unx     1019 b- defN 23-May-03 21:22 FiberFusing/instances/Fused10.py
+-rw-r--r--  2.0 unx     1127 b- defN 23-May-03 21:22 FiberFusing/instances/Fused12.py
+-rw-r--r--  2.0 unx     1153 b- defN 23-May-03 21:22 FiberFusing/instances/Fused19.py
+-rw-r--r--  2.0 unx     1085 b- defN 23-May-03 21:22 FiberFusing/instances/Fused2.py
+-rw-r--r--  2.0 unx     1092 b- defN 23-May-03 21:22 FiberFusing/instances/Fused3.py
+-rw-r--r--  2.0 unx     1148 b- defN 23-May-03 21:22 FiberFusing/instances/Fused4.py
+-rw-r--r--  2.0 unx     1144 b- defN 23-May-03 21:22 FiberFusing/instances/Fused5.py
+-rw-r--r--  2.0 unx     1148 b- defN 23-May-03 21:22 FiberFusing/instances/Fused6.py
+-rw-r--r--  2.0 unx     1156 b- defN 23-May-03 21:22 FiberFusing/instances/Fused7.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-03 21:22 FiberFusing/instances/__init__.py
+-rw-r--r--  2.0 unx     1021 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused1.cpython-310.pyc
+-rw-r--r--  2.0 unx     1138 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused10.cpython-310.pyc
+-rw-r--r--  2.0 unx     1220 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused12.cpython-310.pyc
+-rw-r--r--  2.0 unx     1241 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused19.cpython-310.pyc
+-rw-r--r--  2.0 unx     1276 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused2.cpython-310.pyc
+-rw-r--r--  2.0 unx     1276 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused3.cpython-310.pyc
+-rw-r--r--  2.0 unx     1294 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused4.cpython-310.pyc
+-rw-r--r--  2.0 unx     1294 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused5.cpython-310.pyc
+-rw-r--r--  2.0 unx     1294 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused6.cpython-310.pyc
+-rw-r--r--  2.0 unx     1215 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/Fused7.cpython-310.pyc
+-rw-r--r--  2.0 unx      168 b- defN 23-May-03 21:23 FiberFusing/instances/__pycache__/__init__.cpython-310.pyc
+-rw-r--r--  2.0 unx        0 b- defN 23-May-03 21:22 FiberFusing/tools/__init__.py
+-rw-r--r--  2.0 unx      828 b- defN 23-May-03 21:22 FiberFusing/tools/directories.py
+-rw-r--r--  2.0 unx     1072 b- defN 23-May-03 21:23 FiberFusing-0.4.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3681 b- defN 23-May-03 21:23 FiberFusing-0.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-03 21:23 FiberFusing-0.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 23-May-03 21:23 FiberFusing-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6303 b- defN 23-May-03 21:23 FiberFusing-0.4.0.dist-info/RECORD
+66 files, 208245 bytes uncompressed, 72103 bytes compressed:  65.4%
```

## zipnote {}

```diff
@@ -1,7 +1,10 @@
+Filename: FiberFusing/VERSION
+Comment: 
+
 Filename: FiberFusing/__init__.py
 Comment: 
 
 Filename: FiberFusing/axes.py
 Comment: 
 
 Filename: FiberFusing/baseclass.py
@@ -27,14 +30,89 @@
 
 Filename: FiberFusing/rings.py
 Comment: 
 
 Filename: FiberFusing/utils.py
 Comment: 
 
+Filename: FiberFusing/__pycache__/__init__.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/axes.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/baseclass.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/buffer.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/connection.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/geometry.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/plot_style.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/rings.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/__pycache__/utils.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/examples/clad/README.rst
+Comment: 
+
+Filename: FiberFusing/examples/clad/plot_clad01x01.py
+Comment: 
+
+Filename: FiberFusing/examples/clad/plot_clad02x02.py
+Comment: 
+
+Filename: FiberFusing/examples/clad/plot_clad03x03.py
+Comment: 
+
+Filename: FiberFusing/examples/clad/plot_clad04x04.py
+Comment: 
+
+Filename: FiberFusing/examples/clad/plot_clad07x07.py
+Comment: 
+
+Filename: FiberFusing/examples/clad/plot_clad12x12.py
+Comment: 
+
+Filename: FiberFusing/examples/clad/plot_clad19x19.py
+Comment: 
+
+Filename: FiberFusing/examples/geometry/README.rst
+Comment: 
+
+Filename: FiberFusing/examples/geometry/plot_geometry1x1.py
+Comment: 
+
+Filename: FiberFusing/examples/geometry/plot_geometry2x2.py
+Comment: 
+
+Filename: FiberFusing/examples/geometry/plot_geometry3x3.py
+Comment: 
+
+Filename: FiberFusing/examples/geometry/plot_geometry4x4.py
+Comment: 
+
+Filename: FiberFusing/examples/geometry/plot_geometry7x7.py
+Comment: 
+
+Filename: FiberFusing/examples/validation/README.rst
+Comment: 
+
+Filename: FiberFusing/examples/validation/SZ_fusion_degree.py
+Comment: 
+
 Filename: FiberFusing/instances/Fused1.py
 Comment: 
 
 Filename: FiberFusing/instances/Fused10.py
 Comment: 
 
 Filename: FiberFusing/instances/Fused12.py
@@ -60,23 +138,62 @@
 
 Filename: FiberFusing/instances/Fused7.py
 Comment: 
 
 Filename: FiberFusing/instances/__init__.py
 Comment: 
 
-Filename: FiberFusing-0.3.9.dist-info/LICENSE
+Filename: FiberFusing/instances/__pycache__/Fused1.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused10.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused12.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused19.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused2.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused3.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused4.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused5.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused6.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/Fused7.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/instances/__pycache__/__init__.cpython-310.pyc
+Comment: 
+
+Filename: FiberFusing/tools/__init__.py
+Comment: 
+
+Filename: FiberFusing/tools/directories.py
+Comment: 
+
+Filename: FiberFusing-0.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: FiberFusing-0.3.9.dist-info/METADATA
+Filename: FiberFusing-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: FiberFusing-0.3.9.dist-info/WHEEL
+Filename: FiberFusing-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: FiberFusing-0.3.9.dist-info/top_level.txt
+Filename: FiberFusing-0.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: FiberFusing-0.3.9.dist-info/RECORD
+Filename: FiberFusing-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## FiberFusing/axes.py

```diff
@@ -3,35 +3,68 @@
 
 # Built-in imports
 import numpy
 import matplotlib.pyplot as plt
 
 
 class Axes(object):
-    def __init__(self, nx: int, ny: int, x_bounds: list, y_bounds: list):
+    def __init__(self, nx: int, ny: int, min_x: float, max_x: float, min_y: float, max_y: float):
         self._nx = nx
         self._ny = ny
 
-        self._x_bounds = x_bounds
-        self._y_bounds = y_bounds
+        self._x_bounds = [min_x, max_x]
+        self._y_bounds = [min_y, max_y]
 
         self.compute_mesh()
 
+    @property
+    def min_x(self):
+        return self.x_bounds[0]
+
+    @property
+    def max_x(self):
+        return self.x_bounds[1]
+
+    @property
+    def min_y(self):
+        return self.y_bounds[0]
+
+    @property
+    def max_y(self):
+        return self.y_bounds[1]
+
     def centering(self, factor: float = 1.2, zero_included: bool = True) -> None:
         min_bound = min(self.x_bounds[0], self.y_bounds[0]) * factor
         max_bound = min(self.x_bounds[1], self.y_bounds[1]) * factor
 
         self._x_bounds = self._y_bounds = (min_bound, max_bound)
 
         if zero_included:
             self.make_nx_odd()
             self.make_ny_odd()
 
         self.compute_mesh()
 
+    def add_padding(self, padding_factor: float) -> None:
+        average_x = (self.min_x + self.max_x) / 2
+        difference_x = abs(self.min_x - self.max_x)
+
+        average_y = (self.min_y + self.max_y) / 2
+        difference_y = abs(self.min_y - self.max_y)
+
+        self.x_bounds = [
+            average_x - difference_x * padding_factor / 2,
+            average_x + difference_x * padding_factor / 2,
+        ]
+
+        self.y_bounds = [
+            average_y - difference_y * padding_factor / 2,
+            average_y + difference_y * padding_factor / 2,
+        ]
+
     def x_centering(self, zero_included: bool = True) -> None:
         """
         Center the x coordinate system around 0
 
         :param      zero_included:  Indicates if zero included
         :type       zero_included:  bool
         """
```

## FiberFusing/baseclass.py

```diff
@@ -172,15 +172,15 @@
         """
         Rotates the full structure, including the fiber cores.
         """
         for fiber in self.fiber_list:
             fiber.rotate(*args, **kwargs, in_place=True)
             fiber.core.rotate(*args, **kwargs, in_place=True)
 
-        self.clad_structure = self.clad_structure.rotate(*args, **kwargs)
+        self._clad_structure = self.clad_structure.rotate(*args, **kwargs)
 
     def scale_position(self, factor: float):
         """
         Scale down the distance between each cores.
 
         :param      factor:  The scaling factor
         :type       factor:  float
```

## FiberFusing/buffer.py

```diff
@@ -77,16 +77,14 @@
     def rotate(self, output, angle, origin: tuple = (0, 0)) -> None:
         origin = utils.interpret_to_point(origin)
         output._shapely_object = affinity.rotate(self._shapely_object, angle=angle, origin=origin._shapely_object)
         return output
 
 
 class BaseArea(Alteration):
-    graded_index_factor: float = 0
-
     @property
     def is_iterable(self):
         return isinstance(self._shapely_object, Iterable)
 
     @property
     def is_multi(self):
         return isinstance(self._shapely_object, geo.MultiPolygon)
@@ -338,22 +336,20 @@
 class Polygon(BaseArea):
     inherit_attr: list = ('name', 'facecolor', 'alpha', 'edgecolor', 'index')
 
     def __init__(self, coordinates: list = None,
                        instance: geo.Polygon = None,
                        name: str = '',
                        index: float = 1.0,
-                       graded_index_factor: float = 0,
                        facecolor: str = 'lightblue',
                        edgecolor: str = 'black',
                        alpha: float = 0.4):
 
         self.name = name
         self.index = index
-        self.graded_index_factor = graded_index_factor
         self.facecolor = facecolor
         self.edgecolor = edgecolor
         self.alpha = alpha
 
         if coordinates is not None:
             coordinates = utils.interpret_to_point(*coordinates)
             self._shapely_object = geo.Polygon((c.x, c.y) for c in coordinates)
```

## FiberFusing/fiber_base_class.py

```diff
@@ -2,62 +2,98 @@
 # -*- coding: utf-8 -*-
 
 
 import numpy
 from FiberFusing import Circle
 from FiberFusing import plot_style
 from FiberFusing.axes import Axes
-from FiberFusing.utils import get_rho_gradient
+from FiberFusing.utils import get_rho_gradient, get_silica_index
 import pprint
 import logging
 
 # MPSPlots imports
-import MPSPlots.CMAP
+from MPSPlots import colormaps
 from MPSPlots.Render2D import Scene2D, Axis, Mesh, Polygon, ColorBar
 
 pp = pprint.PrettyPrinter(indent=4, sort_dicts=False, compact=True, width=1)
 
 
-def get_silica_index(wavelength: float):
-    # From https://refractiveindex.info/?shelf=main&book=SiO2&page=Malitson
-
-    wavelength *= 1e6  # Put into micro-meter scale
-
-    A_numerator = 0.6961663
-    A_denominator = 0.0684043
-
-    B_numerator = 0.4079426
-    B_denominator = 0.1162414
-
-    C_numerator = 0.8974794
-    C_denominator = 9.896161
-
-    index = (A_numerator * wavelength**2) / (wavelength**2 - A_denominator**2)
-    index += (B_numerator * wavelength**2) / (wavelength**2 - B_denominator**2)
-    index += (C_numerator * wavelength**2) / (wavelength**2 - C_denominator**2)
-    index += 1
-    index = numpy.sqrt(index)
-
-    return index
-
-
 class GenericFiber():
-    pure_silica_na = 1.0417297132615746
-
     def __init__(self, wavelength: float, position: tuple = (0, 0)):
         self.structure_dictionary = {}
-        self.wavelength = wavelength
+        self._wavelength = wavelength
         self.position = position
         self.brand = "Unknown"
         self.model = "Unknown"
 
-        self.post_init()
+    def set_position(self, position: tuple):
+        for structure_name, structure in self.structure_dictionary.items():
+
+            if structure['radius'] is None:
+                continue
+
+            new_polygon = Circle(
+                position=position,
+                radius=structure['radius'],
+                index=structure['index']
+            )
+
+            structure['polygon'] = new_polygon
+
+    @property
+    def bounds(self):
+        fiber_structure_list = []
+        for fiber_structure in self.inner_structure:
+            fiber_structure_list.append(fiber_structure)
+
+        min_x, min_y, max_x, max_y = [], [], [], []
+
+        for name, structure in self.inner_structure.items():
+            bounds = structure['polygon'].bounds
+
+            min_x.append(bounds[0])
+            min_y.append(bounds[1])
+            max_x.append(bounds[2])
+            max_y.append(bounds[3])
+
+        return (
+            numpy.min(min_x),
+            numpy.min(min_y),
+            numpy.max(max_x),
+            numpy.max(max_y)
+        )
+
+    def show_NA(self):
+        for structure_name, structure in self.structure_dictionary.items():
+            value = structure.get('na')
+            print(structure_name, f'NA: {value}')
+
+    def show_radius(self):
+        for structure_name, structure in self.structure_dictionary.items():
+            value = structure.get('radius')
+            print(structure_name, f'radius: {value}')
+
+    def show_index(self):
+        for structure_name, structure in self.structure_dictionary.items():
+            value = structure.get('index')
+            print(structure_name, f'index: {value}')
+
+    @property
+    def wavelength(self):
+        if self._wavelength is None:
+            raise Exception("Wavelength has not be defined for the fiber.")
+        return self._wavelength
+
+    @wavelength.setter
+    def wavelength(self, value: tuple):
+        self._wavelength = value
+        self.initialize()
 
     @property
-    def silica_index(self):
+    def pure_silica_index(self):
         return get_silica_index(wavelength=self.wavelength)
 
     def NA_to_core_index(self, NA: float, index_clad: float):
         return numpy.sqrt(NA**2 + index_clad**2)
 
     def core_index_to_NA(self, interior_index: float, exterior_index: float):
         return numpy.sqrt(interior_index**2 - exterior_index**2)
@@ -85,83 +121,138 @@
             "na": None,
             "radius": None,
             "index": 1,
             "V": None,
             "polygon": None
         }
 
-    def add_next_structure_with_NA(self,
-                                   name: str,
-                                   na: float,
-                                   radius: float,
-                                   graded_index_factor: float = 0):
+    def add_silica_pure_cladding(self, radius: float = 62.5e-6, name: str = 'outer-clad'):
+        self.add_next_structure_with_index(
+            name=name,
+            index=self.pure_silica_index,
+            radius=radius
+        )
+
+    def add_next_structure_with_NA(self, name: str, na: float, radius: float):
+        """
+        Add a new circular structure following the previously defined.
+        This structure is defined with a name, numerical aperture, and radius.
+
+        :param      name:    The name of the structure
+        :type       name:    str
+        :param      na:      The numerical aperture of the structure
+        :type       na:      float
+        :param      radius:  The radius of the circular structure
+        :type       radius:  float
 
+        :returns:   No returns
+        :rtype:     None
+        """
         previous_structure_name = [*self.structure_dictionary.keys()][-1]
 
         exterior_index = self.structure_dictionary[previous_structure_name]['index']
 
-        structure_index = self.NA_to_core_index(na, exterior_index)
+        index = self.NA_to_core_index(na, exterior_index)
 
-        V = 2 * numpy.pi / self.wavelength * numpy.sqrt(structure_index**2 - exterior_index**2) * radius
+        V = 2 * numpy.pi / self.wavelength * numpy.sqrt(index**2 - exterior_index**2) * radius
 
         polygon = Circle(
             position=self.position,
             radius=radius,
-            index=structure_index,
-            graded_index_factor=graded_index_factor
+            index=index
         )
 
         self.structure_dictionary[name] = {
             "na": na,
             "radius": radius,
-            "index": structure_index,
+            "index": index,
             "V": V,
-            "polygon": polygon,
-            "graded_index_factor": graded_index_factor
+            "polygon": polygon
         }
 
-    def add_next_structure_with_index(self,
-                                      name: str,
-                                      structure_index: float,
-                                      radius: float,
-                                      graded_index_factor: float = 0):
+    def add_next_structure_with_index(self, name: str, index: float, radius: float) -> None:
+        """
+        Add a new circular structure following the previously defined.
+        This structure is defined with a name, index, and radius.
+
+        :param      name:    The name of the structure
+        :type       name:    str
+        :param      index:   The index of the structure
+        :type       index:   float
+        :param      radius:  The radius of the circular structure
+        :type       radius:  float
 
+        :returns:   No returns
+        :rtype:     None
+        """
         previous_structure_name = [*self.structure_dictionary.keys()][-1]
 
         exterior_index = self.structure_dictionary[previous_structure_name]['index']
 
-        na = self.core_index_to_NA(interior_index=structure_index, exterior_index=exterior_index)
+        delta_index = numpy.sqrt(index**2 - exterior_index**2)
 
-        V = 2 * numpy.pi / self.wavelength * numpy.sqrt(structure_index**2 - exterior_index**2) * radius
+        V = 2 * numpy.pi / self.wavelength * delta_index * radius
 
         polygon = Circle(
             position=self.position,
             radius=radius,
-            index=structure_index,
-            graded_index_factor=graded_index_factor
+            index=index
         )
 
         self.structure_dictionary[name] = {
-            "na": na,
             "radius": radius,
-            "index": structure_index,
+            "index": index,
             "V": V,
             "polygon": polygon,
+        }
+
+    def add_next_structure_with_gradient(self, name: str, index: float, radius: float, graded_index_factor: float = 0):
+        """
+        Add a new circular structure with graded index following the previously defined.
+        This structure is defined with a name, index, gradient factor, and radius.
+
+        :param      name:                  The name of the structure
+        :type       name:                  str
+        :param      index:                 The index of the structure
+        :type       index:                 float
+        :param      graded_index_factor:   The index of the structure
+        :type       graded_index_factor:   float
+        :param      radius:                The radius of the circular structure
+        :type       radius:                float
+
+        :returns:   No returns
+        :rtype:     None
+        """
+        polygon = Circle(
+            position=self.position,
+            radius=radius,
+            index=index
+        )
+
+        self.structure_dictionary[name] = {
+            "radius": radius,
+            "index": index,
+            "polygon": polygon,
             "graded_index_factor": graded_index_factor
         }
 
     def __str__(self):
         ID = ""
 
         ID += f"brand: {self.brand:<20s}\n"
         ID += f"model: {self.model:<20s}\n"
         ID += "structure:\n"
 
-        for name, value in self.fiber_structure.items():
-            ID += f"\t{name:<21s} [V: {value['V']:<18}\t NA: {value['na']:<18}\t index: {value['index']:<18}\t radius: {value['radius']:<18}]\n"
+        for name, structure in self.fiber_structure.items():
+            ID += f"\t{name:<20s}"
+            for key, value in structure.items():
+                if key == 'polygon':
+                    continue
+                ID += f"{key}: {value:<20.3}"
+            ID += "\n"
 
         return ID
 
     def __repr__(self):
         return self.__str__()
 
     def render_patch_on_ax(self, ax: Axis, coordinate_axis: Axes) -> None:
@@ -170,16 +261,14 @@
 
         :param      ax:   The ax to which append the representation.
         :type       ax:   Axis
         """
 
         for name, structure in self.fiber_structure.items():
             artist = Polygon(
-                x=coordinate_axis.x_vector,
-                y=coordinate_axis.y_vector,
                 instance=structure['polygon']._shapely_object
             )
 
             ax.add_artist(artist)
 
         ax.set_style(**plot_style.geometry)
         ax.title = 'Fiber structure'
@@ -243,15 +332,15 @@
             symmetric=True
         )
 
         artist = Mesh(
             x=coordinate_axis.x_vector,
             y=coordinate_axis.y_vector,
             scalar=rho_gradient,
-            colormap=MPSPlots.CMAP.BWR
+            colormap=colormaps.blue_white_red
         )
 
         ax.colorbar = colorbar
         ax.title = 'Refractive index gradient'
         ax.set_style(**plot_style.geometry)
         ax.add_artist(artist)
 
@@ -271,33 +360,61 @@
         """
         shifted_coordinate = coordinate_axis.to_unstructured_coordinate()
         shifted_coordinate[:, 0] -= x_shift
         shifted_coordinate[:, 1] -= y_shift
 
         return shifted_coordinate
 
-    def get_shifted_distance(self, coordinate_axis: Axis, x_shift: float, y_shift: float, into_mesh: bool = True) -> numpy.ndarray:
+    def get_shifted_distance_mesh(self, coordinate_axis: Axis, x_position: float, y_position: float, into_mesh: bool = True) -> numpy.ndarray:
+        """
+        Returns a mesh representing the distance from a specific point.
+
+        :param      coordinate_axis:  The coordinate axis
+        :type       coordinate_axis:  Axis
+        :param      x_postition:      The x shift
+        :type       x_position:       float
+        :param      y_position:       The y shift
+        :type       y_position:       float
+        :param      into_mesh:        Into mesh
+        :type       into_mesh:        bool
+
+        :returns:   The shifted distance mesh.
+        :rtype:     { return_type_description }
+        """
         shifted_coordinate = self.shift_coordinates(
             coordinate_axis=coordinate_axis,
-            x_shift=x_shift,
-            y_shift=y_shift
+            x_shift=x_position,
+            y_shift=y_position
         )
 
         distance = numpy.sqrt(shifted_coordinate[:, 0]**2 + shifted_coordinate[:, 1]**2)
 
         if into_mesh:
             distance = distance.reshape(coordinate_axis.shape)
 
         return distance
 
-    def get_graded_index(self, coordinate_axis: numpy.ndarray, polygon, delta_n: float) -> numpy.ndarray:
-        shifted_distance_mesh = self.get_shifted_distance(
+    def get_graded_index_mesh(self, coordinate_axis: numpy.ndarray, polygon, delta_n: float) -> numpy.ndarray:
+        """
+        Returns the mesh that represent the refractive index gradient of the fiber structure.
+
+        :param      coordinate_axis:  The coordinate axis
+        :type       coordinate_axis:  numpy.ndarray
+        :param      polygon:          The polygon
+        :type       polygon:          Polygone object
+        :param      delta_n:          The difference between highest and lowest RI value in the gradient.
+        :type       delta_n:          float
+
+        :returns:   The graded index mesh.
+        :rtype:     numpy.ndarray
+        """
+        shifted_distance_mesh = self.get_shifted_distance_mesh(
             coordinate_axis=coordinate_axis,
-            x_shift=polygon.center.x,
-            y_shift=polygon.center.y,
+            x_position=polygon.center.x,
+            y_position=polygon.center.y,
             into_mesh=True
         )
 
         boolean_raster = polygon.get_rasterized_mesh(coordinate_axis=coordinate_axis)
 
         shifted_distance_mesh = -boolean_raster * shifted_distance_mesh**2
 
@@ -323,15 +440,15 @@
         :type       coordinate_axis:  Axis
 
         :returns:   The raster mesh of the structures.
         :rtype:     numpy.ndarray
         """
         mesh = numpy.zeros(coordinate_axis.shape)
 
-        return self.overlay_structures_on_mesh(mesh=mesh, coordinate_axis=coordinate_axis)
+        return self.overlay_fiber_structures_on_mesh(mesh=mesh, coordinate_axis=coordinate_axis)
 
     def overlay_fiber_structures_on_mesh(self, mesh: numpy.ndarray, coordinate_axis: Axis) -> numpy.ndarray:
         """
         Return a mesh overlaying all the structures in the order they were defined.
 
         :param      coordinate_axis:  The coordinates axis
         :type       coordinate_axis:  Axis
@@ -373,16 +490,16 @@
         """
         for name, structure in structure_dictionnary.items():
             polygon = structure['polygon']
             raster = polygon.get_rasterized_mesh(coordinate_axis=coordinate_axis)
             mesh[numpy.where(raster != 0)] = 0
             index = structure['index']
 
-            if structure['graded_index_factor'] != 0:
-                index += self.get_graded_index(
+            if structure.get('graded_index_factor', None) is not None:
+                index += self.get_graded_index_mesh(
                     coordinate_axis=coordinate_axis,
                     polygon=polygon,
                     delta_n=structure['graded_index_factor']
                 )
 
             raster *= index
 
@@ -394,23 +511,26 @@
         """
         Plot the different representations [patch, raster-mesh, raster-gradient]
         of the geometry.
 
         :param      resolution:  The resolution to raster the structures
         :type       resolution:  int
         """
-        max_radius: float = self.get_structures_max_radius()
+        min_x, min_y, max_x, max_y = self.get_structure_max_min_boundaries()
 
         coordinate_axis = Axes(
-            x_bounds=(-max_radius, max_radius),
-            y_bounds=(-max_radius, max_radius),
+            min_x=min_x,
+            max_x=max_x,
+            min_y=min_y,
+            max_y=max_y,
             nx=resolution,
             ny=resolution
         )
-        coordinate_axis.centering(factor=1.2)
+
+        coordinate_axis.add_padding(padding_factor=1.2)
 
         figure = Scene2D(unit_size=(4, 4), tight_layout=True)
 
         ax0 = Axis(row=0, col=0)
         ax1 = Axis(row=0, col=1)
         ax2 = Axis(row=0, col=2)
 
@@ -418,23 +538,45 @@
         self.render_mesh_on_ax(ax=ax1, coordinate_axis=coordinate_axis)
         self.render_gradient_on_ax(ax=ax2, coordinate_axis=coordinate_axis)
 
         figure.add_axes(ax0, ax1, ax2)
 
         return figure
 
-    def get_structures_max_radius(self) -> float:
+    def get_structures_boundaries(self) -> numpy.ndarray:
         """
-        Get the largest radius of all the defined structures except for air of course.
+        Returns array representing the boundaries of each of the existing structures
 
-        :returns:   The structures maximum radius.
-        :rtype:     float
+        :returns:   The structures boundaries.
+        :rtype:     numpy.ndarray
         """
-        radii = [
-            structure['radius'] for structure in self.structure_dictionary.values()
-        ]
+        boundaries = []
+        for structure_name, structure in self.structure_dictionary.items():
+            if not structure.get('polygon', False):
+                continue
+
+            boundaries.append(structure["polygon"].bounds)
+
+        boundaries = numpy.array(boundaries)
+
+        return boundaries
+
+    def get_structure_max_min_boundaries(self) -> numpy.ndarray:
+        """
+        Returns array representing max and min x and y [4 points] boundaries
+        of the total structures except for air.
+
+        :returns:   The structures max/min boundaries.
+        :rtype:     numpy.ndarray
+        """
+        boundaries = self.get_structures_boundaries()
+
+        min_x, min_y, max_x, max_y = boundaries.T
 
-        radii = numpy.asarray(radii).astype(float)
+        min_x = min_x.min()
+        max_x = max_x.max()
+        min_y = min_y.min()
+        max_y = max_y.max()
 
-        radii = radii[~numpy.isnan(radii)]
+        return min_x, min_y, max_x, max_y
 
-        return radii.max()
+# -
```

## FiberFusing/fiber_catalogue.py

```diff
@@ -1,77 +1,112 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 from FiberFusing.fiber_base_class import GenericFiber, get_silica_index
 
 micro = 1e-6
 
-__all__ = ['DCF1300S_20',
-           'DCF1300S_33',
-           'F2028M24',
-           'F2028M21',
-           'F2028M12',
-           'F2058G1',
-           'F2058L1',
-           'SMF28',
-           'HP630',
-           'CustomFiber',
-           'get_silica_index']
+__all__ = [
+    'DCF13',
+    'DCF1300S_20',
+    'DCF1300S_33',
+    'F2028M24',
+    'F2028M21',
+    'F2028M12',
+    'F2058G1',
+    'F2058L1',
+    'SMF28',
+    'HP630',
+    'CustomFiber',
+    'get_silica_index'
+]
 
 
 class CustomFiber(GenericFiber):
-    def __init__(self, wavelength: float, na_list: list, radius_list: list, name_list: list = None, position: tuple = (0, 0)):
+    def __init__(self, wavelength: float, position: tuple = (0, 0)):
         self.structure_dictionary = {}
-        self.wavelength = wavelength
+        self._wavelength = wavelength
         self.position = position
 
-        if name_list is None:
-            name_list = [f'layer_{n}' for n in range(len(na_list))]
-
         self.add_air()
 
-        for n, (na, radius) in enumerate(zip(na_list, radius_list)):
-            self.add_next_structure_with_NA(
-                name=name_list[n],
-                na=na,
-                radius=radius,
-            )
-
 
 class GradientFiber(GenericFiber):
     # Fiber from https://www.nature.com/articles/s41598-018-27072-2
-    def post_init(self):
+    def __init__(self, wavelength: float,
+                       core_radius: float,
+                       delta_n: float,
+                       position: tuple = (0, 0)):
+
+        self.structure_dictionary = {}
+        self._wavelength = wavelength
+        self.position = position
+        self.delta_n = delta_n
+        self.core_radius = core_radius
+        self.brand = "Unknown"
+        self.model = "Unknown"
+
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
+
+        self.add_next_structure_with_gradient(
+            name='core',
+            index=self.pure_silica_index + self.delta_n,
+            radius=self.core_radius,
+            graded_index_factor=self.delta_n
+        )
+
+
+class DCF13(GenericFiber):
+    brand = "Thorlabs"
+    model = "DCF13"
+
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
         self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
+            name='inner-clad',
+            na=0.2,
+            radius=19.9 / 2 * micro
         )
 
-        self.add_next_structure_with_index(
+        self.add_next_structure_with_NA(
             name='core',
-            structure_index=self.pure_silica_na + 16e-3,
-            radius=19.9 / 2 * micro,
-            graded_index_factor=16e-3
+            na=0.12,
+            radius=105.0 / 2 * micro
         )
 
 
 class DCF1300S_20(GenericFiber):
     brand = "COPL"
     model = "DCF1300S_20"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='inner-clad',
             na=0.11,
             radius=19.9 / 2 * micro
         )
 
@@ -82,22 +117,24 @@
         )
 
 
 class DCF1300S_33(GenericFiber):
     brand = "COPL"
     model = "DCF1300S_33"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='inner-clad',
             na=0.11,
             radius=33.0 / 2 * micro
         )
 
@@ -108,22 +145,24 @@
         )
 
 
 class F2058L1(GenericFiber):
     brand = "COPL"
     model = "F2058L1"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='inner-clad',
             na=0.117,
             radius=19.6 / 2 * micro
         )
 
@@ -134,22 +173,24 @@
         )
 
 
 class F2058G1(GenericFiber):
     brand = "COPL"
     model = "F2058G1"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='inner-clad',
             na=0.115,
             radius=32.3 / 2 * micro
         )
 
@@ -159,22 +200,24 @@
             radius=9.0 / 2 * micro
         )
 
 
 class F2028M24(GenericFiber):
     model = "F2028M24"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='inner-clad',
             na=0.19,
             radius=14.1 / 2 * micro
         )
 
@@ -184,22 +227,24 @@
             radius=2.3 / 2 * micro
         )
 
 
 class F2028M21(GenericFiber):
     model = "F2028M21"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='inner-clad',
             na=0.19,
             radius=17.6 / 2 * micro
         )
 
@@ -209,22 +254,24 @@
             radius=2.8 / 2 * micro
         )
 
 
 class F2028M12(GenericFiber):
     model = "F2028M12"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='inner-clad',
             na=0.19,
             radius=25.8 / 2 * micro
         )
 
@@ -235,83 +282,91 @@
         )
 
 
 class SMF28(GenericFiber):
     brand = 'Corning'
     model = "SMF28"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='core',
             na=0.12,
             radius=8.2 / 2 * micro
         )
 
 
 class HP630(GenericFiber):
     brand = 'Thorlab'
     model = "HP630"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='core',
             na=0.13,
             radius=3.5 / 2 * micro
         )
 
 
 class FiberCoreA(GenericFiber):
     brand = 'FiberCore'
     model = 'PS1250/1500'
     note = "Boron Doped Photosensitive Fiber"
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=124.9 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='core',
             na=0.12,
             radius=8.8 / 2 * micro
         )
 
 
 class FiberCoreB(GenericFiber):
     brand = 'FiberCore'
     model = 'SM1250'
 
-    def post_init(self):
-        self.add_air()
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
-        self.add_next_structure_with_NA(
-            name='outer-clad',
-            na=self.pure_silica_na,
-            radius=125 / 2 * micro
-        )
+        self.initialize()
+
+    def initialize(self):
+        self.structure_dictionary = {}
+
+        self.add_air()
+        self.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
 
         self.add_next_structure_with_NA(
             name='core',
             na=0.12,
             radius=9 / 2 * micro
         )
```

## FiberFusing/geometry.py

```diff
@@ -1,102 +1,109 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 # Third-party imports
 import logging
 import numpy
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 from scipy.ndimage import gaussian_filter
 
 # MPSPlots imports
-import MPSPlots.CMAP
+from MPSPlots import colormaps
 from MPSPlots.Render2D import Scene2D, ColorBar, Axis, Mesh, Polygon
 
 # FiberFusing imports
 from FiberFusing import utils
 from FiberFusing.axes import Axes
-from FiberFusing.buffer import BackGround
 from FiberFusing import plot_style
 
 
 @dataclass
 class Geometry(object):
     """
     Class represent the refractive index (RI) geometrique profile which
     can be used to retrieve the supermodes.
     """
     background: object
     """ Geometrique object representing the background (usually air). """
-    structures: list
+    additional_structure_list: list = field(default_factory=list)
     """ List of geometrique object representing the fiber structure. """
+    fiber_list: list = field(default_factory=list)
+    """ List of fiber structure to add. """
     x_bounds: list = 'auto-centering'
     """ X boundary to render the structure, argument can be either list or a string from ['auto', 'left', 'right', 'centering']. """
     y_bounds: list = 'auto-centering'
     """ Y boundary to render the structure, argument can be either list or a string from ['auto', 'top', 'bottom', 'centering']. """
     n: int = 100
-    """ Number of point (x and y-direction) to evaluate the rendering """
+    """ Number of point (x and y-direction) to evaluate the rendering. """
     index_scrambling: float = 0
-    """ Index scrambling for degeneracy lifting """
+    """ Index scrambling for degeneracy lifting. """
     gaussian_filter: int = None
-    """ Standard deviation of the gaussian blurring for the mesh and gradient """
+    """ Standard deviation of the gaussian blurring for the mesh and gradient. """
     boundary_pad_factor: int = 1.3
-    """ The factor that multiply the boundary value in order to keep padding between mesh and boundary """
+    """ The factor that multiply the boundary value in order to keep padding between mesh and boundary. """
 
     def __post_init__(self):
-        self._mesh = None
-        self._gradient = None
-        self.fiber_list = []
+        self.index_list = self.get_index_range()
+
+    def generate_coordinate_system(self) -> None:
+        """
+        Generates the coordinate system (Axes) for the mesh construction
 
+        :returns:   No returns
+        :rtype:     None
+        """
         min_x, min_y, max_x, max_y = self.get_boundaries()
 
         self.coordinate_system = Axes(
-            x_bounds=(min_x, max_x),
-            y_bounds=(min_y, max_y),
+            min_x=min_x,
+            max_x=max_x,
+            min_y=min_y,
+            max_y=max_y,
             nx=self.n,
             ny=self.n
         )
+
         self.coordinate_system.centering(factor=self.boundary_pad_factor)
 
-        self.interpret_boundaries()
+        self.interpret_y_boundary()
 
-        self.index_list = self.get_index_range()
+        self.interpret_x_boundary()
 
     def add_fiber(self, *fibers):
         """
         Adds a fiber structure to the geometry. The fibers than can be added
-        have to be defined with the generic_fiber class in fiber_model.py
+        have to be defined with the generic_fiber class in fiber_catalogue.py
 
         :param      fibers:  The fibers to be added
         :type       fibers:  tuple
         """
         for fiber in fibers:
             self.fiber_list.append(fiber)
 
-    @property
-    def object_list(self):
-        fiber_structure_list = []
-        for fiber in self.fiber_list:
-            for fiber_structure in fiber.inner_structure:
-                fiber_structure_list.append(fiber_structure)
+    def add_structure(self, *structures):
+        """
+        Adds a custom structure to the geometry.
 
-        return [self.background, *self.structures, *fiber_structure_list]
+        :param      structures:  The fibers to be added
+        :type       structures:  tuple
+        """
+        for structure in structures:
+            self.additional_structure_list.append(structure)
 
     @property
-    def fiber_structures(self):
-        fiber_structure_list = []
-        for fiber in self.fiber_list:
-            for fiber_structure in fiber.inner_structure:
-                fiber_structure_list.append(fiber_structure)
-
-        return fiber_structure_list
+    def structure_list(self) -> list:
+        """
+        Returns list of all the optical structure to be considered for the mesh construct.
 
-    def interpret_boundaries(self):
-        self.interpret_y_boundary()
+        :returns:   List of the optical structures
+        :rtype:     list
+        """
 
-        self.interpret_x_boundary()
+        return [self.background, *self.additional_structure_list, *self.fiber_list]
 
     def interpret_y_boundary(self) -> None:
         """
         Interpret the y_bound parameter.
         If the parameter is in ["top", "bottom", "centering"], it returns
         an auto-evaluated boundary
 
@@ -114,27 +121,41 @@
             if 'centering' in arguments:
                 self.coordinate_system.y_centering()
             if 'top' in arguments:
                 self.coordinate_system.set_top()
             if 'bottom' in arguments:
                 self.coordinate_system.set_bottom()
 
-    def get_boundaries(self):
+    def get_boundaries(self) -> tuple:
+        """
+        Gets the boundaries containing the collection of defined structures.
+        The list returns min_x, min_y, max_x, max_y.
+
+        :returns:   The boundaries.
+        :rtype:     tuple
+        """
+        if self.structure_list == []:
+            raise ValueError('No internal structure provided for computation of the mesh.')
+
         min_x, min_y, max_x, max_y = [], [], [], []
-        for obj in self.structures:
+
+        for obj in [*self.additional_structure_list, *self.fiber_list]:
             bounds = obj.bounds
+
             min_x.append(bounds[0])
             min_y.append(bounds[1])
             max_x.append(bounds[2])
             max_y.append(bounds[3])
 
-        return (numpy.min(min_x),
-                numpy.min(min_y),
-                numpy.max(max_x),
-                numpy.max(max_y))
+        return (
+            numpy.min(min_x),
+            numpy.min(min_y),
+            numpy.max(max_x),
+            numpy.max(max_y)
+        )
 
     def interpret_x_boundary(self) -> None:
         """
         Interpret the x_bound parameter.
         If the parameter is in ["left", "right", "centering"], it returns
         an auto-evaluated boundary
 
@@ -154,47 +175,35 @@
                 self.coordinate_system.x_centering()
             if 'right' in arguments:
                 self.coordinate_system.set_right()
             if 'left' in arguments:
                 self.coordinate_system.set_left()
 
     @property
-    def mesh(self) -> numpy.ndarray:
-        if self._mesh is None:
-            self._mesh, self._gradient = self.generate_mesh()
-        return self._mesh
-
-    @property
-    def gradient(self) -> numpy.ndarray:
-        if self._gradient is None:
-            self._mesh, self._gradient = self.generate_mesh()
-        return self._gradient
-
-    @property
     def max_index(self) -> float:
-        return max([obj.index for obj in self.object_list])[0]
+        return max([obj.index for obj in self.structure_list])[0]
 
     @property
     def min_index(self) -> float:
-        return min([obj.index for obj in self.object_list])[0]
+        return min([obj.index for obj in self.structure_list])[0]
 
     def get_index_range(self) -> list:
         """
         Returns the list of all index associated to the element of the geometry.
         """
-        return [float(obj.index) for obj in self.object_list]
+        return [float(obj.index) for obj in self.structure_list]
 
     def rotate(self, angle: float) -> None:
         """
         Rotate the full geometry
 
         :param      angle:  Angle to rotate the geometry, in degrees.
         :type       angle:  float
         """
-        for obj in self.structures:
+        for obj in self.structure_list:
             obj = obj.rotate(angle=angle)
 
     def shift_coordinates(self, coordinates: numpy.ndarray, x_shift: float, y_shift: float) -> numpy.ndarray:
         """
         Return the same coordinate system but x-y shifted
 
         :param      coordinates:  The coordinates
@@ -253,14 +262,21 @@
 
         shifted_distance_mesh *= delta_n
 
         shifted_distance_mesh -= delta_n
 
         return shifted_distance_mesh
 
+    def generate_coordinate_mesh_gradient(self) -> None:
+        self.generate_coordinate_system()
+
+        self.generate_mesh()
+
+        self.generate_gradient()
+
     def rasterize_polygons(self, coordinates: numpy.ndarray) -> numpy.ndarray:
         """
         Returns the rasterize mesh of the object.
 
         :param      coordinates:  The coordinates to which evaluate the mesh.
         :type       coordinates:  { type_description }
         :param      n_x:          The number of point in the x direction
@@ -271,15 +287,15 @@
         :returns:   The rasterized mesh
         :rtype:     numpy.ndarray
         """
         mesh = numpy.zeros(self.coordinate_system.shape)
 
         self.add_background_to_mesh(mesh=mesh)
 
-        for structure in self.structures:
+        for structure in self.additional_structure_list:
             self.add_structure_to_mesh(mesh=mesh, structure=structure)
 
         for fiber in self.fiber_list:
             fiber.overlay_inner_structures_on_mesh(mesh=mesh, coordinate_axis=self.coordinate_system)
 
         return mesh
 
@@ -294,40 +310,41 @@
         mesh[numpy.where(raster != 0)] = 0
         raster *= structure.index
         mesh += raster
 
     def generate_mesh(self) -> numpy.ndarray:
         self.coords = numpy.vstack((self.coordinate_system.x_mesh.flatten(), self.coordinate_system.y_mesh.flatten())).T
 
-        mesh = self.rasterize_polygons(coordinates=self.coords)
+        self.mesh = self.rasterize_polygons(coordinates=self.coords)
 
         if self.gaussian_filter is not None:
-            mesh = gaussian_filter(input=mesh, sigma=self.gaussian_filter)
+            self.mesh = gaussian_filter(input=self.mesh, sigma=self.gaussian_filter)
 
-        gradient = utils.get_rho_gradient(mesh=mesh**2, coordinate_axis=self.coordinate_system)
+        return self.mesh
 
-        return mesh, gradient
+    def generate_gradient(self) -> numpy.ndarray:
+        self.gradient = utils.get_rho_gradient(mesh=self.mesh**2, coordinate_axis=self.coordinate_system)
+
+        return self.gradient
 
     def render_structure_patch_on_ax(self, structure, ax: Axis, coordinate_axis: Axes):
         artist = Polygon(
-            x=self.coordinate_system.x_vector,
-            y=self.coordinate_system.y_vector,
             instance=structure._shapely_object
         )
 
         ax.add_artist(artist)
 
     def render_patch_on_ax(self, ax: Axis) -> None:
         """
         Add the patch representation of the geometry into the give ax.
 
         :param      ax:   The ax to which append the representation.
         :type       ax:   Axis
         """
-        for structure in self.structures:
+        for structure in self.additional_structure_list:
             self.render_structure_patch_on_ax(
                 structure=structure,
                 ax=ax,
                 coordinate_axis=self.coordinate_system
             )
 
         for fiber in self.fiber_list:
@@ -352,15 +369,15 @@
             symmetric=True
         )
 
         artist = Mesh(
             x=self.coordinate_system.x_vector,
             y=self.coordinate_system.y_vector,
             scalar=self.gradient,
-            colormap=MPSPlots.CMAP.BWR
+            colormap=colormaps.blue_white_red
         )
 
         ax.colorbar = colorbar
         ax.title = 'Refractive index gradient'
         ax.add_artist(artist)
 
     def render_mesh_on_ax(self, ax: Axis) -> None:
@@ -390,14 +407,16 @@
         ax.add_artist(artist)
 
     def plot(self) -> None:
         """
         Plot the different representations [patch, raster-mesh, raster-gradient]
         of the geometry.
         """
+        self.generate_coordinate_mesh_gradient()
+
         figure = Scene2D(unit_size=(4, 4), tight_layout=True)
 
         ax0 = Axis(row=0, col=0)
 
         ax1 = Axis(row=0, col=1)
 
         ax2 = Axis(row=0, col=2)
```

## FiberFusing/utils.py

```diff
@@ -10,14 +10,37 @@
 from FiberFusing import buffer
 from MPSPlots.Render2D import Scene2D, Axis
 from shapely.ops import unary_union
 from shapely.ops import nearest_points
 import shapely.geometry as geo
 
 
+def get_silica_index(wavelength: float):
+    # From https://refractiveindex.info/?shelf=main&book=SiO2&page=Malitson
+
+    wavelength *= 1e6  # Put into micro-meter scale
+
+    A_numerator = 0.6961663
+    A_denominator = 0.0684043
+
+    B_numerator = 0.4079426
+    B_denominator = 0.1162414
+
+    C_numerator = 0.8974794
+    C_denominator = 9.896161
+
+    index = (A_numerator * wavelength**2) / (wavelength**2 - A_denominator**2)
+    index += (B_numerator * wavelength**2) / (wavelength**2 - B_denominator**2)
+    index += (C_numerator * wavelength**2) / (wavelength**2 - C_denominator**2)
+    index += 1
+    index = numpy.sqrt(index)
+
+    return index
+
+
 def NearestPoints(Object0, Object1):
     if hasattr(Object0, '_shapely_object'):
         Object0 = Object0._shapely_object
 
     if hasattr(Object0, '_shapely_object'):
         Object1 = Object1._shapely_object
```

## Comparing `FiberFusing-0.3.9.dist-info/LICENSE` & `FiberFusing-0.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `FiberFusing-0.3.9.dist-info/METADATA` & `FiberFusing-0.4.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: FiberFusing
-Version: 0.3.9
+Version: 0.4.0
 Summary: A package fiber fusing simulation.
 Home-page: https://github.com/MartinPdeS/FiberFusing
 Author: Martin Poinsinet de Sivry
 Author-email: Martin.poinsinet.de.sivry@gmail.com
 License: MIT
 Platform: unix
 Platform: linux
```


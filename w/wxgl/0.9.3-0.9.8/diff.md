# Comparing `tmp/wxgl-0.9.3-py3-none-any.whl.zip` & `tmp/wxgl-0.9.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,37 +1,25 @@
-Zip file size: 146045 bytes, number of entries: 35
--rw-rw-rw-  2.0 fat     2349 b- defN 22-Apr-05 09:41 wxgl/__init__.py
--rw-rw-rw-  2.0 fat    46639 b- defN 22-Apr-05 01:25 wxgl/axes.py
--rw-rw-rw-  2.0 fat    13176 b- defN 21-Sep-10 06:28 wxgl/cm.py
--rw-rw-rw-  2.0 fat    13068 b- defN 22-Apr-04 23:57 wxgl/cmap.py
--rw-rw-rw-  2.0 fat    38395 b- defN 20-Oct-06 06:54 wxgl/colormap.py
--rw-rw-rw-  2.0 fat    30369 b- defN 22-Apr-05 06:40 wxgl/figure.py
--rw-rw-rw-  2.0 fat     7327 b- defN 21-Jul-29 07:56 wxgl/fm.py
--rw-rw-rw-  2.0 fat     3696 b- defN 20-Oct-04 03:15 wxgl/fontmanager.py
--rw-rw-rw-  2.0 fat     4988 b- defN 22-Apr-03 02:15 wxgl/glplot.py
--rw-rw-rw-  2.0 fat     5931 b- defN 22-Mar-18 08:18 wxgl/glt.py
--rw-rw-rw-  2.0 fat    64455 b- defN 22-Apr-02 08:37 wxgl/light.py
--rw-rw-rw-  2.0 fat    18656 b- defN 22-Apr-05 09:41 wxgl/model.py
--rw-rw-rw-  2.0 fat    89011 b- defN 22-Apr-05 01:24 wxgl/region.py
--rw-rw-rw-  2.0 fat    21975 b- defN 22-Apr-05 09:41 wxgl/scene.py
--rw-rw-rw-  2.0 fat     7107 b- defN 21-Dec-31 03:07 wxgl/text.py
--rw-rw-rw-  2.0 fat     8669 b- defN 22-Apr-02 02:30 wxgl/texture.py
--rw-rw-rw-  2.0 fat     2749 b- defN 22-Feb-14 02:52 wxgl/timer.py
--rw-rw-rw-  2.0 fat    23330 b- defN 22-Mar-31 07:30 wxgl/util.py
--rw-rw-rw-  2.0 fat    11561 b- defN 21-Apr-13 06:48 wxgl/wxfigure.py
--rw-rw-rw-  2.0 fat     5943 b- defN 22-Feb-13 15:22 wxgl/wxplot.py
--rw-rw-rw-  2.0 fat     1044 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_config_32.png
--rw-rw-rw-  2.0 fat     1584 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_hide_32.png
--rw-rw-rw-  2.0 fat     1031 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_play_32.png
--rw-rw-rw-  2.0 fat     1573 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_restore_32.png
--rw-rw-rw-  2.0 fat      778 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_rplay_32.png
--rw-rw-rw-  2.0 fat     1441 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_rstop_32.png
--rw-rw-rw-  2.0 fat      948 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_save_32.png
--rw-rw-rw-  2.0 fat     1359 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_show_32.png
--rw-rw-rw-  2.0 fat     1447 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_stop_32.png
--rw-rw-rw-  2.0 fat     1533 b- defN 22-Mar-31 07:30 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_style_32.png
--rw-rw-rw-  2.0 fat   249054 b- defN 21-Dec-17 09:20 wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/wxplot.ico
--rw-rw-rw-  2.0 fat     5251 b- defN 22-Apr-05 09:46 wxgl-0.9.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 22-Apr-05 09:46 wxgl-0.9.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        5 b- defN 22-Apr-05 09:46 wxgl-0.9.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     3018 b- defN 22-Apr-05 09:46 wxgl-0.9.3.dist-info/RECORD
-35 files, 689552 bytes uncompressed, 141221 bytes compressed:  79.5%
+Zip file size: 122121 bytes, number of entries: 23
+-rw-rw-r--  2.0 unx     2315 b- defN 23-Mar-17 03:25 wxgl/__init__.py
+-rw-rw-r--  2.0 unx     4488 b- defN 23-Mar-17 03:25 wxgl/app.py
+-rw-rw-r--  2.0 unx    11556 b- defN 23-Mar-17 03:25 wxgl/color.py
+-rw-rw-r--  2.0 unx     6567 b- defN 23-Mar-08 07:55 wxgl/glutfigure.py
+-rw-rw-r--  2.0 unx   338817 b- defN 22-Dec-14 08:45 wxgl/imgres.py
+-rw-rw-r--  2.0 unx    55491 b- defN 23-Mar-17 03:25 wxgl/light.py
+-rw-rw-r--  2.0 unx    18454 b- defN 23-Mar-17 03:25 wxgl/model.py
+-rw-rw-r--  2.0 unx     2255 b- defN 22-Dec-14 08:45 wxgl/qtapp.py
+-rw-rw-r--  2.0 unx     7934 b- defN 23-Feb-07 02:27 wxgl/qtfigure (副本).py
+-rw-rw-r--  2.0 unx     9243 b- defN 23-Mar-08 07:55 wxgl/qtfigure.py
+-rw-rw-r--  2.0 unx     4000 b- defN 23-Mar-17 03:25 wxgl/qtscene.py
+-rw-rw-r--  2.0 unx    23920 b- defN 23-Mar-09 02:05 wxgl/scene.py
+-rw-rw-r--  2.0 unx    71618 b- defN 23-Mar-17 03:25 wxgl/scheme.py
+-rw-rw-r--  2.0 unx     7175 b- defN 23-Feb-28 02:31 wxgl/text.py
+-rw-rw-r--  2.0 unx     8173 b- defN 23-Mar-17 03:25 wxgl/texture.py
+-rw-rw-r--  2.0 unx    24323 b- defN 23-Mar-17 03:25 wxgl/util.py
+-rw-rw-r--  2.0 unx     1279 b- defN 22-Dec-14 08:45 wxgl/wxapp.py
+-rw-rw-r--  2.0 unx     8625 b- defN 23-Mar-08 07:55 wxgl/wxfigure.py
+-rw-rw-r--  2.0 unx     4661 b- defN 23-Feb-28 02:31 wxgl/wxscene.py
+-rw-rw-r--  2.0 unx     2251 b- defN 23-Mar-17 03:31 wxgl-0.9.8.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Mar-17 03:31 wxgl-0.9.8.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        5 b- defN 23-Mar-17 03:31 wxgl-0.9.8.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1653 b- defN 23-Mar-17 03:31 wxgl-0.9.8.dist-info/RECORD
+23 files, 614895 bytes uncompressed, 119565 bytes compressed:  80.6%
```

## zipnote {}

```diff
@@ -1,106 +1,70 @@
 Filename: wxgl/__init__.py
 Comment: 
 
-Filename: wxgl/axes.py
+Filename: wxgl/app.py
 Comment: 
 
-Filename: wxgl/cm.py
+Filename: wxgl/color.py
 Comment: 
 
-Filename: wxgl/cmap.py
+Filename: wxgl/glutfigure.py
 Comment: 
 
-Filename: wxgl/colormap.py
+Filename: wxgl/imgres.py
 Comment: 
 
-Filename: wxgl/figure.py
-Comment: 
-
-Filename: wxgl/fm.py
+Filename: wxgl/light.py
 Comment: 
 
-Filename: wxgl/fontmanager.py
+Filename: wxgl/model.py
 Comment: 
 
-Filename: wxgl/glplot.py
+Filename: wxgl/qtapp.py
 Comment: 
 
-Filename: wxgl/glt.py
+Filename: wxgl/qtfigure (#U526f#U672c).py
 Comment: 
 
-Filename: wxgl/light.py
+Filename: wxgl/qtfigure.py
 Comment: 
 
-Filename: wxgl/model.py
+Filename: wxgl/qtscene.py
 Comment: 
 
-Filename: wxgl/region.py
+Filename: wxgl/scene.py
 Comment: 
 
-Filename: wxgl/scene.py
+Filename: wxgl/scheme.py
 Comment: 
 
 Filename: wxgl/text.py
 Comment: 
 
 Filename: wxgl/texture.py
 Comment: 
 
-Filename: wxgl/timer.py
-Comment: 
-
 Filename: wxgl/util.py
 Comment: 
 
-Filename: wxgl/wxfigure.py
-Comment: 
-
-Filename: wxgl/wxplot.py
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_config_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_hide_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_play_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_restore_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_rplay_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_rstop_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_save_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_show_32.png
-Comment: 
-
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_stop_32.png
+Filename: wxgl/wxapp.py
 Comment: 
 
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/tb_style_32.png
+Filename: wxgl/wxfigure.py
 Comment: 
 
-Filename: wxgl-0.9.3.data/data/lib/site-packages/wxgl/res/wxplot.ico
+Filename: wxgl/wxscene.py
 Comment: 
 
-Filename: wxgl-0.9.3.dist-info/METADATA
+Filename: wxgl-0.9.8.dist-info/METADATA
 Comment: 
 
-Filename: wxgl-0.9.3.dist-info/WHEEL
+Filename: wxgl-0.9.8.dist-info/WHEEL
 Comment: 
 
-Filename: wxgl-0.9.3.dist-info/top_level.txt
+Filename: wxgl-0.9.8.dist-info/top_level.txt
 Comment: 
 
-Filename: wxgl-0.9.3.dist-info/RECORD
+Filename: wxgl-0.9.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## wxgl/__init__.py

```diff
@@ -1,50 +1,51 @@
-# -*- coding: utf-8 -*-
-
-from OpenGL.GL import *
-from wxgl.scene import Scene
-from wxgl.texture import Texture
-from wxgl.model import Model
-from wxgl.light import BaseLight, SunLight, LampLight, SkyLight, SphereLight
-from wxgl.util import font_list, color_list, color_help, cmap_list, cmap_help, cmap, text2image
-
-name = 'wxgl'
-version = '0.9.3'
-version_info = (0, 9, 3, 0)
-
-VERTEX_SHADER                   = GL_VERTEX_SHADER
-TESS_CONTROL_SHADER             = GL_TESS_CONTROL_SHADER
-TESS_EVALUATION_SHADER          = GL_TESS_EVALUATION_SHADER
-GEOMETRY_SHADER                 = GL_GEOMETRY_SHADER
-FRAGMENT_SHADER                 = GL_FRAGMENT_SHADER
-COMPUTE_SHADER                  = GL_COMPUTE_SHADER
-
-POINTS	                        = GL_POINTS	      
-LINES	                        = GL_LINES	      
-LINE_STRIP	                    = GL_LINE_STRIP	  
-LINE_LOOP	                    = GL_LINE_LOOP
-TRIANGLES	                    = GL_TRIANGLES	  
-TRIANGLE_STRIP                  = GL_TRIANGLE_STRIP
-TRIANGLE_FAN                    = GL_TRIANGLE_FAN  
-QUADS	                        = GL_QUADS	      
-QUAD_STRIP                      = GL_QUAD_STRIP
-
-TEXTURE_1D                      = GL_TEXTURE_1D                         
-TEXTURE_1D_ARRAY                = GL_TEXTURE_1D_ARRAY                   
-TEXTURE_2D                      = GL_TEXTURE_2D                         
-TEXTURE_2D_ARRAY                = GL_TEXTURE_2D_ARRAY                   
-TEXTURE_3D                      = GL_TEXTURE_3D                         
-TEXTURE_RECTANGLE               = GL_TEXTURE_RECTANGLE                  
-TEXTURE_CUBE_MAP                = GL_TEXTURE_CUBE_MAP                   
-TEXTURE_CUBE_MAP_ARRAY          = GL_TEXTURE_CUBE_MAP_ARRAY             
-TEXTURE_BUFFER                  = GL_TEXTURE_BUFFER
-    
-NEAREST                         = GL_NEAREST             
-LINEAR                          = GL_LINEAR              
-NEAREST_MIPMAP_NEAREST          = GL_NEAREST_MIPMAP_NEAREST
-LINEAR_MIPMAP_NEAREST           = GL_LINEAR_MIPMAP_NEAREST
-NEAREST_MIPMAP_LINEAR           = GL_NEAREST_MIPMAP_LINEAR
-LINEAR_MIPMAP_LINEAR            = GL_LINEAR_MIPMAP_LINEAR
-    
-REPEAT                          = GL_REPEAT         
-MIRRORED_REPEAT                 = GL_MIRRORED_REPEAT
-CLAMP_TO_EDGE                   = GL_CLAMP_TO_EDGE
+#!/usr/bin/env python3
+
+from OpenGL.GL import *
+from wxgl.app import App
+from wxgl.scheme import Scheme
+from wxgl.texture import Texture
+from wxgl.model import Model
+from wxgl.light import BaseLight, SunLight, LampLight, SkyLight, SphereLight
+from wxgl.util import font_list, color_list, cm_list, cmap, text2img, get_normal, y2v
+
+name = 'wxgl'
+version = '0.9.8'
+version_info = (0, 9, 8, 0)
+
+VERTEX_SHADER                   = GL_VERTEX_SHADER
+TESS_CONTROL_SHADER             = GL_TESS_CONTROL_SHADER
+TESS_EVALUATION_SHADER          = GL_TESS_EVALUATION_SHADER
+GEOMETRY_SHADER                 = GL_GEOMETRY_SHADER
+FRAGMENT_SHADER                 = GL_FRAGMENT_SHADER
+COMPUTE_SHADER                  = GL_COMPUTE_SHADER
+
+POINTS	                        = GL_POINTS	      
+LINES	                        = GL_LINES	      
+LINE_STRIP	                    = GL_LINE_STRIP	  
+LINE_LOOP	                    = GL_LINE_LOOP
+TRIANGLES	                    = GL_TRIANGLES	  
+TRIANGLE_STRIP                  = GL_TRIANGLE_STRIP
+TRIANGLE_FAN                    = GL_TRIANGLE_FAN  
+QUADS	                        = GL_QUADS	      
+QUAD_STRIP                      = GL_QUAD_STRIP
+
+TEXTURE_1D                      = GL_TEXTURE_1D                         
+TEXTURE_1D_ARRAY                = GL_TEXTURE_1D_ARRAY                   
+TEXTURE_2D                      = GL_TEXTURE_2D                         
+TEXTURE_2D_ARRAY                = GL_TEXTURE_2D_ARRAY                   
+TEXTURE_3D                      = GL_TEXTURE_3D                         
+TEXTURE_RECTANGLE               = GL_TEXTURE_RECTANGLE                  
+TEXTURE_CUBE_MAP                = GL_TEXTURE_CUBE_MAP                   
+TEXTURE_CUBE_MAP_ARRAY          = GL_TEXTURE_CUBE_MAP_ARRAY             
+TEXTURE_BUFFER                  = GL_TEXTURE_BUFFER
+    
+NEAREST                         = GL_NEAREST             
+LINEAR                          = GL_LINEAR              
+NEAREST_MIPMAP_NEAREST          = GL_NEAREST_MIPMAP_NEAREST
+LINEAR_MIPMAP_NEAREST           = GL_LINEAR_MIPMAP_NEAREST
+NEAREST_MIPMAP_LINEAR           = GL_NEAREST_MIPMAP_LINEAR
+LINEAR_MIPMAP_LINEAR            = GL_LINEAR_MIPMAP_LINEAR
+    
+REPEAT                          = GL_REPEAT         
+MIRRORED_REPEAT                 = GL_MIRRORED_REPEAT
+CLAMP_TO_EDGE                   = GL_CLAMP_TO_EDGE
```

## wxgl/light.py

```diff
@@ -1,1587 +1,1302 @@
-# -*- coding: utf-8 -*-
-
-import numpy as np
-from OpenGL.GL import *
-from . import model as wxModel
-
-
-class BaseLight:
-    """环境光照情景模式"""
-    
-    def __init__(self, ambient=(1.0,1.0,1.0)):
-        """构造函数"""
-        
-        self.ambient = ambient              # 环境光
-    
-    def get_model(self, gltype, vs, **kwds):
-        """返回模型对象"""
-        
-        indices = kwds.get('indices')
-        color = kwds.get('color')
-        texture = kwds.get('texture')
-        texcoord = kwds.get('texcoord')
-        lw = kwds.get('lw')
-        ls = kwds.get('ls')
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', True)
-        cull = kwds.get('cull')
-        fill = kwds.get('fill')
-        slide = kwds.get('slide')
-        transform = kwds.get('transform')
-        
-        if color is None:
-            vshader = self.get_texture_vshader(texture.ttype)
-            fshader = self.get_texture_fshader(texture.ttype)
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_vertex('a_Position', vs, indices)
-            m.set_texcoord('a_Texcoord', texcoord)
-            m.add_texture('u_Texture', texture)
-            m.set_argument('u_AmbientColor', self.ambient)
-            m.set_picked('u_Picked')
-            m.set_proj_matrix('u_ProjMatrix')
-            m.set_view_matrix('u_ViewMatrix')
-            m.set_model_matrix('u_ModelMatrix', transform)
-            m.set_cull_mode(cull)
-            m.set_fill_mode(fill)
-            m.set_slide(slide)
-        else:
-            vshader = self.get_color_vshader()
-            fshader = self.get_color_fshader()
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_vertex('a_Position', vs, indices)
-            m.set_color('a_Color', color)
-            m.set_argument('u_AmbientColor', self.ambient)
-            m.set_picked('u_Picked')
-            m.set_proj_matrix('u_ProjMatrix')
-            m.set_view_matrix('u_ViewMatrix')
-            m.set_model_matrix('u_ModelMatrix', transform)
-            m.set_line_style(lw, ls)
-            m.set_cull_mode(cull)
-            m.set_fill_mode(fill)
-            m.set_slide(slide)
-        
-        return m
-    
-    def get_color_vshader(self):
-        """返回颜色模型的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec4 a_Color;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out vec4 v_Color;
-            
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Color = a_Color;
-            }
-        """
-    
-    def get_texture_vshader(self, ttype):
-        """返回纹理模型的顶点着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-        elif ttype == GL_TEXTURE_2D_ARRAY or ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in %s a_Texcoord;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out %s v_Texcoord;
-            
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Texcoord = a_Texcoord;
-            }
-        """ % (a_dtype, a_dtype)
-        
-    def get_color_fshader(self):
-        """返回颜色的片元着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 v_Color;
-            uniform vec3 u_AmbientColor;
-            uniform int u_Picked;
-            
-            void main() { 
-                vec3 rgb = v_Color.rgb * u_AmbientColor;
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, v_Color.a); 
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a); 
-            } 
-        """
-        
-    def get_texture_fshader(self, ttype):
-        """返回纹理的片元着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-            u_dtype = 'sampler1D'
-            f_name = 'texture1D'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-            u_dtype = 'sampler2D'
-            f_name = 'texture2D'
-        elif ttype == GL_TEXTURE_2D_ARRAY:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler2DArray'
-            f_name = 'texture2DArray'
-        elif ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler3D'
-            f_name = 'texture3D'
-        
-        return """
-            #version 330 core
-            
-            in %s v_Texcoord;
-            uniform vec3 u_AmbientColor;
-            uniform %s u_Texture;
-            uniform int u_Picked;
-            
-            void main() { 
-                vec4 color = %s(u_Texture, v_Texcoord);
-                vec3 rgb = color.rgb * u_AmbientColor;
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """ % (a_dtype, u_dtype, f_name)
-
-class BaseLightPoint:
-    """适用于点环境光照情景模式"""
-    
-    def __init__(self, ambient=(1.0,1.0,1.0)):
-        """构造函数"""
-        
-        self.ambient = ambient              # 环境光
-    
-    def get_model(self, gltype, vs, **kwds):
-        """返回模型对象"""
-        
-        color = kwds.get('color')
-        psize = kwds.get('psize')
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', False)
-        slide = kwds.get('slide')
-        transform = kwds.get('transform')
-        
-        vshader = self.get_point_vshader()
-        fshader = self.get_point_fshader()
-        
-        m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-        m.set_vertex('a_Position', vs)
-        m.set_color('a_Color', color)
-        m.set_psize('a_Psize', psize)
-        m.set_picked('u_Picked')
-        m.set_argument('u_AmbientColor', self.ambient)
-        m.set_proj_matrix('u_ProjMatrix')
-        m.set_view_matrix('u_ViewMatrix')
-        m.set_model_matrix('u_ModelMatrix', transform)
-        m.set_slide(slide)
-        
-        return m
-    
-    def get_point_vshader(self):
-        """返回点的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec4 a_Color;
-            in float a_Psize;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out vec4 v_Color;
-            
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
-                gl_PointSize = a_Psize;
-                v_Color = a_Color;
-            }
-        """
-        
-    def get_point_fshader(self):
-        """返回散点的片元着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 v_Color;
-            uniform vec3 u_AmbientColor;
-            uniform int u_Picked;
-            
-            void main() { 
-                vec2 temp = gl_PointCoord - vec2(0.5);
-                float f = dot(temp, temp);
-                
-                if (f > 0.25)
-                    discard;
-                
-                vec3 rgb = v_Color.rgb * u_AmbientColor;
-                vec4 color = mix(vec4(rgb, v_Color.a), vec4(rgb, 0.0), smoothstep(0.2, 0.25, f));
-                if (u_Picked == 0)
-                    gl_FragColor = color;
-                else
-                    gl_FragColor = vec4(min(color.rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """
-
-class BaseLightText2d:
-    """适用于2d文本的环境光照情景模式"""
-    
-    def __init__(self, ambient=(1.0,1.0,1.0)):
-        """构造函数"""
-        
-        self.ambient = ambient              # 环境光
-    
-    def get_model(self, gltype, vs, **kwds):
-        """返回模型对象"""
-        
-        color = kwds.get('color')
-        texture = kwds.get('texture')
-        texcoord = kwds.get('texcoord')
-        loc = kwds.get('loc')
-        tw = kwds.get('tw')
-        th = kwds.get('th')
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', True)
-        slide = kwds.get('slide')
-        
-        vshader = self.get_text2d_vshader()
-        fshader = self.get_text2d_fshader()
-        
-        m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-        m.set_vertex('a_Position', vs)
-        m.set_texcoord('a_Texcoord', texcoord)
-        m.add_texture('u_Texture', texture)
-        m.set_argument('u_AmbientColor', self.ambient)
-        m.set_argument('u_TextWidth', tw)
-        m.set_argument('u_TextHeight', th)
-        m.set_argument('u_Corner', loc)
-        m.set_picked('u_Picked')
-        m.set_proj_matrix('u_ProjMatrix')
-        m.set_view_matrix('u_ViewMatrix')
-        m.set_model_matrix('u_ModelMatrix')
-        m.set_slide(slide)
-        
-        return m
-    
-    def get_text2d_vshader(self):
-        """返回2d文本的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec2 a_Texcoord;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            uniform float u_TextWidth;
-            uniform float u_TextHeight;
-            uniform int u_Corner;
-            out vec2 v_Texcoord;
-            
-            void main() {
-                v_Texcoord = a_Texcoord;
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                
-                switch (u_Corner) {
-                    case 0:
-                        if (gl_VertexID == 1) {
-                            gl_Position.y -= u_TextHeight;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.y -= u_TextHeight;
-                            gl_Position.x += u_TextWidth;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.x += u_TextWidth;
-                        }
-                        break;
-                    case 1:
-                        if (gl_VertexID == 0) {
-                            gl_Position.y += u_TextHeight/2;
-                        } else if (gl_VertexID == 1) {
-                            gl_Position.y -= u_TextHeight/2;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.x += u_TextWidth;
-                            gl_Position.y -= u_TextHeight/2;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.x += u_TextWidth;
-                            gl_Position.y += u_TextHeight/2;
-                        }
-                        break;
-                    case 2:
-                        if (gl_VertexID == 0) {
-                            gl_Position.y += u_TextHeight;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.x += u_TextWidth;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.x += u_TextWidth;
-                            gl_Position.y += u_TextHeight;
-                        }
-                        break;
-                    case 3:
-                        if (gl_VertexID == 0) {
-                            gl_Position.x -= u_TextWidth/2;
-                        } else if (gl_VertexID == 1) {
-                            gl_Position.x -= u_TextWidth/2;
-                            gl_Position.y -= u_TextHeight;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.x += u_TextWidth/2;
-                            gl_Position.y -= u_TextHeight;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.x += u_TextWidth/2;
-                        }
-                        break;
-                    case 4:
-                        if (gl_VertexID == 0) {
-                            gl_Position.x -= u_TextWidth/2;
-                            gl_Position.y += u_TextHeight/2;
-                        } else if (gl_VertexID == 1) {
-                            gl_Position.x -= u_TextWidth/2;
-                            gl_Position.y -= u_TextHeight/2;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.x += u_TextWidth/2;
-                            gl_Position.y -= u_TextHeight/2;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.x += u_TextWidth/2;
-                            gl_Position.y += u_TextHeight/2;
-                        }
-                        break;
-                    case 5:
-                        if (gl_VertexID == 0) {
-                            gl_Position.x -= u_TextWidth/2;
-                            gl_Position.y += u_TextHeight;
-                        } else if (gl_VertexID == 1) {
-                            gl_Position.x -= u_TextWidth/2;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.x += u_TextWidth/2;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.x += u_TextWidth/2;
-                            gl_Position.y += u_TextHeight;
-                        }
-                        break;
-                    case 6:
-                        if (gl_VertexID == 0) {
-                            gl_Position.x -= u_TextWidth;
-                        } else if (gl_VertexID == 1) {
-                            gl_Position.x -= u_TextWidth;
-                            gl_Position.y -= u_TextHeight;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.y -= u_TextHeight;
-                        }
-                        break;
-                    case 7:
-                        if (gl_VertexID == 0) {
-                            gl_Position.x -= u_TextWidth;
-                            gl_Position.y += u_TextHeight/2;
-                        } else if (gl_VertexID == 1) {
-                            gl_Position.x -= u_TextWidth;
-                            gl_Position.y -= u_TextHeight/2;
-                        } else if (gl_VertexID == 3) {
-                            gl_Position.y -= u_TextHeight/2;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.y += u_TextHeight/2;
-                        }
-                        break;
-                    default:
-                        if (gl_VertexID == 0) {
-                            gl_Position.x -= u_TextWidth;
-                            gl_Position.y += u_TextHeight;
-                        } else if (gl_VertexID == 1) {
-                            gl_Position.x -= u_TextWidth;
-                        } else if (gl_VertexID == 2) {
-                            gl_Position.y += u_TextHeight;
-                        }
-                }
-            }
-        """
-        
-    def get_text2d_fshader(self):
-        """返回2d文本的片元着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec2 v_Texcoord;
-            uniform vec3 u_AmbientColor;
-            uniform sampler2D u_Texture;
-            uniform int u_Picked;
-            
-            void main() { 
-                vec4 color = texture2D(u_Texture, v_Texcoord);
-                vec3 rgb = color.rgb * u_AmbientColor;
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """
-
-class BaseLightText2dArray:
-    """适用于2d文本数组的环境光照情景模式"""
-    
-    def __init__(self, ambient=(1.0,1.0,1.0)):
-        """构造函数"""
-        
-        self.ambient = ambient              # 环境光
-    
-    def get_model(self, gltype, vs_arr, loc_view, texture, texcoord, tw, th, **kwds):
-        """返回模型对象"""
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', False)
-        slide = kwds.get('slide')
-        
-        vshader = self.get_text2darray_vshader()
-        fshader = self.get_text2darray_fshader()
-        
-        m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-        m.set_vertex('a_Position', vs_arr)
-        m.set_texcoord('a_Texcoord', texcoord)
-        m.add_texture('u_Texture', texture)
-        m.set_argument('u_AmbientColor', self.ambient)
-        m.set_argument('u_TextWidth', tw)
-        m.set_argument('u_TextHeight', th)
-        m.set_argument('a_LocView', loc_view)
-        m.set_ae('u_Ae')
-        m.set_picked('u_Picked')
-        m.set_proj_matrix('u_ProjMatrix')
-        m.set_view_matrix('u_ViewMatrix')
-        m.set_model_matrix('u_ModelMatrix')
-        m.set_slide(slide)
-        
-        return m
-    
-    def get_text2darray_vshader(self):
-        """返回2d文本数组的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec3 a_Texcoord;
-            in ivec2 a_LocView;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            uniform float u_TextWidth;
-            uniform float u_TextHeight;
-            out vec3 v_Texcoord;
-            out float v_View;
-            
-            void main() {
-                v_Texcoord = a_Texcoord;
-                v_View = float(a_LocView[1]);
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                
-                int idx = gl_VertexID % 4;
-                if (a_LocView[0] == 4) {
-                    if (idx == 0) {
-                        gl_Position.x -= u_TextWidth/2;
-                        gl_Position.y += u_TextHeight/2;
-                    } else if (idx == 1) {
-                        gl_Position.x -= u_TextWidth/2;
-                        gl_Position.y -= u_TextHeight/2;
-                    } else if (idx == 2) {
-                        gl_Position.x += u_TextWidth/2;
-                        gl_Position.y -= u_TextHeight/2;
-                    } else if (idx == 3) {
-                        gl_Position.x += u_TextWidth/2;
-                        gl_Position.y += u_TextHeight/2;
-                    }
-                } else {
-                    if (idx == 0) {
-                        gl_Position.x -= u_TextWidth;
-                        gl_Position.y += u_TextHeight/2;
-                    } else if (idx == 1) {
-                        gl_Position.x -= u_TextWidth;
-                        gl_Position.y -= u_TextHeight/2;
-                    } else if (idx == 2) {
-                        gl_Position.y -= u_TextHeight/2;
-                    } else if (idx == 3) {
-                        gl_Position.y += u_TextHeight/2;
-                    }
-                }
-            }
-        """
-        
-    def get_text2darray_fshader(self):
-        """返回2d文本数组的片元着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec3 v_Texcoord;
-            in float v_View;
-            uniform vec3 u_AmbientColor;
-            uniform sampler2DArray u_Texture;
-            uniform int u_Picked;
-            uniform vec2 u_Ae;
-            
-            void main() { 
-                bool up = u_Ae[1] > -90 && u_Ae[1] < 90; 
-                switch (int(v_View)) {
-                    case 1:
-                        if (u_Ae[0] < 0 || u_Ae[0] >= 90) discard;
-                        break;
-                    case 2:
-                        if (u_Ae[0] < 90 || u_Ae[0] >= 180) discard;
-                        break;
-                    case 3:
-                        if (u_Ae[0] >= -90 || u_Ae[0] < -180) discard;
-                        break;
-                    case 4:
-                        if (u_Ae[0] >= 0 || u_Ae[0] < -90) discard;
-                        break;
-                    case 5:
-                        if (u_Ae[1] < 0 || (up && (u_Ae[0] <= -90 || u_Ae[0] >= 90)) || (!up && u_Ae[0] >= -90 && u_Ae[0] <= 90)) discard;
-                        break;
-                    case 6:
-                        if (u_Ae[1] >= 0 || (up && (u_Ae[0] <= -90 || u_Ae[0] >= 90)) || (!up && u_Ae[0] >= -90 && u_Ae[0] <= 90)) discard;
-                        break;
-                    case 7:
-                        if (u_Ae[1] < 0 || (up && u_Ae[0] >= -90 && u_Ae[0] <= 90) || (!up && (u_Ae[0] <= -90 || u_Ae[0] >= 90))) discard;
-                        break;
-                    case 8:
-                        if (u_Ae[1] >= 0 || (up && u_Ae[0] >= -90 && u_Ae[0] <= 90) || (!up && (u_Ae[0] <= -90 || u_Ae[0] >= 90))) discard;
-                        break;
-                    case 9:
-                        if (u_Ae[1] < 0 || (up && u_Ae[0] >= 0 && u_Ae[0] <= 180) || (!up && u_Ae[0] >= -180 && u_Ae[0] <= 0)) discard;
-                        break;
-                    case 10:
-                        if (u_Ae[1] >= 0 || (up && u_Ae[0] >= 0 && u_Ae[0] <= 180) || (!up && u_Ae[0] >= -180 && u_Ae[0] <= 0)) discard;
-                        break;
-                    case 11:
-                        if (u_Ae[1] < 0 || (!up && u_Ae[0] >= 0 && u_Ae[0] <= 180) || (up && u_Ae[0] >= -180 && u_Ae[0] <= 0)) discard;
-                        break;
-                    case 12:
-                        if (u_Ae[1] >= 0 || (!up && u_Ae[0] >= 0 && u_Ae[0] <= 180) || (up && u_Ae[0] >= -180 && u_Ae[0] <= 0)) discard;
-                        break;
-                    default:
-                        break;
-                }
-                
-                vec4 color = texture2DArray(u_Texture, v_Texcoord);
-                vec3 rgb = color.rgb * u_AmbientColor;
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """
-
-class SunLight:
-    """太阳光照情景模式"""
-    
-    def __init__(self, direction=(-5.0,-1.0,-5.0), color=(1.0,1.0,1.0), ambient=(0.3,0.3,0.3), **kwds):
-        """构造函数"""
-        
-        self.direction = direction                                  # 光的方向
-        self.color = color                                          # 光的颜色
-        self.ambient = ambient                                      # 环境光
-        self.stray = kwds.get('stray', False)                       # 杂散光
-        self.roughness = kwds.get('roughness', 0.2)                 # 粗糙度（1-镜面反射系数）：值域范围[0.0,1.0]
-        self.metalness = kwds.get('metalness', 0.2)                 # 金属度（1-漫反射系数）：值域范围[0.0,1.0]
-        self.pellucidness = kwds.get('pellucidness', 0.2)           # 透光度：值域范围[0.0,1.0]
-        self.shininess = np.exp(8*(1-kwds.get('shininess', 0.5)))   # 光洁度（高光系数）：值域范围(0.0,1.0]
-    
-    def get_model(self, gltype, vs, **kwds):
-        """返回模型对象"""
-        
-        indices = kwds.get('indices')
-        color = kwds.get('color')
-        normal = kwds.get('normal')
-        texture = kwds.get('texture')
-        texcoord = kwds.get('texcoord')
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', True)
-        cull = kwds.get('cull')
-        fill = kwds.get('fill')
-        slide = kwds.get('slide')
-        transform = kwds.get('transform')
-        
-        if color is None:
-            vshader = self.get_texture_vshader(texture.ttype)
-            fshader = self.get_texture_fshader(texture.ttype)
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_texcoord('a_Texcoord', texcoord)
-            m.add_texture('u_Texture', texture)
-        else:
-            vshader = self.get_color_vshader()
-            fshader = self.get_color_fshader()
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_color('a_Color', color)
-        
-        m.set_vertex('a_Position', vs, indices)
-        m.set_normal('a_Normal', normal)
-        m.set_cam_pos('u_CamPos')
-        m.set_picked('u_Picked')
-        m.set_argument('u_AmbientColor', self.ambient)
-        m.set_argument('u_LightDir', self.direction)
-        m.set_argument('u_LightColor', self.color)
-        m.set_argument('u_Shininess', self.shininess)
-        m.set_argument('u_Roughness', self.roughness)
-        m.set_argument('u_Metalness', self.metalness)
-        m.set_argument('u_Pellucidness', self.pellucidness)
-        m.set_proj_matrix('u_ProjMatrix')
-        m.set_view_matrix('u_ViewMatrix')
-        m.set_model_matrix('u_ModelMatrix', transform)
-        m.set_cull_mode(cull)
-        m.set_fill_mode(fill)
-        m.set_slide(slide)
-        
-        return m
-    
-    def get_color_vshader(self):
-        """返回使用颜色的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in vec4 a_Color;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out vec4 v_Color;
-            out vec3 v_Position;
-            out vec3 v_Normal;
-            
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Color = a_Color;
-                v_Position= vec3(u_ModelMatrix * a_Position);
-                
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-            }
-        """
-    
-    def get_texture_vshader(self, ttype):
-        """返回使用纹理的顶点着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-        elif ttype == GL_TEXTURE_2D_ARRAY or ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in %s a_Texcoord;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out %s v_Texcoord;
-            out vec3 v_Position;
-            out vec3 v_Normal;
-            
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Texcoord = a_Texcoord;
-                v_Position= vec3(u_ModelMatrix * a_Position);
-                
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-            }
-        """ % (a_dtype, a_dtype)
-    
-    def get_color_fshader(self):
-        """返回使用颜色的片元着色器源码"""
-        
-        if self.stray:
-            diffuse_str = '(1 - u_Metalness) * (dot(lightDir, v_Normal) + 1.0) / 2.0'
-        else:
-            diffuse_str = '(1 - u_Metalness) * max(0.0, dot(lightDir, v_Normal))'
-        
-        return """
-            #version 330 core
-            
-            in vec4 v_Color;
-            in vec3 v_Position;
-            in vec3 v_Normal;
-            uniform vec3 u_LightDir; // 定向光方向
-            uniform vec3 u_LightColor; // 定向光颜色
-            uniform vec3 u_AmbientColor; // 环境光颜色
-            uniform vec3 u_CamPos; // 相机位置
-            uniform int u_Picked; // 拾取标志
-            uniform float u_Shininess; // 光洁度
-            uniform float u_Roughness; // 粗糙度
-            uniform float u_Metalness; // 金属度
-            uniform float u_Pellucidness; // 透光度
-            
-            void main() { 
-                vec3 lightDir = normalize(u_LightDir); // 光线向量
-                vec3 camDir = normalize(v_Position - u_CamPos); // 视线向量
-                vec3 middleDir = normalize(camDir + lightDir); // 视线和光线的中间向量
-                
-                float diffuseCos = %s; // 光线向量和法向量的内积
-                float specularCos = (1 - u_Roughness) * max(0.0, dot(middleDir, v_Normal)); // 中间向量和法向量内积
-                
-                specularCos = pow(specularCos, u_Shininess);
-                if (!gl_FrontFacing) diffuseCos *= u_Pellucidness;
-                
-                vec3 scatteredLight = u_AmbientColor + u_LightColor * diffuseCos; // 散射光
-                vec3 reflectedLight = u_LightColor * specularCos; // 反射光
-                vec3 rgb = min(v_Color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
-                
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, v_Color.a);
-                else
-                    gl_FragColor = vec4(min(rgb * 1.5, vec3(1.0)), v_Color.a);
-            }
-        """ % diffuse_str
-    
-    def get_texture_fshader(self, ttype):
-        """返回使用纹理的片元着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-            u_dtype = 'sampler1D'
-            f_name = 'texture1D'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-            u_dtype = 'sampler2D'
-            f_name = 'texture2D'
-        elif ttype == GL_TEXTURE_2D_ARRAY:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler2DArray'
-            f_name = 'texture2DArray'
-        elif ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler3D'
-            f_name = 'texture3D'
-        
-        if self.stray:
-            diffuse_str = '(1 - u_Metalness) * (dot(lightDir, v_Normal) + 1.0) / 2.0'
-        else:
-            diffuse_str = '(1 - u_Metalness) * max(0.0, dot(lightDir, v_Normal))'
-        
-        return """
-            #version 330 core
-            
-            in %s v_Texcoord;
-            in vec3 v_Position;
-            in vec3 v_Normal;
-            uniform %s u_Texture;
-            uniform vec3 u_LightDir; // 定向光方向
-            uniform vec3 u_LightColor; // 定向光颜色
-            uniform vec3 u_AmbientColor; // 环境光颜色
-            uniform vec3 u_CamPos; // 相机位置
-            uniform int u_Picked; // 拾取标志
-            uniform float u_Shininess; // 光洁度
-            uniform float u_Roughness; // 粗糙度
-            uniform float u_Metalness; // 金属度
-            uniform float u_Pellucidness; // 透光度
-            
-            void main() { 
-                vec3 lightDir = normalize(u_LightDir); // 光线向量
-                vec3 camDir = normalize(v_Position - u_CamPos); // 视线向量
-                vec3 middleDir = normalize(camDir + lightDir); // 视线和光线的中间向量
-                vec4 color = %s(u_Texture, v_Texcoord);
-                
-                float diffuseCos = %s; // 光线向量和法向量的内积
-                float specularCos = (1 - u_Roughness) * max(0.0, dot(middleDir, v_Normal)); // 中间向量和法向量内积
-                
-                if (!gl_FrontFacing) 
-                    diffuseCos *= u_Pellucidness;
-                
-                if (diffuseCos == 0.0 || u_Shininess > 2980.0) 
-                    specularCos = 0.0;
-                else
-                    specularCos = pow(specularCos, u_Shininess);
-                
-                vec3 scatteredLight = u_AmbientColor + u_LightColor * diffuseCos; // 散射光
-                vec3 reflectedLight = u_LightColor * specularCos; // 反射光
-                vec3 rgb = min(color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
-                
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """ % (a_dtype, u_dtype, f_name, diffuse_str)
-
-class LampLight:
-    """定位光照情景模式"""
-    
-    def __init__(self, position=(5.0,1.0,5.0), color=(1.0,1.0,1.0), ambient=(0.3,0.3,0.3), **kwds):
-        """构造函数"""
-        
-        self.position = position                                    # 光源位置
-        self.color = color                                          # 光的颜色
-        self.ambient = ambient                                      # 环境光
-        self.stray = kwds.get('stray', False)                       # 杂散光
-        self.roughness = kwds.get('roughness', 0.2)                 # 粗糙度（1-镜面反射系数）：值域范围[0.0,1.0]
-        self.metalness = kwds.get('metalness', 0.2)                 # 金属度（1-漫反射系数）：值域范围[0.0,1.0]
-        self.pellucidness = kwds.get('pellucidness', 0.2)           # 透光度：值域范围[0.0,1.0]
-        self.shininess = np.exp(8*(1-kwds.get('shininess', 0.5)))   # 光洁度（高光系数）：值域范围(0.0,1.0]
-    
-    def get_model(self, gltype, vs, **kwds):
-        """返回模型对象"""
-        
-        indices = kwds.get('indices')
-        color = kwds.get('color')
-        normal = kwds.get('normal')
-        texture = kwds.get('texture')
-        texcoord = kwds.get('texcoord')
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', True)
-        cull = kwds.get('cull')
-        fill = kwds.get('fill')
-        slide = kwds.get('slide')
-        transform = kwds.get('transform')
-        
-        if color is None:
-            vshader = self.get_texture_vshader(texture.ttype)
-            fshader = self.get_texture_fshader(texture.ttype)
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_texcoord('a_Texcoord', texcoord)
-            m.add_texture('u_Texture', texture)
-        else:
-            vshader = self.get_color_vshader()
-            fshader = self.get_color_fshader()
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_color('a_Color', color)
-        
-        m.set_vertex('a_Position', vs, indices)
-        m.set_normal('a_Normal', normal)
-        m.set_cam_pos('u_CamPos')
-        m.set_picked('u_Picked')
-        m.set_argument('u_AmbientColor', self.ambient)
-        m.set_argument('u_LightPos', self.position)
-        m.set_argument('u_LightColor', self.color)
-        m.set_argument('u_Shininess', self.shininess)
-        m.set_argument('u_Roughness', self.roughness)
-        m.set_argument('u_Metalness', self.metalness)
-        m.set_argument('u_Pellucidness', self.pellucidness)
-        m.set_proj_matrix('u_ProjMatrix')
-        m.set_view_matrix('u_ViewMatrix')
-        m.set_model_matrix('u_ModelMatrix', transform)
-        m.set_cull_mode(cull)
-        m.set_fill_mode(fill)
-        m.set_slide(slide)
-        
-        return m
-    
-    def get_color_vshader(self):
-        """返回使用颜色的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in vec4 a_Color;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out vec4 v_Color;
-            out vec3 v_Position;
-            out vec3 v_Normal;
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Color = a_Color;
-                v_Position= vec3(u_ModelMatrix * a_Position);
-                
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-            }
-        """
-    
-    def get_texture_vshader(self):
-        """返回使用纹理的顶点着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-        elif ttype == GL_TEXTURE_2D_ARRAY or ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-        
-        return """
-            #version 330 core
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in %s a_Texcoord;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out %s v_Texcoord;
-            out vec3 v_Position;
-            out vec3 v_Normal;
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Texcoord = a_Texcoord;
-                v_Position= vec3(u_ModelMatrix * a_Position);
-                
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-            }
-        """ % (a_dtype, a_dtype)
-    
-    def get_color_fshader(self):
-        """返回使用颜色的片元着色器源码"""
-        
-        if self.stray:
-            diffuse_str = '(1 - u_Metalness) * (dot(lightDir, v_Normal) + 1.0) / 2.0'
-        else:
-            diffuse_str = '(1 - u_Metalness) * max(0.0, dot(lightDir, v_Normal))'
-        
-        return """
-            #version 330 core
-            in vec4 v_Color;
-            in vec3 v_Position;
-            in vec3 v_Normal;
-            uniform vec3 u_LightPos; // 光源位置
-            uniform vec3 u_LightColor; // 光源颜色
-            uniform vec3 u_AmbientColor; // 环境光颜色
-            uniform vec3 u_CamPos; // 相机位置
-            uniform int u_Picked; // 拾取标志
-            uniform float u_Shininess; // 光洁度
-            uniform float u_Roughness; // 粗糙度
-            uniform float u_Metalness; // 金属度
-            uniform float u_Pellucidness; // 透光度
-            void main() { 
-                vec3 lightDir = normalize(v_Position - u_LightPos); // 光线向量
-                vec3 camDir = normalize(v_Position - u_CamPos); // 视线向量
-                vec3 middleDir = normalize(camDir + lightDir); // 视线和光线的中间向量
-                
-                float diffuseCos = %s; // 光线向量和法向量的内积
-                float specularCos = (1 - u_Roughness) * max(0.0, dot(middleDir, v_Normal)); // 中间向量和法向量内积
-                
-                specularCos = pow(specularCos, u_Shininess);
-                if (!gl_FrontFacing) diffuseCos *= u_Pellucidness;
-                
-                vec3 scatteredLight = u_AmbientColor + u_LightColor * diffuseCos; // 散射光
-                vec3 reflectedLight = u_LightColor * specularCos; // 反射光
-                vec3 rgb = min(v_Color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
-                
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, v_Color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a);
-            }
-        """ % diffuse_str
-    
-    def get_texture_fshader(self):
-        """返回使用纹理的片元着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-            u_dtype = 'sampler1D'
-            f_name = 'texture1D'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-            u_dtype = 'sampler2D'
-            f_name = 'texture2D'
-        elif ttype == GL_TEXTURE_2D_ARRAY:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler2DArray'
-            f_name = 'texture2DArray'
-        elif ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler3D'
-            f_name = 'texture3D'
-        
-        if self.stray:
-            diffuse_str = '(1 - u_Metalness) * (dot(lightDir, v_Normal) + 1.0) / 2.0'
-        else:
-            diffuse_str = '(1 - u_Metalness) * max(0.0, dot(lightDir, v_Normal))'
-        
-        return """
-            #version 330 core
-            in %s v_Texcoord;
-            in vec3 v_Position;
-            in vec3 v_Normal;
-            uniform %s u_Texture;
-            uniform vec3 u_LightPos; // 光源位置
-            uniform vec3 u_LightColor; // 光源颜色
-            uniform vec3 u_AmbientColor; // 环境光颜色
-            uniform vec3 u_CamPos; // 相机位置
-            uniform int u_Picked; // 拾取标志
-            uniform float u_Shininess; // 光洁度
-            uniform float u_Roughness; // 粗糙度
-            uniform float u_Metalness; // 金属度
-            uniform float u_Pellucidness; // 透光度
-            void main() { 
-                vec3 lightDir = normalize(v_Position - u_LightPos); // 光线向量
-                vec3 camDir = normalize(v_Position - u_CamPos); // 视线向量
-                vec3 middleDir = normalize(camDir + lightDir); // 视线和光线的中间向量
-                vec4 color = %s(u_Texture, v_Texcoord);
-                
-                float diffuseCos = %s; // 光线向量和法向量的内积
-                float specularCos = (1 - u_Roughness) * max(0.0, dot(middleDir, v_Normal)); // 中间向量和法向量内积
-                
-                if (!gl_FrontFacing) 
-                    diffuseCos *= u_Pellucidness;
-                
-                if (diffuseCos == 0.0 || u_Shininess > 2980.0) 
-                    specularCos = 0.0;
-                else
-                    specularCos = pow(specularCos, u_Shininess);
-                
-                vec3 scatteredLight = u_AmbientColor + u_LightColor * diffuseCos; // 散射光
-                vec3 reflectedLight = u_LightColor * specularCos; // 反射光
-                vec3 rgb = min(color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
-                
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """ % (a_dtype, u_dtype, f_name, diffuse_str)
-
-class SkyLight:
-    """户外光照情景模式"""
-    
-    def __init__(self, direction=(0.0,-1.0,0.0), sky=(1.0,1.0,1.0), ground=(0.5,0.5,0.5)):
-        """构造函数"""
-        
-        self.direction = direction          # 光的方向
-        self.sky = sky                      # 来自天空的环境光
-        self.ground = ground                # 来自地面的环境光
-    
-    def get_model(self, gltype, vs, **kwds):
-        """返回模型对象"""
-        
-        indices = kwds.get('indices')
-        color = kwds.get('color')
-        normal = kwds.get('normal')
-        texture = kwds.get('texture')
-        texcoord = kwds.get('texcoord')
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', True)
-        cull = kwds.get('cull')
-        fill = kwds.get('fill')
-        slide = kwds.get('slide')
-        transform = kwds.get('transform')
-        
-        if color is None:
-            vshader = self.get_texture_vshader(texture.ttype)
-            fshader = self.get_texture_fshader(texture.ttype)
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_texcoord('a_Texcoord', texcoord)
-            m.add_texture('u_Texture', texture)
-        else:
-            vshader = self.get_color_vshader()
-            fshader = self.get_color_fshader()
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_color('a_Color', color)
-        
-        m.set_vertex('a_Position', vs, indices)
-        m.set_normal('a_Normal', normal)
-        m.set_argument('u_LightDir', self.direction)
-        m.set_argument('u_SkyColor', self.sky)
-        m.set_argument('u_GroundColor', self.ground)
-        m.set_picked('u_Picked')
-        m.set_proj_matrix('u_ProjMatrix')
-        m.set_view_matrix('u_ViewMatrix')
-        m.set_model_matrix('u_ModelMatrix', transform)
-        m.set_cull_mode(cull)
-        m.set_fill_mode(fill)
-        m.set_slide(slide)
-        
-        return m
-    
-    def get_color_vshader(self):
-        """返回使用颜色的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in vec4 a_Color;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out vec3 v_Normal;
-            out vec4 v_Color;
-            
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Color = a_Color;
-                
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-            }
-        """
-    
-    def get_texture_vshader(self):
-        """返回使用纹理的顶点着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-        elif ttype == GL_TEXTURE_2D_ARRAY or ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in %s a_Texcoord;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out vec3 v_Normal;
-            out %s v_Texcoord;
-            
-            void main() { 
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-                v_Texcoord = a_Texcoord;
-                
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-            }
-        """ % (a_dtype, a_dtype)
-    
-    def get_color_fshader(self):
-        """返回使用颜色的片元着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 v_Color;
-            in vec3 v_Normal;
-            uniform vec3 u_LightDir; // 定向光方向
-            uniform vec3 u_SkyColor; // 天空光线颜色
-            uniform vec3 u_GroundColor; // 地面光线颜色
-            uniform int u_Picked; // 拾取标志
-            
-            void main() { 
-                float costheta = dot(v_Normal, normalize(u_LightDir)) * 0.5 + 0.5;
-                if (!gl_FrontFacing) costheta *= 0.5;
-                
-                vec3 rgb = mix(u_GroundColor, u_SkyColor, costheta) * v_Color.rgb;
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, v_Color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a);
-            } 
-        """
-    
-    def get_texture_fshader(self):
-        """返回使用纹理的片元着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-            u_dtype = 'sampler1D'
-            f_name = 'texture1D'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-            u_dtype = 'sampler2D'
-            f_name = 'texture2D'
-        elif ttype == GL_TEXTURE_2D_ARRAY:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler2DArray'
-            f_name = 'texture2DArray'
-        elif ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler3D'
-            f_name = 'texture3D'
-        
-        return """
-            #version 330 core
-            
-            in vec3 v_Normal;
-            in %s v_Texcoord;
-            uniform %s u_Texture;
-            uniform vec3 u_LightDir; // 定向光方向
-            uniform vec3 u_SkyColor; // 天空光线颜色
-            uniform vec3 u_GroundColor; // 地面光线颜色
-            uniform int u_Picked; // 拾取标志
-            
-            void main() { 
-                float costheta = dot(v_Normal, normalize(u_LightDir)) * 0.5 + 0.5;
-                if (!gl_FrontFacing) costheta *= 0.5;
-                vec4 color = %s(u_Texture, v_Texcoord);
-                vec3 rgb = mix(u_GroundColor, u_SkyColor, costheta) * color.rgb;
-                
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """ % (a_dtype, u_dtype, f_name)
-        
-class SphereLight:
-    """球谐光照情景模式"""
-    
-    def __init__(self, key=0, factor=0.8):
-        """构造函数"""
-        
-        self.factor = factor                # 反射衰减因子
-        self.parameter = [
-            # 0. Old Town square 
-            """
-            const vec3 L00 = vec3(0.871297, 0.875255, 0.864470);
-            const vec3 L1m1 = vec3(0.175058, 0.245335, 0.312891);
-            const vec3 L10 = vec3(0.034675, 0.036107, 0.037362);
-            const vec3 L11 = vec3(-0.004629, -0.029448, -0.048028);
-            const vec3 L2m1 = vec3(0.003242, 0.003624, 0.007511);
-            const vec3 L2m2 = vec3(-0.120535, -0.121160, -0.117507);
-            const vec3 L20 = vec3(-0.028667, -0.024926, -0.020998);
-            const vec3 L21 = vec3(-0.077539, -0.086325, -0.091591);
-            const vec3 L22 = vec3(-0.161784, -0.191783, -0.219152);
-            """,
-            
-            # 1. Grace cathedral
-            """
-            const vec3 L00 = vec3(0.79, 0.44, 0.54);
-            const vec3 L1m1 = vec3(0.39, 0.35, 0.60);
-            const vec3 L10 = vec3(-0.34, -0.18, -0.27);
-            const vec3 L11 = vec3(-0.29, -0.06, 0.01);
-            const vec3 L2m1 = vec3(-0.26, -0.22, -0.47);
-            const vec3 L2m2 = vec3(-0.11, -0.05, -0.12);
-            const vec3 L20 = vec3(-0.16, -0.09, -0.15);
-            const vec3 L21 = vec3(0.56, 0.21, 0.14);
-            const vec3 L22 = vec3(0.21, -0.05, -0.30);
-            """,
-            
-            # 2. Eucalyptus grove
-            """
-            const vec3 L00 = vec3(0.38, 0.43, 0.45);
-            const vec3 L1m1 = vec3(0.29, 0.36, 0.41);
-            const vec3 L10 = vec3(0.04, 0.03, 0.01);
-            const vec3 L11 = vec3(-0.10, -0.10, -0.09);
-            const vec3 L2m1 = vec3(0.01, -0.01, -0.05);
-            const vec3 L2m2 = vec3(-0.06, -0.06, -0.04);
-            const vec3 L20 = vec3(-0.09, -0.13, -0.15);
-            const vec3 L21 = vec3(-0.06, -0.05, -0.04);
-            const vec3 L22 = vec3(0.02, 0.0, -0.05);
-            """,
-            
-            # 3. St. Peter's basilica
-            """
-            const vec3 L00 = vec3(0.36, 0.26, 0.23);
-            const vec3 L1m1 = vec3(0.18, 0.14, 0.13);
-            const vec3 L10 = vec3(-0.02, -0.01, 0.0);
-            const vec3 L11 = vec3(0.03, 0.02, 0.0);
-            const vec3 L2m1 = vec3(-0.05, -0.03, -0.01);
-            const vec3 L2m2 = vec3(0.02, 0.01, 0.0);
-            const vec3 L20 = vec3(-0.09, -0.08, -0.07);
-            const vec3 L21 = vec3(0.01, 0.0, 0.0);
-            const vec3 L22 = vec3(-0.08, -0.03, 0.0);
-            """,
-            
-            # 4. Uffizi gallery
-            """
-            const vec3 L00 = vec3(0.32, 0.31, 0.35);
-            const vec3 L1m1 = vec3(0.37, 0.37, 0.43);
-            const vec3 L10 = vec3(0.0, 0.0, 0.0);
-            const vec3 L11 = vec3(-0.01, -0.01, -0.01);
-            const vec3 L2m1 = vec3(-0.01, -0.01, -0.01);
-            const vec3 L2m2 = vec3(-0.02, -0.02, -0.03);
-            const vec3 L20 = vec3(-0.28, -0.28, -0.32);
-            const vec3 L21 = vec3(0.0, 0.0, 0.0);
-            const vec3 L22 = vec3(-0.24, -0.24, -0.28);
-            """,
-            
-            # 5. Galileo's tomb
-            """
-            const vec3 L00 = vec3(1.04, 0.76, 0.71);
-            const vec3 L1m1 = vec3(0.44, 0.34, 0.34);
-            const vec3 L10 = vec3(-0.22, -0.18, -0.17);
-            const vec3 L11 = vec3(0.71, 0.54, 0.56);
-            const vec3 L2m1 = vec3(-0.12, -0.09, -0.08);
-            const vec3 L2m2 = vec3(0.64, 0.50, 0.52);
-            const vec3 L20 = vec3(-0.37, -0.28, -0.29);
-            const vec3 L21 = vec3(-0.17, -0.13, -0.13);
-            const vec3 L22 = vec3(0.55, 0.42, 0.42);
-            """,
-            
-            # 6. Vine street kitchen
-            """
-            const vec3 L00 = vec3(0.64, 0.67, 0.73);
-            const vec3 L1m1 = vec3(0.28, 0.32, 0.33);
-            const vec3 L10 = vec3(0.42, 0.60, 0.77);
-            const vec3 L11 = vec3(-0.05, -0.04, -0.02);
-            const vec3 L2m1 = vec3(0.25, 0.39, 0.53);
-            const vec3 L2m2 = vec3(-0.10, -0.08, -0.05);
-            const vec3 L20 = vec3(0.38, 0.54, 0.71);
-            const vec3 L21 = vec3(0.06, 0.01, -0.02);
-            const vec3 L22 = vec3(-0.03, -0.02, -0.03);
-            """,
-            
-            # 7. Breezeway
-            """
-            const vec3 L00 = vec3(0.32, 0.36, 0.38);
-            const vec3 L1m1 = vec3(0.37, 0.41, 0.45);
-            const vec3 L10 = vec3(-0.01, -0.01, -0.01);
-            const vec3 L11 = vec3(-0.10, -0.12, -0.12);
-            const vec3 L2m1 = vec3(-0.01, -0.02, 0.02);
-            const vec3 L2m2 = vec3(-0.13, -0.15, -0.17);
-            const vec3 L20 = vec3(-0.07, -0.08, -0.09);
-            const vec3 L21 = vec3(0.02, 0.03, 0.03);
-            const vec3 L22 = vec3(-0.29, -0.32, -0.36);
-            """,
-            
-            # 8. Campus sunset
-            """
-            const vec3 L00 = vec3(0.79, 0.94, 0.98);
-            const vec3 L1m1 = vec3(0.44, 0.56, 0.70);
-            const vec3 L10 = vec3(-0.10, -0.18, -0.27);
-            const vec3 L11 = vec3(0.45, 0.38, 0.20);
-            const vec3 L2m1 = vec3(-0.14, -0.22, -0.31);
-            const vec3 L2m2 = vec3(0.18, 0.14, 0.05);
-            const vec3 L20 = vec3(-0.39, -0.40, -0.36);
-            const vec3 L21 = vec3(0.09, 0.07, 0.04);
-            const vec3 L22 = vec3(0.67, 0.67, 0.52);
-            """,
-            
-            # 9. Funston Beach sunset
-            """
-            const vec3 L00 = vec3(0.68, 0.69, 0.70);
-            const vec3 L1m1 = vec3(0.32, 0.37, 0.44);
-            const vec3 L10 = vec3(-0.17, -0.17, -0.17);
-            const vec3 L11 = vec3(-0.45, -0.42, -0.34);
-            const vec3 L2m1 = vec3(-0.08, -0.09, -0.10);
-            const vec3 L2m2 = vec3(-0.17, -0.17, -0.15);
-            const vec3 L20 = vec3(-0.03, -0.02, -0.01);
-            const vec3 L21 = vec3(0.16, 0.14, 0.10);
-            const vec3 L22 = vec3(0.37, 0.31, 0.20);
-            """
-        ][key]
-    
-    def get_model(self, gltype, vs, **kwds):
-        """返回模型对象"""
-        
-        indices = kwds.get('indices')
-        color = kwds.get('color')
-        normal = kwds.get('normal')
-        texture = kwds.get('texture')
-        texcoord = kwds.get('texcoord')
-        
-        visible = kwds.get('visible', True)
-        inside = kwds.get('inside', True)
-        opacity = kwds.get('opacity', True)
-        cull = kwds.get('cull')
-        fill = kwds.get('fill')
-        slide = kwds.get('slide')
-        transform = kwds.get('transform')
-        
-        if color is None:
-            vshader = self.get_texture_vshader(texture.ttype)
-            fshader = self.get_texture_fshader(texture.ttype)
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_texcoord('a_Texcoord', texcoord)
-            m.add_texture('u_Texture', texture)
-        else:
-            vshader = self.get_color_vshader()
-            fshader = self.get_color_fshader()
-            
-            m = wxModel.Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
-            m.set_color('a_Color', color)
-        
-        m.set_vertex('a_Position', vs, indices)
-        m.set_normal('a_Normal', normal)
-        m.set_picked('u_Picked')
-        m.set_argument('u_ScaleFactor', self.factor)
-        m.set_proj_matrix('u_ProjMatrix')
-        m.set_view_matrix('u_ViewMatrix')
-        m.set_model_matrix('u_ModelMatrix', transform)
-        m.set_cull_mode(cull)
-        m.set_fill_mode(fill)
-        m.set_slide(slide)
-        
-        return m
-    
-    def get_color_vshader(self):
-        """返回使用颜色的顶点着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in vec4 a_Color;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out vec4 v_Color;
-            out vec3 v_Normal;
-            
-            void main() { 
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-                v_Color = a_Color;
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-            }
-        """
-    
-    def get_texture_vshader(self):
-        """返回使用纹理的顶点着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-        elif ttype == GL_TEXTURE_2D_ARRAY or ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-        
-        return """
-            #version 330 core
-            
-            in vec4 a_Position;
-            in vec3 a_Normal;
-            in %s a_Texcoord;
-            uniform mat4 u_ProjMatrix;
-            uniform mat4 u_ViewMatrix;
-            uniform mat4 u_ModelMatrix;
-            out %s v_Texcoord;
-            out vec3 v_Normal;
-            
-            void main() { 
-                mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
-                v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
-                v_Texcoord = a_Texcoord;
-                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
-            }
-        """ % (a_dtype, a_dtype)
-    
-    def get_color_fshader(self):
-        """返回使用颜色的片元着色器源码"""
-        
-        return """
-            #version 330 core
-            
-            in vec4 v_Color;
-            in vec3 v_Normal;
-            const float C1 = 0.429043;
-            const float C2 = 0.511664;
-            const float C3 = 0.743125;
-            const float C4 = 0.886227;
-            const float C5 = 0.247708;
-            %s
-            uniform float u_ScaleFactor;
-            uniform int u_Picked;
-            
-            void main() { 
-                vec3 diffuse = C1 * L22 * (v_Normal.x * v_Normal.x - v_Normal.y * v_Normal.y)
-                        + C3 * L20 * v_Normal.z * v_Normal.z
-                        + C4 * L00
-                        - C5 * L20
-                        + 2.0 * C1 * L2m2 * v_Normal.x * v_Normal.y
-                        + 2.0 * C1 * L21 * v_Normal.x * v_Normal.z
-                        + 2.0 * C1 * L2m1 * v_Normal.y * v_Normal.z
-                        + 2.0 * C2 * L11 * v_Normal.x
-                        + 2.0 * C2 * L1m1 * v_Normal.y
-                        + 2.0 * C2 * L10 * v_Normal.z;
-                
-                diffuse *= u_ScaleFactor;
-                vec3 rgb = v_Color.rgb * diffuse;
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, v_Color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a);
-            } 
-        """ % self.parameter
-    
-    def get_texture_fshader(self):
-        """返回使用纹理的片元着色器源码"""
-        
-        if ttype == GL_TEXTURE_1D:
-            a_dtype = 'float'
-            u_dtype = 'sampler1D'
-            f_name = 'texture1D'
-        elif ttype == GL_TEXTURE_2D:
-            a_dtype = 'vec2'
-            u_dtype = 'sampler2D'
-            f_name = 'texture2D'
-        elif ttype == GL_TEXTURE_2D_ARRAY:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler2DArray'
-            f_name = 'texture2DArray'
-        elif ttype == GL_TEXTURE_3D:
-            a_dtype = 'vec3'
-            u_dtype = 'sampler3D'
-            f_name = 'texture3D'
-        
-        return """
-            #version 330 core
-            
-            in %s v_Texcoord;
-            in vec3 v_Normal;
-            const float C1 = 0.429043;
-            const float C2 = 0.511664;
-            const float C3 = 0.743125;
-            const float C4 = 0.886227;
-            const float C5 = 0.247708;
-            %s
-            uniform %s u_Texture;
-            uniform float u_ScaleFactor;
-            uniform int u_Picked;
-            
-            void main() { 
-                vec3 diffuse = C1 * L22 * (v_Normal.x * v_Normal.x - v_Normal.y * v_Normal.y)
-                        + C3 * L20 * v_Normal.z * v_Normal.z
-                        + C4 * L00
-                        - C5 * L20
-                        + 2.0 * C1 * L2m2 * v_Normal.x * v_Normal.y
-                        + 2.0 * C1 * L21 * v_Normal.x * v_Normal.z
-                        + 2.0 * C1 * L2m1 * v_Normal.y * v_Normal.z
-                        + 2.0 * C2 * L11 * v_Normal.x
-                        + 2.0 * C2 * L1m1 * v_Normal.y
-                        + 2.0 * C2 * L10 * v_Normal.z;
-                
-                diffuse *= u_ScaleFactor;
-                vec4 color = %s(u_Texture, v_Texcoord);
-                vec3 rgb = color.rgb * diffuse;
-                if (u_Picked == 0)
-                    gl_FragColor = vec4(rgb, color.a);
-                else
-                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
-            } 
-        """ % (a_dtype, self.parameter, u_dtype, f_name)
-        
-        
+#!/usr/bin/env python3
+
+import sys
+from OpenGL.GL import *
+from . model import Model
+
+class _Light:
+    """光照模型基类"""
+ 
+    def __init__(self, **kwds):
+        """构造函数"""
+ 
+        self.ambient = kwds.get('ambient')              # 环境光亮度
+        self.lamp = kwds.get('lamp')                    # 光源位置
+        self.direction = kwds.get('direction')          # 光的方向
+        self.lightcolor = kwds.get('lightcolor')        # 光的颜色
+        self.sky = kwds.get('sky')                      # 来自天空的环境光
+        self.ground = kwds.get('ground')                # 来自地面的环境光
+        self.diffuse = kwds.get('diffuse')              # 漫反射系数：值域范围[0.0, 1.0]，数值越大，表面越亮
+        self.specular = kwds.get('specular')            # 镜面反射系数：值域范围[0.0, 1.0]，数值越大，高光越亮
+        self.shiny = kwds.get('shiny')                  # 高光系数：值域范围[1, 3000]，数值越大，高光区域越小
+        self.pellucid = kwds.get('pellucid')            # 透光系数：值域范围[0.0,1.0]，数值越大，反面越亮
+        self.factor = kwds.get('factor')                # 反射衰减因子：值域范围[0.0,1.0]，仅用于球谐光照模型
+        self.cpos = kwds.get('cpos')                    # 相机位置
+        self.fixed = kwds.get('fixed', False)           # 使用固定的MVP矩阵
+
+        self.texcoodr_type = None                       # 纹理坐标数据类型（attribute变量）
+        self.sampler_type = None                        # 纹理采样器类型（uniform变量）
+        self.texture_func = None                        # 纹理函数
+
+        self.platform = sys.platform.lower()            # 操作系统
+        self.glsl_version = '#version 330 core \n\n'    # 适配的GLSL版本
+        self.glsl_functions = ''                        # 低版本GLSL的扩展函数
+
+        if self.platform == 'darwin':
+            self.glsl_version = ''
+            self.glsl_functions = """
+                mat4 inverse(mat4 m) {
+                    float Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
+                    float Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
+                    float Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
+                       
+                    float Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
+                    float Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
+                    float Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
+                       
+                    float Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
+                    float Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
+                    float Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
+                       
+                    float Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
+                    float Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
+                    float Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
+                       
+                    float Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
+                    float Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
+                    float Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
+                       
+                    float Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
+                    float Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
+                    float Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];
+                       
+                    const vec4 SignA = vec4( 1.0, -1.0,  1.0, -1.0);
+                    const vec4 SignB = vec4(-1.0,  1.0, -1.0,  1.0);
+                       
+                    vec4 Fac0 = vec4(Coef00, Coef00, Coef02, Coef03);
+                    vec4 Fac1 = vec4(Coef04, Coef04, Coef06, Coef07);
+                    vec4 Fac2 = vec4(Coef08, Coef08, Coef10, Coef11);
+                    vec4 Fac3 = vec4(Coef12, Coef12, Coef14, Coef15);
+                    vec4 Fac4 = vec4(Coef16, Coef16, Coef18, Coef19);
+                    vec4 Fac5 = vec4(Coef20, Coef20, Coef22, Coef23);
+                       
+                    vec4 Vec0 = vec4(m[1][0], m[0][0], m[0][0], m[0][0]);
+                    vec4 Vec1 = vec4(m[1][1], m[0][1], m[0][1], m[0][1]);
+                    vec4 Vec2 = vec4(m[1][2], m[0][2], m[0][2], m[0][2]);
+                    vec4 Vec3 = vec4(m[1][3], m[0][3], m[0][3], m[0][3]);
+                       
+                    vec4 Inv0 = SignA * (Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
+                    vec4 Inv1 = SignB * (Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
+                    vec4 Inv2 = SignA * (Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
+                    vec4 Inv3 = SignB * (Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);
+                       
+                    mat4 Inverse = mat4(Inv0, Inv1, Inv2, Inv3);
+                    vec4 Row0 = vec4(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);
+                    float Determinant = dot(m[0], Row0);
+                    Inverse /= Determinant;
+                       
+                    return Inverse;
+                }
+
+                mat4 transpose(mat4 m) {
+                    mat4 result = mat4(0.0);
+                    for (int i=0; i<4; i++)
+                        for (int j=0; j<4; j++)
+                            result[i][j] = m[j][i];
+
+                    return result;
+                }
+            """
+ 
+    def _get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+ 
+        indices = kwds.get('indices')
+        color = kwds.get('color')
+        normal = kwds.get('normal')
+        texture = kwds.get('texture')
+        texcoord = kwds.get('texcoord')
+        align = kwds.get('align')
+        tsize = kwds.get('tsize')
+        psize = kwds.get('psize')
+        vid = kwds.get('vid')
+        cpos = kwds.get('cpos')
+        lw = kwds.get('lw')
+        ls = kwds.get('ls')
+
+        visible = kwds.get('visible', True)
+        inside = kwds.get('inside', True)
+        opacity = kwds.get('opacity', True)
+        cull = kwds.get('cull')
+        fill = kwds.get('fill')
+        slide = kwds.get('slide')
+        transform = kwds.get('transform')
+
+        if texture:
+            if texture.ttype == GL_TEXTURE_1D:
+                self.texcoodr_type = 'float'
+                self.sampler_type = 'sampler1D'
+                self.texture_func = 'texture1D'
+            elif texture.ttype == GL_TEXTURE_2D:
+                self.texcoodr_type = 'vec2'
+                self.sampler_type = 'sampler2D'
+                self.texture_func = 'texture2D'
+            elif texture.ttype == GL_TEXTURE_2D_ARRAY:
+                self.texcoodr_type = 'vec3'
+                if self.platform == 'darwin':
+                    self.sampler_type = 'sampler3D'
+                    self.texture_func = 'texture3D'
+                else:
+                    self.sampler_type = 'sampler2DArray'
+            elif texture.ttype == GL_TEXTURE_3D:
+                self.texcoodr_type = 'vec3'
+                self.sampler_type = 'sampler3D'
+                self.texture_func = 'texture3D'
+
+            if self.platform != 'darwin':
+                self.texture_func = 'texture'
+
+        vshader = self.get_vshader(texture)
+        fshader = self.get_fshader(texture)
+ 
+        m = Model(gltype, vshader, fshader, visible=visible, opacity=opacity, inside=inside)
+        m.set_vertex('a_Position', vs, indices)
+        m.set_picked('u_Picked')
+
+        if not color is None:
+            m.set_color('a_Color', color)
+        if not psize is None:
+            m.set_psize('a_Psize', psize)
+        if not normal is None:
+            m.set_normal('a_Normal', normal)
+        if not texcoord is None:
+            m.set_texcoord('a_Texcoord', texcoord)
+        if not texture is None:
+            m.add_texture('u_Texture', texture)
+        
+        if not self.ambient is None:
+            m.set_argument('u_AmbientColor', self.ambient)
+        if not self.lamp is None:
+            m.set_argument('u_LightPos', self.lamp)
+        if not self.direction is None:
+            m.set_argument('u_LightDir', self.direction)
+        if not self.lightcolor is None:
+            m.set_argument('u_LightColor', self.lightcolor)
+        if not self.sky is None:
+            m.set_argument('u_SkyColor', self.sky)
+        if not self.ground is None:
+            m.set_argument('u_GroundColor', self.ground)
+        if not self.shiny is None:
+            m.set_argument('u_Shiny', self.shiny)
+        if not self.diffuse is None:
+            m.set_argument('u_Diffuse', self.diffuse)
+        if not self.specular is None:
+            m.set_argument('u_Specular', self.specular)
+        if not self.pellucid is None:
+            m.set_argument('u_Pellucid', self.pellucid)
+        if not self.factor is None:
+            m.set_argument('u_ScaleFactor', self.factor)
+        if not self.cpos is None:
+            m.set_cam_pos('u_CamPos')
+        if not lw is None or not ls is None:
+            m.set_line_style(width=lw, stipple=ls)
+        if not tsize is None:
+            m.set_text_size('u_TextSize', tsize)
+        if not align is None:
+            m.set_argument('u_Align', align)
+        if not vid is None:
+            m.set_argument('a_VertexID', vid)
+ 
+        m.set_cull_mode(cull)
+        m.set_fill_mode(fill)
+        m.set_slide(slide)
+
+        if not self.fixed:
+            m.set_proj_matrix('u_ProjMatrix')
+            m.set_view_matrix('u_ViewMatrix')
+            m.set_model_matrix('u_ModelMatrix', transform)
+
+        return m
+
+    def get_vshader(self, texture):
+        """返回顶点着色器源码"""
+
+        return ''
+
+    def get_fshader(self, texture):
+        """返回片元着色器源码"""
+ 
+        return ''
+
+class ScatterLight(_Light):
+    """散列点专用的光照模型"""
+ 
+    def __init__(self, ambient=(1.0,1.0,1.0)):
+        """构造函数"""
+ 
+        _Light.__init__(self, ambient=ambient)
+ 
+    def get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+
+        kwds.update({'normal':None, 'texcoord':None})
+        return self._get_model(gltype, vs, **kwds)
+ 
+    def get_vshader(self, texture):
+        """返回顶点着色器源码"""
+ 
+        if texture is None:
+            shader_src = self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec4 a_Color;
+                attribute float a_Psize;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                varying vec4 v_Color;
+ 
+                void main() { 
+                    v_Color = a_Color;
+                    gl_PointSize = a_Psize;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
+                }
+            """
+        else:
+            shader_src = self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute float a_Psize;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+ 
+                void main() { 
+                    gl_PointSize = a_Psize;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
+                }
+            """
+
+        return shader_src
+ 
+    def get_fshader(self,texture):
+        """返回片元着色器源码"""
+ 
+        if self.platform == 'darwin':
+            shader_src = self.glsl_version + """
+                varying vec4 v_Color;
+                uniform vec3 u_AmbientColor;
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec3 rgb = v_Color.rgb * u_AmbientColor;
+                    vec4 color = vec4(rgb, v_Color.a);
+                    
+                    if (u_Picked == 0)
+                        gl_FragColor = color;
+                    else
+                        gl_FragColor = vec4(min(color.rgb*1.5, vec3(1.0)), color.a);
+                } 
+            """
+        else:
+            if texture is None:
+                shader_src = self.glsl_version + """
+                    varying vec4 v_Color;
+                    uniform vec3 u_AmbientColor;
+                    uniform int u_Picked;
+ 
+                    void main() { 
+                        vec2 temp = gl_PointCoord - vec2(0.5);
+                        float f = dot(temp, temp);
+ 
+                        if (f > 0.25)
+                            discard;
+ 
+                        vec3 rgb = v_Color.rgb * u_AmbientColor;
+                        vec4 color = mix(vec4(rgb, v_Color.a), vec4(rgb, 0.0), smoothstep(0.2, 0.25, f));
+                        
+                        if (u_Picked == 0)
+                            gl_FragColor = color;
+                        else
+                            gl_FragColor = vec4(min(color.rgb*1.5, vec3(1.0)), color.a);
+                    } 
+                """
+            else:
+                shader_src = self.glsl_version + """
+                    uniform vec3 u_AmbientColor;
+                    uniform sampler2D u_Texture;
+                    uniform int u_Picked;
+ 
+                    void main() { 
+                        vec4 color = %s(u_Texture, gl_PointCoord);
+                        vec3 rgb = color.rgb * u_AmbientColor;
+
+                        if (u_Picked == 0)
+                            gl_FragColor = vec4(rgb, color.a);
+                        else
+                            gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
+                    } 
+                """ % self.texture_func
+        
+        return shader_src
+
+class Text2dLight(_Light):
+    """2d文本专用的光照模型"""
+ 
+    def __init__(self, ambient=(1.0,1.0,1.0)):
+        """构造函数"""
+ 
+        _Light.__init__(self, ambient=ambient)
+ 
+    def get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+
+        kwds.update({'normal':None})
+        return self._get_model(gltype, vs, **kwds)
+ 
+    def get_vshader(self, texture):
+        """返回2d文本的顶点着色器源码"""
+ 
+        return self.glsl_version + """
+            attribute vec4 a_Position;
+            attribute vec2 a_Texcoord;
+            attribute float a_VertexID;
+            uniform mat4 u_ProjMatrix;
+            uniform mat4 u_ViewMatrix;
+            uniform mat4 u_ModelMatrix;
+            uniform vec2 u_TextSize;
+            uniform int u_Align;
+            varying vec2 v_Texcoord;
+ 
+            void main() {
+                v_Texcoord = a_Texcoord;
+                gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+ 
+                if (u_Align == 0) {
+                    if (a_VertexID == 1.0) {
+                        gl_Position.y -= u_TextSize.y;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.y -= u_TextSize.y;
+                        gl_Position.x += u_TextSize.x;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.x += u_TextSize.x;
+                    }
+                } else if (u_Align == 1) {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.y += u_TextSize.y/2.0;
+                    } else if (a_VertexID == 1.0) {
+                        gl_Position.y -= u_TextSize.y/2.0;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.x += u_TextSize.x;
+                        gl_Position.y -= u_TextSize.y/2.0;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.x += u_TextSize.x;
+                        gl_Position.y += u_TextSize.y/2.0;
+                    }
+                } else if (u_Align == 2) {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.y += u_TextSize.y;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.x += u_TextSize.x;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.x += u_TextSize.x;
+                        gl_Position.y += u_TextSize.y;
+                    }
+                } else if (u_Align == 3) {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.x -= u_TextSize.x/2.0;
+                    } else if (a_VertexID == 1.0) {
+                        gl_Position.x -= u_TextSize.x/2.0;
+                        gl_Position.y -= u_TextSize.y;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.x += u_TextSize.x/2.0;
+                        gl_Position.y -= u_TextSize.y;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.x += u_TextSize.x/2.0;
+                    }
+                } else if (u_Align == 4) {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.x -= u_TextSize.x/2.0;
+                        gl_Position.y += u_TextSize.y/2.0;
+                    } else if (a_VertexID == 1.0) {
+                        gl_Position.x -= u_TextSize.x/2.0;
+                        gl_Position.y -= u_TextSize.y/2.0;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.x += u_TextSize.x/2.0;
+                        gl_Position.y -= u_TextSize.y/2.0;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.x += u_TextSize.x/2.0;
+                        gl_Position.y += u_TextSize.y/2.0;
+                    }
+                } else if (u_Align == 5) {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.x -= u_TextSize.x/2.0;
+                        gl_Position.y += u_TextSize.y;
+                    } else if (a_VertexID == 1.0) {
+                        gl_Position.x -= u_TextSize.x/2.0;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.x += u_TextSize.x/2.0;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.x += u_TextSize.x/2.0;
+                        gl_Position.y += u_TextSize.y;
+                    }
+                } else if (u_Align == 6) {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.x -= u_TextSize.x;
+                    } else if (a_VertexID == 1.0) {
+                        gl_Position.x -= u_TextSize.x;
+                        gl_Position.y -= u_TextSize.y;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.y -= u_TextSize.y;
+                    }
+                } else if (u_Align == 7) {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.x -= u_TextSize.x;
+                        gl_Position.y += u_TextSize.y/2.0;
+                    } else if (a_VertexID == 1.0) {
+                        gl_Position.x -= u_TextSize.x;
+                        gl_Position.y -= u_TextSize.y/2.0;
+                    } else if (a_VertexID == 3.0) {
+                        gl_Position.y -= u_TextSize.y/2.0;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.y += u_TextSize.y/2.0;
+                    }
+                } else {
+                    if (a_VertexID == 0.0) {
+                        gl_Position.x -= u_TextSize.x;
+                        gl_Position.y += u_TextSize.y;
+                    } else if (a_VertexID == 1.0) {
+                        gl_Position.x -= u_TextSize.x;
+                    } else if (a_VertexID == 2.0) {
+                        gl_Position.y += u_TextSize.y;
+                    }
+                }
+            }
+        """
+ 
+    def get_fshader(self, texture):
+        """返回片元着色器源码"""
+ 
+        return self.glsl_version + """
+            varying vec2 v_Texcoord;
+            uniform vec3 u_AmbientColor;
+            uniform sampler2D u_Texture;
+            uniform int u_Picked;
+ 
+            void main() { 
+                vec4 color = %s(u_Texture, v_Texcoord);
+                vec3 rgb = color.rgb * u_AmbientColor;
+
+                if (u_Picked == 0)
+                    gl_FragColor = vec4(rgb, color.a);
+                else
+                    gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
+            } 
+        """ % self.texture_func
+
+class BaseLight(_Light):
+    """环境光照模型"""
+ 
+    def __init__(self, ambient=(1.0,1.0,1.0), fixed=False):
+        """构造函数"""
+ 
+        _Light.__init__(self, ambient=ambient, fixed=fixed)
+ 
+    def get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+
+        kwds.update({'normal':None})
+        return self._get_model(gltype, vs, **kwds)
+ 
+    def get_vshader(self, texture):
+        """返回顶点着色器源码"""
+ 
+        if self.fixed:
+            if texture is None:
+                shader_src = self.glsl_version + """
+                    attribute vec4 a_Position;
+                    attribute vec4 a_Color;
+                    varying vec4 v_Color;
+ 
+                    void main() { 
+                        v_Color = a_Color;
+                        gl_Position = a_Position; 
+                    }
+                """
+            else:
+                shader_src = self.glsl_version + """
+                    attribute vec4 a_Position;
+                    attribute %s a_Texcoord;
+                    varying %s v_Texcoord;
+ 
+                    void main() { 
+                        v_Texcoord = a_Texcoord;
+                        gl_Position = a_Position; 
+                    }
+                """ % (self.texcoodr_type, self.texcoodr_type)
+        else:
+            if texture is None:
+                shader_src = self.glsl_version + """
+                    attribute vec4 a_Position;
+                    attribute vec4 a_Color;
+                    uniform mat4 u_ProjMatrix;
+                    uniform mat4 u_ViewMatrix;
+                    uniform mat4 u_ModelMatrix;
+                    varying vec4 v_Color;
+ 
+                    void main() { 
+                        v_Color = a_Color;
+                        gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+                    }
+                """
+            else:
+                shader_src = self.glsl_version + """
+                    attribute vec4 a_Position;
+                    attribute %s a_Texcoord;
+                    uniform mat4 u_ProjMatrix;
+                    uniform mat4 u_ViewMatrix;
+                    uniform mat4 u_ModelMatrix;
+                    varying %s v_Texcoord;
+ 
+                    void main() { 
+                        v_Texcoord = a_Texcoord;
+                        gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+                    }
+                """ % (self.texcoodr_type, self.texcoodr_type)
+ 
+        return shader_src
+ 
+    def get_fshader(self, texture):
+        """返回片元着色器源码"""
+ 
+        if texture is None:
+            shader_src = self.glsl_version + """
+                varying vec4 v_Color;
+                uniform vec3 u_AmbientColor;
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec3 rgb = v_Color.rgb * u_AmbientColor;
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, v_Color.a);
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a);
+                } 
+            """
+        else:
+            shader_src = self.glsl_version + """
+                varying %s v_Texcoord;
+                uniform vec3 u_AmbientColor;
+                uniform %s u_Texture;
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec4 color = %s(u_Texture, v_Texcoord);
+                    vec3 rgb = color.rgb * u_AmbientColor;
+                    
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, color.a);
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
+                } 
+            """ % (self.texcoodr_type, self.sampler_type, self.texture_func)
+ 
+        return shader_src
+
+class SunLight(_Light):
+    """平行光照模型"""
+
+    def __init__(self, direction=(0.0,0.0,-1.0), lightcolor=(1.0,1.0,1.0), ambient=(0.3,0.3,0.3), **kwds):
+        """构造函数"""
+
+        _Light.__init__(self, 
+            ambient     = ambient,                      # 环境光
+            direction   = direction,                    # 光的方向
+            lightcolor  = lightcolor,                   # 光的颜色
+            diffuse     = kwds.get('diffuse', 0.8),     # 漫反射系数：值域范围[0.0, 1.0]，数值越大，表面越亮
+            specular    = kwds.get('specular', 0.6),    # 镜面反射系数：值域范围[0.0, 1.0]，数值越大，高光越亮
+            shiny       = kwds.get('shiny', 50),        # 高光系数：值域范围[1, 3000]，数值越大，高光区域越小
+            pellucid    = kwds.get('pellucid', 0.5),    # 透光系数：值域范围[0.0,1.0]，数值越大，背面越亮
+            cpos        = True                          # 着色器需要传入相机位置
+        )
+ 
+    def get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+
+        return self._get_model(gltype, vs, **kwds)
+ 
+    def get_vshader(self, texture):
+        """返回顶点着色器源码"""
+ 
+        if texture is None:
+            shader_src =  self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute vec4 a_Color;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                uniform vec3 u_CamPos;
+                uniform vec3 u_LightDir; // 定向光方向
+                varying vec4 v_Color;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+
+                """ + self.glsl_functions + """
+
+                void main() { 
+                    v_Color = a_Color;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+ 
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix)); // 法向量矩阵
+                    v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0))); // 重新计算模型变换后的法向量
+                    vec3 camDir = normalize(u_CamPos - vec3(u_ModelMatrix * a_Position)); // 从当前顶点指向相机的向量
+                    v_LightDir = normalize(-u_LightDir); // 光线向量取反后单位化
+                    v_MiddleDir = normalize(camDir + v_LightDir); // 视线和光线的中间向量
+                }
+            """
+        else:
+            shader_src = self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute %s a_Texcoord;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                uniform vec3 u_CamPos;
+                uniform vec3 u_LightDir; // 定向光方向
+                varying %s v_Texcoord;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+ 
+                """ % (self.texcoodr_type, self.texcoodr_type) + self.glsl_functions + """
+
+                void main() { 
+                    v_Texcoord = a_Texcoord;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+ 
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix)); // 法向量矩阵
+                    v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0))); // 重新计算模型变换后的法向量
+                    vec3 camDir = normalize(u_CamPos - vec3(u_ModelMatrix * a_Position)); // 从当前顶点指向相机的向量
+                    v_LightDir = normalize(-u_LightDir); // 光线向量取反后单位化
+                    v_MiddleDir = normalize(camDir + v_LightDir); // 视线和光线的中间向量
+                }
+            """
+
+        return shader_src
+ 
+    def get_fshader(self, texture):
+        """返回片元着色器源码"""
+ 
+        if texture is None:
+            shader_src = self.glsl_version + """
+                varying vec4 v_Color;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+                uniform vec3 u_LightColor; // 定向光颜色
+                uniform vec3 u_AmbientColor; // 环境光颜色
+                uniform float u_Shiny; // 高光系数
+                uniform float u_Specular; // 镜面反射系数
+                uniform float u_Diffuse; // 漫反射系数
+                uniform float u_Pellucid; // 透光系数
+                uniform int u_Picked;
+ 
+                void main() { 
+                    float diffuseCos = u_Diffuse * max(0.0, dot(v_LightDir, v_Normal)); // 光线向量和法向量的内积
+                    float specularCos = u_Specular * max(0.0, dot(v_MiddleDir, v_Normal)); // 中间向量和法向量内积
+ 
+                    if (!gl_FrontFacing) 
+                        diffuseCos *= u_Pellucid; // 背面受透光系数影响
+ 
+                    if (diffuseCos == 0.0) 
+                        specularCos = 0.0;
+                    else
+                        specularCos = pow(specularCos, u_Shiny);
+ 
+                    vec3 scatteredLight = min(u_AmbientColor + u_LightColor * diffuseCos, vec3(1.0)); // 散射光
+                    vec3 reflectedLight = u_LightColor * specularCos; // 反射光
+                    vec3 rgb = min(v_Color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
+ 
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, v_Color.a);
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a);
+                }
+            """
+        else:
+            shader_src = self.glsl_version + """
+                varying %s v_Texcoord;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+                uniform %s u_Texture;
+                uniform vec3 u_LightColor; // 定向光颜色
+                uniform vec3 u_AmbientColor; // 环境光颜色
+                uniform float u_Shiny; // 高光系数
+                uniform float u_Specular; // 镜面反射系数
+                uniform float u_Diffuse; // 漫反射系数
+                uniform float u_Pellucid; // 透光系数
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec4 color = %s(u_Texture, v_Texcoord);
+                    float diffuseCos = u_Diffuse * max(0.0, dot(v_LightDir, v_Normal)); // 光线向量和法向量的内积
+                    float specularCos = u_Specular * max(0.0, dot(v_MiddleDir, v_Normal)); // 中间向量和法向量内积
+ 
+                    if (!gl_FrontFacing) 
+                        diffuseCos *= u_Pellucid; // 背面受透光系数影响
+ 
+                    if (diffuseCos == 0.0) 
+                        specularCos = 0.0;
+                    else
+                        specularCos = pow(specularCos, u_Shiny);
+ 
+                    vec3 scatteredLight = min(u_AmbientColor + u_LightColor * diffuseCos, vec3(1.0)); // 散射光
+                    vec3 reflectedLight = u_LightColor * specularCos; // 反射光
+                    vec3 rgb = min(color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
+ 
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, color.a);
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
+                } 
+            """ % (self.texcoodr_type, self.sampler_type, self.texture_func)
+
+        return shader_src
+
+class LampLight(_Light):
+    """定位光照模型"""
+
+    def __init__(self, lamp=(0.0,0.0,2.0), lightcolor=(1.0,1.0,1.0), ambient=(0.5,0.5,0.5), **kwds):
+        """构造函数"""
+
+        _Light.__init__(self, 
+            ambient     = ambient,                      # 环境光
+            lamp        = lamp,                         # 光源位置
+            lightcolor  = lightcolor,                   # 光的颜色
+            diffuse     = kwds.get('diffuse', 0.8),     # 漫反射系数：值域范围[0.0, 1.0]，数值越大，表面越亮
+            specular    = kwds.get('specular', 0.6),    # 镜面反射系数：值域范围[0.0, 1.0]，数值越大，高光越亮
+            shiny       = kwds.get('shiny', 50),        # 高光系数：值域范围[1, 3000]，数值越大，高光区域越小
+            pellucid    = kwds.get('pellucid', 0.5),    # 透光系数：值域范围[0.0,1.0]，数值越大，反面越亮
+            cpos        = True                          # 着色器需要传入相机位置
+        )
+
+    def get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+
+        return self._get_model(gltype, vs, **kwds)
+ 
+    def get_vshader(self, texture):
+        """返回顶点着色器源码"""
+ 
+        if texture is None:
+            shader_src =  self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute vec4 a_Color;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                uniform vec3 u_CamPos;
+                uniform vec3 u_LightPos;
+                varying vec4 v_Color;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+ 
+                """ + self.glsl_functions + """
+
+                void main() { 
+                    v_Color = a_Color;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+ 
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix)); // 法向量矩阵
+                    v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0))); // 重新计算模型变换后的法向量
+                    
+                    vec3 camDir = normalize(u_CamPos - vec3(u_ModelMatrix * a_Position)); // 从当前顶点指向相机的向量
+                    v_LightDir = normalize(u_LightPos - a_Position.xyz); // 光线向量单位化
+                    v_MiddleDir = normalize(camDir + v_LightDir); // 视线和光线的中间向量
+                }
+            """
+        else:
+            shader_src = self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute %s a_Texcoord;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                uniform vec3 u_CamPos;
+                uniform vec3 u_LightPos;
+                varying %s v_Texcoord;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+ 
+                """ % (self.texcoodr_type, self.texcoodr_type) + self.glsl_functions + """
+
+                void main() { 
+                    v_Texcoord = a_Texcoord;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+ 
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix)); // 法向量矩阵
+                    v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0))); // 重新计算模型变换后的法向量
+                    
+                    vec3 camDir = normalize(u_CamPos - vec3(u_ModelMatrix * a_Position)); // 从当前顶点指向相机的向量
+                    v_LightDir = normalize(u_LightPos - a_Position.xyz); // 光线向量单位化
+                    v_MiddleDir = normalize(camDir + v_LightDir); // 视线和光线的中间向量
+                }
+            """
+
+        return shader_src
+ 
+    def get_fshader(self, texture):
+        """返回片元着色器源码"""
+ 
+        if texture is None:
+            shader_src = self.glsl_version + """
+                varying vec4 v_Color;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+                uniform vec3 u_LightColor; // 灯光颜色
+                uniform vec3 u_AmbientColor; // 环境光颜色
+                uniform float u_Shiny; // 高光系数
+                uniform float u_Specular; // 镜面反射系数
+                uniform float u_Diffuse; // 漫反射系数
+                uniform float u_Pellucid; // 透光系数
+                uniform int u_Picked;
+ 
+                void main() { 
+                    float diffuseCos = u_Diffuse * max(0.0, dot(v_LightDir, v_Normal)); // 光线向量和法向量的内积
+                    float specularCos = u_Specular * max(0.0, dot(v_MiddleDir, v_Normal)); // 中间向量和法向量内积
+ 
+                    if (!gl_FrontFacing) 
+                        diffuseCos *= u_Pellucid; // 背面受透光系数影响
+ 
+                    if (diffuseCos == 0.0) 
+                        specularCos = 0.0;
+                    else
+                        specularCos = pow(specularCos, u_Shiny);
+ 
+                    vec3 scatteredLight = min(u_AmbientColor + u_LightColor * diffuseCos, vec3(1.0)); // 散射光
+                    vec3 reflectedLight = u_LightColor * specularCos; // 反射光
+                    vec3 rgb = min(v_Color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
+ 
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, v_Color.a);
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a);
+                }
+            """
+        else:
+            shader_src = self.glsl_version + """
+                varying %s v_Texcoord;
+                varying vec3 v_Normal;
+                varying vec3 v_LightDir;
+                varying vec3 v_MiddleDir;
+                uniform %s u_Texture;
+                uniform vec3 u_LightColor; // 灯光颜色
+                uniform vec3 u_AmbientColor; // 环境光颜色
+                uniform float u_Shiny; // 高光系数
+                uniform float u_Specular; // 镜面反射系数
+                uniform float u_Diffuse; // 漫反射系数
+                uniform float u_Pellucid; // 透光系数
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec4 color = %s(u_Texture, v_Texcoord);
+                    float diffuseCos = u_Diffuse * max(0.0, dot(v_LightDir, v_Normal)); // 光线向量和法向量的内积
+                    float specularCos = u_Specular * max(0.0, dot(v_MiddleDir, v_Normal)); // 中间向量和法向量内积
+ 
+                    if (!gl_FrontFacing) 
+                        diffuseCos *= u_Pellucid; // 背面受透光系数影响
+ 
+                    if (diffuseCos == 0.0) 
+                        specularCos = 0.0;
+                    else
+                        specularCos = pow(specularCos, u_Shiny);
+ 
+                    vec3 scatteredLight = min(u_AmbientColor + u_LightColor * diffuseCos, vec3(1.0)); // 散射光
+                    vec3 reflectedLight = u_LightColor * specularCos; // 反射光
+                    vec3 rgb = min(color.rgb * (scatteredLight + reflectedLight), vec3(1.0));
+ 
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, color.a);
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a);
+                } 
+            """ % (self.texcoodr_type, self.sampler_type, self.texture_func)
+
+        return shader_src
+
+class SkyLight(_Light):
+    """户外光照模型"""
+
+    def __init__(self, direction=(0.0,-1.0,0.0), sky=(1.0,1.0,1.0), ground=(0.3,0.3,0.3)):
+        """构造函数"""
+
+        _Light.__init__(self, 
+            direction   = direction,                    # 光的方向
+            sky         = sky,                          # 来自天空的环境光
+            ground      = ground,                       # 来自地面的环境光
+        )
+ 
+    def get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+
+        return self._get_model(gltype, vs, **kwds)
+ 
+    def get_vshader(self, texture):
+        """返回使用颜色的顶点着色器源码"""
+ 
+        if texture is None:
+            return self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute vec4 a_Color;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                uniform vec3 u_LightDir; // 定向光方向
+                varying vec4 v_Color;
+                varying float v_Costheta;
+ 
+                """ + self.glsl_functions + """
+
+                void main() { 
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+                    v_Color = a_Color;
+ 
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
+                    vec3 normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
+                    v_Costheta = dot(normal, normalize(-u_LightDir)) * 0.5 + 0.5;
+                }
+            """
+        else:
+            return self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute %s a_Texcoord;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                uniform vec3 u_LightDir; // 定向光方向
+                varying %s v_Texcoord;
+                varying float v_Costheta;
+ 
+                """ % (self.texcoodr_type, self.texcoodr_type) + self.glsl_functions + """
+
+                void main() { 
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; 
+                    v_Texcoord = a_Texcoord;
+ 
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
+                    vec3 normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
+                    v_Costheta = dot(normal, normalize(-u_LightDir)) * 0.5 + 0.5;
+                }
+            """
+ 
+    def get_fshader(self, texture):
+        """返回使用颜色的片元着色器源码"""
+ 
+        if texture is None:
+            return self.glsl_version + """
+                varying vec4 v_Color;
+                varying float v_Costheta;
+                uniform vec3 u_SkyColor; // 天空光线颜色
+                uniform vec3 u_GroundColor; // 地面光线颜色
+                uniform int u_Picked;
+ 
+                void main() { 
+                    float costheta = v_Costheta;
+                    if (!gl_FrontFacing) 
+                        costheta *= 0.5;
+ 
+                    vec3 rgb = mix(u_GroundColor, u_SkyColor, costheta) * v_Color.rgb;
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, v_Color.a); 
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a); 
+                } 
+            """
+        else:
+            return self.glsl_version + """
+                varying %s v_Texcoord;
+                varying float v_Costheta;
+                uniform %s u_Texture;
+                uniform vec3 u_SkyColor; // 天空光线颜色
+                uniform vec3 u_GroundColor; // 地面光线颜色
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec4 color = %s(u_Texture, v_Texcoord);
+                    float costheta = v_Costheta;
+                    if (!gl_FrontFacing) 
+                        costheta *= 0.5;
+
+                    vec3 rgb = mix(u_GroundColor, u_SkyColor, costheta) * color.rgb;
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, color.a); 
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a); 
+                } 
+            """ % (self.texcoodr_type, self.sampler_type, self.texture_func)
+ 
+class SphereLight(_Light):
+    """球谐光照模型"""
+
+    def __init__(self, style=0, factor=0.8):
+        """构造函数"""
+ 
+        _Light.__init__(self)
+
+        self.factor = factor # 反射衰减因子
+        self.parameter = [
+            # 0. Old Town square 
+            """
+            const vec3 L00 = vec3(0.871297, 0.875255, 0.864470);
+            const vec3 L1m1 = vec3(0.175058, 0.245335, 0.312891);
+            const vec3 L10 = vec3(0.034675, 0.036107, 0.037362);
+            const vec3 L11 = vec3(-0.004629, -0.029448, -0.048028);
+            const vec3 L2m1 = vec3(0.003242, 0.003624, 0.007511);
+            const vec3 L2m2 = vec3(-0.120535, -0.121160, -0.117507);
+            const vec3 L20 = vec3(-0.028667, -0.024926, -0.020998);
+            const vec3 L21 = vec3(-0.077539, -0.086325, -0.091591);
+            const vec3 L22 = vec3(-0.161784, -0.191783, -0.219152);
+            """,
+ 
+            # 1. Grace cathedral
+            """
+            const vec3 L00 = vec3(0.79, 0.44, 0.54);
+            const vec3 L1m1 = vec3(0.39, 0.35, 0.60);
+            const vec3 L10 = vec3(-0.34, -0.18, -0.27);
+            const vec3 L11 = vec3(-0.29, -0.06, 0.01);
+            const vec3 L2m1 = vec3(-0.26, -0.22, -0.47);
+            const vec3 L2m2 = vec3(-0.11, -0.05, -0.12);
+            const vec3 L20 = vec3(-0.16, -0.09, -0.15);
+            const vec3 L21 = vec3(0.56, 0.21, 0.14);
+            const vec3 L22 = vec3(0.21, -0.05, -0.30);
+            """,
+
+            # 2. Eucalyptus grove
+            """
+            const vec3 L00 = vec3(0.38, 0.43, 0.45);
+            const vec3 L1m1 = vec3(0.29, 0.36, 0.41);
+            const vec3 L10 = vec3(0.04, 0.03, 0.01);
+            const vec3 L11 = vec3(-0.10, -0.10, -0.09);
+            const vec3 L2m1 = vec3(0.01, -0.01, -0.05);
+            const vec3 L2m2 = vec3(-0.06, -0.06, -0.04);
+            const vec3 L20 = vec3(-0.09, -0.13, -0.15);
+            const vec3 L21 = vec3(-0.06, -0.05, -0.04);
+            const vec3 L22 = vec3(0.02, 0.0, -0.05);
+            """,
+ 
+            # 3. St. Peter's basilica
+            """
+            const vec3 L00 = vec3(0.36, 0.26, 0.23);
+            const vec3 L1m1 = vec3(0.18, 0.14, 0.13);
+            const vec3 L10 = vec3(-0.02, -0.01, 0.0);
+            const vec3 L11 = vec3(0.03, 0.02, 0.0);
+            const vec3 L2m1 = vec3(-0.05, -0.03, -0.01);
+            const vec3 L2m2 = vec3(0.02, 0.01, 0.0);
+            const vec3 L20 = vec3(-0.09, -0.08, -0.07);
+            const vec3 L21 = vec3(0.01, 0.0, 0.0);
+            const vec3 L22 = vec3(-0.08, -0.03, 0.0);
+            """,
+ 
+            # 4. Uffizi gallery
+            """
+            const vec3 L00 = vec3(0.32, 0.31, 0.35);
+            const vec3 L1m1 = vec3(0.37, 0.37, 0.43);
+            const vec3 L10 = vec3(0.0, 0.0, 0.0);
+            const vec3 L11 = vec3(-0.01, -0.01, -0.01);
+            const vec3 L2m1 = vec3(-0.01, -0.01, -0.01);
+            const vec3 L2m2 = vec3(-0.02, -0.02, -0.03);
+            const vec3 L20 = vec3(-0.28, -0.28, -0.32);
+            const vec3 L21 = vec3(0.0, 0.0, 0.0);
+            const vec3 L22 = vec3(-0.24, -0.24, -0.28);
+            """,
+ 
+            # 5. Galileo's tomb
+            """
+            const vec3 L00 = vec3(1.04, 0.76, 0.71);
+            const vec3 L1m1 = vec3(0.44, 0.34, 0.34);
+            const vec3 L10 = vec3(-0.22, -0.18, -0.17);
+            const vec3 L11 = vec3(0.71, 0.54, 0.56);
+            const vec3 L2m1 = vec3(-0.12, -0.09, -0.08);
+            const vec3 L2m2 = vec3(0.64, 0.50, 0.52);
+            const vec3 L20 = vec3(-0.37, -0.28, -0.29);
+            const vec3 L21 = vec3(-0.17, -0.13, -0.13);
+            const vec3 L22 = vec3(0.55, 0.42, 0.42);
+            """,
+ 
+            # 6. Vine street kitchen
+            """
+            const vec3 L00 = vec3(0.64, 0.67, 0.73);
+            const vec3 L1m1 = vec3(0.28, 0.32, 0.33);
+            const vec3 L10 = vec3(0.42, 0.60, 0.77);
+            const vec3 L11 = vec3(-0.05, -0.04, -0.02);
+            const vec3 L2m1 = vec3(0.25, 0.39, 0.53);
+            const vec3 L2m2 = vec3(-0.10, -0.08, -0.05);
+            const vec3 L20 = vec3(0.38, 0.54, 0.71);
+            const vec3 L21 = vec3(0.06, 0.01, -0.02);
+            const vec3 L22 = vec3(-0.03, -0.02, -0.03);
+            """,
+ 
+            # 7. Breezeway
+            """
+            const vec3 L00 = vec3(0.32, 0.36, 0.38);
+            const vec3 L1m1 = vec3(0.37, 0.41, 0.45);
+            const vec3 L10 = vec3(-0.01, -0.01, -0.01);
+            const vec3 L11 = vec3(-0.10, -0.12, -0.12);
+            const vec3 L2m1 = vec3(-0.01, -0.02, 0.02);
+            const vec3 L2m2 = vec3(-0.13, -0.15, -0.17);
+            const vec3 L20 = vec3(-0.07, -0.08, -0.09);
+            const vec3 L21 = vec3(0.02, 0.03, 0.03);
+            const vec3 L22 = vec3(-0.29, -0.32, -0.36);
+            """,
+ 
+            # 8. Campus sunset
+            """
+            const vec3 L00 = vec3(0.79, 0.94, 0.98);
+            const vec3 L1m1 = vec3(0.44, 0.56, 0.70);
+            const vec3 L10 = vec3(-0.10, -0.18, -0.27);
+            const vec3 L11 = vec3(0.45, 0.38, 0.20);
+            const vec3 L2m1 = vec3(-0.14, -0.22, -0.31);
+            const vec3 L2m2 = vec3(0.18, 0.14, 0.05);
+            const vec3 L20 = vec3(-0.39, -0.40, -0.36);
+            const vec3 L21 = vec3(0.09, 0.07, 0.04);
+            const vec3 L22 = vec3(0.67, 0.67, 0.52);
+            """,
+ 
+            # 9. Funston Beach sunset
+            """
+            const vec3 L00 = vec3(0.68, 0.69, 0.70);
+            const vec3 L1m1 = vec3(0.32, 0.37, 0.44);
+            const vec3 L10 = vec3(-0.17, -0.17, -0.17);
+            const vec3 L11 = vec3(-0.45, -0.42, -0.34);
+            const vec3 L2m1 = vec3(-0.08, -0.09, -0.10);
+            const vec3 L2m2 = vec3(-0.17, -0.17, -0.15);
+            const vec3 L20 = vec3(-0.03, -0.02, -0.01);
+            const vec3 L21 = vec3(0.16, 0.14, 0.10);
+            const vec3 L22 = vec3(0.37, 0.31, 0.20);
+            """
+        ][style]
+ 
+    def get_model(self, gltype, vs, **kwds):
+        """返回模型对象"""
+
+        return self._get_model(gltype, vs, **kwds)
+ 
+    def get_vshader(self, texture):
+        """返回使用颜色的顶点着色器源码"""
+ 
+        if texture is None:
+            return self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute vec4 a_Color;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                varying vec4 v_Color;
+                varying vec3 v_Normal;
+ 
+                """ + self.glsl_functions + """
+
+                void main() { 
+                    v_Color = a_Color;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
+
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
+                    v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
+                }
+            """
+        else:
+            return self.glsl_version + """
+                attribute vec4 a_Position;
+                attribute vec3 a_Normal;
+                attribute %s a_Texcoord;
+                uniform mat4 u_ProjMatrix;
+                uniform mat4 u_ViewMatrix;
+                uniform mat4 u_ModelMatrix;
+                varying %s v_Texcoord;
+                varying vec3 v_Normal;
+ 
+                """ % (self.texcoodr_type, self.texcoodr_type) + self.glsl_functions + """
+
+                void main() { 
+                    v_Texcoord = a_Texcoord;
+                    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
+
+                    mat4 NormalMatrix = transpose(inverse(u_ModelMatrix));
+                    v_Normal = normalize(vec3(NormalMatrix * vec4(a_Normal, 1.0)));
+                }
+            """
+ 
+    def get_fshader(self, texture):
+        """返回使用颜色的片元着色器源码"""
+ 
+        if texture is None:
+            return self.glsl_version + """
+                varying vec4 v_Color;
+                varying vec3 v_Normal;
+                const float C1 = 0.429043;
+                const float C2 = 0.511664;
+                const float C3 = 0.743125;
+                const float C4 = 0.886227;
+                const float C5 = 0.247708;
+                %s
+                uniform float u_ScaleFactor;
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec3 diffuse = C1 * L22 * (v_Normal.x * v_Normal.x - v_Normal.y * v_Normal.y)
+                            + C3 * L20 * v_Normal.z * v_Normal.z
+                            + C4 * L00
+                            - C5 * L20
+                            + 2.0 * C1 * L2m2 * v_Normal.x * v_Normal.y
+                            + 2.0 * C1 * L21 * v_Normal.x * v_Normal.z
+                            + 2.0 * C1 * L2m1 * v_Normal.y * v_Normal.z
+                            + 2.0 * C2 * L11 * v_Normal.x
+                            + 2.0 * C2 * L1m1 * v_Normal.y
+                            + 2.0 * C2 * L10 * v_Normal.z;
+ 
+                    diffuse *= u_ScaleFactor;
+                    vec3 rgb = v_Color.rgb * diffuse;
+
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, v_Color.a); 
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), v_Color.a); 
+                } 
+            """ % self.parameter
+        else: 
+            return self.glsl_version + """
+                varying %s v_Texcoord;
+                varying vec3 v_Normal;
+                const float C1 = 0.429043;
+                const float C2 = 0.511664;
+                const float C3 = 0.743125;
+                const float C4 = 0.886227;
+                const float C5 = 0.247708;
+                %s
+                uniform %s u_Texture;
+                uniform float u_ScaleFactor;
+                uniform int u_Picked;
+ 
+                void main() { 
+                    vec3 diffuse = C1 * L22 * (v_Normal.x * v_Normal.x - v_Normal.y * v_Normal.y)
+                            + C3 * L20 * v_Normal.z * v_Normal.z
+                            + C4 * L00
+                            - C5 * L20
+                            + 2.0 * C1 * L2m2 * v_Normal.x * v_Normal.y
+                            + 2.0 * C1 * L21 * v_Normal.x * v_Normal.z
+                            + 2.0 * C1 * L2m1 * v_Normal.y * v_Normal.z
+                            + 2.0 * C2 * L11 * v_Normal.x
+                            + 2.0 * C2 * L1m1 * v_Normal.y
+                            + 2.0 * C2 * L10 * v_Normal.z;
+ 
+                    diffuse *= u_ScaleFactor;
+                    vec4 color = %s(u_Texture, v_Texcoord);
+                    vec3 rgb = color.rgb * diffuse;
+
+                    if (u_Picked == 0)
+                        gl_FragColor = vec4(rgb, color.a); 
+                    else
+                        gl_FragColor = vec4(min(rgb*1.5, vec3(1.0)), color.a); 
+                } 
+            """ % (self.texcoodr_type, self.parameter, self.sampler_type, self.texture_func)
+
```

## wxgl/model.py

```diff
@@ -1,436 +1,462 @@
-# -*- coding: utf-8 -*-
-
-import re
-import numpy as np
-from OpenGL.GL import *
-
-class Model:
-    """WxGL模型类"""
-    
-    def __init__(self, gltype, vshader, fshader, visible=True, opacity=True, inside=True, sprite=False):
-        """构造函数
-        
-        gltype      - GL基本图元
-        vshader     - 顶点着色器源码
-        fshader     - 片元着色器源码
-        visible     - 模型可见性
-        opacity     - 模型不透明属性
-        inside      - 模型显示在视锥体内
-        sprite      - 是否开启点精灵
-        """
-        
-        gltypes = (
-            GL_POINTS,	        # 绘制一个或多个顶点
-            GL_LINES,	        # 绘制线段
-            GL_LINE_STRIP,	    # 绘制连续线段
-            GL_LINE_LOOP,	    # 绘制闭合的线段
-            GL_TRIANGLES,	    # 绘制一个或多个三角形
-            GL_TRIANGLE_STRIP,	# 绘制连续三角形
-            GL_TRIANGLE_FAN,    # 绘制多个三角形组成的扇形
-            GL_QUADS,	        # 绘制一个或多个四边形
-            GL_QUAD_STRIP       # 四边形条带
-        )
-        
-        if gltype not in gltypes:
-            raise ValueError('不支持的绘制方法')
-        
-        self.gltype = gltype                            # GL基本图元
-        
-        self.visible = visible                          # 模型可见性，默认可见
-        self.opacity = opacity                          # 模型不透明属性，默认不透明
-        self.inside = inside                            # 模型顶点是否影响模型空间，默认True
-        self.sprite = sprite                            # 开启点精灵，默认False
-        self.slide = None                               # 幻灯片函数
-        self.depth = None                               # 深度轴均值
-        self.islive = False                             # 模型是否有动画函数
-        self.picked = False                             # 模型被拾取
-        
-        self.program = None                             # 着色器程序
-        self.cshaders = list()                          # 编译后的着色器
-        self.shaders = list()                           # 着色器源码
-        self.other = dict()                             # 着色器中其他变量
-        self.attribute = dict()                         # attribute变量
-        self.uniform = dict()                           # uniform变量
-        
-        self.vshape = None                              # 顶点数据的shape
-        self.indices = None                             # 顶点索引
-        self.r_x = None                                 # 顶点坐标x的动态范围
-        self.r_y = None                                 # 顶点坐标y的动态范围
-        self.r_z = None                                 # 顶点坐标z的动态范围
-        
-        self.before = list()                            # 绘制前执行的GL命令
-        self.after = list()                             # 绘制后执行的GL命令
-        
-        self.add_shader(vshader, GL_VERTEX_SHADER)
-        self.add_shader(fshader, GL_FRAGMENT_SHADER)
-        
-        if sprite:
-            self.before.append((glPushAttrib, (GL_POINT_BIT,)))
-            self.before.append((glEnable, (GL_POINT_SPRITE,)))
-            self.before.append((glEnable, (GL_PROGRAM_POINT_SIZE,)))
-            self.after.append((glPopAttrib, ()))
-    
-    def add_shader(self, shader_src, shader_type):
-        """添加着色器
-        
-        shader_src  - 着色器源码
-        shader_type - 着色器类型
-        """
-        
-        shader_types = (
-            GL_VERTEX_SHADER,           # 顶点着色器
-            GL_TESS_CONTROL_SHADER,     # 细分控制着色器
-            GL_TESS_EVALUATION_SHADER,  # 细分估值着色器
-            GL_GEOMETRY_SHADER,         # 几何着色器
-            GL_FRAGMENT_SHADER,         # 片元着色器
-            GL_COMPUTE_SHADER           # 计算着色器
-        )
-        
-        if shader_type not in shader_types:
-            raise ValueError('不支持的着色器类型')
-        
-        self.shaders.append((shader_src, shader_type))
-    
-    def set_vertex(self, var_name, data, indices=None):
-        """设置顶点
-        
-        var_name    - 顶点在着色器中的变量名
-        data        - 顶点数据
-        indices     - 顶点索引数据
-        """
-        
-        data = np.array(data, dtype=np.float32)
-        if data.ndim == 3:
-            data = data.reshape(-1, data.shape[-1])
-        
-        self.attribute.update({var_name: {'tag':'vertex', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
-        self.depth = data[:, 2].mean() if data.shape[-1] == 3 else 0
-        self.vshape = data.shape
-        
-        if self.inside:
-            self.r_x = (data[:,0].min(), data[:,0].max())
-            self.r_y = (data[:,1].min(), data[:,1].max())
-            if self.vshape[1] == 3:
-                self.r_z = (data[:,2].min(), data[:,2].max())
-        
-        if not indices is None:
-            indices = np.array(indices, dtype=np.int32)
-            self.indices = {'data':indices, 'n':indices.size}
-    
-    def set_normal(self, var_name, data):
-        """设置顶点法向量
-        
-        var_name    - 顶点法向量在着色器中的变量名
-        data        - 顶点法向量数据
-        """
-        
-        data = np.array(data, dtype=np.float32)
-        self.attribute.update({var_name: {'tag':'normal', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
-    
-    def set_texcoord(self, var_name, data):
-        """设置顶点纹理
-        
-        var_name    - 顶点纹理在着色器中的变量名
-        data        - 顶点纹理数据
-        """
-        
-        data = np.array(data, dtype=np.float32)
-        if data.ndim == 1:
-            data = data[:,np.newaxis]
-        
-        self.attribute.update({var_name: {'tag':'texcoord', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
-    
-    def set_color(self, var_name, data):
-        """设置顶点颜色
-        
-        var_name    - 顶点颜色在着色器中的变量名
-        data        - 顶点颜色数据
-        """
-        
-        data = np.array(data, dtype=np.float32)
-        self.attribute.update({var_name: {'tag':'color', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
-    
-    def set_psize(self, var_name, data):
-        """设置顶点大小
-        
-        var_name    - 顶点大小在着色器中的变量名
-        data        - 顶点大小数据
-        """
-        
-        data = np.array(data, dtype=np.float32)
-        self.attribute.update({var_name: {'tag':'psize', 'data':data, 'un':1}})
-        
-        if not self.sprite:
-            self.sprite = True
-            self.before.append((glPushAttrib, (GL_POINT_BIT,)))
-            self.before.append((glEnable, (GL_POINT_SPRITE,)))
-            self.before.append((glEnable, (GL_PROGRAM_POINT_SIZE,)))
-            self.after.append((glPopAttrib, ()))
-    
-    def add_texture(self, var_name, texture):
-        """添加纹理
-        
-        var_name    - 纹理在着色器中的变量名
-        texture     - wxgl.Texture对象
-        """
-        
-        self.uniform.update({var_name: {'tag':'texture', 'data':texture}})
-    
-    def set_cam_pos(self, var_name):
-        """设置相机位置（用于计算镜面反射）
-        
-        var_name    - 相机位置在着色器中的变量名
-        """
-        
-        self.uniform.update({var_name: {'tag':'campos'}})
-    
-    def set_ae(self, var_name):
-        """设置相机方位角和高度角
-        
-        var_name    - 相机方位角和高度角在着色器中的变量名
-        """
-        
-        self.uniform.update({var_name: {'tag':'ae'}})
-    
-    def set_picked(self, var_name):
-        """设置拾取状态
-        
-        var_name    - 拾取状态在着色器中的变量名
-        """
-        
-        self.uniform.update({var_name: {'tag':'picked'}})
-    
-    def set_view_matrix(self, var_name, vmatrix=None):
-        """设置视点矩阵
-        
-        var_name    - 视点矩阵在着色器中的变量名
-        vmatrix     - 视点矩阵或生成视点矩阵的函数，None表示使用当前视点矩阵
-        """
-        
-        if vmatrix is None:
-            self.uniform.update({var_name: {'tag':'vmat'}})
-        elif hasattr(vmatrix, '__call__'):
-            self.uniform.update({var_name: {'tag':'vmat', 'f':vmatrix}})
-            self.islive = True
-        else:
-            self.uniform.update({var_name: {'tag':'vmat', 'v':vmatrix}})
-    
-    def set_proj_matrix(self, var_name, pmatrix=None):
-        """设置投影矩阵
-        
-        var_name    - 投影矩阵在着色器中的变量名
-        mmatrix     - 投影矩阵或生成投影矩阵的函数，None表示使用当前投影矩阵
-        """
-        
-        if pmatrix is None:
-            self.uniform.update({var_name: {'tag':'pmat'}})
-        elif hasattr(pmatrix, '__call__'):
-            self.uniform.update({var_name: {'tag':'pmat', 'f':pmatrix}})
-            self.islive = True
-        else:
-            self.uniform.update({var_name: {'tag':'pmat', 'v':pmatrix}})
-    
-    def set_model_matrix(self, var_name, mmatrix=None):
-        """设置模型矩阵
-        
-        var_name    - 模型矩阵在着色器中的变量名
-        mmatrix     - 模型矩阵或生成模型矩阵的函数，None表示模型无几何变换
-        """
-        
-        if mmatrix is None:
-            self.uniform.update({var_name: {'tag':'mmat'}})
-        elif hasattr(mmatrix, '__call__'):
-            self.uniform.update({var_name: {'tag':'mmat', 'f':mmatrix}})
-            self.islive = True
-        else:
-            self.uniform.update({var_name: {'tag':'mmat', 'v':mmatrix}})
-    
-    def set_argument(self, var_name, var_value):
-        """设置变量
-        
-        var_name    - 变量在着色器中的变量名
-        var_value   - 变量值或生成变量值的函数
-        """
-        
-        self.other.update({var_name:var_value})
-    
-    def set_line_style(self, width=None, stipple=None):
-        """设置线宽和线型
-        
-        width       - 线宽
-        stipple     - 线型，重复因子（整数）和模式（16位二进制）组成的元组
-        """
-        
-        if not width is None or not stipple is None:
-            self.before.append((glPushAttrib, (GL_LINE_BIT,)))
-            if not width is None:
-                self.before.append((glLineWidth,(width,)))
-            if not stipple is None:
-                self.before.append((glEnable, (GL_LINE_STIPPLE,)))
-                self.before.append((glLineStipple, stipple))
-            self.after.append((glPopAttrib, ()))
-    
-    def set_cull_mode(self, mode):
-        """设置面剔除方式
-        
-        mode        - 剔除的面：'front'|'back'
-        """
-        
-        if mode is None:
-            return
-        
-        if isinstance(mode, str):
-            mode = mode.upper()
-        
-        if mode in ('FRONT', 'BACK'):
-            self.before.append((glPushAttrib, (GL_ALL_ATTRIB_BITS,)))
-            self.before.append((glEnable, (GL_CULL_FACE,)))
-            self.before.append((glCullFace, (GL_FRONT if mode=='FRONT' else GL_BACK,)))
-            self.after.append((glPopAttrib, ()))
-        else:
-            raise ValueError('不支持的面剔除参数：%s'%mode)
-    
-    def set_fill_mode(self, mode):
-        """设置填充方式
-        
-        mode        - 填充模式：布尔型，或'FCBC'|'FLBC'|'FCBL'|'FLBL'
-        """
-        
-        if mode is None:
-            return
-        
-        if isinstance(mode, str):
-            mode = mode.upper()
-        
-        if mode in ('FCBC', 'FLBC', 'FCBL', 'FLBL', True, False):
-            self.before.append((glPushAttrib, (GL_ALL_ATTRIB_BITS,)))
-            if mode == 'FCBC' or mode == True:
-                self.before.append((glPolygonMode,(GL_FRONT_AND_BACK, GL_FILL)))
-            elif mode == 'FLBL' or mode == False:
-                self.before.append((glPolygonMode,(GL_FRONT_AND_BACK, GL_LINE)))
-            elif mode == 'FCBL':
-                self.before.append((glPolygonMode,(GL_FRONT, GL_FILL)))
-                self.before.append((glPolygonMode,(GL_BACK, GL_LINE)))
-            else:
-                self.before.append((glPolygonMode,(GL_FRONT, GL_LINE)))
-                self.before.append((glPolygonMode,(GL_BACK, GL_FILL)))
-            self.after.append((glPopAttrib, ()))
-        else:
-            raise ValueError('不支持的填充模式：%s'%mode)
-    
-    def set_slide(self, slide):
-        """设置幻灯片函数"""
-        
-        self.slide = slide
-        if hasattr(slide, '__call__'):
-            self.islive = True
-    
-    def verify(self):
-        """验证模型数据、检查着色器源码"""
-        
-        if self.gltype is None:
-            raise ValueError('未设置GL基本图元')
-        
-        if self.vshape is None:
-            raise ValueError('未设置模型顶点数据')
-        
-        p0 = re.compile(r'void\s+main\s*\(\s*\)') # void main()
-        p1 = re.compile(r'//') # 匹配注释
-        p2 = re.compile(r'(in|attribute|uniform)\s+(\S+)\s+(\S+)\s*;') # in|attribute|uniform vec4 position;
-        p3 = re.compile(r'layout\s*\(\s*location\s*=\s*(\d+)\s*\)') # layout (location=0)
-        pn = re.compile(r'\[(\d+)\]$') # 匹配数组
-        
-        for src, genre in self.shaders: # 遍历每一个着色器
-            for line in src.split('\n'): # 遍历每一行
-                if p0.search(line):
-                    break
-                
-                if p1.match(line.strip()):
-                    continue
-                
-                r2 = p2.search(line)
-                if r2:
-                    qualifier, var_type, var_name = r2.groups()
-                    
-                    if qualifier in ('in', 'attribute'):
-                        if genre == GL_VERTEX_SHADER:
-                            qualifier = 'attribute'
-                        else:
-                            continue
-                    
-                    rpn = pn.search(var_name)
-                    if rpn:
-                        ndim = int(rpn.groups()[0]) # 变量数组的长度（若变量是数组的话）
-                        var_name = var_name.split('[')[0].strip()
-                    else:
-                        ndim = None
-                    
-                    if var_name in self.other:
-                        data = self.other[var_name]
-                        
-                        if not hasattr(data, '__call__'):
-                            if var_type == 'float' or var_type[:3] == 'vec':
-                                data = np.float32(data)
-                            elif var_type == 'double' or var_type[:4] == 'dvec':
-                                data = np.float64(data)
-                            elif var_type == 'int' or var_type[:4] == 'ivec':
-                                data = np.int32(data)
-                            elif var_type == 'uint' or var_type[:4] == 'uvec':
-                                data = np.uint8(data)
-                        
-                        if qualifier == 'attribute':
-                            if hasattr(data, '__call__'):
-                                raise ValueError('in或attribute限定的着色器变量不能赋值为函数')
-                            
-                            if data.ndim > 2:
-                                data = data.reshape(-1, data.shape[-1])
-                            elif data.ndim == 1:
-                                data = data.reshape(-1, 1)
-                            
-                            self.attribute.update({var_name: {'tag':'other', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
-                        else:
-                            if hasattr(data, '__call__'):
-                                self.uniform.update({var_name: {'tag':'other', 'f':data}})
-                                self.islive = True
-                            else:
-                                self.uniform.update({var_name: {'tag':'other', 'v':data}})
-                            
-                            dtype = {
-                                'float': '1f',
-                                'double': '1d',
-                                'int': '1i',
-                                'uint': '1ui',
-                                'vec2': '2fv',
-                                'vec3': '3fv',
-                                'vec4': '4fv',
-                                'dvec2': '2dv',
-                                'dvec3': '3dv',
-                                'dvec4': '4dv',
-                                'ivec2': '2iv',
-                                'ivec3': '3iv',
-                                'ivec4': '4iv',
-                                'uvec2': '2uiv',
-                                'uvec3': '3uiv',
-                                'uvec4': '4uiv'
-                            }.get(var_type, None)
-                        
-                            if not dtype:
-                                raise ValueError('着色器变量“%s”的数据类型不被支持'%var_name)
-                            
-                            if ndim is None:
-                                if dtype[-1] == 'v':
-                                    ndim = 1
-                            else:
-                                if dtype[-1] != 'v':
-                                    dtype = dtype + 'v'
-                            
-                            self.uniform[var_name].update({'dtype': dtype})
-                            self.uniform[var_name].update({'ndim': ndim})
-                    
-                    if var_name not in self.__getattribute__(qualifier):
-                        raise ValueError('着色器变量“%s”未赋值'%var_name)
-                    
-                    r3 = p3.match(line.strip())
-                    if r3:
-                        self.__getattribute__(qualifier)[var_name].update({'loc': int(r3.groups()[0])})
-    
+#!/usr/bin/env python3
+
+import re
+import numpy as np
+from OpenGL.GL import *
+
+class Model:
+    """模型类"""
+ 
+    def __init__(self, gltype, vshader, fshader, **kwds):
+        """构造函数
+ 
+        gltype      - GL基本图元
+        vshader     - 顶点着色器源码
+        fshader     - 片元着色器源码
+        kwds        - 关键字参数
+            visible     - 模型可见性，默认True
+            opacity     - 模型不透明，默认True
+            inside      - 模型显示在视锥体内，默认True
+            sprite      - 开启点精灵，默认False
+            alive       - 启动渲染计时器，默认False
+        """
+ 
+        keys = ['visible', 'opacity', 'inside', 'sprite', 'alive']
+        for key in kwds:
+            if key not in keys:
+                raise KeyError('不支持的关键字参数：%s'%key)
+
+        gltypes = (
+            GL_POINTS,	        # 绘制一个或多个顶点
+            GL_LINES,	        # 绘制线段
+            GL_LINE_STRIP,	    # 绘制连续线段
+            GL_LINE_LOOP,	    # 绘制闭合的线段
+            GL_TRIANGLES,	    # 绘制一个或多个三角形
+            GL_TRIANGLE_STRIP,	# 绘制连续三角形
+            GL_TRIANGLE_FAN,    # 绘制多个三角形组成的扇形
+            GL_QUADS,	        # 绘制一个或多个四边形
+            GL_QUAD_STRIP       # 四边形条带
+        )
+ 
+        if gltype not in gltypes:
+            raise ValueError('不支持的绘制方法')
+ 
+        self.gltype = gltype                            # GL基本图元
+ 
+        self.name = None                                # 模型（部件）名
+        self.visible = kwds.get('visible', True)        # 模型可见性，默认可见
+        self.opacity = kwds.get('opacity', True)        # 模型不透明属性，默认不透明
+        self.inside = kwds.get('inside', True)          # 模型顶点是否影响模型空间，默认True
+        self.sprite = kwds.get('sprite', False)         # 开启点精灵，默认False
+        self.alive = kwds.get('alive', False)           # 启动渲染计时器，默认False
+        self.slide = None                               # 幻灯片函数
+        self.depth = dict()                             # 深度轴均值
+        self.picked = False                             # 模型被拾取
+ 
+        self.program = None                             # 着色器程序
+        self.cshaders = list()                          # 编译后的着色器
+        self.shaders = list()                           # 着色器源码
+        self.other = dict()                             # 着色器中其他变量
+        self.attribute = dict()                         # attribute变量
+        self.uniform = dict()                           # uniform变量
+ 
+        self.vshape = None                              # 顶点数据的shape
+        self.indices = None                             # 顶点索引
+        self.r_x = None                                 # 顶点坐标x的动态范围
+        self.r_y = None                                 # 顶点坐标y的动态范围
+        self.r_z = None                                 # 顶点坐标z的动态范围
+ 
+        self.before = list()                            # 绘制前执行的GL命令
+        self.after = list()                             # 绘制后执行的GL命令
+ 
+        self.add_shader(vshader, GL_VERTEX_SHADER)
+        self.add_shader(fshader, GL_FRAGMENT_SHADER)
+ 
+        if self.sprite:
+            self.before.append((glPushAttrib, (GL_POINT_BIT,)))
+            self.before.append((glEnable, (GL_POINT_SPRITE,)))
+            self.before.append((glEnable, (GL_PROGRAM_POINT_SIZE,)))
+            self.after.append((glPopAttrib, ()))
+ 
+    def add_shader(self, shader_src, shader_type):
+        """添加着色器
+ 
+        shader_src  - 着色器源码
+        shader_type - 着色器类型
+        """
+ 
+        shader_types = (
+            GL_VERTEX_SHADER,           # 顶点着色器
+            GL_TESS_CONTROL_SHADER,     # 细分控制着色器
+            GL_TESS_EVALUATION_SHADER,  # 细分估值着色器
+            GL_GEOMETRY_SHADER,         # 几何着色器
+            GL_FRAGMENT_SHADER,         # 片元着色器
+            GL_COMPUTE_SHADER           # 计算着色器
+        )
+ 
+        if shader_type not in shader_types:
+            raise ValueError('不支持的着色器类型')
+ 
+        self.shaders.append((shader_src, shader_type))
+ 
+    def set_vertex(self, var_name, data, indices=None):
+        """设置顶点
+ 
+        var_name    - 顶点在着色器中的变量名
+        data        - 顶点数据
+        indices     - 顶点索引数据
+        """
+ 
+        data = np.array(data, dtype=np.float32)
+        if data.ndim == 3:
+            data = data.reshape(-1, data.shape[-1])
+ 
+        self.attribute.update({var_name: {'tag':'vertex', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
+        self.depth.update({'y': data[:, 2].mean() if data.shape[-1] == 3 else 0})
+        self.depth.update({'z': -data[:, 1].mean() if data.shape[-1] == 3 else 0})
+        self.vshape = data.shape
+ 
+        if self.inside:
+            self.r_x = (data[:,0].min(), data[:,0].max())
+            self.r_y = (data[:,1].min(), data[:,1].max())
+            if self.vshape[1] == 3:
+                self.r_z = (data[:,2].min(), data[:,2].max())
+ 
+        if not indices is None:
+            indices = np.array(indices, dtype=np.int32)
+            self.indices = {'data':indices, 'n':indices.size}
+ 
+    def set_normal(self, var_name, data):
+        """设置顶点法向量
+ 
+        var_name    - 顶点法向量在着色器中的变量名
+        data        - 顶点法向量数据
+        """
+ 
+        data = np.array(data, dtype=np.float32)
+        self.attribute.update({var_name: {'tag':'normal', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
+ 
+    def set_texcoord(self, var_name, data):
+        """设置顶点纹理坐标
+ 
+        var_name    - 顶点纹理坐标在着色器中的变量名
+        data        - 顶点纹理坐标数据
+        """
+ 
+        data = np.array(data, dtype=np.float32)
+        if data.ndim == 1:
+            data = data[:,np.newaxis]
+ 
+        self.attribute.update({var_name: {'tag':'texcoord', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
+ 
+    def set_color(self, var_name, data):
+        """设置顶点颜色
+ 
+        var_name    - 顶点颜色在着色器中的变量名
+        data        - 顶点颜色数据
+        """
+ 
+        data = np.array(data, dtype=np.float32)
+        self.attribute.update({var_name: {'tag':'color', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
+ 
+    def set_psize(self, var_name, data):
+        """设置顶点大小
+ 
+        var_name    - 顶点大小在着色器中的变量名
+        data        - 顶点大小数据
+        """
+ 
+        data = np.array(data, dtype=np.float32)
+        self.attribute.update({var_name: {'tag':'psize', 'data':data, 'un':1, 'usize':data.itemsize}})
+ 
+        if not self.sprite:
+            self.sprite = True
+            self.before.append((glPushAttrib, (GL_POINT_BIT,)))
+            self.before.append((glEnable, (GL_POINT_SPRITE,)))
+            self.before.append((glEnable, (GL_PROGRAM_POINT_SIZE,)))
+            self.after.append((glPopAttrib, ()))
+ 
+    def add_texture(self, var_name, texture):
+        """添加纹理
+ 
+        var_name    - 纹理在着色器中的变量名
+        texture     - wxgl.Texture对象
+        """
+ 
+        self.uniform.update({var_name: {'tag':'texture', 'data':texture}})
+ 
+    def set_cam_pos(self, var_name):
+        """设置相机位置（用于计算镜面反射）
+ 
+        var_name    - 相机位置在着色器中的变量名
+        """
+ 
+        self.uniform.update({var_name: {'tag':'campos'}})
+ 
+    def set_ae(self, var_name):
+        """设置相机方位角和高度角
+ 
+        var_name    - 相机方位角和高度角在着色器中的变量名
+        """
+ 
+        self.uniform.update({var_name: {'tag':'ae'}})
+
+    def set_timestamp(self, var_name):
+        """设置渲染时间戳（以毫秒为单位的浮点数）
+ 
+        var_name    - 渲染时间戳在着色器中的变量名
+        """
+ 
+        self.uniform.update({var_name: {'tag':'timestamp'}})
+ 
+    def set_picked(self, var_name):
+        """设置拾取状态
+ 
+        var_name    - 拾取状态在着色器中的变量名
+        """
+ 
+        self.uniform.update({var_name: {'tag':'picked'}})
+ 
+    def set_view_matrix(self, var_name, vmatrix=None):
+        """设置视点矩阵
+ 
+        var_name    - 视点矩阵在着色器中的变量名
+        vmatrix     - 视点矩阵或生成视点矩阵的函数，None表示使用当前视点矩阵
+        """
+ 
+        if vmatrix is None:
+            self.uniform.update({var_name: {'tag':'vmat'}})
+        elif hasattr(vmatrix, '__call__'):
+            self.uniform.update({var_name: {'tag':'vmat', 'f':vmatrix}})
+            self.alive = True
+        else:
+            self.uniform.update({var_name: {'tag':'vmat', 'v':vmatrix}})
+ 
+    def set_proj_matrix(self, var_name, pmatrix=None):
+        """设置投影矩阵
+ 
+        var_name    - 投影矩阵在着色器中的变量名
+        mmatrix     - 投影矩阵或生成投影矩阵的函数，None表示使用当前投影矩阵
+        """
+ 
+        if pmatrix is None:
+            self.uniform.update({var_name: {'tag':'pmat'}})
+        elif hasattr(pmatrix, '__call__'):
+            self.uniform.update({var_name: {'tag':'pmat', 'f':pmatrix}})
+            self.alive = True
+        else:
+            self.uniform.update({var_name: {'tag':'pmat', 'v':pmatrix}})
+ 
+    def set_model_matrix(self, var_name, mmatrix=None):
+        """设置模型矩阵
+ 
+        var_name    - 模型矩阵在着色器中的变量名
+        mmatrix     - 模型矩阵或生成模型矩阵的函数，None表示模型无几何变换
+        """
+ 
+        if mmatrix is None:
+            self.uniform.update({var_name: {'tag':'mmat'}})
+        elif hasattr(mmatrix, '__call__'):
+            self.uniform.update({var_name: {'tag':'mmat', 'f':mmatrix}})
+            self.alive = True
+        else:
+            self.uniform.update({var_name: {'tag':'mmat', 'v':mmatrix}})
+
+    def set_argument(self, var_name, var_value):
+        """设置变量
+ 
+        var_name    - 变量在着色器中的变量名
+        var_value   - 变量值或生成变量值的函数
+        """
+ 
+        self.other.update({var_name:var_value})
+
+    def set_text_size(self, var_name, size):
+        """设置2D文本的宽度和高度
+
+        var_name    - 变量在着色器中的变量名
+        size        - 2D文本的宽度和高度
+        """
+
+        self.uniform.update({var_name: {'tag':'tsize', 'v':size}}) 
+
+    def set_line_style(self, width=None, stipple=None):
+        """设置线宽和线型
+ 
+        width       - 线宽
+        stipple     - 线型，重复因子（整数）和模式（16位二进制）组成的元组
+        """
+ 
+        if not width is None or not stipple is None:
+            self.before.append((glPushAttrib, (GL_LINE_BIT,)))
+            if not width is None:
+                self.before.append((glLineWidth,(width,)))
+            if not stipple is None:
+                self.before.append((glEnable, (GL_LINE_STIPPLE,)))
+                self.before.append((glLineStipple, stipple))
+            self.after.append((glPopAttrib, ()))
+ 
+    def set_cull_mode(self, mode):
+        """设置面剔除方式
+ 
+        mode        - 剔除的面：'front'|'back'
+        """
+ 
+        if mode is None:
+            return
+ 
+        if isinstance(mode, str):
+            mode = mode.upper()
+ 
+        if mode in ('FRONT', 'BACK'):
+            self.before.append((glPushAttrib, (GL_ALL_ATTRIB_BITS,)))
+            self.before.append((glEnable, (GL_CULL_FACE,)))
+            self.before.append((glCullFace, (GL_FRONT if mode=='FRONT' else GL_BACK,)))
+            self.after.append((glPopAttrib, ()))
+        else:
+            raise ValueError('不支持的面剔除参数：%s'%mode)
+ 
+    def set_fill_mode(self, mode):
+        """设置填充方式
+ 
+        mode        - 填充模式：布尔型，或'FCBC'|'FLBC'|'FCBL'|'FLBL'
+        """
+ 
+        if mode is None:
+            return
+ 
+        if isinstance(mode, str):
+            mode = mode.upper()
+ 
+        if mode in ('FCBC', 'FLBC', 'FCBL', 'FLBL', True, False):
+            self.before.append((glPushAttrib, (GL_ALL_ATTRIB_BITS,)))
+            if mode == 'FCBC' or mode == True:
+                self.before.append((glPolygonMode,(GL_FRONT_AND_BACK, GL_FILL)))
+            elif mode == 'FLBL' or mode == False:
+                self.before.append((glPolygonMode,(GL_FRONT_AND_BACK, GL_LINE)))
+            elif mode == 'FCBL':
+                self.before.append((glPolygonMode,(GL_FRONT, GL_FILL)))
+                self.before.append((glPolygonMode,(GL_BACK, GL_LINE)))
+            else:
+                self.before.append((glPolygonMode,(GL_FRONT, GL_LINE)))
+                self.before.append((glPolygonMode,(GL_BACK, GL_FILL)))
+            self.after.append((glPopAttrib, ()))
+        else:
+            raise ValueError('不支持的填充模式：%s'%mode)
+ 
+    def set_slide(self, slide):
+        """设置幻灯片函数"""
+ 
+        self.slide = slide
+        if hasattr(slide, '__call__'):
+            self.alive = True
+ 
+    def verify(self):
+        """验证并返回正确的模型对象"""
+
+        if self.gltype is None:
+            raise ValueError('未设置GL基本图元')
+ 
+        if self.vshape is None:
+            raise ValueError('未设置模型顶点数据')
+ 
+        p0 = re.compile(r'void\s+main\s*\(\s*\)') # void main()
+        p1 = re.compile(r'//') # 匹配注释
+        p2 = re.compile(r'(in|attribute|uniform)\s+(\S+)\s+(\S+)\s*;') # in|attribute|uniform vec4 position;
+        p3 = re.compile(r'layout\s*\(\s*location\s*=\s*(\d+)\s*\)') # layout (location=0)
+        pn = re.compile(r'\[(\d+)\]$') # 匹配数组
+ 
+        for src, genre in self.shaders: # 遍历每一个着色器
+            for line in src.split('\n'): # 遍历每一行
+                if p0.search(line):
+                    break
+ 
+                if p1.match(line.strip()):
+                    continue
+ 
+                r2 = p2.search(line)
+                if r2:
+                    qualifier, var_type, var_name = r2.groups()
+ 
+                    if qualifier in ('in', 'attribute'):
+                        if genre == GL_VERTEX_SHADER:
+                            qualifier = 'attribute'
+                        else:
+                            continue
+ 
+                    rpn = pn.search(var_name)
+                    if rpn:
+                        ndim = int(rpn.groups()[0]) # 变量数组的长度（若变量是数组的话）
+                        var_name = var_name.split('[')[0].strip()
+                    else:
+                        ndim = None
+ 
+                    if var_name in self.other:
+                        data = self.other[var_name]
+ 
+                        if not hasattr(data, '__call__'):
+                            if var_type == 'float' or var_type[:3] == 'vec':
+                                data = np.float32(data)
+                            elif var_type == 'double' or var_type[:4] == 'dvec':
+                                data = np.float64(data)
+                            elif var_type == 'int' or var_type[:4] == 'ivec':
+                                data = np.int32(data)
+                            elif var_type == 'uint' or var_type[:4] == 'uvec':
+                                data = np.uint8(data)
+ 
+                        if qualifier == 'attribute':
+                            if hasattr(data, '__call__'):
+                                raise ValueError('in或attribute限定的着色器变量不能赋值为函数')
+ 
+                            if data.ndim > 2:
+                                data = data.reshape(-1, data.shape[-1])
+                            elif data.ndim == 1:
+                                data = data.reshape(-1, 1)
+ 
+                            self.attribute.update({var_name: {'tag':'other', 'data':data, 'un':data.shape[-1], 'usize':data.itemsize}})
+                        else:
+                            if hasattr(data, '__call__'):
+                                self.uniform.update({var_name: {'tag':'other', 'f':data}})
+                                self.alive = True
+                            else:
+                                self.uniform.update({var_name: {'tag':'other', 'v':data}})
+ 
+                            dtype = {
+                                'float': '1f',
+                                'double': '1d',
+                                'int': '1i',
+                                'uint': '1ui',
+                                'vec2': '2fv',
+                                'vec3': '3fv',
+                                'vec4': '4fv',
+                                'dvec2': '2dv',
+                                'dvec3': '3dv',
+                                'dvec4': '4dv',
+                                'ivec2': '2iv',
+                                'ivec3': '3iv',
+                                'ivec4': '4iv',
+                                'uvec2': '2uiv',
+                                'uvec3': '3uiv',
+                                'uvec4': '4uiv'
+                            }.get(var_type, None)
+ 
+                            if not dtype:
+                                raise ValueError('着色器变量“%s”的数据类型不被支持'%var_name)
+ 
+                            if ndim is None:
+                                if dtype[-1] == 'v':
+                                    ndim = 1
+                            else:
+                                if dtype[-1] != 'v':
+                                    dtype = dtype + 'v'
+ 
+                            self.uniform[var_name].update({'dtype': dtype})
+                            self.uniform[var_name].update({'ndim': ndim})
+ 
+                    if var_name not in self.__getattribute__(qualifier):
+                        raise ValueError('着色器变量“%s”未赋值'%var_name)
+ 
+                    r3 = p3.match(line.strip())
+                    if r3:
+                        self.__getattribute__(qualifier)[var_name].update({'loc': int(r3.groups()[0])})
+
```

## wxgl/scene.py

```diff
@@ -1,547 +1,560 @@
-# -*- coding: utf-8 -*-
-#
-# MIT License
-# 
-# Copyright (c) 2021 Tianyuan Langzi
-# 
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-
-
-"""
-WxGL: 基于PyOpenGL的三维数据绘图工具包
-
-以wx为显示后端，提供Matplotlib风格的应用方式
-也可以和wxpython无缝结合，在wx的窗体上绘制三维模型
-"""
-
-
-import os, time
-from pynput import keyboard
-import wx
-from wx import glcanvas
-import numpy as np
-from PIL import Image
-import imageio
-import queue
-import threading
-from OpenGL.GL import *
-
-from . import region
-from . import util
-
-
-class Scene(glcanvas.GLCanvas):
-    """WxGL场景类"""
-    
-    def __init__(self, parent, smooth=True, style='blue'):
-        """构造函数
-        
-        parent      - 父级窗口对象
-        smooth      - 直线、多边形和点的反走样开关
-        style       - 场景风格，默认太空蓝
-            'blue'      - 太空蓝
-            'gray'      - 国际灰
-            'black'     - 石墨黑
-            'white'     - 珍珠白
-            'royal'     - 宝石蓝
-        """
-        
-        self.parent = parent
-        glcanvas.GLCanvas.__init__(self, self.parent, -1, style=glcanvas.WX_GL_RGBA|glcanvas.WX_GL_DOUBLEBUFFER|glcanvas.WX_GL_DEPTH_SIZE)
-        
-        self.smooth = smooth                                                # 反走样开关
-        self.style = self._set_style(style)                                 # 设置风格（背景和文本颜色）
-        
-        self.csize = self.GetClientSize()                                   # OpenGL窗口的大小
-        self.context = glcanvas.GLContext(self)                             # OpenGL上下文
-        self.regions = list()                                               # 视区列表
-        self.selected = list()                                              # 选中的模型列表
-        
-        self.leftdown = False                                               # 鼠标左键按下
-        self.mpos = wx._core.Point()                                        # 鼠标位置
-        self.ctr = False                                                    # Ctr键按下
-        
-        self.tn = 0                                                         # 计数器
-        self.tstamp = None                                                  # 开始渲染时的时间戳
-        self.tbase = 0                                                      # 开始渲染时的累计时长
-        self.duration = 0;                                                  # 累计渲染时长，单位毫秒
-        self.islive = False                                                 # 存在动画模型
-        self.playing = False                                                # 动画播放中
-        self.creating = False                                               # 动画文件生成中
-        self.capturing = False                                              # 截屏中
-        self.ft = 0                                                         # 录制和输出的帧间隔，单位毫秒
-        self.fn = 0                                                         # 录屏总帧数
-        self.cn = 0                                                         # 已完成帧数
-        self.q = None                                                       # PIL对象数据队列
-        
-        self._init_gl()                                                     # 画布初始化
-        
-        self.Bind(wx.EVT_WINDOW_DESTROY, self._on_destroy)                  # 绑定canvas销毁事件
-        self.Bind(wx.EVT_SIZE, self._on_resize)                             # 绑定canvas大小改变事件
-        
-        self.Bind(wx.EVT_LEFT_DOWN, self._on_left_down)                     # 绑定鼠标左键按下事件
-        self.Bind(wx.EVT_LEFT_UP, self._on_left_up)                         # 绑定鼠标左键弹起事件                   
-        self.Bind(wx.EVT_RIGHT_UP, self._on_right_up)                       # 绑定鼠标右键弹起事件                   
-        self.Bind(wx.EVT_MOTION, self._on_mouse_motion)                     # 绑定鼠标移动事件
-        self.Bind(wx.EVT_MOUSEWHEEL, self._on_mouse_wheel)                  # 绑定鼠标滚轮事件
-        
-        monitor_k = keyboard.Listener(on_press=self._on_press, on_release=self._on_release)
-        monitor_k.start()
-    
-    def _set_style(self, style):
-        """设置风格，返回背景色和前景色"""
-        
-        if not style in ('black', 'white', 'gray', 'blue', 'royal'):
-            raise ValueError('不支持的风格选项：%s'%style)
-        
-        if style == 'black':
-            return (0.0, 0.0, 0.0, 1.0), (0.9, 0.9, 0.9)
-        if style == 'white':
-            return (1.0, 1.0, 1.0, 1.0), (0.0, 0.0, 0.0)
-        if style == 'gray':
-            return (0.9, 0.9, 0.9, 1.0), (0.0, 0.0, 0.3)
-        if style == 'blue':
-            return (0.0, 0.0, 0.2, 1.0), (0.9, 1.0, 1.0)
-        if style == 'royal':
-            return (0.133, 0.302, 0.361, 1.0), (1.0, 1.0, 0.7)
-    
-    def _init_gl(self):
-        """初始化GL"""
-        
-        self.SetCurrent(self.context)
-        
-        glClearColor(*self.style[0],)                                       # 设置画布背景色
-        glEnable(GL_DEPTH_TEST)                                             # 开启深度测试，实现遮挡关系        
-        glDepthFunc(GL_LEQUAL)                                              # 设置深度测试函数
-        glShadeModel(GL_SMOOTH)                                             # GL_SMOOTH(光滑着色)/GL_FLAT(恒定着色)
-        glEnable(GL_BLEND)                                                  # 开启混合        
-        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)                   # 设置混合函数
-        glEnable(GL_ALPHA_TEST)                                             # 启用Alpha测试 
-        glAlphaFunc(GL_GREATER, 0.05)                                       # 设置Alpha测试条件为大于0.05则通过
-        
-        if self.smooth:
-            glEnable(GL_POINT_SMOOTH)                                       # 开启点反走样
-            glHint(GL_POINT_SMOOTH_HINT, GL_NICEST)                         # 最高质量点反走样
-            glEnable(GL_POLYGON_SMOOTH)                                     # 开启多边形反走样
-            glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST)                       # 最高质量多边形反走样
-            glEnable(GL_LINE_SMOOTH)                                        # 开启直线反走样
-            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)                          # 最高质量直线反走样
-    
-    def _on_destroy(self, evt):
-        """canvas销毁事件函数"""
-        
-        for reg in self.regions:
-            reg._clear_buffer()
-        
-        evt.Skip()
-    
-    def _on_resize(self, evt):
-        """窗口改变事件函数"""
-        
-        self.SetCurrent(self.context)
-        self.csize = self.GetClientSize()
-        
-        for reg in self.regions:
-            reg.reset_box()
-        
-        self.render()
-        evt.Skip()
-        
-    def _on_left_down(self, evt):
-        """响应鼠标左键按下事件"""
-        
-        self.leftdown = True
-        self.mpos = evt.GetPosition()
-        
-    def _on_left_up(self, evt):
-        """响应鼠标左键弹起事件"""
-        
-        self.leftdown = False
-        
-    def _on_right_up(self, evt):
-        """响应鼠标右键弹起事件"""
-        
-        x, y = evt.GetPosition()
-        self._render_pick(x, self.csize[1]-y)
-        
-    def _on_mouse_motion(self, evt):
-        """响应鼠标移动事件"""
-        
-        if evt.Dragging() and self.leftdown:
-            pos = evt.GetPosition()
-            dx, dy = pos - self.mpos
-            self.mpos = pos
-            
-            for reg in self.regions:
-                reg._motion(self.ctr, dx, dy)
-            
-            self.render()
-        
-    def _on_mouse_wheel(self, evt):
-        """响应鼠标滚轮事件"""
-        
-        for reg in self.regions:
-            reg._wheel(self.ctr, evt.WheelRotation)
-            
-        self.render()
-    
-    def _on_press(self, key):
-        """键按下"""
-        
-        if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r:
-            self.ctr = True
-    
-    def _on_release(self, key):
-        """键弹起"""
-        
-        if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r:
-            self.ctr = False
-        elif key == keyboard.Key.esc:
-            wx.CallAfter(self.restore_posture)
-    
-    def _render_on_timer(self):
-        """定时器事件函数"""
-        
-        self.tn += 1
-        if self.capturing:
-            self.duration = self.tbase + self.ft * self.cn
-        else:
-            self.duration = self.tbase + int((time.time() - self.tstamp) * 1000)
-        
-        wx.CallAfter(self.render)
-        
-        if self.playing:
-            wx.CallLater(10, self._render_on_timer)
-    
-    def _reset_timer(self):
-        """复位和定时器相关的参数"""
-        
-        self.playing = False
-        self.capturing = False
-        self.creating = False
-        self.cn = 0
-        self.tn = 0 
-        self.tbase = 0
-        self.duration = 0
-        
-    def _get_scene_buffer(self, alpha=True, buffer='front', crop=False):
-        """以PIL对象的格式返回场景缓冲区数据
-        
-        alpha       - 是否使用透明通道
-        buffer      - 显示缓冲区。默认使用前缓冲区（当前显示内容）
-        crop        - 是否将宽高裁切为16的倍数
-        """
-        
-        if alpha:
-            gl_mode = GL_RGBA
-            pil_mode = 'RGBA'
-        else:
-            gl_mode = GL_RGB
-            pil_mode = 'RGB'
-        
-        if buffer.upper() == 'FRONT':
-            glReadBuffer(GL_FRONT)
-        else:
-            glReadBuffer(GL_BACK)
-        
-        data = glReadPixels(0, 0, self.csize[0], self.csize[1], gl_mode, GL_UNSIGNED_BYTE, outputType=None)
-        im = Image.fromarray(data.reshape(data.shape[1], data.shape[0], -1), mode=pil_mode)
-        im = im.transpose(Image.FLIP_TOP_BOTTOM)
-        
-        if crop:
-            w, h = im.size
-            nw, nh = 16*(w//16), 16*(h//16)
-            x0, y0 = (w-nw)//2, (h-nh)//2
-            x1, y1 = x0+nw, y0+nh
-            im = im.crop((x0, y0, x1, y1))
-        
-        return im
-    
-    def _create_gif_or_video(self, out_file, fps, loop):
-        """生成gif或视频文件的线程函数"""
-        
-        if os.path.splitext(out_file)[1] == '.gif':
-            writer = imageio.get_writer(out_file, fps=fps, loop=loop)
-        else:
-            writer = imageio.get_writer(out_file, fps=fps)
-        
-        while True:
-            if self.q.empty():
-                if not self.capturing:
-                    break
-                else:
-                    time.sleep(0.1)
-            else:
-                im = np.array(self.q.get())
-                writer.append_data(im)
-        
-        writer.close()
-        self.creating = False
-    
-    def _render_core(self, m, campos, azim, elev):
-        """模型渲染核函数"""
-        
-        if not m.visible or m.slide and not m.slide(self.duration):
-            return
-        
-        glUseProgram(m.program)
-        tsid = 0
-        
-        for key in m.attribute:
-            loc = m.attribute[key].get('loc')
-            bo = m.attribute[key]['bo']
-            un = m.attribute[key]['un']
-            usize = m.attribute[key]['usize']
-            bo.bind()
-            glVertexAttribPointer(loc, un, GL_FLOAT, GL_FALSE, un*usize, bo)
-            glEnableVertexAttribArray(loc)
-            bo.unbind()
-        
-        for key in m.uniform:
-            tag = m.uniform[key]['tag']
-            loc = m.uniform[key].get('loc')
-            
-            if tag == 'pmat' or tag == 'vmat':
-                if 'v' in m.uniform[key]:
-                    glUniformMatrix4fv(loc, 1, GL_FALSE, m.uniform[key]['v'], None)
-                else:
-                    glUniformMatrix4fv(loc, 1, GL_FALSE, m.uniform[key]['f'](self.duration), None)
-            elif tag == 'mmat':
-                if 'v' in m.uniform[key]:
-                    glUniformMatrix4fv(loc, 1, GL_FALSE, m.uniform[key]['v'], None)
-                else:
-                    args = m.uniform[key]['f'](self.duration)
-                    mmat = util.model_matrix(*args)
-                    glUniformMatrix4fv(loc, 1, GL_FALSE, mmat, None)
-            elif tag == 'texture':
-                eval('glActiveTexture(GL_TEXTURE%d)'%tsid)
-                glBindTexture(m.uniform[key]['data'].ttype, m.uniform[key]['tid'])
-                glUniform1i(loc, tsid)
-                tsid += 1
-            elif tag == 'picked':
-                glUniform1i(loc, m.picked)
-            elif tag == 'campos':
-                glUniform3f(loc, *campos)
-            elif tag == 'ae':
-                glUniform2f(loc, azim, elev)
-            else:
-                value = m.uniform[key].get('v')
-                if value is None:
-                    value = m.uniform[key].get('f')(self.duration)
-                
-                dtype = m.uniform[key]['dtype']
-                ndim = m.uniform[key]['ndim']
-                if ndim is None:
-                    try:
-                        eval('glUniform%s(loc, value)'%dtype)
-                    except:
-                        print('渲染函数出现异常，请通知xufive@gmail.com，如可能的话，请提供shader源码。')
-                else:
-                    eval('glUniform%s(loc, ndim, value)'%dtype)
-
-        for glcmd, args in m.before:
-            glcmd(*args)
-        
-        if m.indices:
-            m.indices['ibo'].bind()
-            glDrawElements(m.gltype, m.indices['n'], GL_UNSIGNED_INT, None)
-            m.indices['ibo'].unbind()
-        else:
-            glDrawArrays(m.gltype, 0, m.vshape[0])
-        
-        for glcmd, args in m.after:
-            glcmd(*args)
-        
-        glUseProgram(0)
-    
-    def _render_pick(self, x, y):
-        """拾取渲染"""
-        
-        for reg in self.regions:
-            if reg.fixed:
-                continue
-            
-            glViewport(*reg.pos, *reg.size)
-            
-            if reg.cam_cruise:
-                v = reg.cam_cruise(self.duration)
-                reg._update_cam_and_up(azim=v.get('azim'), elev=v.get('elev'), dist=v.get('dist'))
-            
-            name_hit, depth_hit, idx_hit = None, 1, 0
-            
-            for i in (0, 1):
-                for name, idx, zmean in reg.mnames[i]:
-                    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
-                    self._render_core(reg.models[name][idx], reg.cam, reg.azim, reg.elev)
-                    
-                    d = glReadPixels(x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, outputType=None)[0,0]
-                    if d < depth_hit:
-                        name_hit, depth_hit, idx_hit = name, d, idx
-            
-            if name_hit:
-                for m in reg.models[name_hit]:
-                    m.picked = not m.picked
-                
-                if reg.models[name_hit][idx_hit].picked:
-                    self.selected.append((reg, name_hit))
-                else:
-                    self.selected.remove((reg, name_hit))
-                
-                break
-        
-        self.render()
-    
-    def render(self):
-        """模型渲染"""
-        
-        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT) # 清除屏幕及深度缓存
-        
-        for reg in self.regions:
-            glViewport(*reg.pos, *reg.size) # 设置视口
-            
-            if reg.cam_cruise:
-                v = reg.cam_cruise(self.duration)
-                reg._update_cam_and_up(azim=v.get('azim'), elev=v.get('elev'), dist=v.get('dist'))
-            
-            for name, idx, zmean in reg.mnames[0]:
-                self._render_core(reg.models[name][idx], reg.cam, reg.azim, reg.elev)
-            
-            glDepthMask(False) # 对于半透明模型，禁用深度缓冲（锁定）
-            if reg.up[1] > 0 and -90 <= reg.azim < 90 or reg.up[1] < 0 and (reg.azim < -90 or reg.azim >= 90):
-                for name, idx, zmean in reg.mnames[1]:
-                    self._render_core(reg.models[name][idx], reg.cam, reg.azim, reg.elev)
-            else:
-                for name, idx, zmean in reg.mnames[1][::-1]:
-                    self._render_core(reg.models[name][idx], reg.cam, reg.azim, reg.elev)
-            glDepthMask(True) # 释放深度缓冲区
-        
-        self.SwapBuffers() # 切换缓冲区，以显示绘制内容
-        
-        if self.capturing:
-            if self.cn < self.fn:
-                im = self._get_scene_buffer(alpha=True, crop=True)
-                self.q.put(im)
-                self.cn += 1
-            else:
-                self.stop_record()
-    
-    def start_animate(self):
-        """开始动画"""
-        
-        self.render()
-        if self.islive:
-            self.tstamp = time.time()
-            self.tbase = self.duration
-            self.playing = True
-            self._render_on_timer()
-    
-    def stop_animate(self):
-        """停止动画"""
-        
-        self.playing = False
-    
-    def pause_animate(self):
-        """暂停/重启动画"""
-        
-        if self.playing:
-            self.stop_animate()
-        else:
-            self.start_animate()
-    
-    def estimate(self):
-        """动画渲染帧频评估"""
-        
-        return 0 if self.duration == 0 else 1000*self.tn/self.duration
-    
-    def set_style(self, style):
-        """设置风格"""
-        
-        self.style = self._set_style(style)
-        self._init_gl()
-        self.render()
-    
-    def restore_posture(self):
-        """还原场景内各视区的相机初始姿态"""
-        
-        for reg in self.regions:
-            reg.restore_posture()
-        
-        self._reset_timer()
-        self.render()
-        
-    def save_scene(self, fn, alpha=True, buffer='front', crop=False):
-        """保存场景为图像文件
-        
-        fn          - 保存的文件名
-        alpha       - 是否使用透明通道
-        buffer      - 显示缓冲区。默认使用前缓冲区（当前显示内容）
-        crop        - 是否将宽高裁切为16的倍数
-        """
-        
-        im = self._get_scene_buffer(alpha=alpha, buffer=buffer, crop=crop)
-        im.save(fn)
-    
-    def start_record(self, out_file, fps, fn, loop):
-        """开始生成gif或视频文件
-        
-        out_file    - 文件名，支持gif和mp4、avi、wmv等格式
-        fps         - 每秒帧数
-        fn          - 总帧数
-        loop        - 循环播放次数（仅gif格式有效，0表示无限循环）
-        """
-        
-        self.cn = 0
-        self.fn = fn
-        self.ft = round(1000/fps)
-        self.q = queue.Queue()
-        self.capturing = True
-        self.creating = True
-        self.start_animate()
-        
-        self.threading_record = threading.Thread(target=self._create_gif_or_video, args=(out_file, fps, loop))
-        self.threading_record.setDaemon(True)
-        self.threading_record.start()
-    
-    def stop_record(self):
-        """停止生成gif或视频文件"""
-        
-        self.cn = 0
-        self.capturing = False
-        self.stop_animate()
-    
-    def add_region(self, box, **kwds):
-        """添加视区
-        
-        box         - 视区位置四元组：四个元素分别表示视区左下角坐标、宽度、高度，元素值域[0,1]
-        kwds        - 关键字参数
-            proj        - 投影模式：'O' - 正射投影，'P' - 透视投影（默认）
-            fixed       - 锁定模式：固定ECS原点、相机位置和角度，以及视口缩放因子等。布尔型，默认False
-            azim        - 方位角：-180°~180°范围内的浮点数，默认0°
-            elev        - 高度角：-180°~180°范围内的浮点数，默认0°
-            azim_range  - 方位角限位器：默认-180°~180°
-            elev_range  - 仰角限位器：默认-180°~180°
-            zoom        - 视口缩放因子：默认1.0
-            name        - 视区名
-        """
-        
-        reg = region.Region(self, box, **kwds)
-        self.regions.append(reg)
-        
-        return reg
+#!/usr/bin/env python3
+
+import time
+import numpy as np
+from PIL import Image
+from OpenGL.GL import *
+from OpenGL.arrays import vbo
+from OpenGL.GL import shaders
+from . import util
+
+class BaseScene:
+    """场景基类"""
+
+    _DIST = 6.0
+    _NEAR = 3.0
+    _FAR = 1000.0
+
+    def __init__(self, scheme, **kwds):
+        """构造函数"""
+        
+        self.scheme = scheme                                            # 展示方案
+        self.viewport = [None, None, None]                              # 主视区、标题区、调色板区视口
+        self.mns = [[[],[]], [[],[]], [[],[]]]                          # 主视区、标题区、调色板区不透明/透明模型名列表
+        self.selected = list()                                          # 选中的模型
+
+        self.csize = kwds.get('size', (960, 640))                       # 画布分辨率
+        self.bg = util.format_color(kwds.get('bg', [0.0, 0.0, 0.0]))    # 背景色
+        self.haxis = kwds.get('haxis', 'y').lower()                     # 高度轴
+        self.fovy = kwds.get('fovy', 50.0)                              # 相机水平视野角度
+        self.azim = kwds.get('azim', 0.0)                               # 方位角
+        self.elev = kwds.get('elev', 0.0)                               # 高度角
+        self.azim_range = kwds.get('azim_range', (-180.0, 180.0))       # 方位角变化范围
+        self.elev_range = kwds.get('elev_range', (-180.0, 180.0))       # 高度角变化范围
+        self.smooth = kwds.get('smooth', True)                          # 直线和点的反走样开关
+
+        self.oecs = [0.0, 0.0, 0.0]                                     # 视点坐标系ECS原点
+        self.dist = self._DIST                                          # 相机ECS原点的距离
+        self.near = self._NEAR                                          # 相机与视椎体前端面的距离
+        self.far = self._FAR                                            # 相机与视椎体后端面的距离
+        self.aspect = self.csize[0]/self.csize[1]                       # 画布宽高比
+        self.cam = None                                                 # 相机位置
+        self.up = None                                                  # 指向相机上方的单位向量
+        self.origin = None                                              # 初始位置和姿态
+        self.mmat = np.eye(4, dtype=np.float32)                         # 模型矩阵
+        self.vmat = np.eye(4, dtype=np.float32)                         # 视点矩阵
+        self.pmat = np.eye(4, dtype=np.float32)                         # 投影矩阵
+
+        self.gl_init_done = False                                       # GL初始化标志
+        self.painted = False                                            # 期望的重绘已完成 
+        self.left_down = False                                          # 左键按下
+        self.ctrl_down = False                                          # Ctr键按下
+        self.mouse_pos = None                                           # 鼠标位置
+        self.scale = 1.0                                                # 眼睛位置自适应调整系数
+
+        self.im_pil = None                                              # 缓冲区图像数据
+        self.increment = True                                           # 计时器自动增量
+        self.start= 1000 * time.time()                                  # 开始渲染时的时间戳
+        self.duration = 0                                               # 累计渲染时长，单位毫秒
+        self.tbase = 0                                                  # 累计渲染时长基数，单位毫秒
+        self.playing = False                                            # 动画播放中
+
+        self._update_cam_and_up()                                       # 更新眼睛位置和指向观察者上方的单位向量
+        self._update_view_matrix()                                      # 更新视点矩阵
+        self._update_proj_matrix()                                      # 更新投影矩阵
+
+    def _update_cam_and_up(self, oecs=None, dist=None, azim=None, elev=None):
+        """根据当前ECS原点位置、距离、方位角、仰角等参数，重新计算眼睛位置和up向量"""
+
+        if not oecs is None:
+            self.oecs = [*oecs,]
+ 
+        if not dist is None:
+            self.dist = dist
+ 
+        if not azim is None:
+            azim = (azim+180)%360 - 180
+            if azim < self.azim_range[0]:
+                self.azim = self.azim_range[0]
+            elif azim > self.azim_range[1]:
+                self.azim = self.azim_range[1]
+            else:
+                self.azim = azim
+ 
+        if not elev is None:
+            elev = (elev+180)%360 - 180
+            if elev < self.elev_range[0]:
+                self.elev = self.elev_range[0]
+            elif elev > self.elev_range[1]:
+                self.elev = self.elev_range[1]
+            else:
+                self.elev = elev
+ 
+        up = 1.0 if -90 <= self.elev <= 90 else -1.0
+        azim, elev  = np.radians(self.azim), np.radians(self.elev)
+        d = self.dist * np.cos(elev)
+
+        if self.haxis == 'z':
+            azim -= 0.5 * np.pi
+            self.cam = [d*np.cos(azim)+self.oecs[0], d*np.sin(azim)+self.oecs[1], self.dist*np.sin(elev)+self.oecs[2]]
+            self.up = [0.0, 0.0, up]
+        else:
+            self.cam = [d*np.sin(azim)+self.oecs[0], self.dist*np.sin(elev)+self.oecs[1], d*np.cos(azim)+self.oecs[2]]
+            self.up = [0.0, up, 0.0]
+
+    def _update_proj_matrix(self):
+        """更新投影矩阵"""
+ 
+        self.pmat[:] = util.proj_matrix(self.fovy, self.aspect, self.near, self.far)
+
+    def _update_view_matrix(self):
+        """更新视点矩阵"""
+ 
+        self.vmat[:] = util.view_matrix(self.cam, self.up, self.oecs)
+
+    def _capture(self, mode='RGBA', crop=False, buffer='front', qt=None):
+        """捕捉缓冲区数据
+ 
+        mode        - 'RGB'或'RGBA'
+        crop        - 是否将宽高裁切为16的倍数
+        buffer      - 'front'（前缓冲区）或'back'（后缓冲区）
+        qt          - 使用Qt作为后端的偏移量
+        """
+
+        self.im_pil = self._get_buffer(mode=mode, crop=crop, buffer=buffer, qt=qt)
+
+    def _get_buffer(self, mode='RGBA', crop=False, buffer='front', qt=None):
+        """以PIL对象的格式返回场景缓冲区数据
+ 
+        mode        - 'RGB'或'RGBA'
+        crop        - 是否将宽高裁切为16的倍数
+        buffer      - 'front'（前缓冲区）或'back'（后缓冲区）
+        qt          - 使用Qt作为后端的偏移量
+        """
+
+        gl_mode = GL_RGBA if mode=='RGBA' else GL_RGB
+        glReadBuffer(GL_FRONT if buffer=='front' else GL_BACK)
+        data = glReadPixels(0, 0, self.csize[0], self.csize[1], gl_mode, GL_UNSIGNED_BYTE, outputType=None)
+        data = data.reshape(data.shape[1], data.shape[0], -1)
+        im = Image.fromarray(data[qt[0]:, qt[1]:] if qt else data, mode=mode)
+        im = im.transpose(Image.FLIP_TOP_BOTTOM)
+ 
+        if crop:
+            w, h = im.size
+            nw, nh = 16*(w//16), 16*(h//16)
+            x0, y0 = (w-nw)//2, (h-nh)//2
+            x1, y1 = x0+nw, y0+nh
+            im = im.crop((x0, y0, x1, y1))
+ 
+        return im
+
+    def _resize(self):
+        """改变窗口"""
+ 
+        if not self.scheme.models[1] and not self.scheme.models[2]:
+            self.viewport[0] = (0, 0, *self.csize)
+        elif self.scheme.models[1] and not self.scheme.models[2]:
+            self.viewport[1] = (0, int(self.csize[1]*0.85), self.csize[0], int(self.csize[1]*0.15))
+            self.viewport[0] = (0, 0, self.csize[0], int(self.csize[1]*0.85))
+        elif not self.scheme.models[1] and self.scheme.models[2]:
+            self.viewport[2] = (int(self.csize[0]*0.85), 0, int(self.csize[0]*0.15), self.csize[1])
+            self.viewport[0] = (0, 0, int(self.csize[0]*0.85), self.csize[1])
+        else:
+            self.viewport[1] = (0, int(self.csize[1]*0.85), self.csize[0], int(self.csize[1]*0.15))
+            self.viewport[2] = (int(self.csize[0]*0.85), 0, int(self.csize[0]*0.15), int(self.csize[1]*0.85))
+            self.viewport[0] = (0, 0, int(self.csize[0]*0.85), int(self.csize[1]*0.85))
+
+        if self.viewport[0][2] == 0:
+            self.aspect = 1e-5
+        elif self.viewport[0][3] == 0:
+            self.aspect = self.viewport[0][2]
+        else:
+            self.aspect = self.viewport[0][2]/self.viewport[0][3]
+
+        self._update_proj_matrix()
+
+    def _paint(self):
+        """绘制函数"""
+ 
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # 清除屏幕及深度缓存
+
+        if self.scheme.alive and self.playing:
+            if self.increment:
+                self.duration = self.tbase + 1000*time.time() - self.start
+
+            if self.scheme.cruise_func:
+                v = self.scheme.cruise_func(self.duration)
+                self._update_cam_and_up(azim=v.get('azim'), elev=v.get('elev'), dist=v.get('dist'))
+                self._update_view_matrix()
+
+        for i in range(3):
+            if self.scheme.models[i]:
+                glViewport(*self.viewport[i])
+                for mid, depth in self.mns[i][0]:
+                    self._render(self.scheme.models[i][mid])
+
+                glDepthMask(False) # 对于半透明模型，禁用深度缓冲（锁定）
+                if (self.up[1]+self.up[2]) > 0 and -90 <= self.azim < 90 or (self.up[1]+self.up[2]) < 0 and (self.azim < -90 or self.azim >= 90):
+                    for mid, depth in self.mns[i][1]:
+                        self._render(self.scheme.models[i][mid])
+                else:
+                    for mid, depth in self.mns[i][1][::-1]:
+                        self._render(self.scheme.models[i][mid])
+                glDepthMask(True) # 释放深度缓冲区
+
+    def _pick(self, x, y):
+        """拾取渲染"""
+
+        glViewport(*self.viewport[0])
+        mid_hit, depth_hit = None, 1
+
+        for i in (0,1):
+            for mid, depth in self.mns[0][i]:
+                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # 清除屏幕及深度缓存
+
+                m = self.scheme.models[0][mid]
+                self._render(m)
+                
+                d = glReadPixels(x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, None)[0,0]
+                if d < depth_hit:
+                    mid_hit, depth_hit = mid, d
+            
+        if mid_hit:
+            name = self.scheme.models[0][mid_hit].name
+            for mid in self.scheme.widgets[name]:
+                m = self.scheme.models[0][mid]
+                m.picked = not m.picked
+
+                if m.picked:
+                    self.selected.append(mid)
+                else:
+                    self.selected.remove(mid)
+
+    def _initialize_gl(self):
+        """GL初始化函数"""
+ 
+        glClearColor(*self.bg, 1.0)                                         # 设置画布背景色
+        glEnable(GL_DEPTH_TEST)                                             # 开启深度测试，实现遮挡关系        
+        glDepthFunc(GL_LEQUAL)                                              # 设置深度测试函数
+        glShadeModel(GL_SMOOTH)                                             # GL_SMOOTH(光滑着色)/GL_FLAT(恒定着色)
+        glEnable(GL_BLEND)                                                  # 开启混合        
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)                   # 设置混合函数
+        glEnable(GL_ALPHA_TEST)                                             # 启用Alpha测试 
+        glAlphaFunc(GL_GREATER, 0.05)                                       # 设置Alpha测试条件为大于0.05则通过
+        
+        if self.smooth:
+            glEnable(GL_POINT_SMOOTH)                                       # 开启点反走样
+            glHint(GL_POINT_SMOOTH_HINT, GL_NICEST)                         # 最高质量点反走样
+            glEnable(GL_LINE_SMOOTH)                                        # 开启直线反走样
+            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)                          # 最高质量直线反走样
+
+    def _timer(self):
+        """定时函数"""
+
+        if self.scheme.alive and self.playing:
+            if self.increment:
+                self.duration = self.tbase + 1000*time.time() - self.start
+
+            if self.scheme.cruise_func:
+                v = self.scheme.cruise_func(self.duration)
+                self._update_cam_and_up(azim=v.get('azim'), elev=v.get('elev'), dist=v.get('dist'))
+                self._update_view_matrix()
+
+    def _home(self):
+        """恢复初始位置和姿态"""
+
+        if self.origin:
+            self.fovy = self.origin['fovy']
+            self._update_cam_and_up(
+                dist = self.origin['dist'], 
+                azim = self.origin['azim'], 
+                elev = self.origin['elev'], 
+                oecs = self.origin['oecs']
+            )
+
+        self._update_view_matrix()
+        self._update_proj_matrix()
+
+        self.tn = 0
+        self.start= 1000 * time.time()
+        self.duration = 0
+        self.tbase = 0
+
+        while self.selected:
+            mid = self.selected.pop()
+            self.scheme.models[0][mid].picked = False
+
+    def _pause(self):
+        """动画/暂停"""
+
+        if self.playing:
+            self.playing = False
+            self.tbase = self.duration
+        else:
+            self.start = 1000 * time.time()
+            self.playing = True
+
+    def _drag(self, dx, dy):
+        """鼠标拖拽"""
+
+        if self.ctrl_down:
+            if self.haxis == 'z':
+                oecs = [self.oecs[0]-dx/(self.csize[0]*self.scale), self.oecs[1], self.oecs[2]+dy/(self.csize[1]*self.scale)]
+            else:
+                oecs = [self.oecs[0]-dx/(self.csize[0]*self.scale), self.oecs[1]+dy/(self.csize[1]*self.scale), self.oecs[2]]
+            self._update_cam_and_up(oecs=oecs)
+        else:
+            azim = self.azim - (180*dx/self.csize[0]) * (self.up[2] if self.haxis == 'z' else self.up[1])
+            elev = self.elev + 90*dy/self.csize[1]
+            self._update_cam_and_up(azim=azim, elev=elev)
+        
+        self._update_view_matrix()
+
+    def _wheel(self, delta):
+        """鼠标滚轮，前滚时delta为正值"""
+        
+        if self.ctrl_down:
+            dist = self.dist * 0.99 if delta > 0 else self.dist * 1.01
+            self._update_cam_and_up(dist=dist)
+            self._update_view_matrix()
+        else:
+            if delta > 0: # 滚轮前滚
+                self.fovy *= 0.95
+            else: # 滚轮后滚
+                self.fovy += (180 - self.fovy) / 180
+            self._update_proj_matrix()
+
+    def _assemble(self):
+        """模型装配"""
+
+        if self.scheme.expost:
+            if 'grid' in self.scheme.expost:
+                self.scheme._grid()
+            if 'axes' in self.scheme.expost:
+                self.scheme._axes()
+
+        for i in range(3):
+            for mid in self.scheme.models[i]:
+                m = self.scheme.models[i][mid]
+
+                if i == 1 and mid == 'caption_text':
+                    m.attribute['a_Position']['data'][:,0] /= self.viewport[i][2]/self.viewport[i][3]
+
+                if i == 2 and mid == 'cb_label':
+                    m.attribute['a_Position']['data'][:,0] /= self.viewport[i][2]/self.viewport[i][3]
+
+                for src, genre in m.shaders:
+                    m.cshaders.append(shaders.compileShader(src, genre))
+ 
+                m.program = shaders.compileProgram(*m.cshaders)
+                glUseProgram(m.program)
+
+                if m.indices:
+                    m.indices.update({'ibo':vbo.VBO(m.indices['data'], target=GL_ELEMENT_ARRAY_BUFFER)})
+
+                for key in m.attribute:
+                    item = m.attribute[key]
+                    item.update({'bo': vbo.VBO(item['data'])})
+ 
+                    if 'loc' not in item:
+                        item.update({'loc': glGetAttribLocation(m.program, key)})
+ 
+                for key in m.uniform:
+                    item = m.uniform[key]
+                    if item['tag'] == 'texture':
+                        if item['data'].tid is None:
+                            item['data'].create_texture()
+                        item.update({'tid': item['data'].tid})
+                    elif item['tag'] == 'pmat':
+                        if 'v' not in item and 'f' not in item:
+                            item.update({'v': self.pmat})
+                    elif item['tag'] == 'vmat':
+                        if 'v' not in item and 'f' not in item:
+                            item.update({'v': self.vmat})
+                    elif item['tag'] == 'mmat':
+                        if 'v' not in item and 'f' not in item:
+                            item.update({'v': self.mmat})
+                        elif 'v' in item:
+                            item.update({'v': util.model_matrix(*item['v'])})
+ 
+                    if 'loc' not in item:
+                        item.update({'loc': glGetUniformLocation(m.program, key)})
+ 
+                glUseProgram(0)
+
+                if m.opacity:
+                    self.mns[i][0].append((mid, m.depth[self.haxis]))
+                else:
+                    self.mns[i][1].append((mid, m.depth[self.haxis]))
+            
+            self.mns[i][1].sort(key=lambda item:item[1])
+
+        dx = self.scheme.r_x[1]-self.scheme.r_x[0]
+        dy = self.scheme.r_y[1]-self.scheme.r_y[0]
+        dz = self.scheme.r_z[1]-self.scheme.r_z[0]
+
+        if self.haxis == 'z':
+            if dx > 0 and dz > 0:
+                if self.aspect > dx/dz:
+                    self.scale = 2/dz if self.aspect > 1 else 2/(self.aspect*dz)
+                else:
+                    self.scale = 2*self.aspect/dx if self.aspect > 1 else 2/dx
+            elif dx > 0 and dz <= 0:
+                self.scale = 2*self.aspect/dx if self.aspect > 1 else 2/dx
+            elif dx <= 0 and dz > 0:
+                self.scale = 2/dz if self.aspect > 1 else 2/(self.aspect*dz)
+
+            if self.scale * dy > 4:
+                self.scale = 4/dy
+        else:
+            if dx > 0 and dy > 0:
+                if self.aspect > dx/dy:
+                    self.scale = 2/dy if self.aspect > 1 else 2/(self.aspect*dy)
+                else:
+                    self.scale = 2*self.aspect/dx if self.aspect > 1 else 2/dx
+            elif dx > 0 and dy <= 0:
+                self.scale = 2*self.aspect/dx if self.aspect > 1 else 2/dx
+            elif dx <= 0 and dy > 0:
+                self.scale = 2/dy if self.aspect > 1 else 2/(self.aspect*dy)
+ 
+            if self.scale * dz > 4:
+                self.scale = 4/dz
+
+        self.playing = self.scheme.alive
+        self.dist = self._DIST/self.scale
+        self.near = self._NEAR/self.scale
+        self.far = self._FAR/self.scale
+        self.oecs = [sum(self.scheme.r_x)/2, sum(self.scheme.r_y)/2, sum(self.scheme.r_z)/2]
+        self.origin = {'fovy':self.fovy, 'azim':self.azim, 'elev':self.elev, 'dist':self.dist, 'oecs':self.oecs}
+
+        self._update_cam_and_up()
+        self._update_view_matrix()
+        self._update_proj_matrix()
+        
+        self.start= 1000 * time.time()
+        self.duration = 0
+        self.tbase = 0
+        
+        self.gl_init_done = True
+
+    def _render(self, m):
+        """绘制单个模型"""
+
+        if not m.visible or m.slide and not m.slide(self.duration):
+            return
+ 
+        glUseProgram(m.program)
+        tsid = 0
+ 
+        for key in m.attribute:
+            loc = m.attribute[key].get('loc')
+            bo = m.attribute[key]['bo']
+            un = m.attribute[key]['un']
+            usize = m.attribute[key]['usize']
+            bo.bind()
+            glVertexAttribPointer(loc, un, GL_FLOAT, GL_FALSE, un*usize, bo)
+            glEnableVertexAttribArray(loc)
+            bo.unbind()
+ 
+        for key in m.uniform:
+            tag = m.uniform[key]['tag']
+            loc = m.uniform[key].get('loc')
+ 
+            if tag == 'pmat' or tag == 'vmat':
+                if 'v' in m.uniform[key]:
+                    glUniformMatrix4fv(loc, 1, GL_FALSE, m.uniform[key]['v'], None)
+                else:
+                    glUniformMatrix4fv(loc, 1, GL_FALSE, m.uniform[key]['f'](self.duration), None)
+            elif tag == 'mmat':
+                if 'v' in m.uniform[key]:
+                    glUniformMatrix4fv(loc, 1, GL_FALSE, m.uniform[key]['v'], None)
+                else:
+                    args = m.uniform[key]['f'](self.duration)
+                    mmat = util.model_matrix(*args)
+                    glUniformMatrix4fv(loc, 1, GL_FALSE, mmat, None)
+            elif tag == 'texture':
+                eval('glActiveTexture(GL_TEXTURE%d)'%tsid)
+                glBindTexture(m.uniform[key]['data'].ttype, m.uniform[key]['tid'])
+                glUniform1i(loc, tsid)
+                tsid += 1
+            elif tag == 'picked':
+                glUniform1i(loc, m.picked)
+            elif tag == 'timestamp':
+                glUniform1f(loc, self.duration)
+            elif tag == 'campos':
+                glUniform3f(loc, *self.cam)
+            elif tag == 'ae':
+                glUniform2f(loc, self.azim, self.elev)
+            elif tag == 'tsize':
+                k = 0.3/(32*self.scale)
+                tw, th = m.uniform[key].get('v')
+                glUniform2f(loc, tw*k/self.aspect, th*k)
+            else:
+                value = m.uniform[key].get('v')
+                if value is None:
+                    value = m.uniform[key].get('f')(self.duration)
+                
+                dtype = m.uniform[key]['dtype']
+                ndim = m.uniform[key]['ndim']
+                if ndim is None:
+                    try:
+                        eval('glUniform%s(loc, value)'%dtype)
+                    except:
+                        print('渲染函数出现异常，请通知xufive@gmail.com，如可能的话，请提供shader源码。')
+                else:
+                    eval('glUniform%s(loc, ndim, value)'%dtype)
+
+        for glcmd, args in m.before:
+            glcmd(*args)
+ 
+        if m.indices:
+            m.indices['ibo'].bind()
+            glDrawElements(m.gltype, m.indices['n'], GL_UNSIGNED_INT, None)
+            m.indices['ibo'].unbind()
+        else:
+            glDrawArrays(m.gltype, 0, m.vshape[0])
+ 
+        for glcmd, args in m.after:
+            glcmd(*args)
+ 
+        glUseProgram(0)
+
+    def _clear_buffer(self):
+        """删除纹理、顶点缓冲区等显存对象"""
+
+        for i in range(3):
+            for name in self.scheme.models[i]:
+                m = self.scheme.models[i][name]
+                #for item in m.cshaders:
+                #    glDeleteShader(item)
+                
+                if m.program:
+                    glDeleteProgram(m.program)
+                
+                if m.indices and 'ibo' in m.indices:
+                    m.indices['ibo'].delete()
+                
+                for key in m.attribute:
+                    if 'bo' in m.attribute[key]:
+                        m.attribute[key]['bo'].delete()
+                
+                textures = list()
+                for key in m.uniform:
+                    if 'texture' in m.uniform[key]:
+                        textures.append(m.attribute[key]['texture'])
+                if textures:
+                    glDeleteTextures(len(textures), textures)
+
+    def _set_visible(self, name, visible):
+        """设置部件或模型的可见性
+
+        name        - 部件名或模型id
+        visible     - bool型
+        """
+
+        if name in self.scheme.widgets:
+            for mid in self.scheme.widgets[name]:
+                self.scheme.models[0][mid].visible = visible
+        elif name in self.scheme.models[0]:
+            self.scheme.models[0][name].visible = visible
+
```

## wxgl/text.py

```diff
@@ -1,189 +1,206 @@
-# -*- coding: utf-8 -*-
-
-import re
-from io import BytesIO
-import freetype
-from PIL import Image
-import numpy as np
-import matplotlib.font_manager as mfm
-from matplotlib import mathtext
-
-class FontManager:
-    """字体管理"""
-    
-    def __init__(self):
-        self.fonts = dict()
-        for item in mfm.fontManager.ttflist:
-            if item.name in self.fonts:
-                self.fonts[item.name].append(item)
-            else:
-                self.fonts.update({item.name: [item]})
-        
-        # 设置默认字体
-        if 'Microsoft YaHei' in self.fonts:
-            self.default_font = 'Microsoft YaHei' # 微软雅黑
-        elif 'STSong' in self.fonts:
-            self.default_font = 'STSong' # 宋体
-        elif 'FangSong' in self.fonts:
-            self.default_font = 'FangSong' # 仿宋
-        else:
-            self.default_font = mfm.ttfFontProperty(mfm.get_font(mfm.findfont(''))).name # matplotlib默认字体
-    
-    def get_font_list(self):
-        """返回当前系统可用字体列表"""
-        
-        return list(self.fonts.keys())
-    
-    def get_default_font(self):
-        """返回默认字体"""
-        
-        return self.default_font
-    
-    def set_default_font(self, font_name):
-        """设置默认字体"""
-        
-        if font_name in self.fonts:
-            self.default_font = font_name
-        else:
-            raise ValueError('字体%s不在当前系统可用字体列表中'%font_name)
-    
-    def get_font_file(self, family=None, weight='normal'):
-        """返回字体文件"""
-        
-        if weight not in ['light', 'bold', 'normal']:
-            weight = 'normal'
-        
-        if family not in self.fonts:
-            family = self.default_font
-        
-        if len(self.fonts[family]) > 1:
-            for item in self.fonts[family]:
-                if item.weight == weight or item.weight == 400 and weight == 'normal':
-                    return item.fname
-        
-        return self.fonts[family][0].fname
-    
-    def get_text_pixels(self, text, size, font_file):
-        """生成文本像素数据"""
-        
-        face = freetype.Face(font_file)
-        face.set_char_size(size*size)
-        
-        over, under = -1, -1
-        pixels = None
-        
-        for ch in text:
-            face.load_char(ch)
-            btm_obj = face.glyph.bitmap
-            w, h = btm_obj.width, btm_obj.rows
-            data = np.array(btm_obj.buffer, dtype=np.uint8).reshape(h,w)
-            
-            bx, by = int(face.glyph.metrics.horiBearingX/64), int(face.glyph.metrics.horiBearingY/64)
-            ha = int(face.glyph.metrics.horiAdvance/64)
-            sapre = ha - bx - w
-            bottom = h-by
-            
-            if bottom < 0:
-                patch = np.zeros((-bottom, data.shape[1]), dtype=np.uint8)
-                data = np.vstack((data, patch))
-                bottom = 0
-            
-            if bx > 0:
-                patch = np.zeros((data.shape[0], bx), dtype=np.uint8)
-                data = np.hstack((patch, data))
-            if sapre > 0:
-                patch = np.zeros((data.shape[0], sapre), dtype=np.uint8)
-                data = np.hstack((data, patch))
-            
-            if not isinstance(pixels, np.ndarray):
-                pixels = data
-                over, under = by, bottom
-            else:
-                if over > by:
-                    patch = np.zeros((over-by, data.shape[1]), dtype=np.uint8)
-                    data = np.vstack((patch, data))
-                elif over < by:
-                    patch = np.zeros((by-over, pixels.shape[1]), dtype=np.uint8)
-                    pixels = np.vstack((patch, pixels))
-                
-                if under > bottom:
-                    patch = np.zeros((under-bottom, data.shape[1]), dtype=np.uint8)
-                    data = np.vstack((data, patch))
-                elif under < bottom:
-                    patch = np.zeros((bottom-under, pixels.shape[1]), dtype=np.uint8)
-                    pixels = np.vstack((pixels, patch ))
-                
-                pixels = np.hstack((pixels, data))
-                over = max(over, by)
-                under = max(under, bottom)
-        
-        return pixels
-    
-    def text2alpha(self, text, size, family=None, weight='normal'):
-        """文本转透明通道
-        
-        text        - 文本字符串
-        size        - 文字大小，整型
-        family      - （系统支持的）字体
-        weight      - 字体的浓淡：'normal'-正常（默认），'light'-轻，'bold'-重
-        """
-        
-        p = re.compile(r'\$.+\$')
-        if p.search(text):
-            if family not in self.fonts:
-                family = self.default_font
-            
-            bfo = BytesIO()
-            prop = mfm.FontProperties(family=family, size=size, weight=weight)
-            mathtext.math_to_image(text, bfo, prop=prop, dpi=72)
-            
-            im = Image.open(bfo)
-            r, g, b, a = im.split()
-            r, g, b = 255-np.array(r), 255-np.array(g), 255-np.array(b)
-            pixels = np.uint8(r/3 + g/3 + b/3)
-        else:
-            font_file = self.get_font_file(family=family, weight=weight)
-            pixels = self.get_text_pixels(text, size, font_file)
-        
-        return pixels
-    
-    def text2img(self, text, size, color, family=None, weight='normal'):
-        """文本转图像，返回图像数据和size元组
-        
-        text        - 文本字符串
-        size        - 文字大小，整型
-        color       - 文本颜色，numpy数组
-        family      - （系统支持的）字体
-        weight      - 字体的浓淡：'normal'-正常（默认），'light'-轻，'bold'-重
-        """
-        
-        p = re.compile(r'\$.+\$')
-        if p.search(text):
-            if family not in self.fonts:
-                family = self.default_font
-            
-            bfo = BytesIO()
-            prop = mfm.FontProperties(family=family, size=size, weight=weight)
-            mathtext.math_to_image(text, bfo, prop=prop, dpi=72)
-            
-            im = Image.open(bfo)
-            r, g, b, a = im.split()
-            r, g, b = 255-np.array(r), 255-np.array(g), 255-np.array(b)
-            a = r/3 + g/3 + b/3
-            
-            r, g, b = r*color[0], g*color[1], b*color[2]
-            im = np.dstack((r,g,b,a)).astype(np.uint8)
-        else:
-            font_file = self.get_font_file(family=family, weight=weight)
-            pixels = self.get_text_pixels(text, size, font_file)
-            rows, cols = pixels.shape
-            
-            if rows == 0:
-                pixels = np.zeros((1, cols))
-            
-            r = np.ones(pixels.shape)*color[0]*255
-            g = np.ones(pixels.shape)*color[1]*255
-            b = np.ones(pixels.shape)*color[2]*255
-            im = np.dstack((r,g,b,pixels)).astype(np.uint8)
-        
-        return im
+# -*- coding: utf-8 -*-
+
+import re
+from io import BytesIO
+import freetype
+from PIL import Image
+import numpy as np
+import matplotlib.font_manager as mfm
+from matplotlib import mathtext
+
+class FontManager:
+    """字体管理"""
+ 
+    def __init__(self):
+        self.fonts = dict()
+        for item in mfm.fontManager.ttflist:
+            if item.name in self.fonts:
+                self.fonts[item.name].append(item)
+            else:
+                self.fonts.update({item.name: [item]})
+ 
+        # 设置默认字体
+        for item in ('Microsoft YaHei', 'STSong', 'FangSong', 'Songti SC'):
+            if item in self.fonts:
+                self.default_font = item
+                break
+        else:
+            for item in self.fonts:
+                if 'Song' in item or 'Hei' in item:
+                    self.default_font = item
+                    break
+            else:
+                self.default_font = 'DejaVu Sans'
+ 
+    def get_font_list(self):
+        """返回当前系统可用字体列表"""
+ 
+        return list(self.fonts.keys())
+ 
+    def get_default_font(self):
+        """返回默认字体"""
+ 
+        return self.default_font
+ 
+    def set_default_font(self, font_name):
+        """设置默认字体"""
+ 
+        if font_name in self.fonts:
+            self.default_font = font_name
+        else:
+            raise ValueError('字体%s不在当前系统可用字体列表中'%font_name)
+ 
+    def get_font_file(self, family=None, weight='normal'):
+        """返回字体文件"""
+ 
+        if weight not in ['light', 'bold', 'normal']:
+            weight = 'normal'
+ 
+        if family not in self.fonts:
+            family = self.default_font
+ 
+        if len(self.fonts[family]) > 1:
+            for item in self.fonts[family]:
+                if item.weight == weight or item.weight == 400 and weight == 'normal':
+                    return item.fname
+ 
+        return self.fonts[family][0].fname
+ 
+    def get_text_pixels(self, text, size, font_file):
+        """生成文本像素数据"""
+ 
+        face = freetype.Face(font_file)
+        face.set_char_size(size*size)
+ 
+        over, under = -1, -1
+        pixels = None
+ 
+        for ch in text:
+            face.load_char(ch)
+            btm_obj = face.glyph.bitmap
+            w, h = btm_obj.width, btm_obj.rows
+            data = np.array(btm_obj.buffer, dtype=np.uint8).reshape(h,w)
+ 
+            bx, by = int(face.glyph.metrics.horiBearingX/64), int(face.glyph.metrics.horiBearingY/64)
+            ha = int(face.glyph.metrics.horiAdvance/64)
+            sapre = ha - bx - w
+            bottom = h-by
+ 
+            if bottom < 0:
+                patch = np.zeros((-bottom, data.shape[1]), dtype=np.uint8)
+                data = np.vstack((data, patch))
+                bottom = 0
+ 
+            if bx > 0:
+                patch = np.zeros((data.shape[0], bx), dtype=np.uint8)
+                data = np.hstack((patch, data))
+            if sapre > 0:
+                patch = np.zeros((data.shape[0], sapre), dtype=np.uint8)
+                data = np.hstack((data, patch))
+ 
+            if not isinstance(pixels, np.ndarray):
+                pixels = data
+                over, under = by, bottom
+            else:
+                if over > by:
+                    patch = np.zeros((over-by, data.shape[1]), dtype=np.uint8)
+                    data = np.vstack((patch, data))
+                elif over < by:
+                    patch = np.zeros((by-over, pixels.shape[1]), dtype=np.uint8)
+                    pixels = np.vstack((patch, pixels))
+ 
+                if under > bottom:
+                    patch = np.zeros((under-bottom, data.shape[1]), dtype=np.uint8)
+                    data = np.vstack((data, patch))
+                elif under < bottom:
+                    patch = np.zeros((bottom-under, pixels.shape[1]), dtype=np.uint8)
+                    pixels = np.vstack((pixels, patch ))
+ 
+                pixels = np.hstack((pixels, data))
+                over = max(over, by)
+                under = max(under, bottom)
+ 
+        return pixels
+ 
+    def text2alpha(self, text, size, family=None, weight='normal'):
+        """文本转透明通道
+ 
+        text        - 文本字符串
+        size        - 文字大小，整型
+        family      - （系统支持的）字体
+        weight      - 字体的浓淡：'normal'-正常（默认），'light'-轻，'bold'-重
+        """
+ 
+        p = re.compile(r'\$.+\$')
+        if p.search(text):
+            if family not in self.fonts:
+                family = self.default_font
+ 
+            bfo = BytesIO()
+            prop = mfm.FontProperties(family=family, size=size, weight=weight)
+            mathtext.math_to_image(text, bfo, prop=prop, dpi=72)
+ 
+            im = Image.open(bfo)
+            r, g, b, a = im.split()
+            r, g, b = 255-np.array(r), 255-np.array(g), 255-np.array(b)
+            pixels = np.uint8(r/3 + g/3 + b/3)
+        else:
+            font_file = self.get_font_file(family=family, weight=weight)
+            pixels = self.get_text_pixels(text, size, font_file)
+ 
+        return pixels
+ 
+    def text2img(self, text, size, color, bg=None, padding=0, family=None, weight='normal'):
+        """文本转图像，返回图像数据和size元组
+ 
+        text        - 文本字符串
+        size        - 文字大小，整型
+        color       - 文本颜色，numpy数组
+        bg          - 背景色，None表示背景透明
+        padding     - 留白
+        family      - （系统支持的）字体
+        weight      - 字体的浓淡：'normal'-正常（默认），'light'-轻，'bold'-重
+        """
+ 
+        p = re.compile(r'\$.+\$')
+        if p.search(text):
+            if family not in self.fonts:
+                family = self.default_font
+ 
+            bfo = BytesIO()
+            prop = mfm.FontProperties(family=family, size=size, weight=weight)
+            mathtext.math_to_image(text, bfo, prop=prop, dpi=72)
+ 
+            im = Image.open(bfo)
+            r, g, b, a = im.split()
+            r, g, b = 255-np.array(r), 255-np.array(g), 255-np.array(b)
+            a = r/3 + g/3 + b/3
+ 
+            r, g, b = r*color[0], g*color[1], b*color[2]
+            im = np.dstack((r,g,b,a)).astype(np.uint8)
+        else:
+            font_file = self.get_font_file(family=family, weight=weight)
+            pixels = self.get_text_pixels(text, size, font_file)
+            rows, cols = pixels.shape
+ 
+            if rows == 0:
+                pixels = np.zeros((1, cols))
+ 
+            r = np.ones(pixels.shape)*color[0]*255
+            g = np.ones(pixels.shape)*color[1]*255
+            b = np.ones(pixels.shape)*color[2]*255
+            im = np.dstack((r,g,b,pixels)).astype(np.uint8)
+
+        if bg is None:
+            bg = np.array([0, 0, 0, 0], dtype=np.uint8)
+        else:
+            bg = np.array([int(255*bg[0]), int(255*bg[1]), int(255*bg[2]), 255], dtype=np.uint8)
+            im[im[...,3] == 0] = bg
+
+        if padding > 0:
+            ext = np.tile(bg, (im.shape[0], padding, 1))
+            im = np.hstack((ext, im, ext))
+            ext = np.tile(bg, (padding, im.shape[1], 1))
+            im = np.vstack((ext, im, ext))
+ 
+        return im
```

## wxgl/texture.py

```diff
@@ -1,219 +1,213 @@
-# -*- coding: utf-8 -*-
-
-import os
-import numpy as np
-from PIL import Image
-from OpenGL.GL import *
-
-
-class Texture:
-    """WxGL纹理对象"""
-    
-    def __init__(self, tsrc, ttype=GL_TEXTURE_2D, **kwds):
-        """构造函数
-    
-        tsrc            - 图像全路径或者np.array数组
-        ttype           - 纹理类型，默认2D纹理
-        kwds            - 关键字参数
-            level           - 纹理分级数，默认1
-            min_filter      - 纹理缩小滤波器
-                                - GL_NEAREST
-                                - GL_LINEAR
-                                - GL_NEAREST_MIPMAP_NEAREST
-                                - GL_LINEAR_MIPMAP_NEAREST
-                                - GL_NEAREST_MIPMAP_LINEAR
-                                - GL_LINEAR_MIPMAP_LINEAR
-            mag_filter      - 纹理放大滤波器
-                                - GL_NEAREST
-                                - GL_LINEAR
-            s_tile          - S方向纹理铺贴方式，GL_REPEAT|GL_MIRRORED_REPEAT|GL_CLAMP_TO_EDGE
-            t_tile          - T方向纹理铺贴方式，GL_REPEAT|GL_MIRRORED_REPEAT|GL_CLAMP_TO_EDGE
-            r_tile          - R方向纹理铺贴方式，GL_REPEAT|GL_MIRRORED_REPEAT|GL_CLAMP_TO_EDGE
-            xflip           - 图像左右翻转
-            yflip           - 图像上下翻转
-        """
-        
-        if ttype not in (GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D):
-            raise ValueError('不支持的纹理类型')
-        
-        self.ttype = ttype
-        self.tsrc = tsrc
-        self.tid = None
-        
-        self.level = kwds.get('level', 1)
-        self.min_filter = kwds.get('min_filter', GL_LINEAR_MIPMAP_NEAREST)
-        self.mag_filter = kwds.get('mag_filter', GL_LINEAR)
-        self.s_tile = kwds.get('s_tile', GL_REPEAT)
-        self.t_tile = kwds.get('t_tile', GL_REPEAT)
-        self.r_tile = kwds.get('r_tile', GL_REPEAT)
-        self.xflip = kwds.get('xflip', False)
-        self.yflip = kwds.get('yflip', False)
-    
-    def create_texture(self):
-        """创建纹理对象"""
-        
-        if self.ttype == GL_TEXTURE_1D:
-            self.tid = self._create_texture_1d()
-        elif self.ttype == GL_TEXTURE_2D:
-            self.tid = self._create_texture_2d()
-        elif self.ttype == GL_TEXTURE_2D_ARRAY:
-            self.tid = self._create_texture_2d_array()
-        elif self.ttype == GL_TEXTURE_3D:
-            self.tid = self._create_texture_3d()
-    
-    def _create_texture_1d(self):
-        """创建1D纹理对象"""
-        
-        if isinstance(self.tsrc, np.ndarray) and self.tsrc.dtype == np.uint8 and self.tsrc.ndim in (1, 2):
-            im = self.tsrc
-        else:
-            raise ValueError('不支持的纹理资源类型')
-        
-        im_w = im.shape[0]
-        im_mode = GL_LUMINANCE if im.ndim == 1 else (GL_RGB, GL_RGBA)[im.shape[-1]-3]
-        
-        tid = glGenTextures(1)
-        glBindTexture(self.ttype, tid)
-        
-        if im_w%4 == 0:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
-        else:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
-        
-        for i in range(self.level):
-            glTexImage1D(self.ttype, i, GL_RGBA, im_w, 0, im_mode, GL_UNSIGNED_BYTE, im)
-        
-        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
-        
-        glGenerateMipmap(self.ttype)
-        glBindTexture(self.ttype, 0)
-        
-        return tid
-    
-    def _create_texture_2d(self):
-        """创建2D纹理对象"""
-        
-        if isinstance(self.tsrc, str):
-            if os.path.isfile(self.tsrc):
-                im = np.array(Image.open(self.tsrc))
-            else:
-                raise ValueError('纹理资源文件不存在：%s'%self.tsrc)
-        elif isinstance(self.tsrc, np.ndarray) and self.tsrc.dtype == np.uint8 and self.tsrc.ndim in (2, 3):
-            im = self.tsrc
-        else:
-            raise ValueError('不支持的纹理资源类型')
-        
-        im_h, im_w = im.shape[:2]
-        im_mode = GL_LUMINANCE if im.ndim == 2 else (GL_RGB, GL_RGBA)[im.shape[-1]-3]
-        
-        if self.xflip:
-            im = np.fliplr(im)
-        if self.yflip:
-            im = np.flipud(im)
-        
-        tid = glGenTextures(1)
-        glBindTexture(self.ttype, tid)
-        
-        if (im.size/im_h)%4 == 0:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
-        else:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
-        
-        for i in range(self.level):
-            glTexImage2D(self.ttype, i, GL_RGBA, im_w, im_h, 0, im_mode, GL_UNSIGNED_BYTE, im)
-        
-        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_T, self.t_tile)
-        
-        glGenerateMipmap(self.ttype)
-        glBindTexture(self.ttype, 0)
-        
-        return tid
-    
-    def _create_texture_2d_array(self):
-        """创建2D纹理数组对象"""
-        
-        if isinstance(self.tsrc, list):
-            im = list()
-            for path in self.tsrc:
-                if os.path.isfile(path):
-                    im.append(np.array(Image.open(path)))
-                raise ValueError('纹理资源文件不存在：%s'%path)
-            
-            im = np.stack(im)
-        elif isinstance(self.tsrc, np.ndarray) and self.tsrc.dtype == np.uint8 and self.tsrc.ndim in (3, 4):
-            im = self.tsrc
-        else:
-            raise ValueError('不支持的纹理资源类型')
-            
-        im_layer, im_h, im_w = im.shape[:-1]
-        im_mode = GL_LUMINANCE if im.ndim == 3 else (GL_RGB, GL_RGBA)[im.shape[-1]-3]
-        
-        tid = glGenTextures(1)
-        glBindTexture(self.ttype, tid)
-        
-        if (im.size/(im_layer*im_h))%4 == 0:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
-        else:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
-        
-        for i in range(self.level):
-            glTexImage3D(self.ttype, i, GL_RGBA, im_w, im_h, im_layer, 0, im_mode, GL_UNSIGNED_BYTE, im)
-
-        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_T, self.t_tile)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_R, self.r_tile)
-        
-        glGenerateMipmap(self.ttype)
-        glBindTexture(self.ttype, 0)
-        
-        return tid
-    
-    def _create_texture_3d(self):
-        """创建3D纹理对象"""
-        
-        if isinstance(self.tsrc, list):
-            im = list()
-            for path in self.tsrc:
-                if os.path.isfile(path):
-                    im.append(np.array(Image.open(path)))
-                raise ValueError('纹理资源文件不存在：%s'%path)
-            
-            im = np.stack(im)
-        elif isinstance(self.tsrc, np.ndarray) and self.tsrc.dtype == np.uint8 and self.tsrc.ndim in (3, 4):
-            im = self.tsrc
-        else:
-            raise ValueError('不支持的纹理资源类型')
-            
-        im_layer, im_h, im_w = im.shape[:-1]
-        im_mode = GL_LUMINANCE if im.ndim == 3 else (GL_RGB, GL_RGBA)[im.shape[-1]-3]
-        
-        tid = glGenTextures(1)
-        glBindTexture(self.ttype, tid)
-        
-        if (im.size/(im_layer*im_h))%4 == 0:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
-        else:
-            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
-        
-        for i in range(self.level):
-            glTexImage3D(self.ttype, i, GL_RGBA, im_w, im_h, im_layer, 0, im_mode, GL_UNSIGNED_BYTE, im)
-
-        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_T, self.t_tile)
-        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_R, self.r_tile)
-        
-        glGenerateMipmap(self.ttype)
-        glBindTexture(self.ttype, 0)
-        
-        return tid
-
-    
+#!/usr/bin/env python3
+
+import os
+import numpy as np
+from PIL import Image
+from OpenGL.GL import *
+
+class Texture:
+    """WxGL纹理对象"""
+ 
+    def __init__(self, tsrc, ttype=GL_TEXTURE_2D, **kwds):
+        """构造函数
+ 
+        tsrc            - 图像全路径或者np.array数组
+        ttype           - 纹理类型
+            - wxgl.TEXTURE_1D
+            - wxgl.TEXTURE_2D（默认）
+            - wxgl.TEXTURE_2D_ARRAY
+            - wxgl.TEXTURE_3D
+        kwds            - 关键字参数
+            level           - 纹理分级数，默认1
+            min_filter      - 纹理缩小滤波器
+                - GL_NEAREST
+                - GL_LINEAR
+                - GL_NEAREST_MIPMAP_NEAREST（默认）
+                - GL_LINEAR_MIPMAP_NEAREST
+                - GL_NEAREST_MIPMAP_LINEAR
+                - GL_LINEAR_MIPMAP_LINEAR
+            mag_filter      - 纹理放大滤波器
+                - GL_NEAREST
+                - GL_LINEAR（默认）
+            s_tile          - S方向纹理铺贴方式，GL_REPEAT（默认）|GL_MIRRORED_REPEAT|GL_CLAMP_TO_EDGE
+            t_tile          - T方向纹理铺贴方式，GL_REPEAT（默认）|GL_MIRRORED_REPEAT|GL_CLAMP_TO_EDGE
+            r_tile          - R方向纹理铺贴方式，GL_REPEAT（默认）|GL_MIRRORED_REPEAT|GL_CLAMP_TO_EDGE
+            xflip           - 图像左右翻转，默认False
+            yflip           - 图像上下翻转，默认False
+        """
+ 
+        if ttype not in (GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D):
+            raise ValueError('不支持的纹理类型')
+ 
+        self.ttype = ttype
+        self.tsrc = tsrc
+        self.tid = None
+ 
+        self.level = kwds.get('level', 1)
+        self.min_filter = kwds.get('min_filter', GL_LINEAR_MIPMAP_NEAREST)
+        self.mag_filter = kwds.get('mag_filter', GL_LINEAR)
+        self.s_tile = kwds.get('s_tile', GL_REPEAT)
+        self.t_tile = kwds.get('t_tile', GL_REPEAT)
+        self.r_tile = kwds.get('r_tile', GL_REPEAT)
+        self.xflip = kwds.get('xflip', False)
+        self.yflip = kwds.get('yflip', False)
+
+        if self.ttype == GL_TEXTURE_1D:
+            if not isinstance(self.tsrc, np.ndarray) or self.tsrc.dtype != np.uint8 or self.tsrc.ndim > 2 :
+                raise ValueError('不支持的纹理资源类型')
+        elif self.ttype == GL_TEXTURE_2D:
+            if isinstance(self.tsrc, str):
+                if not os.path.isfile(self.tsrc):
+                    raise ValueError('纹理资源文件不存在：%s'%self.tsrc)
+            elif not isinstance(self.tsrc, np.ndarray) or self.tsrc.dtype != np.uint8 or self.tsrc.ndim not in (2, 3):
+                raise ValueError('不支持的纹理资源类型')
+        elif self.ttype == GL_TEXTURE_2D_ARRAY or self.ttype == GL_TEXTURE_3D:
+            if isinstance(self.tsrc, list):
+                for fn in self.tsrc:
+                    if not os.path.isfile(path):
+                        raise ValueError('纹理资源文件不存在：%s'%fn)
+            elif not isinstance(self.tsrc, np.ndarray) or self.tsrc.dtype != np.uint8 or self.tsrc.ndim not in (3, 4):
+                raise ValueError('不支持的纹理资源类型') 
+ 
+    def create_texture(self):
+        """创建纹理对象"""
+ 
+        if self.ttype == GL_TEXTURE_1D:
+            self.tid = self._create_texture_1d()
+        elif self.ttype == GL_TEXTURE_2D:
+            self.tid = self._create_texture_2d()
+        elif self.ttype == GL_TEXTURE_2D_ARRAY:
+            self.tid = self._create_texture_2d_array()
+        elif self.ttype == GL_TEXTURE_3D:
+            self.tid = self._create_texture_3d()
+ 
+    def _create_texture_1d(self):
+        """创建1D纹理对象"""
+ 
+        im_w = self.tsrc.shape[0]
+        im_mode = GL_LUMINANCE if self.tsrc.ndim == 1 else (GL_RGB, GL_RGBA)[self.tsrc.shape[-1]-3]
+ 
+        tid = glGenTextures(1)
+        glBindTexture(self.ttype, tid)
+ 
+        if im_w%4 == 0:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
+        else:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
+ 
+        for i in range(self.level):
+            glTexImage1D(self.ttype, i, GL_RGBA, im_w, 0, im_mode, GL_UNSIGNED_BYTE, self.tsrc)
+ 
+        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
+ 
+        glGenerateMipmap(self.ttype)
+        glBindTexture(self.ttype, 0)
+ 
+        return tid
+ 
+    def _create_texture_2d(self):
+        """创建2D纹理对象"""
+        
+        if isinstance(self.tsrc, str):
+            im = np.array(Image.open(self.tsrc))
+        else:
+            im = self.tsrc
+        
+        im_h, im_w = im.shape[:2]
+        im_mode = GL_LUMINANCE if im.ndim == 2 else (GL_RGB, GL_RGBA)[im.shape[-1]-3]
+        
+        if self.xflip:
+            im = np.fliplr(im)
+        if self.yflip:
+            im = np.flipud(im)
+        
+        tid = glGenTextures(1)
+        glBindTexture(self.ttype, tid)
+        
+        if (im.size/im_h)%4 == 0:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
+        else:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
+        
+        for i in range(self.level):
+            glTexImage2D(self.ttype, i, GL_RGBA, im_w, im_h, 0, im_mode, GL_UNSIGNED_BYTE, im)
+        
+        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_T, self.t_tile)
+        
+        glGenerateMipmap(self.ttype)
+        glBindTexture(self.ttype, 0)
+        
+        return tid
+    
+    def _create_texture_2d_array(self):
+        """创建2D纹理数组对象"""
+ 
+        if isinstance(self.tsrc, list):
+            im = np.stack([np.array(Image.open(fn)) for fn in self.tsrc])
+        else:
+            im = self.tsrc
+ 
+        im_layer, im_h, im_w = im.shape[:-1]
+        im_mode = GL_LUMINANCE if im.ndim == 3 else (GL_RGB, GL_RGBA)[im.shape[-1]-3]
+ 
+        tid = glGenTextures(1)
+        glBindTexture(self.ttype, tid)
+ 
+        if (im.size/(im_layer*im_h))%4 == 0:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
+        else:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
+ 
+        for i in range(self.level):
+            glTexImage3D(self.ttype, i, GL_RGBA, im_w, im_h, im_layer, 0, im_mode, GL_UNSIGNED_BYTE, im)
+
+        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_T, self.t_tile)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_R, self.r_tile)
+ 
+        glGenerateMipmap(self.ttype)
+        glBindTexture(self.ttype, 0)
+ 
+        return tid
+ 
+    def _create_texture_3d(self):
+        """创建3D纹理对象"""
+ 
+        if isinstance(self.tsrc, list):
+            im = np.stack([np.array(Image.open(fn)) for fn in self.tsrc])
+        else:
+            im = self.tsrc
+ 
+        im_layer, im_h, im_w = im.shape[:-1]
+        im_mode = GL_LUMINANCE if im.ndim == 3 else (GL_RGB, GL_RGBA)[im.shape[-1]-3]
+ 
+        tid = glGenTextures(1)
+        glBindTexture(self.ttype, tid)
+ 
+        if (im.size/(im_layer*im_h))%4 == 0:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 4)
+        else:
+            glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
+ 
+        for i in range(self.level):
+            glTexImage3D(self.ttype, i, GL_RGBA, im_w, im_h, im_layer, 0, im_mode, GL_UNSIGNED_BYTE, im)
+
+        glTexParameterf(self.ttype, GL_TEXTURE_MIN_FILTER, self.min_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_MAG_FILTER, self.mag_filter)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_S, self.s_tile)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_T, self.t_tile)
+        glTexParameterf(self.ttype, GL_TEXTURE_WRAP_R, self.r_tile)
+ 
+        glGenerateMipmap(self.ttype)
+        glBindTexture(self.ttype, 0)
+ 
+        return tid
+
+
```

## wxgl/util.py

```diff
@@ -1,611 +1,661 @@
-# -*- coding: utf-8 -*-
-
-import numpy as np
-np.seterr(invalid='ignore')
-
-from . import text
-from . import cmap
-
-FM = text.FontManager()
-CM = cmap.ColorManager()
-
-def y2v(v):
-    """返回y轴正方向到向量v的旋转矩阵"""
-    
-    # *** 右手坐标系旋转矩阵 ***
-    # r_x = np.array([[1, 0, 0], [0, np.cos(), np.sin()], [0, -np.sin(), np.cos()]])
-    # r_y = np.array([[np.cos(), 0, -np.sin()], [0, 1, 0], [np.sin(), 0, np.cos()]])
-    # r_z = np.array([[np.cos(), np.sin(), 0], [-np.sin(), np.cos, 0], [0, 0, 1]])
-    
-    h =  np.linalg.norm(v)
-    a_z = -np.arccos(v[1]/h)
-    
-    if v[0] == 0:
-        if v[2] == 0:
-            a_y = 0
-        elif v[2] > 0:
-            a_y = -np.pi/2
-        else:
-            a_y = np.pi/2
-    else:
-        a_y = np.arctan(-v[2]/v[0]) + (np.pi if v[0] < 0 else 0)
-    
-    r_y_0 = np.array([[np.cos(-a_y), 0, -np.sin(-a_y)], [0, 1, 0], [np.sin(-a_y), 0, np.cos(-a_y)]])
-    r_z = np.array([[np.cos(a_z), np.sin(a_z), 0], [-np.sin(a_z), np.cos(a_z), 0], [0, 0, 1]])
-    r_y = np.array([[np.cos(a_y), 0, -np.sin(a_y)], [0, 1, 0], [np.sin(a_y), 0, np.cos(a_y)]])
-    
-    return np.dot(r_y_0, np.dot(r_z, r_y))
-
-def rotate(axis_angle):
-    """返回旋转矩阵
-    
-    axis_angle  - 轴角，由旋转向量和旋转角度组成的元组、列表或numpy数组。旋转方向使用右手定则
-    """
-    
-    v, a = np.array(axis_angle[:3]), np.radians(-axis_angle[3]), 
-    v = v/np.linalg.norm(v)
-    x, y, z = v
-    
-    # 轴角转旋转矩阵
-    m = np.array([
-		[np.cos(a)+x*x*(1-np.cos(a)), -z*np.sin(a)+x*y*(1-np.cos(a)), y*np.sin(a)+x*z*(1-np.cos(a))],
-		[z*np.sin(a)+x*y*(1-np.cos(a)), np.cos(a)+y*y*(1-np.cos(a)), -x*np.sin(a)+y*z*(1-np.cos(a))],
-		[-y*np.sin(a)+x*z*(1-np.cos(a)), x*np.sin(a)+y*z*(1-np.cos(a)), np.cos(a)+z*z*(1-np.cos(a))]
-    ])
-    
-    m = np.hstack((m, np.array([[0.0], [0.0], [0.0]])))
-    m = np.vstack((m, np.array([0.0, 0.0, 0.0, 1.0])))
-    
-    return np.float32(m)
-    
-def translate(shift):
-    """返回平移矩阵
-    
-    shift       - 由xyz轴偏移量组成的元组、列表或numpy数组
-    """
-    
-    v = np.array(shift).reshape(3,1)
-    m = np.eye(4)
-    m[3] += np.sum((m[:3] * v), axis=0)
-    
-    return np.float32(m)
-    
-def scale(k):
-    """返回缩放矩阵
-    
-    k           - 缩放系数
-    """
-    
-    v = np.array([k,k,k]).reshape(3,1)
-    m = np.eye(4)
-    m[:3] *= v
-    
-    return np.float32(m)
-
-def model_matrix(*args):
-    """返回模型矩阵
-    
-    args        - 旋转（4元组）、平移（3元组）、缩放（数值型）参数
-    """
-    
-    m = np.eye(4)
-    for item in args:
-        if isinstance(item, (int, float)):
-            m = np.dot(m, scale(item))
-        elif len(item) == 3:
-            m = np.dot(m, translate(item))
-        else:
-            m = np.dot(m, rotate(item))
-    
-    return np.float32(m)
-    
-def view_matrix(cam_pos, cam_up, oecs):
-    """返回视点矩阵
-    
-    cam_pos     - 相机位置
-    cam_up      - 指向相机上方的单位向量
-    oecs        - 视点坐标系ECS原点
-    """
-    
-    camX, camY, camZ = cam_pos
-    oecsX, oecsY, oecsZ = oecs
-    upX, upY, upZ = cam_up
-    
-    f = np.array([oecsX-camX, oecsY-camY, oecsZ-camZ], dtype=np.float64)
-    f /= np.linalg.norm(f)
-    s = np.array([f[1]*upZ - f[2]*upY, f[2]*upX - f[0]*upZ, f[0]*upY - f[1]*upX], dtype=np.float64)
-    s /= np.linalg.norm(s)
-    u = np.cross(s, f)
-    
-    m = np.array([
-        [s[0], u[0], -f[0], 0],
-        [s[1], u[1], -f[1], 0],
-        [s[2], u[2], -f[2], 0],
-        [- s[0]*camX - s[1]*camY - s[2]*camZ, 
-        - u[0]*camX - u[1]*camY - u[2]*camZ, 
-        f[0]*camX + f[1]*camY + f[2]*camZ, 1]
-    ], dtype=np.float32)
-    
-    return m
-    
-def proj_matrix(proj, hexa, zoom):
-    """返回投影矩阵
-    
-    proj        - 投影模式，'O' - 正射投影，'P' - 透视投影
-    hexa        - 视锥体的左右下上距离中心线的距离以及前后面距离相机的距离组成的元组
-    zoom        - 视口缩放因子
-    csize       - GL窗口宽高元组
-    """
-    
-    left, right, bottom, top, near, far = hexa
-    left, right, bottom, top = zoom*left, zoom*right, zoom*bottom, zoom*top
-    rw, rh, rd = 1/(right - left), 1/(top - bottom), 1/(far - near)
-    
-    if proj[0].upper() == 'O':
-        m = np.array([
-            [2 * rw, 0, 0, 0],
-            [0, 2 * rh, 0, 0],
-            [0, 0, -2 * rd, 0],
-            [-(right+left) * rw, -(top+bottom) * rh, -(far+near) * rd, 1]
-        ], dtype=np.float32)
-    else:
-        m = np.array([
-            [2 * near * rw, 0, 0, 0],
-            [0, 2 * near * rh, 0, 0],
-            [(right+left) * rw, (top+bottom) * rh, -(far + near) * rd, -1],
-            [0, 0, -2 * near * far * rd, 0]
-        ], dtype=np.float32)
-    
-    return m
-
-def text2image(text, size, color, family=None, weight='normal'):
-    """生成文本图像
-    
-    text        - 文本字符串
-    size        - 字号，整型，默认32
-    color       - 文本颜色，浮点型元组、列表或numpy数组，值域范围[0,1]
-    family      - 字体，None表示当前默认的字体
-    weight      - 字体的浓淡：'normal'-正常（默认），'light'-轻，'bold'-重
-    """
-    
-    return FM.text2img(text, size, color, family=family, weight=weight)
-
-def font_list():
-    """返回当前系统可用字体列表"""
-    
-    return FM.get_font_list()
-    
-def color2c(color, drop=False, outsize=None):
-    """检查颜色参数，将字符串、元组、列表等类型的颜色转为值域范围[0,1]的numpy数组颜色
-    
-    color       - 待处理的颜色
-    drop        - 舍弃alpha通道
-    outsize     - 返回颜色的数量：整型或整型元组，None表示不改变返回颜色的数量
-    """
-    
-    return CM.color2c(color, drop=drop, outsize=outsize)
-    
-def color_list():
-    """颜色列表"""
-    
-    return CM.color_list
-    
-def cmap_list():
-    """调色板列表"""
-    
-    return CM.cmap_list
-    
-def color_help():
-    """返回颜色中英文对照表"""
-    
-    return CM.color_help()
-    
-def cmap_help():
-    """返回调色板分类列表"""
-    
-    return CM.cmap_help()
-    
-def cmap(data, cm, invalid=np.nan, invalid_c=(0,0,0,0), drange=None, alpha=None, drop=False):
-    """数值映射到颜色
-        
-    data        - 数据
-    cm          - 调色板
-    invalid     - 无效数据的标识
-    invalid_c   - 无效数据的颜色
-    drange      - 数据动态范围，None表示使用data的动态范围
-    alpha       - 透明度，None表示不改变当前透明度
-    drop        - 舍弃alpha通道
-    """
-    
-    return CM.cmap(data, cm, invalid=invalid, invalid_c=invalid_c, drange=drange, alpha=alpha, drop=drop)
-
-def _isosurface(data, level):
-    """返回基于MarchingCube算法的等值面"""
-    
-    data = np.ascontiguousarray(data)
-    mask = data < level
-    face_shift_tables, edge_shifts, edge_table, n_table_faces = _get_data_cache()
-    
-    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)
-    fields = np.empty((2, 2, 2), dtype=object)
-    slices = [slice(0, -1), slice(1, None)]
-    for i in [0, 1]:
-        for j in [0, 1]:
-            for k in [0, 1]:
-                fields[i, j, k] = mask[slices[i], slices[j], slices[k]]
-                vertIndex = i - 2*j*i + 3*j + 4*k
-                index += (fields[i, j, k] * 2**vertIndex).astype(np.ubyte)
-    
-    cut_edges = np.zeros([x+1 for x in index.shape]+[3], dtype=np.uint32)
-    edges = edge_table[index]
-    for i, shift in enumerate(edge_shifts[:12]):        
-        slices = [slice(shift[j], cut_edges.shape[j]+(shift[j]-1)) 
-                  for j in range(3)]
-        cut_edges[slices[0], slices[1], slices[2], shift[3]] += edges & 2**i
-    
-    m = cut_edges > 0
-    vertex_inds = np.argwhere(m)
-    vertexes = vertex_inds[:, :3].astype(np.float32).copy()
-    dataFlat = data.reshape(data.shape[0]*data.shape[1]*data.shape[2])
-    
-    cut_edges[vertex_inds[:, 0], 
-              vertex_inds[:, 1], 
-              vertex_inds[:, 2], 
-              vertex_inds[:, 3]] = np.arange(vertex_inds.shape[0])
-    
-    for i in [0, 1, 2]:
-        vim = vertex_inds[:, 3] == i
-        vi = vertex_inds[vim, :3]
-        vi_flat = (vi * (np.array(data.strides[:3]) // 
-                         data.itemsize)[np.newaxis, :]).sum(axis=1)
-        v1 = dataFlat[vi_flat]
-        v2 = dataFlat[vi_flat + data.strides[i]//data.itemsize]
-        vertexes[vim, i] += (level-v1) / (v2-v1)
-    
-    n_faces = n_table_faces[index]
-    tot_faces = n_faces.sum()
-    faces = np.empty((tot_faces, 3), dtype=np.uint32)
-    ptr = 0
-    
-    cs = np.array(cut_edges.strides)//cut_edges.itemsize
-    cut_edges = cut_edges.flatten()
-    
-    for i in range(1, 6):
-        cells = np.argwhere(n_faces == i)  
-        if cells.shape[0] == 0:
-            continue
-        cellInds = index[cells[:, 0], cells[:, 1], cells[:, 2]]
-        
-        verts = face_shift_tables[i][cellInds]
-        verts[..., :3] += (cells[:, np.newaxis, np.newaxis, :]).astype(np.uint16)
-        verts = verts.reshape((verts.shape[0]*i,)+verts.shape[2:])
-        
-        verts = (verts * cs[np.newaxis, np.newaxis, :]).sum(axis=2)
-        vert_inds = cut_edges[verts]
-        nv = vert_inds.shape[0]
-        faces[ptr:ptr+nv] = vert_inds
-        ptr += nv
-    
-    return vertexes, faces
-
-def _get_data_cache():
-    edge_table = np.array([
-        0x0,   0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
-        0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
-        0x190, 0x99,  0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
-        0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
-        0x230, 0x339, 0x33,  0x13a, 0x636, 0x73f, 0x435, 0x53c,
-        0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
-        0x3a0, 0x2a9, 0x1a3, 0xaa,  0x7a6, 0x6af, 0x5a5, 0x4ac,
-        0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
-        0x460, 0x569, 0x663, 0x76a, 0x66,  0x16f, 0x265, 0x36c,
-        0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
-        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff,  0x3f5, 0x2fc,
-        0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
-        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55,  0x15c,
-        0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
-        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 
-        0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
-        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
-        0xcc,  0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
-        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
-        0x15c, 0x55,  0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
-        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
-        0x2fc, 0x3f5, 0xff,  0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
-        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
-        0x36c, 0x265, 0x16f, 0x66,  0x76a, 0x663, 0x569, 0x460,
-        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
-        0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa,  0x1a3, 0x2a9, 0x3a0,
-        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
-        0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33,  0x339, 0x230,
-        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
-        0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99,  0x190,
-        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
-        0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0   
-    ], dtype=np.uint16)
-    
-    triTable = [
-        [],
-        [0, 8, 3],
-        [0, 1, 9],
-        [1, 8, 3, 9, 8, 1],
-        [1, 2, 10],
-        [0, 8, 3, 1, 2, 10],
-        [9, 2, 10, 0, 2, 9],
-        [2, 8, 3, 2, 10, 8, 10, 9, 8],
-        [3, 11, 2],
-        [0, 11, 2, 8, 11, 0],
-        [1, 9, 0, 2, 3, 11],
-        [1, 11, 2, 1, 9, 11, 9, 8, 11],
-        [3, 10, 1, 11, 10, 3],
-        [0, 10, 1, 0, 8, 10, 8, 11, 10],
-        [3, 9, 0, 3, 11, 9, 11, 10, 9],
-        [9, 8, 10, 10, 8, 11],
-        [4, 7, 8],
-        [4, 3, 0, 7, 3, 4],
-        [0, 1, 9, 8, 4, 7],
-        [4, 1, 9, 4, 7, 1, 7, 3, 1],
-        [1, 2, 10, 8, 4, 7],
-        [3, 4, 7, 3, 0, 4, 1, 2, 10],
-        [9, 2, 10, 9, 0, 2, 8, 4, 7],
-        [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4],
-        [8, 4, 7, 3, 11, 2],
-        [11, 4, 7, 11, 2, 4, 2, 0, 4],
-        [9, 0, 1, 8, 4, 7, 2, 3, 11],
-        [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1],
-        [3, 10, 1, 3, 11, 10, 7, 8, 4],
-        [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4],
-        [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3],
-        [4, 7, 11, 4, 11, 9, 9, 11, 10],
-        [9, 5, 4],
-        [9, 5, 4, 0, 8, 3],
-        [0, 5, 4, 1, 5, 0],
-        [8, 5, 4, 8, 3, 5, 3, 1, 5],
-        [1, 2, 10, 9, 5, 4],
-        [3, 0, 8, 1, 2, 10, 4, 9, 5],
-        [5, 2, 10, 5, 4, 2, 4, 0, 2],
-        [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8],
-        [9, 5, 4, 2, 3, 11],
-        [0, 11, 2, 0, 8, 11, 4, 9, 5],
-        [0, 5, 4, 0, 1, 5, 2, 3, 11],
-        [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5],
-        [10, 3, 11, 10, 1, 3, 9, 5, 4],
-        [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10],
-        [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3],
-        [5, 4, 8, 5, 8, 10, 10, 8, 11],
-        [9, 7, 8, 5, 7, 9],
-        [9, 3, 0, 9, 5, 3, 5, 7, 3],
-        [0, 7, 8, 0, 1, 7, 1, 5, 7],
-        [1, 5, 3, 3, 5, 7],
-        [9, 7, 8, 9, 5, 7, 10, 1, 2],
-        [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3],
-        [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2],
-        [2, 10, 5, 2, 5, 3, 3, 5, 7],
-        [7, 9, 5, 7, 8, 9, 3, 11, 2],
-        [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11],
-        [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7],
-        [11, 2, 1, 11, 1, 7, 7, 1, 5],
-        [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11],
-        [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0],
-        [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0],
-        [11, 10, 5, 7, 11, 5],
-        [10, 6, 5],
-        [0, 8, 3, 5, 10, 6],
-        [9, 0, 1, 5, 10, 6],
-        [1, 8, 3, 1, 9, 8, 5, 10, 6],
-        [1, 6, 5, 2, 6, 1],
-        [1, 6, 5, 1, 2, 6, 3, 0, 8],
-        [9, 6, 5, 9, 0, 6, 0, 2, 6],
-        [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8],
-        [2, 3, 11, 10, 6, 5],
-        [11, 0, 8, 11, 2, 0, 10, 6, 5],
-        [0, 1, 9, 2, 3, 11, 5, 10, 6],
-        [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11],
-        [6, 3, 11, 6, 5, 3, 5, 1, 3],
-        [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6],
-        [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9],
-        [6, 5, 9, 6, 9, 11, 11, 9, 8],
-        [5, 10, 6, 4, 7, 8],
-        [4, 3, 0, 4, 7, 3, 6, 5, 10],
-        [1, 9, 0, 5, 10, 6, 8, 4, 7],
-        [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4],
-        [6, 1, 2, 6, 5, 1, 4, 7, 8],
-        [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7],
-        [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6],
-        [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9],
-        [3, 11, 2, 7, 8, 4, 10, 6, 5],
-        [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11],
-        [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6],
-        [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6],
-        [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6],
-        [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11],
-        [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7],
-        [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9],
-        [10, 4, 9, 6, 4, 10],
-        [4, 10, 6, 4, 9, 10, 0, 8, 3],
-        [10, 0, 1, 10, 6, 0, 6, 4, 0],
-        [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10],
-        [1, 4, 9, 1, 2, 4, 2, 6, 4],
-        [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4],
-        [0, 2, 4, 4, 2, 6],
-        [8, 3, 2, 8, 2, 4, 4, 2, 6],
-        [10, 4, 9, 10, 6, 4, 11, 2, 3],
-        [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6],
-        [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10],
-        [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1],
-        [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3],
-        [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1],
-        [3, 11, 6, 3, 6, 0, 0, 6, 4],
-        [6, 4, 8, 11, 6, 8],
-        [7, 10, 6, 7, 8, 10, 8, 9, 10],
-        [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10],
-        [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0],
-        [10, 6, 7, 10, 7, 1, 1, 7, 3],
-        [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7],
-        [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9],
-        [7, 8, 0, 7, 0, 6, 6, 0, 2],
-        [7, 3, 2, 6, 7, 2],
-        [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7],
-        [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7],
-        [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11],
-        [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1],
-        [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6],
-        [0, 9, 1, 11, 6, 7],
-        [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0],
-        [7, 11, 6],
-        [7, 6, 11],
-        [3, 0, 8, 11, 7, 6],
-        [0, 1, 9, 11, 7, 6],
-        [8, 1, 9, 8, 3, 1, 11, 7, 6],
-        [10, 1, 2, 6, 11, 7],
-        [1, 2, 10, 3, 0, 8, 6, 11, 7],
-        [2, 9, 0, 2, 10, 9, 6, 11, 7],
-        [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8],
-        [7, 2, 3, 6, 2, 7],
-        [7, 0, 8, 7, 6, 0, 6, 2, 0],
-        [2, 7, 6, 2, 3, 7, 0, 1, 9],
-        [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6],
-        [10, 7, 6, 10, 1, 7, 1, 3, 7],
-        [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8],
-        [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7],
-        [7, 6, 10, 7, 10, 8, 8, 10, 9],
-        [6, 8, 4, 11, 8, 6],
-        [3, 6, 11, 3, 0, 6, 0, 4, 6],
-        [8, 6, 11, 8, 4, 6, 9, 0, 1],
-        [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6],
-        [6, 8, 4, 6, 11, 8, 2, 10, 1],
-        [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6],
-        [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9],
-        [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3],
-        [8, 2, 3, 8, 4, 2, 4, 6, 2],
-        [0, 4, 2, 4, 6, 2],
-        [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8],
-        [1, 9, 4, 1, 4, 2, 2, 4, 6],
-        [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1],
-        [10, 1, 0, 10, 0, 6, 6, 0, 4],
-        [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3],
-        [10, 9, 4, 6, 10, 4],
-        [4, 9, 5, 7, 6, 11],
-        [0, 8, 3, 4, 9, 5, 11, 7, 6],
-        [5, 0, 1, 5, 4, 0, 7, 6, 11],
-        [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5],
-        [9, 5, 4, 10, 1, 2, 7, 6, 11],
-        [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5],
-        [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2],
-        [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6],
-        [7, 2, 3, 7, 6, 2, 5, 4, 9],
-        [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7],
-        [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0],
-        [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8],
-        [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7],
-        [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4],
-        [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10],
-        [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10],
-        [6, 9, 5, 6, 11, 9, 11, 8, 9],
-        [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5],
-        [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11],
-        [6, 11, 3, 6, 3, 5, 5, 3, 1],
-        [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6],
-        [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10],
-        [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5],
-        [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3],
-        [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2],
-        [9, 5, 6, 9, 6, 0, 0, 6, 2],
-        [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8],
-        [1, 5, 6, 2, 1, 6],
-        [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6],
-        [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0],
-        [0, 3, 8, 5, 6, 10],
-        [10, 5, 6],
-        [11, 5, 10, 7, 5, 11],
-        [11, 5, 10, 11, 7, 5, 8, 3, 0],
-        [5, 11, 7, 5, 10, 11, 1, 9, 0],
-        [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1],
-        [11, 1, 2, 11, 7, 1, 7, 5, 1],
-        [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11],
-        [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7],
-        [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2],
-        [2, 5, 10, 2, 3, 5, 3, 7, 5],
-        [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5],
-        [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2],
-        [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2],
-        [1, 3, 5, 3, 7, 5],
-        [0, 8, 7, 0, 7, 1, 1, 7, 5],
-        [9, 0, 3, 9, 3, 5, 5, 3, 7],
-        [9, 8, 7, 5, 9, 7],
-        [5, 8, 4, 5, 10, 8, 10, 11, 8],
-        [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0],
-        [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5],
-        [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4],
-        [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8],
-        [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11],
-        [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5],
-        [9, 4, 5, 2, 11, 3],
-        [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4],
-        [5, 10, 2, 5, 2, 4, 4, 2, 0],
-        [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9],
-        [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2],
-        [8, 4, 5, 8, 5, 3, 3, 5, 1],
-        [0, 4, 5, 1, 0, 5],
-        [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5],
-        [9, 4, 5],
-        [4, 11, 7, 4, 9, 11, 9, 10, 11],
-        [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11],
-        [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11],
-        [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4],
-        [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2],
-        [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3],
-        [11, 7, 4, 11, 4, 2, 2, 4, 0],
-        [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4],
-        [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9],
-        [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7],
-        [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10],
-        [1, 10, 2, 8, 7, 4],
-        [4, 9, 1, 4, 1, 7, 7, 1, 3],
-        [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1],
-        [4, 0, 3, 7, 4, 3],
-        [4, 8, 7],
-        [9, 10, 8, 10, 11, 8],
-        [3, 0, 9, 3, 9, 11, 11, 9, 10],
-        [0, 1, 10, 0, 10, 8, 8, 10, 11],
-        [3, 1, 10, 11, 3, 10],
-        [1, 2, 11, 1, 11, 9, 9, 11, 8],
-        [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9],
-        [0, 2, 11, 8, 0, 11],
-        [3, 2, 11],
-        [2, 3, 8, 2, 8, 10, 10, 8, 9],
-        [9, 10, 2, 0, 9, 2],
-        [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8],
-        [1, 10, 2],
-        [1, 3, 8, 9, 1, 8],
-        [0, 9, 1],
-        [0, 3, 8],
-        []
-    ]
-    
-    edge_shifts = np.array([
-        [0, 0, 0, 0],   
-        [1, 0, 0, 1],
-        [0, 1, 0, 0],
-        [0, 0, 0, 1],
-        [0, 0, 1, 0],
-        [1, 0, 1, 1],
-        [0, 1, 1, 0],
-        [0, 0, 1, 1],
-        [0, 0, 0, 2],
-        [1, 0, 0, 2],
-        [1, 1, 0, 2],
-        [0, 1, 0, 2]
-    ], dtype=np.uint16) 
-    
-    n_table_faces = np.array([len(f)/3 for f in triTable], dtype=np.ubyte)
-    face_shift_tables = [None]
-    for i in range(1, 6):
-        faceTableI = np.zeros((len(triTable), i*3), dtype=np.ubyte)
-        faceTableInds = np.argwhere(n_table_faces == i)[:, 0]
-        faceTableI[faceTableInds] = np.array([triTable[j] for j in faceTableInds])
-        faceTableI = faceTableI.reshape((len(triTable), i, 3))
-        face_shift_tables.append(edge_shifts[faceTableI])
-        
-    return face_shift_tables, edge_shifts, edge_table, n_table_faces
-    
+#!/usr/bin/env python3
+
+import numpy as np
+np.seterr(invalid='ignore')
+
+from OpenGL.GL import *
+from . color import ColorManager
+from . text import FontManager
+
+CM = ColorManager()
+FM = FontManager()
+
+def font_list():
+    """返回可用字体"""
+
+    return FM.get_font_list()
+
+def color_list():
+    """返回可用颜色"""
+
+    return CM.colors
+
+def cm_list():
+    """返回可用调色板"""
+
+    return CM.cmaps
+
+def format_color(color, cid=0, repeat=None):
+    """检查颜色参数，将字符串、元组、列表等类型的颜色转为浮点型的numpy数组
+
+    color       - 预定义颜色、十六进制颜色，或者浮点型元组、列表或numpy数组
+    cid         - 缺省颜色id
+    repeat      - 若color为单个颜色，repeat表示重复次数或重复行列数
+    """
+
+    return CM.format_color(color, cid=cid, repeat=repeat)
+
+def cmap(data, cm, drange=None, alpha=None, invalid=np.nan, invalid_c=(0,0,0,0)):
+    """数值映射到颜色
+ 
+    data        - 数据
+    cm          - 调色板
+    drange      - 数据动态范围，None表示使用data的动态范围
+    alpha       - 透明度，None表示不改变当前透明度
+    invalid     - 无效数据的标识
+    invalid_c   - 无效数据的颜色
+    """
+
+    return CM.cmap(data, cm, drange=drange, alpha=alpha, invalid=invalid, invalid_c=invalid_c)
+
+def get_cm_colors(cm):
+    """返回给定调色板的颜色列表"""
+
+    return CM.get_cm_colors(cm)
+
+def text2img(text, size, color, bg=None, padding=0, family=None, weight='normal'):
+    """文本转图像，返回图像数据和size元组
+ 
+    text        - 文本字符串
+    size        - 文字大小，整型
+    color       - 文本颜色，numpy数组，值域范围[0,1]
+    bg          - 背景色，None表示背景透明
+    padding     - 留白
+    family      - （系统支持的）字体
+    weight      - 字体的浓淡：'normal'-正常（默认），'light'-轻，'bold'-重
+    """
+
+    return FM.text2img(text, size, color, bg=bg, padding=padding, family=family, weight=weight)
+
+def y2v(v):
+    """返回y轴正方向到向量v的旋转矩阵"""
+ 
+    # *** 右手坐标系旋转矩阵 ***
+    # r_x = np.array([[1, 0, 0], [0, np.cos(), np.sin()], [0, -np.sin(), np.cos()]])
+    # r_y = np.array([[np.cos(), 0, -np.sin()], [0, 1, 0], [np.sin(), 0, np.cos()]])
+    # r_z = np.array([[np.cos(), np.sin(), 0], [-np.sin(), np.cos, 0], [0, 0, 1]])
+ 
+    h =  np.linalg.norm(v)
+    a_z = -np.arccos(v[1]/h)
+ 
+    if v[0] == 0:
+        if v[2] == 0:
+            a_y = 0
+        elif v[2] > 0:
+            a_y = -np.pi/2
+        else:
+            a_y = np.pi/2
+    else:
+        a_y = np.arctan(-v[2]/v[0]) + (np.pi if v[0] < 0 else 0)
+ 
+    r_y_0 = np.array([[np.cos(-a_y), 0, -np.sin(-a_y)], [0, 1, 0], [np.sin(-a_y), 0, np.cos(-a_y)]])
+    r_z = np.array([[np.cos(a_z), np.sin(a_z), 0], [-np.sin(a_z), np.cos(a_z), 0], [0, 0, 1]])
+    r_y = np.array([[np.cos(a_y), 0, -np.sin(a_y)], [0, 1, 0], [np.sin(a_y), 0, np.cos(a_y)]])
+ 
+    return np.dot(r_y_0, np.dot(r_z, r_y))
+
+def rotate(axis_angle):
+    """返回旋转矩阵
+ 
+    axis_angle  - 轴角，由旋转向量和旋转角度组成的元组、列表或numpy数组。旋转方向使用右手定则
+    """
+ 
+    v, a = np.array(axis_angle[:3]), np.radians(-axis_angle[3]), 
+    v = v/np.linalg.norm(v)
+    x, y, z = v
+ 
+    # 轴角转旋转矩阵
+    m = np.array([
+		[np.cos(a)+x*x*(1-np.cos(a)), -z*np.sin(a)+x*y*(1-np.cos(a)), y*np.sin(a)+x*z*(1-np.cos(a))],
+		[z*np.sin(a)+x*y*(1-np.cos(a)), np.cos(a)+y*y*(1-np.cos(a)), -x*np.sin(a)+y*z*(1-np.cos(a))],
+		[-y*np.sin(a)+x*z*(1-np.cos(a)), x*np.sin(a)+y*z*(1-np.cos(a)), np.cos(a)+z*z*(1-np.cos(a))]
+    ])
+ 
+    m = np.hstack((m, np.array([[0.0], [0.0], [0.0]])))
+    m = np.vstack((m, np.array([0.0, 0.0, 0.0, 1.0])))
+ 
+    return np.float32(m)
+ 
+def translate(shift):
+    """返回平移矩阵
+ 
+    shift       - 由xyz轴偏移量组成的元组、列表或numpy数组
+    """
+ 
+    v = np.array(shift).reshape(3,1)
+    m = np.eye(4)
+    m[3] += np.sum((m[:3] * v), axis=0)
+ 
+    return np.float32(m)
+ 
+def scale(k):
+    """返回缩放矩阵
+ 
+    k           - 缩放系数
+    """
+ 
+    v = np.array([k, k, k]).reshape(3,1)
+    m = np.eye(4)
+    m[:3] *= v
+ 
+    return np.float32(m)
+
+def model_matrix(*args):
+    """返回模型矩阵
+    
+    args        - 旋转（4元组）、平移（3元组）、缩放（数值型）参数
+    """
+ 
+    m = np.eye(4)
+    for item in args:
+        if isinstance(item, (int, float)):
+            m = np.dot(m, scale(item))
+        elif len(item) == 3:
+            m = np.dot(m, translate(item))
+        else:
+            m = np.dot(m, rotate(item))
+ 
+    return np.float32(m)
+ 
+def view_matrix(cam, up, oecs):
+    """返回视点矩阵
+ 
+    cam         - 相机位置
+    up          - 指向相机上方的单位向量
+    oecs        - 视点坐标系ECS原点
+    """
+ 
+    camX, camY, camZ = cam
+    oecsX, oecsY, oecsZ = oecs
+    upX, upY, upZ = up
+ 
+    f = np.array([oecsX-camX, oecsY-camY, oecsZ-camZ], dtype=np.float64)
+    f /= np.linalg.norm(f)
+    s = np.array([f[1]*upZ - f[2]*upY, f[2]*upX - f[0]*upZ, f[0]*upY - f[1]*upX], dtype=np.float64)
+    s /= np.linalg.norm(s)
+    u = np.cross(s, f)
+ 
+    m = np.array([
+        [s[0], u[0], -f[0], 0],
+        [s[1], u[1], -f[1], 0],
+        [s[2], u[2], -f[2], 0],
+        [- s[0]*camX - s[1]*camY - s[2]*camZ, 
+        - u[0]*camX - u[1]*camY - u[2]*camZ, 
+        f[0]*camX + f[1]*camY + f[2]*camZ, 1]
+    ], dtype=np.float32)
+ 
+    return m
+ 
+def proj_matrix(fovy, aspect, near, far):
+    """返回投影矩阵
+ 
+    fovy        - 相机水平视野角度
+    aspect      - 画布宽高比
+    near        - 相机与视椎体前端面的距离
+    far         - 相机与视椎体后端面的距离
+    """
+ 
+    right = np.tan(np.radians(fovy/2)) * near
+    left = -right
+    top = right/aspect
+    bottom = left/aspect
+    rw, rh, rd = 1/(right-left), 1/(top-bottom), 1/(far-near)
+ 
+    m = np.array([
+        [2 * near * rw, 0, 0, 0],
+        [0, 2 * near * rh, 0, 0],
+        [(right+left) * rw, (top+bottom) * rh, -(far+near) * rd, -1],
+        [0, 0, -2 * near * far * rd, 0]
+    ], dtype=np.float32)
+ 
+    return m
+
+def get_normal(gltype, vs, indices=None):
+    """返回法线集"""
+ 
+    if gltype not in (GL_TRIANGLES, GL_TRIANGLES, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP):
+        raise KeyError('%s不支持法线计算'%(str(gltype)))
+ 
+    if not indices is None and gltype != GL_TRIANGLES and gltype != GL_QUADS:
+        raise KeyError('%s不支持indices参数'%(str(gltype)))
+ 
+    if vs.ndim == 3:
+        vs = vs.reshape(-1, vs.shape[-1])
+    n = vs.shape[0]
+
+    if indices is None:
+        if gltype == GL_TRIANGLE_FAN:
+            a = np.zeros(n-2, dtype=np.int32)
+            b = np.arange(1, n-1, dtype=np.int32)
+            c = np.arange(2, n, dtype=np.int32)
+            idx = np.stack((a, b, c), axis=1).ravel()
+        elif gltype == GL_TRIANGLE_STRIP:
+            a = np.repeat(np.arange(0, n-1, 2, dtype=np.int32), 2)[1:n-1]
+            b = np.repeat(np.arange(1, n-1, 2, dtype=np.int32), 2)[:n-2]
+            c = np.arange(2, n, dtype=np.int32)
+            idx = np.stack((a, b, c), axis=1).ravel()
+        elif gltype == GL_QUAD_STRIP:
+            a = np.arange(0, n-2, 2, dtype=np.int32)
+            b = np.arange(1, n-2, 2, dtype=np.int32)
+            c = np.arange(3, n, 2, dtype=np.int32)
+            d = np.arange(2, n, 2, dtype=np.int32)
+            idx = np.stack((a, b, c, d), axis=1).ravel()
+        else:
+            idx = np.arange(n, dtype=np.int32)
+    else:
+        idx = np.array(indices, dtype=np.int32)
+ 
+    primitive = vs[idx]
+    if gltype == GL_QUADS or gltype == GL_QUAD_STRIP:
+        a = primitive[::4]
+        b = primitive[1::4]
+        c = primitive[2::4]
+        d = primitive[3::4]
+        normal = np.repeat(np.cross(c-a, d-b), 4, axis=0)
+    else:
+        a = primitive[::3]
+        b = primitive[1::3]
+        c = primitive[2::3]
+        normal = np.repeat(np.cross(b-a, c-a), 3, axis=0)
+ 
+    if indices is None and (gltype == GL_TRIANGLES or gltype == GL_QUADS):
+        return normal
+ 
+    result = np.zeros((n,3), dtype=np.float32)
+    idx_arg = np.argsort(idx)
+    rise = np.where(np.diff(idx[idx_arg])==1)[0]+1
+    rise = np.hstack((0,rise,len(idx)))
+ 
+    for i in range(n):
+        result[i] = np.sum(normal[idx_arg[rise[i]:rise[i+1]]], axis=0)
+    return result
+
+def _get_data_cache():
+    edge_table = np.array([
+        0x0,   0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
+        0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
+        0x190, 0x99,  0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
+        0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
+        0x230, 0x339, 0x33,  0x13a, 0x636, 0x73f, 0x435, 0x53c,
+        0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
+        0x3a0, 0x2a9, 0x1a3, 0xaa,  0x7a6, 0x6af, 0x5a5, 0x4ac,
+        0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
+        0x460, 0x569, 0x663, 0x76a, 0x66,  0x16f, 0x265, 0x36c,
+        0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
+        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff,  0x3f5, 0x2fc,
+        0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
+        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55,  0x15c,
+        0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
+        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 
+        0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
+        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
+        0xcc,  0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
+        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
+        0x15c, 0x55,  0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
+        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
+        0x2fc, 0x3f5, 0xff,  0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
+        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
+        0x36c, 0x265, 0x16f, 0x66,  0x76a, 0x663, 0x569, 0x460,
+        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
+        0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa,  0x1a3, 0x2a9, 0x3a0,
+        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
+        0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33,  0x339, 0x230,
+        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
+        0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99,  0x190,
+        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
+        0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0   
+    ], dtype=np.uint16)
+ 
+    triTable = [
+        [],
+        [0, 8, 3],
+        [0, 1, 9],
+        [1, 8, 3, 9, 8, 1],
+        [1, 2, 10],
+        [0, 8, 3, 1, 2, 10],
+        [9, 2, 10, 0, 2, 9],
+        [2, 8, 3, 2, 10, 8, 10, 9, 8],
+        [3, 11, 2],
+        [0, 11, 2, 8, 11, 0],
+        [1, 9, 0, 2, 3, 11],
+        [1, 11, 2, 1, 9, 11, 9, 8, 11],
+        [3, 10, 1, 11, 10, 3],
+        [0, 10, 1, 0, 8, 10, 8, 11, 10],
+        [3, 9, 0, 3, 11, 9, 11, 10, 9],
+        [9, 8, 10, 10, 8, 11],
+        [4, 7, 8],
+        [4, 3, 0, 7, 3, 4],
+        [0, 1, 9, 8, 4, 7],
+        [4, 1, 9, 4, 7, 1, 7, 3, 1],
+        [1, 2, 10, 8, 4, 7],
+        [3, 4, 7, 3, 0, 4, 1, 2, 10],
+        [9, 2, 10, 9, 0, 2, 8, 4, 7],
+        [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4],
+        [8, 4, 7, 3, 11, 2],
+        [11, 4, 7, 11, 2, 4, 2, 0, 4],
+        [9, 0, 1, 8, 4, 7, 2, 3, 11],
+        [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1],
+        [3, 10, 1, 3, 11, 10, 7, 8, 4],
+        [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4],
+        [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3],
+        [4, 7, 11, 4, 11, 9, 9, 11, 10],
+        [9, 5, 4],
+        [9, 5, 4, 0, 8, 3],
+        [0, 5, 4, 1, 5, 0],
+        [8, 5, 4, 8, 3, 5, 3, 1, 5],
+        [1, 2, 10, 9, 5, 4],
+        [3, 0, 8, 1, 2, 10, 4, 9, 5],
+        [5, 2, 10, 5, 4, 2, 4, 0, 2],
+        [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8],
+        [9, 5, 4, 2, 3, 11],
+        [0, 11, 2, 0, 8, 11, 4, 9, 5],
+        [0, 5, 4, 0, 1, 5, 2, 3, 11],
+        [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5],
+        [10, 3, 11, 10, 1, 3, 9, 5, 4],
+        [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10],
+        [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3],
+        [5, 4, 8, 5, 8, 10, 10, 8, 11],
+        [9, 7, 8, 5, 7, 9],
+        [9, 3, 0, 9, 5, 3, 5, 7, 3],
+        [0, 7, 8, 0, 1, 7, 1, 5, 7],
+        [1, 5, 3, 3, 5, 7],
+        [9, 7, 8, 9, 5, 7, 10, 1, 2],
+        [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3],
+        [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2],
+        [2, 10, 5, 2, 5, 3, 3, 5, 7],
+        [7, 9, 5, 7, 8, 9, 3, 11, 2],
+        [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11],
+        [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7],
+        [11, 2, 1, 11, 1, 7, 7, 1, 5],
+        [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11],
+        [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0],
+        [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0],
+        [11, 10, 5, 7, 11, 5],
+        [10, 6, 5],
+        [0, 8, 3, 5, 10, 6],
+        [9, 0, 1, 5, 10, 6],
+        [1, 8, 3, 1, 9, 8, 5, 10, 6],
+        [1, 6, 5, 2, 6, 1],
+        [1, 6, 5, 1, 2, 6, 3, 0, 8],
+        [9, 6, 5, 9, 0, 6, 0, 2, 6],
+        [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8],
+        [2, 3, 11, 10, 6, 5],
+        [11, 0, 8, 11, 2, 0, 10, 6, 5],
+        [0, 1, 9, 2, 3, 11, 5, 10, 6],
+        [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11],
+        [6, 3, 11, 6, 5, 3, 5, 1, 3],
+        [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6],
+        [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9],
+        [6, 5, 9, 6, 9, 11, 11, 9, 8],
+        [5, 10, 6, 4, 7, 8],
+        [4, 3, 0, 4, 7, 3, 6, 5, 10],
+        [1, 9, 0, 5, 10, 6, 8, 4, 7],
+        [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4],
+        [6, 1, 2, 6, 5, 1, 4, 7, 8],
+        [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7],
+        [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6],
+        [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9],
+        [3, 11, 2, 7, 8, 4, 10, 6, 5],
+        [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11],
+        [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6],
+        [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6],
+        [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6],
+        [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11],
+        [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7],
+        [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9],
+        [10, 4, 9, 6, 4, 10],
+        [4, 10, 6, 4, 9, 10, 0, 8, 3],
+        [10, 0, 1, 10, 6, 0, 6, 4, 0],
+        [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10],
+        [1, 4, 9, 1, 2, 4, 2, 6, 4],
+        [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4],
+        [0, 2, 4, 4, 2, 6],
+        [8, 3, 2, 8, 2, 4, 4, 2, 6],
+        [10, 4, 9, 10, 6, 4, 11, 2, 3],
+        [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6],
+        [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10],
+        [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1],
+        [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3],
+        [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1],
+        [3, 11, 6, 3, 6, 0, 0, 6, 4],
+        [6, 4, 8, 11, 6, 8],
+        [7, 10, 6, 7, 8, 10, 8, 9, 10],
+        [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10],
+        [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0],
+        [10, 6, 7, 10, 7, 1, 1, 7, 3],
+        [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7],
+        [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9],
+        [7, 8, 0, 7, 0, 6, 6, 0, 2],
+        [7, 3, 2, 6, 7, 2],
+        [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7],
+        [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7],
+        [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11],
+        [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1],
+        [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6],
+        [0, 9, 1, 11, 6, 7],
+        [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0],
+        [7, 11, 6],
+        [7, 6, 11],
+        [3, 0, 8, 11, 7, 6],
+        [0, 1, 9, 11, 7, 6],
+        [8, 1, 9, 8, 3, 1, 11, 7, 6],
+        [10, 1, 2, 6, 11, 7],
+        [1, 2, 10, 3, 0, 8, 6, 11, 7],
+        [2, 9, 0, 2, 10, 9, 6, 11, 7],
+        [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8],
+        [7, 2, 3, 6, 2, 7],
+        [7, 0, 8, 7, 6, 0, 6, 2, 0],
+        [2, 7, 6, 2, 3, 7, 0, 1, 9],
+        [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6],
+        [10, 7, 6, 10, 1, 7, 1, 3, 7],
+        [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8],
+        [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7],
+        [7, 6, 10, 7, 10, 8, 8, 10, 9],
+        [6, 8, 4, 11, 8, 6],
+        [3, 6, 11, 3, 0, 6, 0, 4, 6],
+        [8, 6, 11, 8, 4, 6, 9, 0, 1],
+        [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6],
+        [6, 8, 4, 6, 11, 8, 2, 10, 1],
+        [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6],
+        [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9],
+        [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3],
+        [8, 2, 3, 8, 4, 2, 4, 6, 2],
+        [0, 4, 2, 4, 6, 2],
+        [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8],
+        [1, 9, 4, 1, 4, 2, 2, 4, 6],
+        [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1],
+        [10, 1, 0, 10, 0, 6, 6, 0, 4],
+        [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3],
+        [10, 9, 4, 6, 10, 4],
+        [4, 9, 5, 7, 6, 11],
+        [0, 8, 3, 4, 9, 5, 11, 7, 6],
+        [5, 0, 1, 5, 4, 0, 7, 6, 11],
+        [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5],
+        [9, 5, 4, 10, 1, 2, 7, 6, 11],
+        [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5],
+        [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2],
+        [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6],
+        [7, 2, 3, 7, 6, 2, 5, 4, 9],
+        [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7],
+        [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0],
+        [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8],
+        [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7],
+        [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4],
+        [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10],
+        [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10],
+        [6, 9, 5, 6, 11, 9, 11, 8, 9],
+        [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5],
+        [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11],
+        [6, 11, 3, 6, 3, 5, 5, 3, 1],
+        [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6],
+        [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10],
+        [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5],
+        [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3],
+        [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2],
+        [9, 5, 6, 9, 6, 0, 0, 6, 2],
+        [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8],
+        [1, 5, 6, 2, 1, 6],
+        [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6],
+        [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0],
+        [0, 3, 8, 5, 6, 10],
+        [10, 5, 6],
+        [11, 5, 10, 7, 5, 11],
+        [11, 5, 10, 11, 7, 5, 8, 3, 0],
+        [5, 11, 7, 5, 10, 11, 1, 9, 0],
+        [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1],
+        [11, 1, 2, 11, 7, 1, 7, 5, 1],
+        [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11],
+        [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7],
+        [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2],
+        [2, 5, 10, 2, 3, 5, 3, 7, 5],
+        [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5],
+        [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2],
+        [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2],
+        [1, 3, 5, 3, 7, 5],
+        [0, 8, 7, 0, 7, 1, 1, 7, 5],
+        [9, 0, 3, 9, 3, 5, 5, 3, 7],
+        [9, 8, 7, 5, 9, 7],
+        [5, 8, 4, 5, 10, 8, 10, 11, 8],
+        [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0],
+        [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5],
+        [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4],
+        [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8],
+        [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11],
+        [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5],
+        [9, 4, 5, 2, 11, 3],
+        [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4],
+        [5, 10, 2, 5, 2, 4, 4, 2, 0],
+        [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9],
+        [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2],
+        [8, 4, 5, 8, 5, 3, 3, 5, 1],
+        [0, 4, 5, 1, 0, 5],
+        [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5],
+        [9, 4, 5],
+        [4, 11, 7, 4, 9, 11, 9, 10, 11],
+        [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11],
+        [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11],
+        [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4],
+        [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2],
+        [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3],
+        [11, 7, 4, 11, 4, 2, 2, 4, 0],
+        [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4],
+        [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9],
+        [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7],
+        [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10],
+        [1, 10, 2, 8, 7, 4],
+        [4, 9, 1, 4, 1, 7, 7, 1, 3],
+        [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1],
+        [4, 0, 3, 7, 4, 3],
+        [4, 8, 7],
+        [9, 10, 8, 10, 11, 8],
+        [3, 0, 9, 3, 9, 11, 11, 9, 10],
+        [0, 1, 10, 0, 10, 8, 8, 10, 11],
+        [3, 1, 10, 11, 3, 10],
+        [1, 2, 11, 1, 11, 9, 9, 11, 8],
+        [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9],
+        [0, 2, 11, 8, 0, 11],
+        [3, 2, 11],
+        [2, 3, 8, 2, 8, 10, 10, 8, 9],
+        [9, 10, 2, 0, 9, 2],
+        [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8],
+        [1, 10, 2],
+        [1, 3, 8, 9, 1, 8],
+        [0, 9, 1],
+        [0, 3, 8],
+        []
+    ]
+ 
+    edge_shifts = np.array([
+        [0, 0, 0, 0],   
+        [1, 0, 0, 1],
+        [0, 1, 0, 0],
+        [0, 0, 0, 1],
+        [0, 0, 1, 0],
+        [1, 0, 1, 1],
+        [0, 1, 1, 0],
+        [0, 0, 1, 1],
+        [0, 0, 0, 2],
+        [1, 0, 0, 2],
+        [1, 1, 0, 2],
+        [0, 1, 0, 2]
+    ], dtype=np.uint16) 
+ 
+    n_table_faces = np.array([len(f)/3 for f in triTable], dtype=np.ubyte)
+    face_shift_tables = [None]
+    for i in range(1, 6):
+        faceTableI = np.zeros((len(triTable), i*3), dtype=np.ubyte)
+        faceTableInds = np.argwhere(n_table_faces == i)[:, 0]
+        faceTableI[faceTableInds] = np.array([triTable[j] for j in faceTableInds])
+        faceTableI = faceTableI.reshape((len(triTable), i, 3))
+        face_shift_tables.append(edge_shifts[faceTableI])
+ 
+    return face_shift_tables, edge_shifts, edge_table, n_table_faces
+
+def _isosurface(data, level):
+    """返回基于MarchingCube算法的等值面"""
+ 
+    data = np.ascontiguousarray(data)
+    mask = data < level
+    face_shift_tables, edge_shifts, edge_table, n_table_faces = _get_data_cache()
+ 
+    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)
+    fields = np.empty((2, 2, 2), dtype=object)
+    slices = [slice(0, -1), slice(1, None)]
+    for i in [0, 1]:
+        for j in [0, 1]:
+            for k in [0, 1]:
+                fields[i, j, k] = mask[slices[i], slices[j], slices[k]]
+                vertIndex = i - 2*j*i + 3*j + 4*k
+                index += (fields[i, j, k] * 2**vertIndex).astype(np.ubyte)
+ 
+    cut_edges = np.zeros([x+1 for x in index.shape]+[3], dtype=np.uint32)
+    edges = edge_table[index]
+    for i, shift in enumerate(edge_shifts[:12]):        
+        slices = [slice(shift[j], cut_edges.shape[j]+(shift[j]-1)) 
+                  for j in range(3)]
+        cut_edges[slices[0], slices[1], slices[2], shift[3]] += edges & 2**i
+ 
+    m = cut_edges > 0
+    vertex_inds = np.argwhere(m)
+    vertexes = vertex_inds[:, :3].astype(np.float32).copy()
+    dataFlat = data.reshape(data.shape[0]*data.shape[1]*data.shape[2])
+ 
+    cut_edges[vertex_inds[:, 0], 
+              vertex_inds[:, 1], 
+              vertex_inds[:, 2], 
+              vertex_inds[:, 3]] = np.arange(vertex_inds.shape[0])
+ 
+    for i in [0, 1, 2]:
+        vim = vertex_inds[:, 3] == i
+        vi = vertex_inds[vim, :3]
+        vi_flat = (vi * (np.array(data.strides[:3]) // data.itemsize)[np.newaxis, :]).sum(axis=1)
+        v1 = dataFlat[vi_flat]
+        v2 = dataFlat[vi_flat + data.strides[i]//data.itemsize]
+        vertexes[vim, i] += (level-v1) / (v2-v1)
+ 
+    n_faces = n_table_faces[index]
+    tot_faces = n_faces.sum()
+    faces = np.empty((tot_faces, 3), dtype=np.uint32)
+    ptr = 0
+ 
+    cs = np.array(cut_edges.strides)//cut_edges.itemsize
+    cut_edges = cut_edges.flatten()
+ 
+    for i in range(1, 6):
+        cells = np.argwhere(n_faces == i)  
+        if cells.shape[0] == 0:
+            continue
+        cellInds = index[cells[:, 0], cells[:, 1], cells[:, 2]]
+ 
+        verts = face_shift_tables[i][cellInds]
+        verts[..., :3] += (cells[:, np.newaxis, np.newaxis, :]).astype(np.uint16)
+        verts = verts.reshape((verts.shape[0]*i,)+verts.shape[2:])
+ 
+        verts = (verts * cs[np.newaxis, np.newaxis, :]).sum(axis=2)
+        vert_inds = cut_edges[verts]
+        nv = vert_inds.shape[0]
+        faces[ptr:ptr+nv] = vert_inds
+        ptr += nv
+ 
+    return vertexes, faces
+
```

## wxgl/wxfigure.py

```diff
@@ -1,309 +1,253 @@
-# -*- coding: utf-8 -*-
-
-import os, wx
-import uuid
-import wx.lib.agw.aui as aui
-import numpy as np
-
-from . import scene
-from . import colormap
-
-
-BASE_PATH = os.path.dirname(__file__)
-
-
-class FigureFrame(wx.Frame):
-    """"""
-    
-    ID_RESTORE = wx.NewIdRef()      # 回到初始状态
-    ID_AXES = wx.NewIdRef()         # 坐标轴
-    ID_GRID = wx.NewIdRef()         # 网格
-    ID_ARGS = wx.NewIdRef()         # 设置
-    ID_SAVE = wx.NewIdRef()         # 保存
-    
-    def __init__(self, parent, size=(800,600), **kwds):
-        """构造函数"""
-        
-        for key in kwds:
-            if key not in ['head', 'zoom', 'proj', 'mode', 'aim', 'dist', 'view', 'elevation', 'azimuth', 'interval', 'style']:
-                raise KeyError('不支持的关键字参数：%s'%key)
-        
-        mode = kwds.get('mode', '3D')
-        
-        wx.Frame.__init__(self, None, -1, u'wxPlot', style=wx.DEFAULT_FRAME_STYLE)
-        self.parent = parent
-        self.SetSize(size)
-        self.Center()
-        
-        icon = wx.Icon(os.path.join(BASE_PATH, 'res', 'wxgl.ico'))
-        self.SetIcon(icon)
-        
-        bmp_restore = wx.Bitmap(os.path.join(BASE_PATH, 'res', 'tb_restore.png'), wx.BITMAP_TYPE_ANY)
-        bmp_axes = wx.Bitmap(os.path.join(BASE_PATH, 'res', 'tb_axes.png'), wx.BITMAP_TYPE_ANY)
-        bmp_grid = wx.Bitmap(os.path.join(BASE_PATH, 'res', 'tb_grid.png'), wx.BITMAP_TYPE_ANY)
-        bmp_args = wx.Bitmap(os.path.join(BASE_PATH, 'res', 'tb_args.png'), wx.BITMAP_TYPE_ANY)
-        bmp_save = wx.Bitmap(os.path.join(BASE_PATH, 'res', 'tb_save.png'), wx.BITMAP_TYPE_ANY)
-        
-        self.tb = aui.AuiToolBar(self, -1, wx.DefaultPosition, wx.DefaultSize)
-        self.tb.SetToolBitmapSize(wx.Size(32, 32))
-        self.tb.AddSimpleTool(self.ID_RESTORE, '复位', bmp_restore, '回到初始状态')
-        self.tb.AddSeparator()
-        if mode == '3D':
-            self.tb.AddSimpleTool(self.ID_AXES, '坐标轴', bmp_axes, '显示/隐藏坐标轴')
-            self.tb.AddSimpleTool(self.ID_GRID, '网格', bmp_grid, '显示/隐藏网格')
-        self.tb.AddSimpleTool(self.ID_ARGS, '背景', bmp_args, '设置背景颜色')
-        self.tb.AddSeparator()
-        self.tb.AddSimpleTool(self.ID_SAVE, '保存', bmp_save, '保存为文件')
-        self.tb.Realize()
-        
-        self.scene = scene.WxGLScene(self, **kwds)
-        
-        self._mgr = aui.AuiManager()
-        self._mgr.SetManagedWindow(self)
-        self._mgr.AddPane(self.scene, aui.AuiPaneInfo().Name('Scene').CenterPane().Show())
-        self._mgr.AddPane(self.tb, aui.AuiPaneInfo().Name('ToolBar').ToolbarPane().Bottom().Floatable(False))
-        self._mgr.Update()
-        
-        self.Bind(wx.EVT_MENU, self.on_restore, id=self.ID_RESTORE)
-        self.Bind(wx.EVT_MENU, self.on_args, id=self.ID_ARGS)
-        self.Bind(wx.EVT_MENU, self.on_save, id=self.ID_SAVE)
-        
-        if mode == '3D':
-            self.Bind(wx.EVT_MENU, self.on_axes, id=self.ID_AXES)
-            self.Bind(wx.EVT_MENU, self.on_grid, id=self.ID_GRID)
-        
-        # 创建axes视区，并添加部件
-        if mode == '3D':
-            self.xyz = self.scene.add_region((0,0,0.15,0.15))
-            self.xyz.coordinate(name='xyz')
-        
-        self.xyz_visible = True
-        self.grid_visible = False
-    
-    def on_restore(self, evt):
-        """回到初始状态"""
-        
-        self.scene.reset_posture()
-    
-    def on_axes(self, evt):
-        """显示/隐藏坐标轴"""
-        
-        self.xyz_visible = not self.xyz_visible
-        self.xyz.set_model_visible('xyz', self.xyz_visible)
-        self.xyz.refresh()
-    
-    def on_grid(self, evt):
-        """显示/隐藏网格"""
-        
-        self.grid_visible = not self.grid_visible
-        for ax in self.parent.subgraphs:
-            if ax.reg_main.grid_tick:
-                ax.reg_main.hide_ticks()
-            else:
-                ax.reg_main.ticks(**ax.reg_main.grid_tick_kwds)
-    
-    def on_args(self, evt):
-        """调整参数"""
-        
-        choices = ['暗黑', '纯白', '浅灰', '幽蓝']
-        styles = ['black', 'white', 'gray', 'blue']
-        dlg = wx.SingleChoiceDialog(self, '请选择配色方案', '设置背景颜色', choices, wx.CHOICEDLG_STYLE)
-        dlg.SetSelection(styles.index(self.scene.style))
-        
-        if dlg.ShowModal() == wx.ID_OK:
-            style = styles[choices.index(dlg.GetStringSelection())]
-            if style != self.scene.style:
-                self.scene.set_style(style)
-                self.scene.init_gl()
-                
-                for rid in self.scene.regions:
-                    reg = self.scene.regions[rid]
-                    reg.assembly = dict()
-                    reg.models = dict()
-                
-                self.parent.draw()
-                
-                if self.scene.mode == '3D':
-                    self.xyz.coordinate(name='xyz')
-                    if not self.xyz_visible:
-                        self.xyz.set_model_visible('xyz', False)
-                        self.xyz.refresh()
-                    
-                    if self.grid_visible:
-                        for ax in self.parent.subgraphs:
-                            ax.reg_main.show_ticks()
-        dlg.Destroy()
-    
-    def on_save(self, evt):
-        """保存为文件"""
-        
-        dlg = wx.FileDialog(self, 
-            message = "保存为文件...", 
-            defaultDir = os.getcwd(),
-            defaultFile = "", 
-            wildcard = 'PNG (*.png)|*.png|JPG (*.jpg)|*.jpg',
-            style = wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT
-        )
-        
-        if dlg.ShowModal() == wx.ID_OK:
-            fn = dlg.GetPaths()[0]
-            self.scene.save_scene(fn, alpha=True, buffer='FRONT')
-        
-        dlg.Destroy()
-        
-
-class Figure:
-    """wxplot的API"""
-    
-    def __init__(self, size=(800,600), **kwds):
-        """构造函数
-        
-        size        - 画布分辨率
-        kwds        - 关键字参数
-                        head        - 定义方向：'x+'|'y+'|'z+'
-                        zoom        - 视口缩放因子
-                        mode        - 2D/3D模式
-                        aim         - 观察焦点
-                        dist        - 相机位置与目标点位之间的距离
-                        view        - 视景体
-                        elevation   - 仰角
-                        azimuth     - 方位角
-                        interval    - 模型动画帧间隔时间（单位：ms）
-                        style       - 场景风格，'black'|'white'|'gray'
-        """
-        
-        for key in kwds:
-            if key not in ['head', 'zoom', 'proj', 'mode', 'aim', 'dist', 'view', 'elevation', 'azimuth', 'interval', 'style']:
-                raise KeyError('不支持的关键字参数：%s'%key)
-        
-        if 'elevation' not in kwds:
-            kwds.update({'elevation':10})
-        if 'azimuth' not in kwds:
-            kwds.update({'azimuth':30})
-        
-        self.size = size
-        self.kwds = kwds
-        
-        self.cm = colormap.WxGLColorMap()
-        self.app = None
-        self.ff = None
-        self.curr_ax = None
-        self.assembly = list()
-        self.subgraphs = list()
-    
-    def create_frame(self):
-        """生成窗体"""
-        
-        if not self.app:
-            self.app = wx.App()
-        
-        if not self.ff:
-            self.ff = FigureFrame(self, size=self.size, **self.kwds)
-            self.curr_ax = None
-            self.assembly = list()
-            self.subgraphs = list()
-    
-    def destroy_frame(self):
-        """销毁窗体"""
-        
-        self.app.Destroy()
-        
-        del self.ff
-        del self.app
-        
-        self.app = None
-        self.ff = None
-    
-    def draw(self):
-        """绘制"""
-        
-        for item in self.assembly:
-            getattr(item[0], item[1])(*item[2], **item[3])
-        
-        if self.ff.scene.mode == '2D':
-            for ax in self.subgraphs:
-                ax.reg_main.ticks2d()
-    
-    def show(self, rotation=None, **kwds):
-        """显示画布
-        
-        rotation    - 旋转模式
-                        None        - 无旋转
-                        'h+'        - 水平顺时针旋转（默认方式）
-                        'h-'        - 水平逆时针旋转
-                        'v+'        - 垂直前翻旋转
-                        'v-'        - 垂直后翻旋转
-        kwds        - 关键字参数
-                        elevation   - 初始仰角，以度（°）为单位，默认值为0
-                        azimuth     - 初始方位角以度（°）为单位，默认值为0
-                        step        - 帧增量，以度（°）为单位，默认值为5
-                        interval    - 帧间隔，以ms为单位，默认值为20
-        """
-        
-        self.create_frame()
-        try:
-            self.draw()
-            self.ff.Show()
-            self.ff.scene.start_slide()
-            if rotation:
-                self.ff.scene.auto_rotate(rotation=rotation, **kwds)
-        except Exception as e:
-            print(str(e))
-        finally:
-            self.app.MainLoop()
-            self.destroy_frame()
-    
-    def savefig(self, fn, alpha=False):
-        """保存画布为文件
-        
-        fn          - 文件名
-        alpha       - 透明通道开关
-        """
-        
-        self.create_frame()
-        try:
-            self.draw()
-            self.ff.Show()
-            self.ff.scene.save_scene(fn, alpha=alpha)
-        except Exception as e:
-            print(str(e))
-        finally:
-            self.ff.Destroy()
-            self.destroy_frame()
-    
-    def add_axes(self, pos, padding=(20,20,20,20)):
-        """添加子图
-        
-        pos         - 子图在场景中的位置和大小
-                        三位数字    - 指定分割画布的行数、列数和子图序号。例如，223表示两行两列的第3个位置
-                        四元组      - 以画布左下角为原点，宽度和高度都是1。四元组分别表示子图左下角在画布上的水平、垂直位置和宽度、高度
-        padding     - 四元组，上、右、下、左四个方向距离边缘的留白像素
-        """
-        
-        self.create_frame()
-        ax = self.ff.scene.add_axes(pos, padding=padding)
-        self.subgraphs.append(ax)
-        self.curr_ax = ax
-        
-        return ax
-    
-    def cmap(self, *args, **kwds):
-        """数值颜色映射
-        
-        data        - 数据
-        cm          - 颜色映射表名
-        kwds        - 关键字参数
-                        invalid     - 无效数据的标识
-                        invalid_c   - 无效数据的颜色
-                        datamax     - 数据最大值，默认为None
-                        datamin     - 数据最小值，默认为None
-                        alpha       - 透明度，None表示返回RGB格式
-        """
-        
-        return self.cm.cmap(*args, **kwds)
-    
-    def add_widget(self, reg, func, *args, **kwds):
-        """添加部件"""
-        
-        self.assembly.append([reg, func, list(args), kwds])
-        
+#!/usr/bin/env python3
+
+import os, sys, time
+import numpy as np
+import threading
+import imageio
+import wx
+import wx.lib.agw.aui as aui
+from wx.lib.embeddedimage import PyEmbeddedImage
+from . wxscene import WxScene
+from . import imgres
+
+if sys.platform.lower() != 'darwin':
+    import webp
+
+class WxFigure(wx.Frame):
+    """构造函数"""
+
+    ID_RESTORE = wx.NewIdRef()  # 相机复位
+    ID_SAVE = wx.NewIdRef()     # 保存
+    ID_ANIMATE = wx.NewIdRef()  # 动画播放/暂停
+
+    def __init__(self, scheme, **kwds):
+        """构造函数
+
+        scheme      - 展示方案
+        kwds        - 关键字参数
+            outfile     - 输出文件名
+            ext         - 输出文件扩展名
+            dpi         - 图像文件每英寸像素数
+            fps         - 动画文件帧率
+            frames      - 动画文件总帧数
+            loop        - gif文件播放次数，0表示循环播放
+            quality     - webp文件质量，100表示最高品质
+        """
+ 
+        self.outfile = kwds.get('outfile')
+        self.ext = kwds.get('ext')
+        self.dpi = kwds.get('dpi')
+        self.fps = kwds.get('fps')
+        self.frames = kwds.get('frames')
+        self.loop = kwds.get('loop')
+        self.quality = kwds.get('quality')
+
+        size = scheme.kwds.get('size', (960,640))
+        wx.Frame.__init__(self, None, -1, 'WxGL', size=size, style=wx.DEFAULT_FRAME_STYLE)
+ 
+        self.SetIcon(PyEmbeddedImage(imgres.data['appicon']).GetIcon())
+        self.Center()
+
+        bmp_save = PyEmbeddedImage(imgres.data['save']).GetBitmap()
+        bmp_home = PyEmbeddedImage(imgres.data['home']).GetBitmap()
+        self.bmp_play = PyEmbeddedImage(imgres.data['play']).GetBitmap()
+        self.bmp_pause = PyEmbeddedImage(imgres.data['pause']).GetBitmap()
+ 
+        self.tb = aui.AuiToolBar(self, -1, wx.DefaultPosition, wx.DefaultSize, agwStyle=aui.AUI_TB_OVERFLOW|aui.AUI_TB_VERTICAL)
+        self.tb.SetToolBitmapSize(wx.Size(32, 32))
+ 
+        self.tb.AddSimpleTool(self.ID_SAVE, '保存', bmp_save, '保存画布')
+        self.tb.AddSimpleTool(self.ID_RESTORE, '复位', bmp_home, '初始位置')
+        self.tb.AddSimpleTool(self.ID_ANIMATE, '动画', self.bmp_play, '动画', kind=aui.ITEM_CHECK)
+ 
+        if scheme.alive:
+            self.tb.SetToolBitmap(self.ID_ANIMATE, self.bmp_pause)
+            self.tb.SetToolShortHelp(self.ID_ANIMATE, '暂停')
+        else:
+            self.tb.EnableTool(self.ID_ANIMATE, False)
+
+        self.tb.Realize()
+        self.sb = self.CreateStatusBar()
+        self.scene = WxScene(self, scheme, **scheme.kwds)
+        
+        self.Show()
+
+        self._mgr = aui.AuiManager()
+        self._mgr.SetManagedWindow(self)
+        self._mgr.AddPane(self.scene, aui.AuiPaneInfo().Name('Scene').CenterPane().Show())
+        self._mgr.AddPane(self.tb, aui.AuiPaneInfo().Name('ToolBar').ToolbarPane().Left())
+        self._mgr.Update()
+
+        self.Bind(wx.EVT_MENU, self.on_home, id=self.ID_RESTORE)
+        self.Bind(wx.EVT_MENU, self.on_save, id=self.ID_SAVE)
+        self.Bind(wx.EVT_MENU, self.on_pause, id=self.ID_ANIMATE)
+        self.scene.Bind(wx.EVT_KEY_DOWN, self.on_key_down)
+        self.scene.Bind(wx.EVT_KEY_UP, self.on_key_up)
+        
+        if not self.outfile is None:
+            self.cn = 0
+            threading_record = threading.Thread(target=self.create_file)
+            threading_record.setDaemon(True)
+            threading_record.start()
+
+    def on_key_down(self, evt):
+        """键盘按下"""
+
+        key = evt.GetKeyCode()
+        if key == wx.WXK_CONTROL:
+            self.scene.ctrl_down = True
+
+    def on_key_up(self, evt):
+        """键盘弹起"""
+
+        key = evt.GetKeyCode()
+        if key == wx.WXK_CONTROL:
+            self.scene.ctrl_down = False
+        elif key == wx.WXK_ESCAPE:
+            wx.CallAfter(self.scene.home)
+
+    def on_home(self, evt):
+        """恢复初始位置和姿态"""
+
+        self.scene.home()
+
+    def on_save(self, evt):
+        """将缓冲区保存为图像文件"""
+
+        im = self.scene.get_buffer()
+
+        wildcard = 'PNG files (*.png)|*.png|JPEG file (*.jpg)|*.jpg'
+        dlg = wx.FileDialog(self, message='保存为文件', wildcard=wildcard, style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
+        dlg.SetFilterIndex(0)
+ 
+        if dlg.ShowModal() == wx.ID_OK:
+            fn = dlg.GetPath()
+            name, ext = os.path.splitext(fn)
+            
+            if ext != '.png' and ext != '.jpg':
+                ext = ['.png', '.jpg'][dlg.GetFilterIndex()]
+
+            if ext == '.jpg':
+                im.convert('RGB').save('%s%s'%(name, ext))
+            else:
+                im.save('%s%s'%(name, ext))
+        
+        dlg.Destroy()
+
+    def on_pause(self, evt):
+        """动画/暂停"""
+
+        self.scene.pause()
+
+        if self.scene.playing:
+            self.tb.SetToolBitmap(self.ID_ANIMATE, self.bmp_pause)
+            self.tb.SetToolShortHelp(self.ID_ANIMATE, '暂停')
+        else:
+            self.tb.SetToolBitmap(self.ID_ANIMATE, self.bmp_play)
+            self.tb.SetToolShortHelp(self.ID_ANIMATE, '动画')
+        
+        self.tb.Realize()
+
+    def create_file(self):
+        """生成图像或动画文件的线程函数"""
+ 
+        self.scene.increment = False
+        self.scene.duration = 0
+        ft = round(1000/self.fps)
+
+        self.scene.Refresh(False)
+        while not self.scene.gl_init_done:
+            time.sleep(0.01)
+
+        if self.ext in ('.png', '.jpg', '.jpeg'):
+            self.scene.duration = 0
+            time.sleep(0.01)
+
+            self.scene.painted = False
+            self.scene.Refresh(False)
+            while not self.scene.painted:
+                time.sleep(0.01)
+
+            self.scene.im_pil = None
+            wx.CallAfter(self.scene.capture, mode='RGBA' if self.ext=='.png' else 'RGB')
+            while self.scene.im_pil is None:
+                time.sleep(0.01)
+
+            if isinstance(self.dpi, (int, float)):
+                self.scene.im_pil.save(self.outfile, dpi=(self.dpi, self.dpi))
+            else:
+                self.scene.im_pil.save(self.outfile)
+        elif self.ext == '.webp':
+            enc = webp.WebPAnimEncoder.new(*self.scene.csize)
+            cfg = webp.WebPConfig.new(quality=100)
+            timestamp_ms = 0
+            while self.cn < self.frames:
+                self.scene.duration = self.cn * ft
+                time.sleep(0.01)
+
+                self.scene.painted = False
+                self.scene.Refresh(False)
+                while not self.scene.painted:
+                    time.sleep(0.01)
+
+                self.scene.im_pil = None
+                wx.CallAfter(self.scene.capture)
+                while self.scene.im_pil is None:
+                    time.sleep(0.01)
+
+                pic = webp.WebPPicture.from_pil(self.scene.im_pil)
+                enc.encode_frame(pic, timestamp_ms, cfg)
+                timestamp_ms += ft
+                self.cn += 1
+
+            anim_data = enc.assemble(timestamp_ms)
+            with open(self.outfile, 'wb') as fp:
+                fp.write(anim_data.buffer())
+        else:
+            if self.ext == '.gif':
+                writer = imageio.get_writer(self.outfile, fps=self.fps, loop=self.loop)
+                crop = False
+            else:
+                writer = imageio.get_writer(self.outfile, fps=self.fps)
+                crop = True
+ 
+            while self.cn < self.frames:
+                self.scene.duration = self.cn * ft
+                time.sleep(0.01)
+
+                self.scene.painted = False
+                self.scene.Refresh(False)
+                while not self.scene.painted:
+                    time.sleep(0.01)
+
+                self.scene.im_pil = None
+                wx.CallAfter(self.scene.capture, crop=crop)
+                while self.scene.im_pil is None:
+                    time.sleep(0.01)
+ 
+                im = np.array(self.scene.im_pil)
+                writer.append_data(im)
+                self.cn +=1
+ 
+            writer.close()
+
+        wx.CallAfter(self.Close)
+
+def show_wxfigure(scheme, **kwds):
+    """保存画布为图像文件或动画文件
+
+    kwds        - 关键字参数
+        outfile     - 输出文件名
+        ext         - 输出文件扩展名
+        dpi         - 图像文件每英寸像素数
+        fps         - 动画文件帧率
+        frames      - 动画文件总帧数
+        loop        - gif文件播放次数，0表示循环播放
+        quality     - webp文件质量，100表示最高品质
+    """
+
+    app = wx.App()
+    fig = WxFigure(scheme, **kwds)
+    app.MainLoop()
+    app.Destroy()
+
```

## Comparing `wxgl/cm.py` & `wxgl/color.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,215 +1,176 @@
-# -*- coding: utf-8 -*-
-
-import re
-import numpy as np
-import matplotlib
-from matplotlib import cm as mcm
-#from scipy.ndimage import filters
-
-class ColorManager:
-    """颜色管理类"""
-    
-    def __init__(self):
-        """构造函数"""
-        
-        self.default_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']
-        self._colors = matplotlib.colors.cnames
-        self._cmaps = [
-            'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 
-            'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 
-            'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBu_r', 
-            'PuBuGn', 'PuBuGn_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 
-            'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 
-            'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGn_r', 'YlGnBu', 'YlGnBu_r', 'YlOrBr', 'YlOrBr_r', 
-            'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 
-            'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'cubehelix', 'cubehelix_r', 
-            'flag', 'flag_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 
-            'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot_r', 
-            'gnuplot2', 'gnuplot2_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 
-            'magma', 'magma_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 
-            'prism', 'prism_r', 'rainbow', 'rainbow_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 
-            'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'twilight', 'twilight_r', 
-            'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'winter', 'winter_r'
-        ]
-    
-    @property    
-    def color_list(self):
-        """颜色列表"""
-        
-        return list(self._colors.keys())
-    
-    @property
-    def cmap_list(self):
-        """调色板列表"""
-        
-        return self._cmaps
-    
-    def color_help(self):
-        """返回颜色中英文对照表"""
-        
-        return [
-            ('aliceblue', '爱丽丝蓝'), ('antiquewhite', '古董白'), ('aqua', '青'), ('aquamarine', '碧绿'), ('azure', '青白'), 
-            ('beige', '米'), ('bisque', '橘黄'), ('black', '黑'), ('blanchedalmond', '杏仁白'), ('blue', '蓝'), ('blueviolet', '蓝紫'), 
-            ('brown', '褐'), ('burlywood', '硬木褐'), ('cadetblue', '军服蓝'), ('chartreuse', '查特酒绿'), ('chocolate', '巧克力'), 
-            ('coral', '珊瑚红'), ('cornflowerblue', '矢车菊蓝'), ('cornsilk', '玉米穗黄'), ('crimson', '绯红'), ('cyan', '青'), 
-            ('darkblue', '深蓝'), ('darkcyan', '深青'), ('darkgoldenrod', '深金菊黄'), ('darkgray', '暗灰'), ('darkgreen', '深绿'), 
-            ('darkgrey', '暗灰'), ('darkkhaki', '深卡其'), ('darkmagenta', '深品红'), ('darkolivegreen', '深橄榄绿'), ('darkorange', '深橙'), 
-            ('darkorchid', '深洋兰紫'), ('darkred', '深红'), ('darksalmon', '深鲑红'), ('darkseagreen', '深海藻绿'), ('darkslateblue', '深岩蓝'), 
-            ('darkslategray', '深岩灰'), ('darkslategrey', '深岩灰'), ('darkturquoise', '深松石绿'), ('darkviolet', '深紫'), ('deeppink', '深粉'), 
-            ('deepskyblue', '深天蓝'), ('dimgray', '昏灰'), ('dimgrey', '昏灰'), ('dodgerblue', '湖蓝'), ('firebrick', '火砖红'), 
-            ('floralwhite', '花卉白'), ('forestgreen', '森林绿'), ('fuchsia', '洋红'), ('gainsboro', '庚氏灰'), ('ghostwhite', '幽灵白'), 
-            ('gold', '金'), ('goldenrod', '金菊'), ('gray', '灰'), ('green', '绿'), ('greenyellow', '黄绿'),  ('honeydew', '蜜瓜绿'), 
-            ('hotpink', '艳粉'), ('indianred', '印度红'), ('indigo', '靛蓝'), ('ivory', '象牙白'), ('khaki', '卡其'), ('lavender', '薰衣草紫'), 
-            ('lavenderblush', '薰衣草红'), ('lawngreen', '草坪绿'), ('lemonchiffon', '柠檬绸黄'), ('lightblue', '浅蓝'), ('lightcoral', '浅珊瑚红'), 
-            ('lightcyan', '浅青'), ('lightgoldenrodyellow', '浅金菊黄'), ('lightgray', '亮灰'), ('lightgreen', '浅绿'), ('lightgrey', '亮灰'), 
-            ('lightpink', '浅粉'), ('lightsalmon', '浅鲑红'), ('lightseagreen', '浅海藻绿'), ('lightskyblue', '浅天蓝'), ('lightslategray', '浅岩灰'), 
-            ('lightslategrey', '浅岩灰'), ('lightsteelblue', '浅钢青'), ('lightyellow', '浅黄'), ('lime', '绿'), ('limegreen', '青柠绿'), 
-            ('linen', '亚麻'), ('magenta', '洋红'), ('maroon', '栗'), ('mediumaquamarine', '中碧绿'), ('mediumblue', '中蓝'), ('mediumorchid', '中洋兰紫'), 
-            ('mediumpurple', '中紫'), ('mediumseagreen', '中海藻绿'), ('mediumslateblue', '中岩蓝'), ('mediumspringgreen', '中嫩绿'), 
-            ('mediumturquoise', '中松石绿'), ('mediumvioletred', '中紫红'), ('midnightblue', '午夜蓝'), ('mintcream', '薄荷乳白'), 
-            ('mistyrose', '雾玫瑰红'), ('moccasin', '鹿皮'), ('navajowhite', '土著白'), ('navy', '藏青'), ('oldlace', '旧蕾丝白'), ('olive', '橄榄'), 
-            ('olivedrab', '橄榄绿'), ('orange', '橙'), ('orangered', '橘红'), ('orchid', '洋兰紫'), ('palegoldenrod', '白金菊黄'), ('palegreen', '白绿'), 
-            ('paleturquoise', '白松石绿'), ('palevioletred', '白紫红'), ('papayawhip', '番木瓜橙'), ('peachpuff', '粉朴桃'), ('peru', '秘鲁红'), 
-            ('pink', '粉'), ('plum', '李紫'), ('powderblue', '粉末蓝'), ('purple', '紫'), ('rebeccapurple', '丽贝卡紫'), ('red', '红'), 
-            ('rosybrown', '玫瑰褐'), ('royalblue', '品蓝'), ('saddlebrown', '鞍褐'), ('salmon', '鲑红'), ('sandybrown', '沙褐'), ('seagreen', '海藻绿'), 
-            ('seashell', '贝壳白'), ('sienna', '土黄赭'), ('silver', '银'), ('skyblue', '天蓝'), ('slateblue', '岩蓝'), ('slategray', '岩灰'), 
-            ('slategrey', '岩灰'), ('snow', '雪白'), ('springgreen', '春绿'), ('steelblue', '钢青'), ('tan', '日晒褐'), ('teal', '鸭翅绿'), 
-            ('thistle', '蓟紫'), ('tomato', '番茄红'), ('turquoise', '松石绿'), ('violet', '紫罗兰'), ('wheat', '麦'), ('white', '白'), 
-            ('whitesmoke', '烟雾白'), ('yellow', '黄'), ('yellowgreen', '暗黄绿')
-        ]
-    
-    def cmap_help(self):
-        """返回调色板分类列表"""
-        
-        return {
-            '视觉均匀类': ['viridis', 'plasma', 'inferno', 'magma', 'cividis'], 
-            '单调变化类': ['Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds', 'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 
-                           'BuPu', 'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn'], 
-            '近似单调类': ['binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink', 'spring', 'summer', 'autumn', 'winter', 
-                           'cool', 'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper'], 
-            '亮度发散类': ['PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu', 'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic'], 
-            '颜色循环类': ['twilight', 'twilight_shifted', 'hsv'],
-            '分段阶梯类': ['Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c'], 
-            '专属定制类': ['flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern', 'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 
-                           'brg', 'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar']
-        }
-    
-    def hex2color(self, str_hex):
-        """以#为前缀的十六进制颜色转numpy数组颜色"""
-        
-        return np.array((int(str_hex[1:3],base=16)/255, int(str_hex[3:5],base=16)/255, int(str_hex[5:],base=16)/255), dtype=np.float64)
-
-    def str2color(self, color):
-        """字符串表示的颜色转numpy数组颜色"""
-        
-        if color in self._colors:
-            return self.hex2color(self._colors[color])
-        elif re.compile(r'#[\da-fA-F]{6}').match(color):
-            return self.hex2color(color)
-        else:
-            raise ValueError('未定义的或不符合规则的颜色：%s'%color)
-    
-    def color2c(self, color, size=None, drop=False):
-        """检查颜色参数，将字符串、元组、列表等类型的颜色转numpy数组颜色
-        
-        color       - 待处理的颜色
-        size        - 返回的颜色数量，有3种可能的类型：None、整型、长度为2的元组或列表
-        drop        - 舍弃alpha通道
-        """
-        
-        if isinstance(color, str):
-            color = self.str2color(color)
-        elif isinstance(color, (list, tuple)):
-            color = np.array(color, dtype=np.float64)
-        
-        if not isinstance(color, np.ndarray):
-            raise ValueError('未定义的或不符合规则的颜色')
-        if color.shape[-1] not in (3,4) or np.nanmin(color) < 0 or np.nanmax(color) > 255:
-            raise ValueError('未定义的或不符合规则的颜色')
-        
-        if isinstance(size, int):
-            if color.ndim == 1:
-                color = np.tile(color, (size,1))
-            elif color.ndim == 2:
-                if color.shape[0] != size:
-                    raise ValueError('未定义的或不符合规则的颜色')
-            else:
-                raise ValueError('未定义的或不符合规则的颜色')
-        elif isinstance(size, (tuple, list)) and len(size) == 2:
-            if color.ndim == 1:
-                color = np.tile(color, (*size,1))
-            elif color.ndim == 3:
-                if color.shape[:-1] != size:
-                    raise ValueError('未定义的或不符合规则的颜色')
-            else:
-                raise ValueError('未定义的或不符合规则的颜色')
-        elif not size is None:
-            raise ValueError('未定义的或不符合规则的颜色')
-        
-        if drop and color.shape[-1] == 4:
-            color = color[..., :-1]
-        
-        return color
-    
-    def cmap(self, data, cm, invalid=np.nan, invalid_c=(0,0,0,0), drange=None, alpha=None, drop=False):
-        """数值映射到颜色
-        
-        data        - 数据
-        cm          - 调色板
-        invalid     - 无效数据的标识
-        invalid_c   - 无效数据的颜色
-        drange      - 数据动态范围，None表示使用data的动态范围
-        alpha       - 透明度，None表示不改变当前透明度
-        drop        - 舍弃alpha通道
-        """
-        
-        assert cm in self._cmaps, '未定义的调色板%s'%cm
-        assert isinstance(invalid_c, (list, tuple, np.ndarray)), '期望参数invalid_c是元组、列表或numpy数组'
-        
-        if not isinstance(invalid_c, np.ndarray):
-            invalid_c = np.array(invalid_c, dtype=np.float64)
-        
-        if not np.isnan(invalid):
-            data[data==invalid] = np.nan
-        invalid_pos = np.isnan(data) # 记录无效数据位置
-        
-        if drange is None:
-            dmin, dmax = np.nanmin(data), np.nanmax(data)
-        else:
-            dmin, dmax = drange
-        
-        data[data<dmin] = dmin
-        data[data>dmax] = dmax
-        
-        cmo = mcm.get_cmap(cm)
-        cmap, k = list(), 256/cmo.N
-        for i in range(cmo.N):
-            c = cmo(i)
-            for j in range(int(i*k), int((i+1)*k)):
-                cmap.append(c)
-        cmap = np.array(cmap)
-        
-        data = np.uint8(255*(data-dmin)/(dmax-dmin))
-        color = cmap[data]
-        color[invalid_pos] = invalid_c
-        
-        if isinstance(alpha, (int, float)) and 0 <= alpha <= 1:
-            color[..., 3] = alpha
-        
-        if drop:
-            color = color[..., :-1]
-        #else:
-        #    if color.ndim == 3:
-        #        a = np.uint8(color[..., -1]*255)
-        #        a = filters.gaussian_filter(a, 0.5)
-        #        color[..., -1] = np.float64(a)/255
-        #
-        return color
-
-if __name__  == '__main__':
-    cm = ColorManager()
-    s1 = set(cm.color_list)
-    s2 = set([item[1] for item in cm.color_help()])
-    print(len(s1), len(s2))
-    print(s1-s2)
-    print(s2-s1)
+# -*- coding: utf-8 -*-
+
+import re
+import numpy as np
+import matplotlib
+from matplotlib import cm as mcm
+
+class ColorManager:
+    """颜色管理类"""
+ 
+    def __init__(self):
+        """构造函数"""
+ 
+        self.default_colors = ['#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#1f77b4', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']
+        self._colors = matplotlib.colors.cnames
+        self._cmaps = [
+            'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 
+            'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 
+            'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBu_r', 
+            'PuBuGn', 'PuBuGn_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 
+            'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 
+            'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGn_r', 'YlGnBu', 'YlGnBu_r', 'YlOrBr', 'YlOrBr_r', 
+            'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 
+            'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'cubehelix', 'cubehelix_r', 
+            'flag', 'flag_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 
+            'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot_r', 
+            'gnuplot2', 'gnuplot2_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 
+            'magma', 'magma_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 
+            'prism', 'prism_r', 'rainbow', 'rainbow_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 
+            'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'twilight', 'twilight_r', 
+            'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'winter', 'winter_r'
+        ]
+ 
+    @property    
+    def colors(self):
+        """全部颜色"""
+ 
+        return [
+            ('aliceblue', '爱丽丝蓝'), ('antiquewhite', '古董白'), ('aqua', '青'), ('aquamarine', '碧绿'), ('azure', '青白'), 
+            ('beige', '米'), ('bisque', '橘黄'), ('black', '黑'), ('blanchedalmond', '杏仁白'), ('blue', '蓝'), ('blueviolet', '蓝紫'), 
+            ('brown', '褐'), ('burlywood', '硬木褐'), ('cadetblue', '军服蓝'), ('chartreuse', '查特酒绿'), ('chocolate', '巧克力'), 
+            ('coral', '珊瑚红'), ('cornflowerblue', '矢车菊蓝'), ('cornsilk', '玉米穗黄'), ('crimson', '绯红'), ('cyan', '青'), 
+            ('darkblue', '深蓝'), ('darkcyan', '深青'), ('darkgoldenrod', '深金菊黄'), ('darkgray', '暗灰'), ('darkgreen', '深绿'), 
+            ('darkgrey', '暗灰'), ('darkkhaki', '深卡其'), ('darkmagenta', '深品红'), ('darkolivegreen', '深橄榄绿'), ('darkorange', '深橙'), 
+            ('darkorchid', '深洋兰紫'), ('darkred', '深红'), ('darksalmon', '深鲑红'), ('darkseagreen', '深海藻绿'), ('darkslateblue', '深岩蓝'), 
+            ('darkslategray', '深岩灰'), ('darkslategrey', '深岩灰'), ('darkturquoise', '深松石绿'), ('darkviolet', '深紫'), ('deeppink', '深粉'), 
+            ('deepskyblue', '深天蓝'), ('dimgray', '昏灰'), ('dimgrey', '昏灰'), ('dodgerblue', '湖蓝'), ('firebrick', '火砖红'), 
+            ('floralwhite', '花卉白'), ('forestgreen', '森林绿'), ('fuchsia', '洋红'), ('gainsboro', '庚氏灰'), ('ghostwhite', '幽灵白'), 
+            ('gold', '金'), ('goldenrod', '金菊'), ('gray', '灰'), ('green', '绿'), ('greenyellow', '黄绿'), ('grey', '灰'),  ('honeydew', '蜜瓜绿'), 
+            ('hotpink', '艳粉'), ('indianred', '印度红'), ('indigo', '靛蓝'), ('ivory', '象牙白'), ('khaki', '卡其'), ('lavender', '薰衣草紫'), 
+            ('lavenderblush', '薰衣草红'), ('lawngreen', '草坪绿'), ('lemonchiffon', '柠檬绸黄'), ('lightblue', '浅蓝'), ('lightcoral', '浅珊瑚红'), 
+            ('lightcyan', '浅青'), ('lightgoldenrodyellow', '浅金菊黄'), ('lightgray', '亮灰'), ('lightgreen', '浅绿'), ('lightgrey', '亮灰'), 
+            ('lightpink', '浅粉'), ('lightsalmon', '浅鲑红'), ('lightseagreen', '浅海藻绿'), ('lightskyblue', '浅天蓝'), ('lightslategray', '浅岩灰'), 
+            ('lightslategrey', '浅岩灰'), ('lightsteelblue', '浅钢青'), ('lightyellow', '浅黄'), ('lime', '绿'), ('limegreen', '青柠绿'), 
+            ('linen', '亚麻'), ('magenta', '洋红'), ('maroon', '栗'), ('mediumaquamarine', '中碧绿'), ('mediumblue', '中蓝'), ('mediumorchid', '中洋兰紫'), 
+            ('mediumpurple', '中紫'), ('mediumseagreen', '中海藻绿'), ('mediumslateblue', '中岩蓝'), ('mediumspringgreen', '中嫩绿'), 
+            ('mediumturquoise', '中松石绿'), ('mediumvioletred', '中紫红'), ('midnightblue', '午夜蓝'), ('mintcream', '薄荷乳白'), 
+            ('mistyrose', '雾玫瑰红'), ('moccasin', '鹿皮'), ('navajowhite', '土著白'), ('navy', '藏青'), ('oldlace', '旧蕾丝白'), ('olive', '橄榄'), 
+            ('olivedrab', '橄榄绿'), ('orange', '橙'), ('orangered', '橘红'), ('orchid', '洋兰紫'), ('palegoldenrod', '白金菊黄'), ('palegreen', '白绿'), 
+            ('paleturquoise', '白松石绿'), ('palevioletred', '白紫红'), ('papayawhip', '番木瓜橙'), ('peachpuff', '粉朴桃'), ('peru', '秘鲁红'), 
+            ('pink', '粉'), ('plum', '李紫'), ('powderblue', '粉末蓝'), ('purple', '紫'), ('rebeccapurple', '丽贝卡紫'), ('red', '红'), 
+            ('rosybrown', '玫瑰褐'), ('royalblue', '品蓝'), ('saddlebrown', '鞍褐'), ('salmon', '鲑红'), ('sandybrown', '沙褐'), ('seagreen', '海藻绿'), 
+            ('seashell', '贝壳白'), ('sienna', '土黄赭'), ('silver', '银'), ('skyblue', '天蓝'), ('slateblue', '岩蓝'), ('slategray', '岩灰'), 
+            ('slategrey', '岩灰'), ('snow', '雪白'), ('springgreen', '春绿'), ('steelblue', '钢青'), ('tan', '日晒褐'), ('teal', '鸭翅绿'), 
+            ('thistle', '蓟紫'), ('tomato', '番茄红'), ('turquoise', '松石绿'), ('violet', '紫罗兰'), ('wheat', '麦'), ('white', '白'), 
+            ('whitesmoke', '烟雾白'), ('yellow', '黄'), ('yellowgreen', '暗黄绿')
+        ]
+ 
+    @property
+    def cmaps(self):
+        """调色板列表"""
+ 
+        return [
+            ('视觉均匀类', ['viridis', 'plasma', 'inferno', 'magma', 'cividis']), 
+            ('单调变化类', ['Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds', 'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu', 'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']), 
+            ('近似单调类', ['binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink', 'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper']), 
+            ('亮度发散类', ['PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu', 'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic']), 
+            ('颜色循环类', ['twilight', 'twilight_shifted', 'hsv']),
+            ('分段阶梯类', ['Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c']), 
+            ('专属定制类', ['flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern', 'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg', 'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar'])
+        ]
+
+    def _hex2color(self, str_hex):
+        """以#为前缀的十六进制颜色转numpy数组颜色"""
+ 
+        if len(str_hex) == 3:
+            color = np.array((int(str_hex[1:2],base=16)/16, int(str_hex[2:3],base=16)/16, int(str_hex[3:],base=16)/16), dtype=np.float32)
+        else:
+            color = np.array((int(str_hex[1:3],base=16)/255, int(str_hex[3:5],base=16)/255, int(str_hex[5:],base=16)/255), dtype=np.float32)
+ 
+        return color
+
+    def _str2color(self, color):
+        """字符串表示的颜色转numpy数组颜色"""
+ 
+        if color in self._colors:
+            return self._hex2color(self._colors[color])
+        elif re.compile(r'#[\da-fA-F]{3}$').match(color) or re.compile(r'#[\da-fA-F]{6}$').match(color):
+            return self._hex2color(color)
+        else:
+            raise ValueError('未定义的或不符合规则的颜色：%s'%color)
+
+    def format_color(self, color, cid=0, repeat=None):
+        """检查颜色参数，将字符串、元组、列表等类型的颜色转为浮点型的numpy数组
+
+        color       - 预定义颜色、十六进制颜色，或者浮点型元组、列表或numpy数组
+        cid         - 缺省颜色id
+        repeat      - 若color为单个颜色，repeat表示重复次数或重复行列数
+        """
+
+        if color is None:
+            color = self._hex2color(self.default_colors[cid])
+        elif isinstance(color, str):
+            color = self._str2color(color)
+        elif isinstance(color, (list, tuple, np.ndarray)):
+            color = np.array(color, dtype=np.float32)
+            cmin, cmax = color.min(), color.max()
+            if cmax > 1 or cmin < 0:
+                color = (color - cmin) / (cmax - cmin)
+        else:
+            raise ValueError('未定义的或不符合规则的颜色')
+
+        if color.shape[-1] not in (3,4):
+            raise ValueError('未定义的或不符合规则的颜色')
+
+        if color.ndim == 1:
+            if isinstance(repeat, int): 
+                color = np.tile(color, (repeat,1))
+            elif isinstance(repeat, (tuple, list)):
+                color = np.tile(color, (*repeat,1))
+
+        return color
+ 
+    def cmap(self, data, cm, drange=None, alpha=None, invalid=np.nan, invalid_c=(0,0,0,0)):
+        """数值映射到颜色
+ 
+        data        - 数据
+        cm          - 调色板
+        drange      - 数据动态范围，None表示使用data的动态范围
+        alpha       - 透明度，None表示不改变当前透明度
+        invalid     - 无效数据的标识
+        invalid_c   - 无效数据的颜色
+        """
+ 
+        if cm not in self._cmaps:
+            raise ValueError('未知的调色板%s'%cm)
+ 
+        if not np.isnan(invalid):
+            data[data==invalid] = np.nan
+        invalid_pos = np.isnan(data) # 记录无效数据位置
+ 
+        dmin, dmax = (np.nanmin(data), np.nanmax(data)) if drange is None else drange
+        data[data<dmin] = dmin
+        data[data>dmax] = dmax
+ 
+        cmo = mcm.get_cmap(cm)
+        cs, k = list(), 256/cmo.N
+        for i in range(cmo.N):
+            c = cmo(i)
+            for j in range(int(i*k), int((i+1)*k)):
+                cs.append(c)
+        cs = np.array(cs)
+ 
+        data = np.uint8(255*(data-dmin)/(dmax-dmin))
+        color = cs[data]
+        color[invalid_pos] = invalid_c
+ 
+        if isinstance(alpha, (int, float)) and 0 <= alpha <= 1:
+            color[..., 3] = alpha
+ 
+        return color
+
+    def get_cm_colors(self, cm):
+        """返回给定调色板的颜色列表"""
+
+        return mcm.get_cmap(cm).colors
```


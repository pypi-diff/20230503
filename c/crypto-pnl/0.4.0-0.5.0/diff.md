# Comparing `tmp/crypto_pnl-0.4.0-py2-none-any.whl.zip` & `tmp/crypto_pnl-0.5.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,27 @@
-Zip file size: 34998 bytes, number of entries: 25
--rw-r--r--  2.0 unx     1129 b- defN 22-Mar-21 00:09 crypto_pnl/__init__.py
--rw-r--r--  2.0 unx     4205 b- defN 22-Mar-21 00:09 crypto_pnl/__main__.py
--rw-r--r--  2.0 unx     2966 b- defN 22-Mar-27 14:28 crypto_pnl/asset.py
--rw-r--r--  2.0 unx    11121 b- defN 22-Mar-21 00:09 crypto_pnl/console_render.py
--rw-r--r--  2.0 unx     6103 b- defN 22-Mar-27 15:12 crypto_pnl/console_report.py
--rw-r--r--  2.0 unx     4786 b- defN 22-Mar-21 00:09 crypto_pnl/console_walk.py
--rw-r--r--  2.0 unx     5890 b- defN 22-Mar-27 14:47 crypto_pnl/core.py
--rw-r--r--  2.0 unx     9008 b- defN 22-Mar-27 16:01 crypto_pnl/csv_export.py
--rw-r--r--  2.0 unx     6181 b- defN 22-Mar-21 00:09 crypto_pnl/exchange_rate_calculator.py
--rw-r--r--  2.0 unx     2562 b- defN 22-Mar-21 00:09 crypto_pnl/journal.py
--rw-r--r--  2.0 unx     2367 b- defN 22-Mar-21 00:09 crypto_pnl/last_prices.py
--rw-r--r--  2.0 unx     2785 b- defN 22-Mar-27 13:57 crypto_pnl/ledger.py
--rw-r--r--  2.0 unx     2943 b- defN 22-Mar-27 17:21 crypto_pnl/market_data.py
--rw-r--r--  2.0 unx     3973 b- defN 22-Mar-21 00:09 crypto_pnl/position.py
--rw-r--r--  2.0 unx     1612 b- defN 22-Mar-21 00:09 crypto_pnl/summary.py
--rw-r--r--  2.0 unx     9676 b- defN 22-Mar-27 16:53 crypto_pnl/tracker.py
--rw-r--r--  2.0 unx     2286 b- defN 22-Mar-21 00:09 crypto_pnl/trade.py
--rw-r--r--  2.0 unx     3783 b- defN 22-Mar-27 16:22 crypto_pnl/transaction.py
--rw-r--r--  2.0 unx     2233 b- defN 22-Mar-21 00:09 crypto_pnl/wallet.py
--rw-rw-r--  2.0 unx     1068 b- defN 22-Mar-27 17:57 crypto_pnl-0.4.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     1375 b- defN 22-Mar-27 17:57 crypto_pnl-0.4.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Mar-27 17:57 crypto_pnl-0.4.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       57 b- defN 22-Mar-27 17:57 crypto_pnl-0.4.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       11 b- defN 22-Mar-27 17:57 crypto_pnl-0.4.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2027 b- defN 22-Mar-27 17:57 crypto_pnl-0.4.0.dist-info/RECORD
-25 files, 90239 bytes uncompressed, 31754 bytes compressed:  64.8%
+Zip file size: 37865 bytes, number of entries: 25
+-rw-r--r--  2.0 unx     1129 b- defN 22-Jul-28 15:15 crypto_pnl/__init__.py
+-rw-r--r--  2.0 unx     4892 b- defN 23-Jan-14 18:27 crypto_pnl/__main__.py
+-rw-r--r--  2.0 unx     3911 b- defN 22-Dec-13 21:08 crypto_pnl/asset.py
+-rw-r--r--  2.0 unx    11121 b- defN 22-Jul-28 15:15 crypto_pnl/console_render.py
+-rw-r--r--  2.0 unx     6152 b- defN 22-Jul-28 15:31 crypto_pnl/console_report.py
+-rw-r--r--  2.0 unx     4787 b- defN 22-Jul-28 15:21 crypto_pnl/console_walk.py
+-rw-r--r--  2.0 unx     6577 b- defN 23-Jan-14 16:44 crypto_pnl/core.py
+-rw-r--r--  2.0 unx    17185 b- defN 23-Jan-14 19:37 crypto_pnl/csv_export.py
+-rw-r--r--  2.0 unx     9285 b- defN 23-Jan-14 16:51 crypto_pnl/exchange_rate_calculator.py
+-rw-r--r--  2.0 unx     2562 b- defN 22-Jul-28 15:15 crypto_pnl/journal.py
+-rw-r--r--  2.0 unx     2749 b- defN 22-Nov-20 16:28 crypto_pnl/last_prices.py
+-rw-r--r--  2.0 unx     3234 b- defN 22-Dec-13 20:58 crypto_pnl/ledger.py
+-rw-r--r--  2.0 unx     2944 b- defN 22-Sep-27 13:42 crypto_pnl/market_data.py
+-rw-r--r--  2.0 unx     3973 b- defN 22-Jul-28 15:15 crypto_pnl/position.py
+-rw-r--r--  2.0 unx     1612 b- defN 22-Jul-28 15:15 crypto_pnl/summary.py
+-rw-r--r--  2.0 unx     9676 b- defN 22-Jul-28 15:15 crypto_pnl/tracker.py
+-rw-r--r--  2.0 unx     2287 b- defN 22-Jul-28 15:22 crypto_pnl/trade.py
+-rw-r--r--  2.0 unx     3783 b- defN 22-Jul-28 15:15 crypto_pnl/transaction.py
+-rw-r--r--  2.0 unx     2233 b- defN 22-Jul-28 15:15 crypto_pnl/wallet.py
+-rw-r--r--  2.0 unx     1068 b- defN 23-May-03 09:43 crypto_pnl-0.5.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1397 b- defN 23-May-03 09:43 crypto_pnl-0.5.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-03 09:43 crypto_pnl-0.5.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       57 b- defN 23-May-03 09:43 crypto_pnl-0.5.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       11 b- defN 23-May-03 09:43 crypto_pnl-0.5.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2028 b- defN 23-May-03 09:43 crypto_pnl-0.5.0.dist-info/RECORD
+25 files, 104745 bytes uncompressed, 34621 bytes compressed:  66.9%
```

## zipnote {}

```diff
@@ -51,26 +51,26 @@
 
 Filename: crypto_pnl/transaction.py
 Comment: 
 
 Filename: crypto_pnl/wallet.py
 Comment: 
 
-Filename: crypto_pnl-0.4.0.dist-info/LICENSE
+Filename: crypto_pnl-0.5.0.dist-info/LICENSE
 Comment: 
 
-Filename: crypto_pnl-0.4.0.dist-info/METADATA
+Filename: crypto_pnl-0.5.0.dist-info/METADATA
 Comment: 
 
-Filename: crypto_pnl-0.4.0.dist-info/WHEEL
+Filename: crypto_pnl-0.5.0.dist-info/WHEEL
 Comment: 
 
-Filename: crypto_pnl-0.4.0.dist-info/entry_points.txt
+Filename: crypto_pnl-0.5.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: crypto_pnl-0.4.0.dist-info/top_level.txt
+Filename: crypto_pnl-0.5.0.dist-info/top_level.txt
 Comment: 
 
-Filename: crypto_pnl-0.4.0.dist-info/RECORD
+Filename: crypto_pnl-0.5.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## crypto_pnl/__main__.py

```diff
@@ -36,15 +36,19 @@
 """
 
 import sys
 import os
 import glob
 
 from .console_walk import walk_trades
-from .csv_export import export_trades, export_tracker_events, export_ledger
+from .csv_export import (
+    export_trades,
+    export_tracker_events,
+    export_ledger,
+    export_prices)
 
 
 def get_paths(path):
     trades_path = glob.glob(os.path.join(path, 'trades/*.csv'))
     ledger_path = glob.glob(os.path.join(path, 'ledger/*.csv'))
     market_data_path = glob.glob(os.path.join(path, 'market_data/*.csv'))
     return trades_path, ledger_path, market_data_path
@@ -54,34 +58,42 @@
     print('''Crypto PnL Calculator (c) 2021, Sonia Sadhbh Kolasinska
 
 usage: crypto_pnl <walk|export-trades|export-tracker-events|export-ledger> <path>
 ''')
 
 def print_commands():
     print('''commands:
-    walk    Walk through transaction log printing for each transaction
+    walk <input_dir>
+            Walk through transaction log printing for each transaction
             the details of transaction, exchange rates, account balance,
             transaction gains, and transaction match and carry actions.
     
-    export-trades
+    export-trades <input_dir>
             Export into CSV file a preprocessed trading log, where
             trades are valuated in EUR using exchange rates driven by market data.
 
-    export-tracker-events
+    export-tracker-events <input_dir>
             Export into CSV file a preprocessed trading log, where
             buys are matched against sells by matching engine
             and EUR gains are calculated using exchange rates driven by market data.
 
-    export-tracker-events-fifo
+    export-tracker-events-fifo <input_dir>
             Same as export-tracker-events, but use FIFO matching instead of default LIFO.
 
-    export-ledger
+    export-ledger <input_dir>
             Export into CSV file a preprocessed transactions log, where
             transactions are valuated in EUR using exchange rates driven by market data.
 
+    export-prices <input_dir> <output_makret_data_dir>
+            Export into CSV file a preprocessed prices log, where
+            prices that were used by events are in EUR using exchange rates driven by market data.
+            
+            Export into CSV file market data filetered by trade and transaction log events.
+            The exported sparse market data can be used instead of original big files when
+            generating all remaining files. Results should not differ.
     ''')
 
 def print_help():
     print_usage()
     print_commands()
 
 def print_error(msg):
@@ -93,29 +105,31 @@
 def main():
     args = sys.argv[1:]
     if not args:
         print_usage()
         return
 
     cmd = args[0]
-    if cmd in ('walk', 'export-trades', 'export-ledger',
+    if cmd in ('walk', 'export-trades', 'export-ledger', 'export-prices',
             'export-tracker-events',
             'export-tracker-events-fifo'):
         path = args[1]
         paths = get_paths(path)
         if cmd == 'walk':
             walk_trades(*paths)
         elif cmd == 'export-trades':
             export_trades(*paths)
         elif cmd == 'export-tracker-events':
             export_tracker_events(*paths)
         elif cmd == 'export-tracker-events-fifo':
             export_tracker_events(*paths, use_fifo=True)
         elif cmd == 'export-ledger':
             export_ledger(*paths)
+        elif cmd == 'export-prices':
+            export_prices(*paths, args[2])
     elif cmd in ('help','-h'):
         print_help()
     else:
         print_error('Unknown command {}'.format(cmd))
 
 
 if __name__ == '__main__':
```

## crypto_pnl/asset.py

```diff
@@ -33,58 +33,88 @@
         self.xid = xid
 
     @property
     def has_id(self):
         return hasattr(self, 'xid')
 
     def set_value(self, value_data, value_type):
+        """
+            Set the value of an asset in default fiat currency.
+        """
         self.value_data = Decimal(value_data).quantize(ZERO_LEVEL)
         self.value_type = value_type
 
     @property
     def has_value(self):
         return hasattr(self, 'value_data')
     
+    def set_unit_value(self, unit_value):
+        """
+            Unit value can be attached to an asset separately from asset value.
+            This can be useful when dealing with price precision and tiny quantites.
+        """
+        self.unit_value = unit_value
+
+    @property
+    def has_unit_value(self):
+        return hasattr(self, 'unit_value')
+
     def split(self, quantity):
         total_quantity = self.quantity
         self.quantity = (self.quantity - quantity).quantize(ZERO_LEVEL)
         other = Asset(quantity, self.symbol)
         if self.has_value:
-            unit_value = self.value_data / total_quantity
+            if self.has_unit_value:
+                unit_value = self.unit_value
+            else:
+                unit_value = self.value_data / total_quantity
             self.value_data = convert(self.quantity, unit_value).quantize(ZERO_LEVEL)
             other.set_value(convert(quantity, unit_value), self.value_type)
+            if self.has_unit_value:
+                other.set_unit_value(unit_value)
         if self.has_id:
             other.set_id(self.xid)
         return other
 
 
 def zero_asset(symbol, value_type):
     asset = Asset(0, symbol)
     asset.set_value(0, value_type)
+    asset.set_unit_value(0)
     asset.set_id(0)
     return asset
 
 
 def copy_asset(asset):
     copy = Asset(asset.quantity, asset.symbol)
     if asset.has_value:
         copy.set_value(asset.value_data, asset.value_type)
+    if asset.has_unit_value:
+        copy.set_unit_value(asset.unit_value)
     if asset.has_id:
         copy.set_id(asset.xid)
     return copy
 
 
+def get_price(asset):
+    return (asset.unit_value if asset.has_unit_value
+        else (asset.value_data / asset.quantity if asset.quantity > ZERO_LEVEL
+            else 0))
+
+
 def parse_price(price):
     price = price.replace(',','')
     return Decimal(price)
 
 
 def parse_asset(quantity):
     quantity = quantity.replace(',','')
     g = INCH_RE.match(quantity)
     if g: # 1INCH is special, because it starts with digit
         return Asset(g.groups()[0], INCH_SYMBOL)
-    g = MONETARY_RE.match(quantity).groups()
-    if len(g) == 2 and g[1]:
-        return Asset(*g)
+    g = MONETARY_RE.match(quantity)
+    if g:
+        g = g.groups()
+        if len(g) == 2 and g[1]:
+            return Asset(*g)
     raise ValueError(quantity)
```

## crypto_pnl/console_report.py

```diff
@@ -35,105 +35,105 @@
     def __init__(self, exchange_rate_calculator, options):
         self.exchange_rate_calculator = exchange_rate_calculator
         self.options = options
 
     def print_trade_summary(self, index, trade, journal):
         render = Render(self.exchange_rate_calculator)
 
-        print '\n{}'.format(line_title('[ Trade #{:5}]'.format(index)))
-        print RenderTrade.render_info(trade)
+        print('\n{}'.format(line_title('[ Trade #{:5}]'.format(index))))
+        print(RenderTrade.render_info(trade))
 
-        print '\n\n{}\n'.format(line_title('[ Total Account Balance ]'))
-        print RenderPositions.render_headers()
-        print line_trade_summary()
+        print('\n\n{}\n'.format(line_title('[ Total Account Balance ]')))
+        print(RenderPositions.render_headers())
+        print(line_trade_summary())
 
         summary_journal_all = Summary()
         summary_journal_all.calculate(journal.position_tracker.all)
-        print render.positions.render(summary_journal_all.total)
+        print(render.positions.render(summary_journal_all.total))
 
         if 'show_traded_pair' in self.options:
-            print '\n{}\n'.format(line_section('[ Traded Pair Account Balance ]'))
+            print('\n{}\n'.format(line_section('[ Traded Pair Account Balance ]')))
             summary_journal_main = Summary()
             summary_journal_main.calculate(journal.position_tracker.main.get_subset([trade.pair]))
-            print '{}   {}:Main'.format(
+            print('{}   {}:Main'.format(
                 render.positions.render(summary_journal_main.total),
-                trade.pair)
+                trade.pair))
 
             summary_journal_traded = Summary()
             summary_journal_traded.calculate(journal.position_tracker.traded.get_subset([trade.pair]))
-            print '{}   {}:Traded'.format(
+            print('{}   {}:Traded'.format(
                 render.positions.render(summary_journal_traded.total),
-                trade.pair)
+                trade.pair))
 
-        print '\n\n{}\n'.format(line_title('[ Asset Portfolio ]'))
-        print RenderPositions.render_headers()
-        print line_trade_summary()
+        print('\n\n{}\n'.format(line_title('[ Asset Portfolio ]')))
+        print(RenderPositions.render_headers())
+        print(line_trade_summary())
 
         trackers = journal.last_transaction.trackers
-        print render.positions.render(trackers.balance())
+        print(render.positions.render(trackers.balance()))
 
         if trackers.has_unpaid_fees():
-            print '\n{}\n'.format(line_section('[ Unpaid Fees ]'))
-            print render.positions.render(trackers.unpaid_fees_balance())
+            print('\n{}\n'.format(line_section('[ Unpaid Fees ]')))
+            print(render.positions.render(trackers.unpaid_fees_balance()))
 
-        print '\n{}\n'.format(line_section('[ Individual Assets ]'))
-        print render.trackers.render_stacks(trackers)
+        print('\n{}\n'.format(line_section('[ Individual Assets ]')))
+        print(render.trackers.render_stacks(trackers))
 
-        print '\n\n{}\n'.format(line_title('[ Transaction Gains ]'))
-        print RenderTransaction.render_headers()
-        print line_trade_summary()
-        print RenderTransaction.render_matches(journal.last_transaction)
-
-        print '\n\n{}\n'.format(line_section('[ Individial Events ]'))
-        print RenderTrackers.render_event_headers()
-        print render.trackers.render_events(trackers)
+        print('\n\n{}\n'.format(line_title('[ Transaction Gains ]')))
+        print(RenderTransaction.render_headers())
+        print(line_trade_summary())
+        print(RenderTransaction.render_matches(journal.last_transaction))
+
+        print('\n\n{}\n'.format(line_section('[ Individial Events ]')))
+        print(RenderTrackers.render_event_headers())
+        print(render.trackers.render_events(trackers))
 
-        print '\n'*4
+        print('\n'*4)
 
 
     def print_final_summary(self, journal):
         render = Render(self.exchange_rate_calculator)
 
         if 'show_traded_pair' in self.options:
-            print '\n{}'.format(line_title('[ Total Main Account Balance ]'))
+            print('\n{}'.format(line_title('[ Total Main Account Balance ]')))
             summary_main = Summary()
             summary_main.calculate(journal.position_tracker.main)
-            print render.summary.render(summary_main)
+            print(render.summary.render(summary_main))
 
-            print '\n{}'.format(line_title('[ Total Traded Account Balance ]'))
+            print('\n{}'.format(line_title('[ Total Traded Account Balance ]')))
             summary_traded = Summary()
             summary_traded.calculate(journal.position_tracker.traded)
-            print render.summary.render(summary_traded)
+            print(render.summary.render(summary_traded))
 
-        print '\n{}'.format(line_title('[ Total Account Balance ]'))
+        print('\n{}'.format(line_title('[ Total Account Balance ]')))
         summary_wallet = Summary()
         summary_wallet.calculate(journal.position_tracker.all)
-        print render.summary.render(summary_wallet)
+        print(render.summary.render(summary_wallet))
 
-        print '\n{}'.format(line_title('[ All Individual Assets (fees deducted) ]'))
-        print RenderPositions.render_headers()
-        print render.trackers.render_stacks(journal.transaction_engine.trackers)
+        print('\n{}'.format(line_title('[ All Individual Assets (fees deducted) ]')))
+        print(RenderPositions.render_headers())
+        print(render.trackers.render_stacks(journal.transaction_engine.trackers))
 
-        print '\n{}'.format(line_title('[ All Asset Balance ]'))
-        print RenderPositions.render_headers()
+        print('\n{}'.format(line_title('[ All Asset Balance ]')))
+        print(RenderPositions.render_headers())
         trackers_balance = journal.transaction_engine.trackers.balance()
-        print render.positions.render(trackers_balance)
+        print(render.positions.render(trackers_balance))
 
         if journal.transaction_engine.trackers.has_unpaid_fees():
             trackers_unpaid_fees = journal.transaction_engine.trackers.unpaid_fees_balance()
-            print '\n{}'.format(line_title('[ All Unpaid Fees ]'))
-            print render.positions.render(trackers_unpaid_fees)
+            print('\n{}'.format(line_title('[ All Unpaid Fees ]')))
+            print(render.positions.render(trackers_unpaid_fees))
             summary_trackers = Summary()
             summary_trackers.calculate(trackers_balance)
             summary_trackers.calculate(trackers_unpaid_fees)
-            print '\n{}'.format(line_title('[ Remaining Asset Balance (after fees are paid) ]'))
-            print render.summary.render(summary_trackers)
+            print('\n{}'.format(line_title('[ Remaining Asset Balance (after fees are paid) ]')))
+            print(render.summary.render(summary_trackers))
 
-        print '\n{}'.format(line_title('[ Total Transaction Gains (summary of all individual matched assets) ]'))
-        print RenderTrackers.render_headers()
-        print render.trackers.render_matches(journal.transaction_engine.trackers.summary())
-
-        print '\n{}'.format(line_title('[ Wallet (remaining total amounts of assets) ]'))
-        print RenderWallet.render_headers()
-        print render.wallet.render(journal.wallet)
+        print('\n{}'.format(line_title('[ Total Transaction Gains (summary of all individual matched assets) ]')))
+        print(RenderTrackers.render_headers())
+        print(render.trackers.render_matches(journal.transaction_engine.trackers.summary()))
+
+        print('\n{}'.format(line_title('[ Wallet (remaining total amounts of assets) ]')))
+        print(RenderWallet.render_headers())
+        print(render.wallet.render(journal.wallet))
 
-        print
+        print()
```

## crypto_pnl/console_walk.py

```diff
@@ -120,15 +120,15 @@
             if shoud_ignore_ledger_entry(entry):
                 continue
 
             exchange_rate_calculator.will_process_ledger_entry(entry)
             journal.process_ledger_entry(entry)
 
 
-    print '(No more trades.)'
+    print('(No more trades.)')
     print('''
     Available commands:
         quit
 
     Press Enter to continue to summary...
     ''')
     command = raw_input('\nT> ')
```

## crypto_pnl/core.py

```diff
@@ -22,20 +22,27 @@
 
 import csv
 import re
 
 from decimal import Decimal
 from datetime import datetime
 
+import pytz
+
+TRADING_LOGS_TZ = pytz.utc
+REPORTING_TZ = pytz.utc
+
 DATE_FORMAT = '%Y-%m-%d %H:%M:%S'
 
 INCH_RE = re.compile('(?P<quantity>[0-9.]+)1INCH')
 MONETARY_RE = re.compile('(?P<quantity>[0-9.]+)(?P<symbol>[A-Z]*)')
-
-ZERO_LEVEL = Decimal('0.00000001')
+ 
+# Binance data comes with precision of 10 decimal places
+ZERO_LEVEL = Decimal('0.0000000001')
+ZERO_LEVEL_FORMAT = '%.10f'
 
 QUANTIZER_1 = Decimal('0.000001')
 QUANTIZER_2 = Decimal('0.001')
 
 FIAT_QUANTIZER = Decimal('0.001')
 FIAT_SYMBOL = 'EUR'
 FIAT_EXCHANGE_SYMBOL = 'USDT'
@@ -91,19 +98,35 @@
          return 4
     if symbol == 'BUSD':
          return 5
     return 1000
 
 
 def get_datetime(date):
-    return datetime.strptime(date, DATE_FORMAT)
+    """
+    Load Date/Time from Date(UTC) column of Ledger/Trades 
+    """
+    naive = datetime.strptime(date, DATE_FORMAT)
+    trading_dt = TRADING_LOGS_TZ.localize(naive, is_dst=None)
+    return trading_dt.astimezone(REPORTING_TZ)
 
 
 def get_datetime_from_timestamp(timestamp):
-    return datetime.fromtimestamp(timestamp/1000.0)
+    """
+    Load Date/Time from UNIX timestamp, which is always UTC
+    """
+    utc_dt = datetime.fromtimestamp(timestamp/1000.0, tz=pytz.utc)
+    return utc_dt.astimezone(REPORTING_TZ)
+
+
+def format_datetime(date):
+    """
+    Format for reporting
+    """
+    return datetime.strftime(date, DATE_FORMAT)
 
 
 def parse_side(side):
     return Decimal(
         SIGN_SELL 
             if side == SIDE_SELL else 
         SIGN_BUY)
@@ -162,14 +185,18 @@
         return quantity.quantize(QUANTIZER_2)
 
 
 def display_fiat(quantity):
     return quantity.quantize(FIAT_QUANTIZER)
 
 
+def format_quantity(quantity):
+    return ZERO_LEVEL_FORMAT % quantity
+
+
 def load_csv(path):
     with open(path) as fp:
         return csv.reader(fp.readlines())
 
 def sorted_items(d):
     return sorted(d.items(), key=lambda x:x[0])
 
@@ -203,19 +230,19 @@
 def combine_data_streams(data_streams, use_reverse=False, use_sort=False):
     def next_or_none(it):
         try:
             return next(it)
         except StopIteration:
             return None
     if use_reverse:
-        data_streams = map(lambda s: reversed(list(s)), data_streams)
+        data_streams = list(map(lambda s: reversed(list(s)), data_streams))
     if use_sort:
-        data_streams = map(lambda s: sorted(list(s), key=lambda x: x.date), data_streams)
-    iters = map(iter, data_streams)
-    current = map(next_or_none, iters)
+        data_streams = list(map(lambda s: sorted(list(s), key=lambda x: x.date), data_streams))
+    iters = list(map(iter, data_streams))
+    current = list(map(next_or_none, iters))
     while not all(x is None for x in current):
         next_i = None
         for (i, it) in enumerate(iters):
             if (current[i] is None):
                 continue
             if (next_i is None or current[i].date < current[next_i].date):
                 next_i = i
```

## crypto_pnl/csv_export.py

```diff
@@ -16,89 +16,137 @@
 # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 # SOFTWARE.
 
+import os
+
 from .core import *
-from .asset import Asset, zero_asset, copy_asset
+from .asset import Asset, zero_asset, copy_asset, get_price
 from .trade import load_trades, use_trade_streams
-from .ledger import load_ledger, use_ledger_streams, shoud_ignore_ledger_entry, should_change_loan_balance
+from .ledger import (
+    load_ledger,
+    use_ledger_streams,
+    is_card_spending_ledger_entry,
+    shoud_ignore_ledger_transfer_entry,
+    shoud_ignore_ledger_duplicated_trade_entry,
+    shoud_ignore_ledger_entry, 
+    should_change_loan_balance)
 from .market_data import load_market_data
 from .wallet import Wallet
 from .journal import Journal
 from .position import Positions, PositionTracker
 from .transaction import TransactionEngine
 from .tracker import Trackers, Tracker
 from .last_prices import LastPrices
 from .exchange_rate_calculator import ExchangeRateCalculator
 from .console_report import ConsoleReport
+from itertools import chain
 
 
 TRACKER_EVENT_HEADERS = (
     'ID',
     'Date',
+    'Tax Year',
+    'Tax Period',
     'Type',
     'Event',
     'Symbol',
     'Action',
     'Side',
     'Match ID',
     'Buy Quantity',
     'Sell Quantity',
+    'Buy Price in {}'.format(FIAT_SYMBOL),
+    'Sell Price in {}'.format(FIAT_SYMBOL),
+    'Buy Value in {}'.format(FIAT_SYMBOL),
+    'Sell Value in {}'.format(FIAT_SYMBOL),
+    'Gains Value in {}'.format(FIAT_SYMBOL),
     'Changed Quantity',
-    'Buy value in {}'.format(FIAT_SYMBOL),
-    'Sell value in {}'.format(FIAT_SYMBOL),
-    'Gains value in {}'.format(FIAT_SYMBOL),
+    'Balance',
+    'Num Lots') + tuple(
+        chain(*(('Lot {} ID'.format(i), 'Lot {} Quantity'.format(i)) for i in range(1,21)))
 )
 
 TRADE_HEADERS = (
     'ID',
     'Date',
+    'Tax Year',
+    'Tax Period',
     'Traded Pair',
     'Side',
     'Main Quantity',
     'Main Symbol',
     'Traded Quantity',
     'Traded Symbol',
     'Fee Quantity',
     'Fee Symbol',
     'Price',
     'Price.Symbol',
     'Exchange Rate in {}'.format(FIAT_SYMBOL),
+    'Price in {}'.format(FIAT_SYMBOL),
     'Trade value in {}'.format(FIAT_SYMBOL),
 )
 
 LEDGER_HEADERS = (
     'ID',
     'Date',
+    'Tax Year',
+    'Tax Period',
     'Account',
     'Operation',
     'Coin',
     'Change',
+    'Price in {}'.format(FIAT_SYMBOL),
     'Value in {}'.format(FIAT_SYMBOL),
     'Remark',
 )
 
-def render_tracker_event(e):
+PRICES_HEADERS = (
+    'ID',
+    'Date',
+    'Tax Year',
+    'Tax Period',
+    'Type',
+    'Market',
+    'Price',
+    'Tick',
+    'Tick Date',
+    'Open',
+    'High',
+    'Low',
+    'Close',
+)
+
+
+def tax_period(date):
+    return 'Second' if date.month == 12 else 'First'
+
+
+def render_tracker_event(e, event_positions, event_lots):
     etype, action, data = e
     if etype == MATCH_EVENT:
         buy, sell, fee = data
         data = buy
         if action in (BUY_MATCH_ACTION, SELL_MATCH_ACTION):
             acquired_id = buy.xid
             disposed_id = sell.xid
             acquired_value = buy.value_data
             disposed_value = sell.value_data
+            acquired_price = get_price(buy)
+            disposed_price = get_price(sell)
         else:
             acquired_id = buy.xid
             disposed_id = fee.xid
             acquired_value = buy.value_data
             disposed_value = fee.value_data
+            acquired_price = get_price(buy)
+            disposed_price = get_price(fee)
 
         gains = disposed_value - acquired_value
 
         if action in (BUY_MATCH_ACTION, REPAY_FEE_MATCH_ACTION):
             acquired_qty = data.quantity
             disposed_qty = 0
             disposed_value = 0
@@ -106,77 +154,125 @@
             match_id = disposed_id
         else:
             acquired_qty = 0
             acquired_value = 0
             disposed_qty = data.quantity
             changed_qty = -data.quantity
             match_id = acquired_id
+        event_lots[data.symbol][match_id] -= abs(changed_qty)
 
     elif etype == CARRY_EVENT:
         if action in (STACK_CARRY_ACTION,):
             acquired_qty = data.quantity
             disposed_qty = 0
             changed_qty = data.quantity
             acquired_value = data.value_data
+            acquired_price = get_price(data)
             disposed_value = 0
+            disposed_price = 0
         else:
             acquired_qty = 0
             disposed_qty = data.quantity
             changed_qty = -data.quantity
             acquired_value = 0
+            acquired_price = 0
             disposed_value = data.value_data
+            disposed_price = get_price(data)
+        event_lots.setdefault(data.symbol, {})[data.xid] = abs(changed_qty)
 
         match_id = ''
         gains = 0
     
+    position_qty = event_positions.get(data.symbol, Decimal(0))
+    position_qty = position_qty + changed_qty
+    event_positions[data.symbol] = position_qty
+    lots_remaining = [(xid, qty) for xid, qty in event_lots[data.symbol].items() if qty > ZERO_LEVEL]
+
+    acquired_price = format_quantity(acquired_price) if acquired_price > 0 else ''
+    disposed_price = format_quantity(disposed_price) if disposed_price > 0 else ''
+
+    acquired_value = format_quantity(acquired_value) if acquired_qty > 0 else ''
+    disposed_value = format_quantity(disposed_value) if disposed_qty > 0 else ''
+
+    acquired_qty = format_quantity(acquired_qty) if acquired_qty > 0 else ''
+    disposed_qty = format_quantity(disposed_qty) if disposed_qty > 0 else ''
+
     type_, event_, action_, side_ = action
 
     return (type_, event_, data.symbol, action_, side_, match_id,
-        '%.7f' % acquired_qty,
-        '%.7f' % disposed_qty,
-        '%.7f' % changed_qty,
-        '%.7f' % acquired_value,
-        '%.7f' % disposed_value,
-        '%.7f' % gains,
+        acquired_qty,
+        disposed_qty,
+        acquired_price,
+        disposed_price,
+        acquired_value,
+        disposed_value,
+        format_quantity(gains),
+        format_quantity(changed_qty),
+        format_quantity(position_qty),
+        '%i' % len(lots_remaining),
+        ','.join('{},{}'.format(xid, format_quantity(qty)) for xid, qty in lots_remaining),
     )
 
 
 def render_trade(trade):
     return (
-        trade.date,
+        format_datetime(trade.date),
+        trade.date.year,
+        tax_period(trade.date),
         trade.pair,
         get_side(trade.side),
         trade.amount.quantity,
         trade.amount.symbol,
         trade.executed.quantity,
         trade.executed.symbol,
         trade.fee.quantity,
         trade.fee.symbol,
         trade.price,
         trade.amount.symbol,
-        '%.7f' % trade.exchange_rate,
-        '%.7f' % trade.amount.value_data,
+        format_quantity(trade.exchange_rate),
+        format_quantity(trade.exchange_rate * trade.price),
+        format_quantity(trade.amount.value_data),
     )
 
 
 def render_ledger_entry(entry):
-    if shoud_ignore_ledger_entry(entry):
-        entry_remark = 'Entry should be ignored as it duplicates an entry from trading log.' + entry.remark
+    ignore = False
+    if shoud_ignore_ledger_transfer_entry(entry):
+        ignore = True
+        entry_remark = 'Entry should be ignored as it is same user transfer'
+    elif shoud_ignore_ledger_duplicated_trade_entry(entry):
+        ignore = True
+        entry_remark = 'Entry should be ignored as it duplicates an entry from trading log'
     elif should_change_loan_balance(entry):
-        entry_remark = 'Entry is used to calculate loan interests.' + entry.remark
+        entry_remark = 'Entry is used to calculate loan interests'
+    elif is_card_spending_ledger_entry(entry):
+        entry_remark = 'Using actual card spending amount'
     else:
         entry_remark = entry.remark
 
+    if ignore:
+        entry_change_value = ''
+        entry_change_price = ''
+    elif not entry.change.has_value:
+        entry_change_value = ''
+        entry_change_price = '<MISSING>'
+    else:
+        entry_change_value = format_quantity(entry.change.value_data)
+        entry_change_price = format_quantity(entry.change.unit_value)
+
     return (
-        entry.date,
+        format_datetime(entry.date),
+        entry.date.year,
+        tax_period(entry.date),
         entry.account,
         entry.operation,
         entry.change.symbol,
-        entry.change.quantity,
-        ('%.7f' % entry.change.value_data) if entry.change.has_value else '',
+        format_quantity(entry.change.quantity),
+        entry_change_price,
+        entry_change_value,
         entry_remark,
     )
 
 
 
 def export_tracker_events(trades_paths, ledger_paths, market_data_paths, use_fifo = False):
     if use_fifo:
@@ -198,14 +294,16 @@
     trades = use_trade_streams(
         map(load_trades, trades_paths))
 
     print(','.join(TRACKER_EVENT_HEADERS))
 
     number = 0
     ledger_number = 0
+    event_positions = {}
+    event_lots = {}
     for which, entry in combine_data_streams([trades, ledgers]):
         if not which:
             number += 1
             xid = 'T/{}'.format(number)
             trade = entry
             trade.amount.set_id(xid)
             trade.executed.set_id(xid)
@@ -225,15 +323,17 @@
                 journal.process_ledger_entry(entry)
             except ValueError as err:
                 raise(ValueError('{} {}'.format(entry.date, err)))
 
         for symbol, tracker in sorted_items(
                 journal.last_transaction.trackers.trackers):
             for te in tracker.events:
-                print(','.join(map(str, (xid, entry.date) + render_tracker_event(te)
+                print(','.join(
+                    map(str, (xid, format_datetime(entry.date), entry.date.year, tax_period(entry.date)
+                    ) + render_tracker_event(te, event_positions, event_lots)
                 )))
 
 
 def export_trades(trades_paths, ledger_paths, market_data_paths):
     last_prices = LastPrices()
     exchange_rate_calculator = ExchangeRateCalculator(last_prices)
     wallet = Wallet()
@@ -280,9 +380,123 @@
         if not which:
             exchange_rate_calculator.will_execute(entry)
             journal.execute(entry)
 
         else:
             ledger_number += 1
             xid = 'L/{}'.format(ledger_number)
-            exchange_rate_calculator.set_asset_value(entry.change)
+            if not shoud_ignore_ledger_entry(entry):
+                exchange_rate_calculator.will_process_ledger_entry(entry)
             print(','.join(map(str, (xid,) + render_ledger_entry(entry))))
+
+
+class LastPricesLogger(LastPrices):
+    def reset_last_accesssed(self):
+        self.last_accessed_symbols = set()
+    
+    def get_last_price(self, traded_symbol, main_symbol):
+        self.last_accessed_symbols.add((traded_symbol, main_symbol))
+        return super().get_last_price(traded_symbol, main_symbol)
+
+    def get_last_update_date(self, traded_symbol, main_symbol):
+        self.last_accessed_symbols.add((traded_symbol, main_symbol))
+        return super().get_last_update_date(traded_symbol, main_symbol)
+
+
+def export_prices(trades_paths, ledger_paths, market_data_paths, output_dir):
+    last_prices = LastPricesLogger()
+    exchange_rate_calculator = ExchangeRateCalculator(last_prices)
+    wallet = Wallet()
+    position_tracker = PositionTracker()
+    transaction_engine = TransactionEngine()
+    journal = Journal(wallet, position_tracker, transaction_engine)
+
+    last_prices.set_market_data_streams(
+        map(load_market_data, market_data_paths))
+
+    ledgers = use_ledger_streams(
+        map(load_ledger, ledger_paths))
+
+    trades = use_trade_streams(
+        map(load_trades, trades_paths))
+
+    print(','.join(PRICES_HEADERS))
+
+    output_files = {}
+    last_ticks = {}
+    try:
+        number = 0
+        ledger_number = 0
+        for which, entry in combine_data_streams([trades, ledgers]):
+            last_prices.reset_last_accesssed()
+            entry_symbols = set()
+
+            if not which:
+                number += 1
+                xid = 'T/{}'.format(number)
+                exchange_rate_calculator.will_execute(entry)
+                entry_symbols.add(entry.executed.symbol)
+                entry_symbols.add(entry.amount.symbol)
+                entry_symbols.add(entry.fee.symbol)
+                dohlc = ('',) * 5
+                market = '{}/{}'.format(entry.executed.symbol, entry.amount.symbol)
+                print(','.join(map(str, (
+                    xid, format_datetime(entry.date), entry.date.year, tax_period(entry.date), 
+                    'Trade', market, entry.price) + dohlc)))
+
+            else:
+                ledger_number += 1
+                xid = 'L/{}'.format(ledger_number)
+                if shoud_ignore_ledger_entry(entry):
+                    continue
+                exchange_rate_calculator.will_process_ledger_entry(entry)
+                entry_symbols.add(entry.change.symbol)
+            
+            if FIAT_SYMBOL in entry_symbols:
+                entry_symbols.remove(FIAT_SYMBOL)
+            
+            for symbol in sorted(entry_symbols):
+                market = '{}/{}'.format(symbol, FIAT_SYMBOL)
+                price_asset = Asset(1, symbol)
+                exchange_rate_calculator.set_asset_value_check_stale(price_asset, entry.date)
+                dohlc = ('',) * 5
+                print(','.join(map(str, (
+                    xid, format_datetime(entry.date), entry.date.year, tax_period(entry.date), 
+                    'ExchangeRate', market, price_asset.value_data) + dohlc)))
+            
+            for symbol_pair in sorted(last_prices.last_accessed_symbols):
+                market = '{}/{}'.format(*symbol_pair)
+                market_data = last_prices._last_market_data.get(symbol_pair)
+                if market_data:
+                    price = market_data.value
+                    dohlc = (
+                        market_data.unix,
+                        format_datetime(market_data.date),
+                        market_data.open_price, 
+                        market_data.high_price, 
+                        market_data.low_price,
+                        market_data.close_price)
+                    filename = '{}{}.csv'.format(*symbol_pair)
+                    fp = output_files.get(filename, None)
+                    if fp is None:
+                        filepath = os.path.join(output_dir, filename)
+                        fp = open(filepath, 'w+')
+                        output_files[filename] = fp
+                    last_tick = last_ticks.get(filename, None)
+                    if last_tick != market_data.unix:
+                        last_ticks[filename] = market_data.unix
+                        print(','.join(map(str, (
+                            market_data.unix,
+                            market_data.open_price, 
+                            market_data.high_price, 
+                            market_data.low_price,
+                            market_data.close_price))), file=fp)
+                else:
+                    price = ''
+                    dohlc = ('',) * 5
+
+                print(','.join(map(str, (
+                    xid, format_datetime(entry.date), entry.date.year, tax_period(entry.date), 
+                    'MarketData', market, price) + dohlc)))
+    finally:
+        for fp in output_files.values():
+            fp.close()
```

## crypto_pnl/exchange_rate_calculator.py

```diff
@@ -17,14 +17,16 @@
 # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 # SOFTWARE.
 
 from .core import *
+from .asset import parse_asset
+from .ledger import is_card_spending_ledger_entry
 
 
 class ExchangeRateCalculator:
     """
     Track asset values based on last trade.
 
     We exchange through stablecoin: USDT, and then to EUR.
@@ -34,57 +36,119 @@
     or receive (Sell). It wouldn't be accurate to use 1INCH price from market data (5 minute klines),
     so we price 1INCH as the amount we paid/received in BTC, and then we use BTC/USDT market data to
     convert to USDT, and then we use EUR/USDT market data to convert to EUR.
     """
     def __init__(self, last_price_provider):
         self.last_price_provider = last_price_provider
         self.last_prices = {}
+        self.last_trade_date = {}
 
     def get_exchange_rate(self, symbol):
         if symbol == FIAT_SYMBOL:
             return Decimal(1.0)
         fiat_price = self.last_price_provider.get_last_price(FIAT_SYMBOL, FIAT_EXCHANGE_SYMBOL)
+        if not fiat_price:
+            raise ValueError('Missing market data for {}/{}'.format(FIAT_SYMBOL, FIAT_EXCHANGE_SYMBOL))
         if symbol == FIAT_EXCHANGE_SYMBOL:
             return Decimal(1.0) / fiat_price
         symbol_price = self.last_price_provider.get_last_price(symbol, FIAT_EXCHANGE_SYMBOL)
         if symbol_price is not None:
             return symbol_price / fiat_price
+        if not symbol_price:
+            raise ValueError('Missing market data for {}/{}'.format(symbol, FIAT_EXCHANGE_SYMBOL))
 
     def set_asset_value(self, asset):
+        """
+            Set asset value based on the Last Trade if any,
+            otherwise set asset value from Last Market Data.
+
+            NOTE: Function always uses Last Trade if any, and 
+            does not check if Last Market Data is more recent than Last Trade.
+        """
         unit_value = self.last_prices.get(asset.symbol)
         if not unit_value:
             unit_value = self.get_exchange_rate(asset.symbol)
         if unit_value:
             asset.set_value(convert(asset.quantity, unit_value), CURRENT_VALUE)
+            asset.set_unit_value(unit_value)
+    
+    def set_asset_value_check_stale(self, asset, date):
+        """
+            Set asset value based on the Last Trade
+            only if Last Trade happened AFTER Last Market Data,
+            otherwise always use Last Market Data.
+
+            NOTE: Last Market Data ticks are aggregated over 1M, 5M, etc,
+            so using Last Trade tick gives more accurate price in fast moving market,
+            however when there there is no trade on our side, the market will move
+            away from our last traded price, so we want to use new price from Last Market Data.
+        """
+        self.last_price_provider.play_market_data_until(date)
+        last_trade_date = self.last_trade_date.get(asset.symbol)
+        last_update_date = self.last_price_provider.get_last_update_date(asset.symbol, FIAT_EXCHANGE_SYMBOL)
+        if last_trade_date and (not last_update_date or not (last_trade_date < last_update_date)):
+            """
+            There exists last trade and:
+                a) there was no market data, or
+                b) last trade is more recent than last market data
+                ==> then use exchange rate calcualted from last trade
+            """
+            unit_value = self.last_prices.get(asset.symbol)
+        else:
+            """
+            Otherwise:
+                ==> use market data
+            """
+            unit_value = self.get_exchange_rate(asset.symbol)
+        if unit_value:
+            asset.set_value(convert(asset.quantity, unit_value), CURRENT_VALUE)
+            asset.set_unit_value(unit_value)
     
     def will_execute(self, trade):
         self._set_trade_assets_value(trade)
         self._set_last_trade(trade)
 
     def will_process_ledger_entry(self, entry):
-        self.set_asset_value(entry.change)
+        if is_card_spending_ledger_entry(entry):
+            self._set_card_spending_value(entry)
+        else:
+            self.set_asset_value_check_stale(entry.change, entry.date)
         if not entry.change.has_value:
             raise ValueError('Please, download market data for {} on {} from {}'.format(
                 entry.change.symbol,
                 entry.date,
                 'https://www.binance.com/en/landing/data'))
 
 
     # private:
+
+    def _set_card_spending_value(self, entry):
+        self.last_price_provider.play_market_data_until(entry.date)
+        try:
+            spent_amount = parse_asset(entry.remark)
+            if entry.change.quantity < 0:
+                spent_amount.quantity *= -1
+        except:
+            raise ValueError('Please, add remark with actual value of the card transaction {}'.format(
+                entry.date))
+        entry.change.set_value(spent_amount.quantity, CURRENT_VALUE)
+        entry.change.set_unit_value(spent_amount.quantity / entry.change.quantity)
     
     def _set_last_trade(self, trade):
         if trade.exchange_symbol == trade.amount.symbol:
             main_unit_value = trade.exchange_rate
             traded_unit_value = main_unit_value * trade.price
         else:
             traded_unit_value = trade.exchange_rate
             main_unit_value = traded_unit_value / trade.price
 
         self.last_prices[trade.amount.symbol] = main_unit_value
         self.last_prices[trade.executed.symbol] = traded_unit_value
+        self.last_trade_date[trade.amount.symbol] = trade.date 
+        self.last_trade_date[trade.executed.symbol] = trade.date
 
     def _set_trade_assets_value(self, trade):
         self.last_price_provider.play_market_data_until(trade.date)
 
         main_rank = get_asset_rank(trade.amount.symbol)
         traded_rank = get_asset_rank(trade.executed.symbol)
         if main_rank < traded_rank:
```

## crypto_pnl/last_prices.py

```diff
@@ -26,31 +26,44 @@
     def __init__(self):
         self._last_market_data = {}
 
     def set_market_data_streams(self, market_data_streams):
         combined_market_data = combine_data_streams(market_data_streams)
         self.market_data_iter = iter(combined_market_data)
         self.market_data_current = None
+        self.which_stream_next = None
         self.market_data_next = None
     
     def play_market_data_until(self, date):
-        while True:
-            if self.market_data_next and date < self.market_data_next.date:
-                break
-            try:
-                which_stream, self.market_data_next = next(self.market_data_iter)
-                if date < self.market_data_next.date:
-                    break
-                key = (
-                    self.market_data_next.symbol_traded,
+        def is_next_after_date():
+            return (date < self.market_data_next.date)
+    
+        def get_next_key():
+            return (self.market_data_next.symbol_traded,
                     self.market_data_next.symbol_main)
-                self._last_market_data[key] = self.market_data_next
-                self.market_data_current = self.market_data_next
-            except StopIteration:
+
+        def set_last_market_data():
+            self._last_market_data[get_next_key()] = self.market_data_next
+            self.market_data_current = self.market_data_next
+        
+        if self.market_data_next:
+            if is_next_after_date():
+                return
+            set_last_market_data()
+        
+        for (self.which_stream_next,
+             self.market_data_next) in self.market_data_iter:
+            if is_next_after_date():
                 break
+            set_last_market_data()
+
     
     def get_last_price(self, traded_symbol, main_symbol):
         last_market_data = self._last_market_data.get((traded_symbol, main_symbol))
         if last_market_data:
             return last_market_data.value
 
+    def get_last_update_date(self, traded_symbol, main_symbol):
+        last_market_data = self._last_market_data.get((traded_symbol, main_symbol))
+        if last_market_data:
+            return last_market_data.date
```

## crypto_pnl/ledger.py

```diff
@@ -42,22 +42,38 @@
         self.date = get_datetime(date)
         self.account = account
         self.operation = operation
         self.change = Asset(change, coin)
         self.remark = remark
 
 
-def shoud_ignore_ledger_entry(entry):
+def is_card_spending_ledger_entry(entry):
+    return entry.operation == 'Binance Card Spending'
+
+
+def shoud_ignore_ledger_transfer_entry(entry):
+    return entry.operation in (
+        'transfer_in',
+        'transfer_out',
+        'Main and funding account transfer')
+
+
+def shoud_ignore_ledger_duplicated_trade_entry(entry):
     return entry.account == 'Spot' and entry.operation in (
         'Transaction Related',
         'Buy',
         'Sell',
         'Fee')
 
 
+def shoud_ignore_ledger_entry(entry):
+    return (shoud_ignore_ledger_transfer_entry(entry) or
+            shoud_ignore_ledger_duplicated_trade_entry(entry))
+
+
 def should_change_loan_balance(entry):
     return (
         entry.account == 'IsolatedMargin' and entry.operation in (
             'IsolatedMargin loan',
             'IsolatedMargin repayment')
         ) or (entry.account == 'CrossMargin' and entry.operation in (
             'Margin loan',
@@ -67,14 +83,14 @@
 def load_ledger(path):
     ledger_csv = load_csv(path)
     header = next(ledger_csv)
     for row in ledger_csv:
         try:
             yield LedgerEntry(*row)
         except Exception as err:
-            print err, row
+            print(err, row)
             raise
 
 def use_ledger_streams(ledger_streams):
     combined_ledgers = combine_data_streams(ledger_streams)
     for which_stream, next_ledger in combined_ledgers:
         yield next_ledger
```

## crypto_pnl/market_data.py

```diff
@@ -60,9 +60,9 @@
 
 def load_market_data(path):
     market_data_csv = load_csv(path)
     for row in market_data_csv:
         try:
             yield MarketData(path, FIAT_EXCHANGE_SYMBOL, *row)
         except Exception as err:
-            print err, row
+            print(err, row)
             raise
```

## crypto_pnl/trade.py

```diff
@@ -49,15 +49,15 @@
 def load_trades(path):
     trades_csv = load_csv(path)
     header = next(trades_csv)
     for row in trades_csv:
         try:
             yield Trade(*row)
         except Exception as err:
-            print err, row
+            print(err, row)
             raise
 
 
 def use_trade_streams(trade_streams):
     combined_trades = combine_data_streams(trade_streams, use_reverse=True)
     for which_stream, next_trade in combined_trades:
         yield next_trade
```

## Comparing `crypto_pnl-0.4.0.dist-info/LICENSE` & `crypto_pnl-0.5.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `crypto_pnl-0.4.0.dist-info/METADATA` & `crypto_pnl-0.5.0.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 Metadata-Version: 2.1
 Name: crypto-pnl
-Version: 0.4.0
+Version: 0.5.0
 Summary: Crypto Trading Realized PnL Calculation (in EUR)
 Home-page: https://github.com/sadhbh-c0d3/crypto-pnl
 Author: Sonia Kolasinska
 Author-email: sonia.kolasinska.pro@gmail.com
 Maintainer: Sonia Kolasinska
 Maintainer-email: sonia.kolasinska.pro@gmail.com
 License: MIT
 Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: End Users/Desktop
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Topic :: Office/Business :: Financial
 Classifier: Topic :: Office/Business :: Financial :: Accounting
 Classifier: Topic :: Office/Business :: Financial :: Spreadsheet
+License-File: LICENSE
 
 Crypto Trading Realized PnL Calculation (in EUR)
 
 Jurisdictions require calculation of the PnL and CGT based off that as per transation basis.
 
 This program performs gains calculations for Binance using Trade History and Transaction History.
```

## Comparing `crypto_pnl-0.4.0.dist-info/RECORD` & `crypto_pnl-0.5.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 crypto_pnl/__init__.py,sha256=e9-V09AvAK58VVjiEvjXfgvYSwyARzNaz2VyBtuzl0A,1129
-crypto_pnl/__main__.py,sha256=fDAkM0876IkjHOcylXzryfGMlRKmDxwonjo9KBREjRA,4205
-crypto_pnl/asset.py,sha256=ZLHpbtNuVT7f_nrr3BjC3W1iWbD0gOekQKzRIrgaTS4,2966
+crypto_pnl/__main__.py,sha256=4x-3XuuHwzA0OVR9_twnC0xR7kSuq8eLT0mqP_xXDM8,4892
+crypto_pnl/asset.py,sha256=vjarofPXUtIHcs28lkgcqSEKAAQZ5z7_tbr1nhqGvdU,3911
 crypto_pnl/console_render.py,sha256=EW5KUjIJX_A78-hg5D0Zi8_AJypyz-E2prXWE9vg5JQ,11121
-crypto_pnl/console_report.py,sha256=X1zyvgee6SCfirnkBGHd3jDoLgkgk87EfUlzHCvUGnM,6103
-crypto_pnl/console_walk.py,sha256=3IbxIUs8956TF93nMPpWXsnkL_B_hNCidrNoocUEdmM,4786
-crypto_pnl/core.py,sha256=2Bp274JyD_HL8W3hMyqgDMA0jKG4_1xn3nD3NamXBKY,5890
-crypto_pnl/csv_export.py,sha256=6vNquMEWVU1TAbIBRL5_wx_F9Cciis4_15qCVqsNOQ8,9008
-crypto_pnl/exchange_rate_calculator.py,sha256=0aCWGuavu0KbVTDdzoM-REEh3j_o2sxdxqtcuglckkA,6181
+crypto_pnl/console_report.py,sha256=iqSO_S-5MR2UUvFJuW5RVTJTyX3cb4bgLBobhzD--f4,6152
+crypto_pnl/console_walk.py,sha256=l9NQJssLXgpTOQ23UsHSJZilRbhSdlgVeAryyNpML4U,4787
+crypto_pnl/core.py,sha256=IhIXpv7xn6HO_ifsP8x4QtyFYZVRiKDZX_iRK_v46jw,6577
+crypto_pnl/csv_export.py,sha256=iHTWxd49yV95RF3fOSIQn1ujYoMbh4sWmMWfR0XSsfI,17185
+crypto_pnl/exchange_rate_calculator.py,sha256=ZddGNmPmBi7Yz94vdmDdOhv8K4yejduNMWZULULs8cY,9285
 crypto_pnl/journal.py,sha256=7KLHNhjhar0mdWg_VfV9ivr1jKEd_2qdy6faSFG2eEU,2562
-crypto_pnl/last_prices.py,sha256=iQIL2t_Gw2idt0HEsbSn6ke01XkxZVnDS_HKnEI7cfc,2367
-crypto_pnl/ledger.py,sha256=gL1nB4NHrm0DBQeQLiIJpDZxiqNgUVi2-xTeykgXNYM,2785
-crypto_pnl/market_data.py,sha256=QX91pAYhJ4tknEGvnK-dECEj2zx7Gp2Xl9m-PuBehco,2943
+crypto_pnl/last_prices.py,sha256=nTOcvxSBjEz0hESca3dSeYpAv5ey8aJekNAHm39Jq6Q,2749
+crypto_pnl/ledger.py,sha256=7oyKSB9yLvutyNKvCBUO69foXDEKf43M5hdGZ2S0JDs,3234
+crypto_pnl/market_data.py,sha256=mKuPqDww86SFJFSfQllaGLtbcvDNpdhG4z-hHRkiRy8,2944
 crypto_pnl/position.py,sha256=5am-X9AN3pvh1BsYB0UlcsUvC7PtTgvC7jkiuwLB5uE,3973
 crypto_pnl/summary.py,sha256=_OqUKxJf0BwVBoU9z40GdRYSVue-X8NDlmN0_V1dvHM,1612
 crypto_pnl/tracker.py,sha256=izsMfgkmsdXMjcHU6-oDbVCTJBeljSUiaOwuiEzW9Ck,9676
-crypto_pnl/trade.py,sha256=k6ssbBeHymOB8wWE4H69eMvTp4T769_vb5FTV7eV4Ug,2286
+crypto_pnl/trade.py,sha256=txJNxYQ0IQZuRXRo8r1s4e8_ZfbehYgHS1z-9WNBbw0,2287
 crypto_pnl/transaction.py,sha256=71uKtHsiPe628aB5WTcO5sZ54TdSVuDW5ob8T7hIv-Q,3783
 crypto_pnl/wallet.py,sha256=cyzZsIkCmamUl3Nyv3zycsT3S2ViTXjUN3ShC40Cs3Q,2233
-crypto_pnl-0.4.0.dist-info/LICENSE,sha256=Q36F8Ed4sl7DzTa0zQNaHA3EvkCPajxG1N_dZxJ88-0,1068
-crypto_pnl-0.4.0.dist-info/METADATA,sha256=HJX-LLKoVUJo1AvKLuQ5rTz_kU1vpGCV4jgYJk8zQV0,1375
-crypto_pnl-0.4.0.dist-info/WHEEL,sha256=1VPi6hfNQaRRNuEdK_3dv9o8COtLGnHWJghhj4CQ28k,92
-crypto_pnl-0.4.0.dist-info/entry_points.txt,sha256=zIqTpxbUYGVrrY_t6EoKywN-mwTxyb_E3uy5a_a71Lc,57
-crypto_pnl-0.4.0.dist-info/top_level.txt,sha256=eBEHz_-wCEeIGBN-n-n4RCsHmu7DX2oV-mCNgFGfecw,11
-crypto_pnl-0.4.0.dist-info/RECORD,,
+crypto_pnl-0.5.0.dist-info/LICENSE,sha256=Q36F8Ed4sl7DzTa0zQNaHA3EvkCPajxG1N_dZxJ88-0,1068
+crypto_pnl-0.5.0.dist-info/METADATA,sha256=_K-hRHPzep-FbvYVmqAWbK_Woam8fwzpyM781XOUnAA,1397
+crypto_pnl-0.5.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+crypto_pnl-0.5.0.dist-info/entry_points.txt,sha256=zIqTpxbUYGVrrY_t6EoKywN-mwTxyb_E3uy5a_a71Lc,57
+crypto_pnl-0.5.0.dist-info/top_level.txt,sha256=eBEHz_-wCEeIGBN-n-n4RCsHmu7DX2oV-mCNgFGfecw,11
+crypto_pnl-0.5.0.dist-info/RECORD,,
```


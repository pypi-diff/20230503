# Comparing `tmp/OctoBot-Trading-2.3.7.tar.gz` & `tmp/OctoBot-Trading-2.4.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "OctoBot-Trading-2.3.7.tar", last modified: Thu Jan 12 01:40:01 2023, max compression
+gzip compressed data, was "OctoBot-Trading-2.4.0.tar", last modified: Tue May  2 22:02:13 2023, max compression
```

## Comparing `OctoBot-Trading-2.3.7.tar` & `OctoBot-Trading-2.4.0.tar`

### file list

```diff
@@ -1,756 +1,573 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.697697 OctoBot-Trading-2.3.7/
--rw-r--r--   0 runner    (1001) docker     (123)    28006 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/CHANGELOG.md
--rw-r--r--   0 runner    (1001) docker     (123)     7652 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)      141 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/MANIFEST.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.585694 OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     1717 2023-01-12 01:40:01.000000 OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    35441 2023-01-12 01:40:01.000000 OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-01-12 01:40:01.000000 OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-01-12 01:40:01.000000 OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (123)      234 2023-01-12 01:40:01.000000 OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       39 2023-01-12 01:40:01.000000 OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1717 2023-01-12 01:40:01.697697 OctoBot-Trading-2.3.7/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     1032 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.585694 OctoBot-Trading-2.3.7/octobot_trading/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)      792 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.589694 OctoBot-Trading-2.3.7/octobot_trading/api/
--rw-r--r--   0 runner    (1001) docker     (123)    10275 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1506 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/channels.py
--rw-r--r--   0 runner    (1001) docker     (123)     1154 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/contracts.py
--rw-r--r--   0 runner    (1001) docker     (123)    10829 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     2941 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/modes.py
--rw-r--r--   0 runner    (1001) docker     (123)     3632 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/orders.py
--rw-r--r--   0 runner    (1001) docker     (123)     2815 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/positions.py
--rw-r--r--   0 runner    (1001) docker     (123)     2310 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/profitability.py
--rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/storage.py
--rw-r--r--   0 runner    (1001) docker     (123)     4644 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/symbol_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     2483 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/trader.py
--rw-r--r--   0 runner    (1001) docker     (123)     2439 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/api/trades.py
--rw-r--r--   0 runner    (1001) docker     (123)     7189 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/constants.py
--rw-r--r--   0 runner    (1001) docker     (123)    13386 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/enums.py
--rw-r--r--   0 runner    (1001) docker     (123)     4393 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/errors.py
--rw-r--r--   0 runner    (1001) docker     (123)     1904 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_channel.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     9192 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_channel.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.589694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/
--rw-r--r--   0 runner    (1001) docker     (123)     4522 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7200 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.589694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/
--rw-r--r--   0 runner    (1001) docker     (123)     1101 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1316 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2519 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/contract_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/future_contract.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4309 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/future_contract.py
--rw-r--r--   0 runner    (1001) docker     (123)     1222 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/margin_contract.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2598 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/margin_contract.py
--rw-r--r--   0 runner    (1001) docker     (123)     2402 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/exchange_symbol_data.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7644 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/exchange_symbol_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1115 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/exchange_symbols_data.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1612 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/exchange_symbols_data.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.589694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/
--rw-r--r--   0 runner    (1001) docker     (123)     1222 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1220 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.593694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1389 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      959 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3130 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding.py
--rw-r--r--   0 runner    (1001) docker     (123)     1083 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7323 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1181 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2919 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1197 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/funding_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1862 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/funding_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.593694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/
--rw-r--r--   0 runner    (1001) docker     (123)     1191 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.593694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1346 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1343 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      964 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2628 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline.py
--rw-r--r--   0 runner    (1001) docker     (123)      920 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4043 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1163 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3057 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/kline_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2968 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/kline_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.593694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/
--rw-r--r--   0 runner    (1001) docker     (123)     1986 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1953 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1917 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/candles_adapter.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4740 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/candles_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)     2524 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/candles_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     9441 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/candles_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.597694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1348 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1342 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      964 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2848 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py
--rw-r--r--   0 runner    (1001) docker     (123)     1286 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    13428 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1473 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     8315 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1467 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5154 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.597694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/
--rw-r--r--   0 runner    (1001) docker     (123)     1474 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1469 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.597694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1568 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1562 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1132 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4907 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book.py
--rw-r--r--   0 runner    (1001) docker     (123)      928 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4028 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1191 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2884 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2487 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/order_book_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7930 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/order_book_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.597694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/
--rw-r--r--   0 runner    (1001) docker     (123)     1531 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1525 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.601694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1388 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      963 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/price.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3046 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/price.py
--rw-r--r--   0 runner    (1001) docker     (123)      981 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7605 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1015 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2313 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1842 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/price_events_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     6523 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/price_events_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     1541 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/prices_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7684 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/prices_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.601694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/
--rw-r--r--   0 runner    (1001) docker     (123)     1337 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1502 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.601694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1599 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1593 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4238 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py
--rw-r--r--   0 runner    (1001) docker     (123)      941 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3903 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1289 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     6871 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1147 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/recent_trades_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2353 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.601694 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/
--rw-r--r--   0 runner    (1001) docker     (123)     1305 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1301 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.605695 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1464 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1458 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1115 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7965 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker.py
--rw-r--r--   0 runner    (1001) docker     (123)     1092 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5312 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1289 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5899 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1085 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/ticker_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3023 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/ticker_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.609695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/
--rw-r--r--   0 runner    (1001) docker     (123)     3637 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5379 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3625 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/abstract_exchange.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    26265 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/abstract_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     1831 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/abstract_websocket_exchange.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7262 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/abstract_websocket_exchange.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.609695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/adapters/
--rw-r--r--   0 runner    (1001) docker     (123)      909 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/adapters/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6799 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/adapters/abstract_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)      981 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/basic_exchange_wrapper.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2839 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/basic_exchange_wrapper.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.609695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/
--rw-r--r--   0 runner    (1001) docker     (123)     1129 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1125 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      855 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/backtesting_exchange_config.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1023 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/backtesting_exchange_config.py
--rw-r--r--   0 runner    (1001) docker     (123)     2589 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/exchange_config_data.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    14745 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/exchange_config_data.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.609695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/
--rw-r--r--   0 runner    (1001) docker     (123)     1134 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1229 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.613695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/
--rw-r--r--   0 runner    (1001) docker     (123)     1138 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1309 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9966 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)     1844 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5690 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     1922 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    31782 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py
--rw-r--r--   0 runner    (1001) docker     (123)     3456 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    36623 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py
--rw-r--r--   0 runner    (1001) docker     (123)      736 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/constants.py
--rw-r--r--   0 runner    (1001) docker     (123)     2647 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/enums.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.613695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/
--rw-r--r--   0 runner    (1001) docker     (123)      980 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1216 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      840 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)     1730 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    11680 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py
--rw-r--r--   0 runner    (1001) docker     (123)     2372 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_builder.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    10470 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_channels.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7450 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_channels.py
--rw-r--r--   0 runner    (1001) docker     (123)     1033 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     8684 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     3817 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    13972 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)      986 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_websocket_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3153 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_websocket_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     1751 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchanges.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3591 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchanges.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.613695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/
--rw-r--r--   0 runner    (1001) docker     (123)     1372 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1366 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      878 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/default_rest_exchange.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1472 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/default_rest_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)      878 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/default_websocket_exchange.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1827 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/default_websocket_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/exchange_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4448 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/exchange_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.613695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/
--rw-r--r--   0 runner    (1001) docker     (123)     1047 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1427 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/trader.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    37673 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/trader.py
--rw-r--r--   0 runner    (1001) docker     (123)      849 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/trader_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/trader_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.617695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/
--rw-r--r--   0 runner    (1001) docker     (123)      949 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1068 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1933 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/rest_exchange.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    34474 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/rest_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     1481 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/websocket_exchange.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     9020 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/websocket_exchange.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.617695 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/
--rw-r--r--   0 runner    (1001) docker     (123)     1760 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2044 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1884 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/exchange_market_status_fixer.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    15477 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/exchange_market_status_fixer.py
--rw-r--r--   0 runner    (1001) docker     (123)     2311 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/exchange_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    10169 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/exchange_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     1037 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/websockets_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2212 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/websockets_util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.617695 OctoBot-Trading-2.3.7/octobot_trading/modes/
--rw-r--r--   0 runner    (1001) docker     (123)     1472 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2665 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    16047 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/abstract_trading_mode.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.621695 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1380 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1414 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1105 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/abstract_mode_consumer.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7929 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/abstract_mode_consumer.py
--rw-r--r--   0 runner    (1001) docker     (123)     1451 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/abstract_mode_producer.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    19750 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/abstract_mode_producer.py
--rw-r--r--   0 runner    (1001) docker     (123)     1222 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/mode.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5567 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/channel/mode.py
--rw-r--r--   0 runner    (1001) docker     (123)     5235 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/mode_config.py
--rw-r--r--   0 runner    (1001) docker     (123)     1249 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/modes_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5509 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/modes_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)      832 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/modes_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1821 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/modes_util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.621695 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/
--rw-r--r--   0 runner    (1001) docker     (123)     2433 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.621695 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/
--rw-r--r--   0 runner    (1001) docker     (123)     2501 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5823 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py
--rw-r--r--   0 runner    (1001) docker     (123)     2357 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/amount.py
--rw-r--r--   0 runner    (1001) docker     (123)     2719 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)     3161 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/run_persistence.py
--rw-r--r--   0 runner    (1001) docker     (123)      995 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py
--rw-r--r--   0 runner    (1001) docker     (123)     4763 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py
--rw-r--r--   0 runner    (1001) docker     (123)    25436 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/context_management.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.621695 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/dsl/
--rw-r--r--   0 runner    (1001) docker     (123)      943 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/dsl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2550 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/dsl/quantity.py
--rw-r--r--   0 runner    (1001) docker     (123)     1279 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/dsl/values.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.621695 OctoBot-Trading-2.3.7/octobot_trading/modes/scripted_trading_mode/
--rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/scripted_trading_mode/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    15946 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py
--rw-r--r--   0 runner    (1001) docker     (123)      834 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/octobot_channel_consumer.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5364 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/octobot_channel_consumer.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.621695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/
--rw-r--r--   0 runner    (1001) docker     (123)     5341 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    10955 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1904 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/exchange_personal_data.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    17594 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/exchange_personal_data.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.625695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/
--rw-r--r--   0 runner    (1001) docker     (123)     4860 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     6376 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.629695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1145 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1361 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      956 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     9923 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders.py
--rw-r--r--   0 runner    (1001) docker     (123)     1103 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    10194 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)      904 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1727 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1586 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/decimal_order_adapter.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    12933 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/decimal_order_adapter.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.629695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/
--rw-r--r--   0 runner    (1001) docker     (123)     1275 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1271 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     9677 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py
--rw-r--r--   0 runner    (1001) docker     (123)      890 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3670 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py
--rw-r--r--   0 runner    (1001) docker     (123)     5300 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    35643 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order.py
--rw-r--r--   0 runner    (1001) docker     (123)     1559 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_adapter.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    10764 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)     2367 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3602 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)      933 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_group.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2236 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_group.py
--rw-r--r--   0 runner    (1001) docker     (123)     1075 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4693 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     1723 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    20857 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     2420 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/orders_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     9899 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/orders_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.629695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/
--rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2133 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      947 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/cancel_order_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5382 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/cancel_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      877 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/close_order_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2600 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/close_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      942 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/fill_order_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5326 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/fill_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      896 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/open_order_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4067 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/open_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      743 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/order_state_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1775 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/order_state_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)      967 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      887 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/pending_creation_order_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1674 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/pending_creation_order_state.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.633695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/
--rw-r--r--   0 runner    (1001) docker     (123)     1839 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1834 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.633695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/
--rw-r--r--   0 runner    (1001) docker     (123)     2184 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2172 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      887 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/buy_limit_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)      987 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/buy_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     1339 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/limit_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4154 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      888 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/sell_limit_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)      989 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/sell_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      918 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2084 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      887 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/stop_loss_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1958 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      920 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1944 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      889 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/take_profit_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1961 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/take_profit_order.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.637695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/
--rw-r--r--   0 runner    (1001) docker     (123)     1342 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1335 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      893 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/buy_market_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/buy_market_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      862 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/market_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1816 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/market_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      894 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/sell_market_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)      999 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/sell_market_order.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.637695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/
--rw-r--r--   0 runner    (1001) docker     (123)     1209 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      930 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1978 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     1610 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     8484 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      863 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/unknown_order.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1250 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/unknown_order.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.641695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/
--rw-r--r--   0 runner    (1001) docker     (123)     3308 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3932 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1147 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/asset.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4336 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/asset.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.641695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/
--rw-r--r--   0 runner    (1001) docker     (123)     1289 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1283 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1700 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/future_asset.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     8175 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/future_asset.py
--rw-r--r--   0 runner    (1001) docker     (123)     1181 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/margin_asset.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4014 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/margin_asset.py
--rw-r--r--   0 runner    (1001) docker     (123)      974 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/spot_asset.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2162 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/spot_asset.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.641695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1696 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1690 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1170 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4999 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance.py
--rw-r--r--   0 runner    (1001) docker     (123)     1101 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     6141 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     1017 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.645695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/
--rw-r--r--   0 runner    (1001) docker     (123)     1541 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1536 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1099 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_asset_value.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1910 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_asset_value.py
--rw-r--r--   0 runner    (1001) docker     (123)      855 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     2415 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    15544 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     3099 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    13777 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)      977 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1368 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     2321 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    12237 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     2126 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_profitability.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7280 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_profitability.py
--rw-r--r--   0 runner    (1001) docker     (123)      893 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     8671 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     4662 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_value_holder.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    21486 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_value_holder.py
--rw-r--r--   0 runner    (1001) docker     (123)     1538 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/sub_portfolio.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3270 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/sub_portfolio.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.645695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/
--rw-r--r--   0 runner    (1001) docker     (123)     1331 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1325 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2145 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/future_portfolio.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    10339 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/future_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)      879 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/margin_portfolio.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1430 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/margin_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)      877 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/spot_portfolio.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3615 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/spot_portfolio.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.645695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/
--rw-r--r--   0 runner    (1001) docker     (123)     2577 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2617 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.649695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1351 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      963 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3155 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions.py
--rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    10177 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)      924 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions_updater_simulator.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4813 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     6648 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    38200 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position.py
--rw-r--r--   0 runner    (1001) docker     (123)      966 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2266 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)      940 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      798 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)      950 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     1704 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/positions_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     8139 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/positions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.649695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/
--rw-r--r--   0 runner    (1001) docker     (123)     1175 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1398 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      899 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/liquidate_position_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2832 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/liquidate_position_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      914 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/open_position_state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3611 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/open_position_state.py
--rw-r--r--   0 runner    (1001) docker     (123)      743 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/position_state_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1319 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/position_state_factory.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.649695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1126 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      881 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/inverse_position.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     8679 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/inverse_position.py
--rw-r--r--   0 runner    (1001) docker     (123)      880 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/linear_position.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7069 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/linear_position.py
--rw-r--r--   0 runner    (1001) docker     (123)     1375 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/state.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     7621 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/state.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.653695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/
--rw-r--r--   0 runner    (1001) docker     (123)     1610 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1714 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.653695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1138 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1135 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      956 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/trades.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2799 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/trades.py
--rw-r--r--   0 runner    (1001) docker     (123)      912 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/trades_updater.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4665 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/trades_updater.py
--rw-r--r--   0 runner    (1001) docker     (123)     2182 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trade.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5075 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trade.py
--rw-r--r--   0 runner    (1001) docker     (123)     1719 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trade_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3627 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trade_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     1381 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trades_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4528 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trades_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     3232 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trades_util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.653695 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/
--rw-r--r--   0 runner    (1001) docker     (123)     1884 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1877 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1087 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transaction.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1647 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     4098 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transaction_factory.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     5136 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transaction_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     1414 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transactions_manager.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     3896 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transactions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.657696 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/
--rw-r--r--   0 runner    (1001) docker     (123)     1623 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1615 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1308 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/blockchain_transaction.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2401 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/blockchain_transaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/fee_transaction.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1790 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/fee_transaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     1319 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2166 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py
--rw-r--r--   0 runner    (1001) docker     (123)      882 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/transfer_transaction.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/transfer_transaction.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.657696 OctoBot-Trading-2.3.7/octobot_trading/signals/
--rw-r--r--   0 runner    (1001) docker     (123)     1983 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.657696 OctoBot-Trading-2.3.7/octobot_trading/signals/channel/
--rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6226 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/channel/remote_trading_signal.py
--rw-r--r--   0 runner    (1001) docker     (123)     1791 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/channel/remote_trading_signal_channel_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     2790 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/channel/signal_producer.py
--rw-r--r--   0 runner    (1001) docker     (123)     5320 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/signal_creation.py
--rw-r--r--   0 runner    (1001) docker     (123)    11684 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/trading_signal_bundle_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     4328 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/signals/util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.661696 OctoBot-Trading-2.3.7/octobot_trading/storage/
--rw-r--r--   0 runner    (1001) docker     (123)     1644 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/storage/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3700 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/storage/abstract_storage.py
--rw-r--r--   0 runner    (1001) docker     (123)     3920 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/storage/candles_storage.py
--rw-r--r--   0 runner    (1001) docker     (123)     2733 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/storage/portfolio_storage.py
--rw-r--r--   0 runner    (1001) docker     (123)     4627 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/storage/storage_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     6606 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/storage/trades_storage.py
--rw-r--r--   0 runner    (1001) docker     (123)     4177 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/storage/transactions_storage.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.661696 OctoBot-Trading-2.3.7/octobot_trading/supervisors/
--rw-r--r--   0 runner    (1001) docker     (123)      730 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/supervisors/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1150 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/supervisors/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2036 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/supervisors/abstract_portfolio_supervisor.py
--rw-r--r--   0 runner    (1001) docker     (123)     3385 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/supervisors/abstract_supervisor.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.661696 OctoBot-Trading-2.3.7/octobot_trading/util/
--rw-r--r--   0 runner    (1001) docker     (123)     1561 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/__init__.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1959 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1452 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/config_util.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     4544 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/config_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/initializable.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     1234 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/initializable.py
--rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/initialization_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     1983 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/simulator_updater_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.661696 OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/
--rw-r--r--   0 runner    (1001) docker     (123)      715 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2421 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/exchanges_test_tools.py
--rw-r--r--   0 runner    (1001) docker     (123)     6668 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py
--rw-r--r--   0 runner    (1001) docker     (123)     3809 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/websocket_test_tools.py
--rw-r--r--   0 runner    (1001) docker     (123)      620 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-01-12 01:40:01.697697 OctoBot-Trading-2.3.7/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)    12913 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.581694 OctoBot-Trading-2.3.7/tests/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.665696 OctoBot-Trading-2.3.7/tests/api/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1849 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_channels.py
--rw-r--r--   0 runner    (1001) docker     (123)     2148 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_modes.py
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_orders.py
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_profitability.py
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_symbol_data.py
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_trader.py
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/api/test_trades.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.665696 OctoBot-Trading-2.3.7/tests/cli/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/cli/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.665696 OctoBot-Trading-2.3.7/tests/exchange_data/
--rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.665696 OctoBot-Trading-2.3.7/tests/exchange_data/contracts/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/contracts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3697 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/contracts/test_future_contract.py
--rw-r--r--   0 runner    (1001) docker     (123)     3044 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/contracts/test_margin_contract.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.665696 OctoBot-Trading-2.3.7/tests/exchange_data/funding/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/funding/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2834 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/funding/test_funding_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.665696 OctoBot-Trading-2.3.7/tests/exchange_data/kline/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/kline/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4470 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/kline/test_kline_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.669696 OctoBot-Trading-2.3.7/tests/exchange_data/ohlcv/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/ohlcv/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6941 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/ohlcv/test_candles_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)     8965 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/ohlcv/test_candles_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.669696 OctoBot-Trading-2.3.7/tests/exchange_data/order_book/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/order_book/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9729 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/order_book/test_order_book_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.669696 OctoBot-Trading-2.3.7/tests/exchange_data/prices/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/prices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10397 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/prices/test_price_events_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     9662 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/prices/test_prices_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.669696 OctoBot-Trading-2.3.7/tests/exchange_data/recent_trades/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/recent_trades/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5439 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/recent_trades/test_recent_trades_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     1866 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/test_exchange_symbols_data.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.669696 OctoBot-Trading-2.3.7/tests/exchange_data/ticker/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/ticker/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4436 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchange_data/ticker/test_ticker_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/exchanges/
--rw-r--r--   0 runner    (1001) docker     (123)    10088 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/exchanges/connectors/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/connectors/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/exchanges/connectors/ccxt/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/connectors/ccxt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7685 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/connectors/ccxt/test_ccxt_connector.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/exchanges/implementations/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/implementations/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2533 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/implementations/test_default_rest_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     5761 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/implementations/test_default_websocket_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     3287 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_abstract_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     2908 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_abstract_websocket_exchange.py
--rw-r--r--   0 runner    (1001) docker     (123)     2409 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_basic_exchange_wrapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2379 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     8792 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_config_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     2363 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     4814 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     4441 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     7347 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/test_exchanges.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/exchanges/traders/
--rw-r--r--   0 runner    (1001) docker     (123)     4719 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/traders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    50708 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/traders/test_trader.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/exchanges/types/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1496 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/types/test_websocket_exchange.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/exchanges/util/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    15676 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/util/test_exchange_market_status_fixer.py
--rw-r--r--   0 runner    (1001) docker     (123)     5339 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/exchanges/util/test_exchange_util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/modes/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.673696 OctoBot-Trading-2.3.7/tests/modes/script_keywords/
--rw-r--r--   0 runner    (1001) docker     (123)     2985 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/script_keywords/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.677696 OctoBot-Trading-2.3.7/tests/modes/script_keywords/basic_keywords/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/script_keywords/basic_keywords/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10962 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/script_keywords/basic_keywords/test_account_balance.py
--rw-r--r--   0 runner    (1001) docker     (123)     4933 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/script_keywords/basic_keywords/test_amount.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.677696 OctoBot-Trading-2.3.7/tests/modes/script_keywords/dsl/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/script_keywords/dsl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5707 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/script_keywords/dsl/test_quantity.py
--rw-r--r--   0 runner    (1001) docker     (123)     8913 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/test_abstract_mode_consumer.py
--rw-r--r--   0 runner    (1001) docker     (123)    14658 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/modes/test_abstract_trading_mode.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.677696 OctoBot-Trading-2.3.7/tests/personal_data/
--rw-r--r--   0 runner    (1001) docker     (123)     1311 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.677696 OctoBot-Trading-2.3.7/tests/personal_data/orders/
--rw-r--r--   0 runner    (1001) docker     (123)     4495 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.677696 OctoBot-Trading-2.3.7/tests/personal_data/orders/groups/
--rw-r--r--   0 runner    (1001) docker     (123)     1101 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/groups/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    19148 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py
--rw-r--r--   0 runner    (1001) docker     (123)     6753 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.681696 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3354 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_cancel_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     1439 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_close_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     2808 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_fill_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_open_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     4160 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     4799 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_order_state_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     1837 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     1784 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_pending_creation_order_state.py
--rw-r--r--   0 runner    (1001) docker     (123)    23002 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/test_decimal_order_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)     5685 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/test_double_filled_order.py
--rw-r--r--   0 runner    (1001) docker     (123)    14683 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/test_order.py
--rw-r--r--   0 runner    (1001) docker     (123)    20330 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/test_order_adapter.py
--rw-r--r--   0 runner    (1001) docker     (123)     3047 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/test_order_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)    25530 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/test_order_util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.681696 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.681696 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2912 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_buy_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     5127 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_sell_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     3242 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     4868 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_stop_loss_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     5061 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_take_profit_order.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.681696 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/market/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/market/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1650 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/market/test_buy_market_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     1732 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/market/test_sell_market_order.py
--rw-r--r--   0 runner    (1001) docker     (123)      717 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/test_unknown_order.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.681696 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/trailing/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/trailing/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      717 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (123)     8964 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.685696 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.685696 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8347 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/test_future_asset.py
--rw-r--r--   0 runner    (1001) docker     (123)     4557 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/test_margin_asset.py
--rw-r--r--   0 runner    (1001) docker     (123)     3401 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/test_spot_asset.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.685696 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/history/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/history/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3265 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)    29998 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     2543 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_asset.py
--rw-r--r--   0 runner    (1001) docker     (123)    52120 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)     5687 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     5661 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio_profitability.py
--rw-r--r--   0 runner    (1001) docker     (123)     9997 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio_value_holder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.685696 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    85487 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/test_future_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)     1807 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/test_margin_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)     4838 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/test_spot_portfolio.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/personal_data/positions/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/personal_data/positions/channel/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/channel/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/personal_data/positions/states/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    67901 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/test_position.py
--rw-r--r--   0 runner    (1001) docker     (123)     3185 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/test_position_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     6235 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/test_positions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/personal_data/positions/types/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    37444 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/types/test_inverse_position.py
--rw-r--r--   0 runner    (1001) docker     (123)    45251 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/positions/types/test_linear_position.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/personal_data/trades/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/trades/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10375 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/trades/test_trade_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     2049 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/trades/test_trade_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/personal_data/transactions/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/transactions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6321 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/transactions/test_transaction_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)    12957 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/personal_data/transactions/test_transactions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/signals/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/signals/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    29656 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/signals/test_trading_signal_bundle_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     9749 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/signals/test_util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.689696 OctoBot-Trading-2.3.7/tests/test_utils/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/test_utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/test_utils/order_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     4860 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/test_utils/random_numbers.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.693696 OctoBot-Trading-2.3.7/tests/util/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9443 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests/util/test_config_util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.693696 OctoBot-Trading-2.3.7/tests_additional/
--rw-r--r--   0 runner    (1001) docker     (123)      716 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-01-12 01:40:01.697697 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/
--rw-r--r--   0 runner    (1001) docker     (123)     2323 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9014 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/real_exchange_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     6835 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_ascendex.py
--rw-r--r--   0 runner    (1001) docker     (123)     7149 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_binance.py
--rw-r--r--   0 runner    (1001) docker     (123)     8680 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitfinex.py
--rw-r--r--   0 runner    (1001) docker     (123)     7583 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitget.py
--rw-r--r--   0 runner    (1001) docker     (123)     7270 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bithumb.py
--rw-r--r--   0 runner    (1001) docker     (123)     6742 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitso.py
--rw-r--r--   0 runner    (1001) docker     (123)     6877 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitstamp.py
--rw-r--r--   0 runner    (1001) docker     (123)     6999 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bittrex.py
--rw-r--r--   0 runner    (1001) docker     (123)     8265 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bybit.py
--rw-r--r--   0 runner    (1001) docker     (123)     6463 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_coinbasepro.py
--rw-r--r--   0 runner    (1001) docker     (123)     7197 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_coinex.py
--rw-r--r--   0 runner    (1001) docker     (123)     6844 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_gateio.py
--rw-r--r--   0 runner    (1001) docker     (123)     7210 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_hitbtc.py
--rw-r--r--   0 runner    (1001) docker     (123)     6858 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_hollaex.py
--rw-r--r--   0 runner    (1001) docker     (123)     6825 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_huobi.py
--rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_huobipro.py
--rw-r--r--   0 runner    (1001) docker     (123)     7903 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_kraken.py
--rw-r--r--   0 runner    (1001) docker     (123)     7737 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_kucoin.py
--rw-r--r--   0 runner    (1001) docker     (123)     6812 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_ndax.py
--rw-r--r--   0 runner    (1001) docker     (123)     3612 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_okcoin.py
--rw-r--r--   0 runner    (1001) docker     (123)     7353 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_okx.py
--rw-r--r--   0 runner    (1001) docker     (123)     7247 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_phemex.py
--rw-r--r--   0 runner    (1001) docker     (123)     7140 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_poloniex.py
--rw-r--r--   0 runner    (1001) docker     (123)     6612 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_upbit.py
--rw-r--r--   0 runner    (1001) docker     (123)     6657 2023-01-12 01:39:04.000000 OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_wavesexchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.163120 OctoBot-Trading-2.4.0/
+-rw-r--r--   0 runner    (1001) docker     (123)    32098 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (123)     7652 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      141 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/MANIFEST.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.095119 OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     1805 2023-05-02 22:02:12.000000 OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    24325 2023-05-02 22:02:13.000000 OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-02 22:02:12.000000 OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-02 22:02:12.000000 OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)      220 2023-05-02 22:02:12.000000 OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-02 22:02:12.000000 OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1805 2023-05-02 22:02:13.163120 OctoBot-Trading-2.4.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.095119 OctoBot-Trading-2.4.0/octobot_trading/
+-rw-r--r--   0 runner    (1001) docker     (123)      792 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.095119 OctoBot-Trading-2.4.0/octobot_trading/api/
+-rw-r--r--   0 runner    (1001) docker     (123)    11009 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1506 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/channels.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1241 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/contracts.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11346 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2941 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/modes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3632 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/orders.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3612 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/positions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3278 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2811 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4644 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/symbol_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2483 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/trader.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2832 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/api/trades.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7958 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15028 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/enums.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5397 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/errors.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9264 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_channel.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.095119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/
+-rw-r--r--   0 runner    (1001) docker     (123)     7200 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/
+-rw-r--r--   0 runner    (1001) docker     (123)     1316 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2776 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/contract_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4376 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/future_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2745 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/margin_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7915 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/exchange_symbol_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1856 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/exchange_symbols_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/
+-rw-r--r--   0 runner    (1001) docker     (123)     1220 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3130 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/funding.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8106 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/funding_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2919 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1850 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/funding_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/
+-rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1343 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2628 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/kline.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3936 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/kline_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3057 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2968 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/kline_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/
+-rw-r--r--   0 runner    (1001) docker     (123)     1953 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4740 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/candles_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10366 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/candles_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1342 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2862 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14979 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8368 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5226 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.099119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/
+-rw-r--r--   0 runner    (1001) docker     (123)     1469 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.103119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1562 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4907 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/order_book.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4028 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/order_book_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2884 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7930 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/order_book_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.103119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/
+-rw-r--r--   0 runner    (1001) docker     (123)     1525 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.103119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3046 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/price.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7729 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/prices_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2313 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6900 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/price_events_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7723 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/prices_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.103119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/
+-rw-r--r--   0 runner    (1001) docker     (123)     1502 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.103119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1593 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4238 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3903 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6871 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2366 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.103119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/
+-rw-r--r--   0 runner    (1001) docker     (123)     1301 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.103119 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1458 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8225 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/ticker.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5312 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/ticker_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6039 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3023 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/ticker_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/
+-rw-r--r--   0 runner    (1001) docker     (123)     5705 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25342 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/abstract_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7947 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/abstract_websocket_exchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/adapters/
+-rw-r--r--   0 runner    (1001) docker     (123)      909 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/adapters/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8134 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/adapters/abstract_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2839 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/basic_exchange_wrapper.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/config/
+-rw-r--r--   0 runner    (1001) docker     (123)     1125 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/config/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1023 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/config/backtesting_exchange_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14782 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/config/exchange_config_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/
+-rw-r--r--   0 runner    (1001) docker     (123)     1229 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/
+-rw-r--r--   0 runner    (1001) docker     (123)     1309 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17945 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7822 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    36361 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44896 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3390 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/enums.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/simulator/
+-rw-r--r--   0 runner    (1001) docker     (123)     1216 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/simulator/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      840 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10529 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8035 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_channels.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8701 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13865 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3688 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_websocket_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3442 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchanges.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/
+-rw-r--r--   0 runner    (1001) docker     (123)     1366 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1483 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/default_rest_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1928 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/default_websocket_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4548 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/exchange_simulator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.107119 OctoBot-Trading-2.4.0/octobot_trading/exchanges/traders/
+-rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/traders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42755 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/traders/trader.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/traders/trader_simulator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.111120 OctoBot-Trading-2.4.0/octobot_trading/exchanges/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1068 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44122 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/types/rest_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9421 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/types/websocket_exchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.111120 OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/
+-rw-r--r--   0 runner    (1001) docker     (123)     2284 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15292 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/exchange_market_status_fixer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14645 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/exchange_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2212 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/websockets_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.111120 OctoBot-Trading-2.4.0/octobot_trading/modes/
+-rw-r--r--   0 runner    (1001) docker     (123)     2665 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16571 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/abstract_trading_mode.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.111120 OctoBot-Trading-2.4.0/octobot_trading/modes/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1414 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10438 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/channel/abstract_mode_consumer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22835 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/channel/abstract_mode_producer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5567 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/channel/mode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5510 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/mode_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5509 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/modes_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1985 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/modes_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.111120 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)     2395 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.111120 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)     2463 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5823 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2357 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/amount.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2719 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1723 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/run_persistence.py
+-rw-r--r--   0 runner    (1001) docker     (123)      995 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4763 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25931 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/context_management.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.111120 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/dsl/
+-rw-r--r--   0 runner    (1001) docker     (123)      943 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/dsl/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2550 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/dsl/quantity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1279 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/dsl/values.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.115120 OctoBot-Trading-2.4.0/octobot_trading/modes/scripted_trading_mode/
+-rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/scripted_trading_mode/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16335 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5364 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/octobot_channel_consumer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.115120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/
+-rw-r--r--   0 runner    (1001) docker     (123)    11980 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19003 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/exchange_personal_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.115120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/
+-rw-r--r--   0 runner    (1001) docker     (123)     7174 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.115120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1361 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13853 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/orders.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10356 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/orders_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1727 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/orders_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13034 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/decimal_order_adapter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.115120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/
+-rw-r--r--   0 runner    (1001) docker     (123)     1573 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9936 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1856 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/group_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3475 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40837 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10764 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5902 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2352 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4875 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22285 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10764 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/orders_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4262 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/orders_storage_operations.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.119120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/
+-rw-r--r--   0 runner    (1001) docker     (123)     2133 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5371 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/cancel_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2600 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/close_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5419 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/fill_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4835 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/open_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1777 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/order_state_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4769 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/pending_creation_order_state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.119120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     2031 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.119120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/
+-rw-r--r--   0 runner    (1001) docker     (123)     2172 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      987 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/buy_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4154 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      989 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/sell_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2084 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1958 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1944 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1961 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/take_profit_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.119120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/
+-rw-r--r--   0 runner    (1001) docker     (123)     1335 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      997 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/buy_market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1995 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      999 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/sell_market_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.119120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/trailing/
+-rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/trailing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1978 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8484 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      971 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/unknown_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1400 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/unsupported_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.123120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/
+-rw-r--r--   0 runner    (1001) docker     (123)     4168 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4783 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/asset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.123120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/
+-rw-r--r--   0 runner    (1001) docker     (123)     1283 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8724 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/future_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4424 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/margin_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2162 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/spot_asset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.123120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1690 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5023 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6141 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/balance_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.123120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/
+-rw-r--r--   0 runner    (1001) docker     (123)     1536 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2391 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/historical_asset_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17826 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14495 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1368 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14643 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7238 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9056 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16679 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_value_holder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3270 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/sub_portfolio.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.123120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1325 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10339 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/future_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1430 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/margin_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3615 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/spot_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17489 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/value_converter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.123120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/
+-rw-r--r--   0 runner    (1001) docker     (123)     2669 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.127120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1351 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2839 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/positions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10013 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/positions_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4971 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38957 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2266 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3662 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)      950 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8139 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/positions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.127120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/
+-rw-r--r--   0 runner    (1001) docker     (123)     1616 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/active_position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4093 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/idle_position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2897 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/liquidate_position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1821 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/position_state_factory.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.127120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1126 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8679 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/types/inverse_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7069 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/types/linear_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8783 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.127120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/
+-rw-r--r--   0 runner    (1001) docker     (123)     1865 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.127120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1135 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2799 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/channel/trades.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4664 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/channel/trades_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8496 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/trade.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3736 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/trade_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6788 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/trade_pnl.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6507 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/trades_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3232 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/trades_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.127120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/
+-rw-r--r--   0 runner    (1001) docker     (123)     1877 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1647 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5136 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/transaction_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3896 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/transactions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.127120 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1615 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2401 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/blockchain_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1790 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/fee_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2166 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/transfer_transaction.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.131120 OctoBot-Trading-2.4.0/octobot_trading/signals/
+-rw-r--r--   0 runner    (1001) docker     (123)     1983 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.131120 OctoBot-Trading-2.4.0/octobot_trading/signals/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6250 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/channel/remote_trading_signal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1791 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/channel/remote_trading_signal_channel_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2790 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/channel/signal_producer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5320 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/signal_creation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11684 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/trading_signal_bundle_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4431 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/signals/util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.131120 OctoBot-Trading-2.4.0/octobot_trading/storage/
+-rw-r--r--   0 runner    (1001) docker     (123)     2159 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6575 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/abstract_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4385 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/candles_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9737 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/orders_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5071 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/portfolio_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5195 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/storage_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8274 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/trades_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4662 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/transactions_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2231 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/storage/util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.131120 OctoBot-Trading-2.4.0/octobot_trading/supervisors/
+-rw-r--r--   0 runner    (1001) docker     (123)     1150 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/supervisors/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2036 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/supervisors/abstract_portfolio_supervisor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3385 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/supervisors/abstract_supervisor.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.131120 OctoBot-Trading-2.4.0/octobot_trading/util/
+-rw-r--r--   0 runner    (1001) docker     (123)     1959 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4552 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/config_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1234 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/initializable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/initialization_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1983 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/simulator_updater_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.131120 OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/
+-rw-r--r--   0 runner    (1001) docker     (123)      715 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2421 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/exchanges_test_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6672 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3809 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/websocket_test_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)      585 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-02 22:02:13.163120 OctoBot-Trading-2.4.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1985 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.091119 OctoBot-Trading-2.4.0/tests/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/api/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1854 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_channels.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2148 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_modes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_orders.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_symbol_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_trader.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/api/test_trades.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/cli/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/cli/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/
+-rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/contracts/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/contracts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3697 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/contracts/test_future_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3044 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/contracts/test_margin_contract.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/funding/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/funding/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2834 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/funding/test_funding_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/kline/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/kline/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4470 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/kline/test_kline_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/ohlcv/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/ohlcv/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6941 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/ohlcv/test_candles_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8970 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/ohlcv/test_candles_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/order_book/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/order_book/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9729 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/order_book/test_order_book_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/prices/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/prices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10397 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/prices/test_price_events_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9662 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/prices/test_prices_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/recent_trades/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/recent_trades/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5439 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/recent_trades/test_recent_trades_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1866 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/test_exchange_symbols_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.135120 OctoBot-Trading-2.4.0/tests/exchange_data/ticker/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/ticker/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4436 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchange_data/ticker/test_ticker_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.139120 OctoBot-Trading-2.4.0/tests/exchanges/
+-rw-r--r--   0 runner    (1001) docker     (123)    10370 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.139120 OctoBot-Trading-2.4.0/tests/exchanges/connectors/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/connectors/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.139120 OctoBot-Trading-2.4.0/tests/exchanges/connectors/ccxt/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/connectors/ccxt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7749 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/connectors/ccxt/test_ccxt_connector.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.139120 OctoBot-Trading-2.4.0/tests/exchanges/implementations/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/implementations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2533 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/implementations/test_default_rest_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5889 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/implementations/test_default_websocket_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3361 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_abstract_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2908 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_abstract_websocket_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2409 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_basic_exchange_wrapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2379 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8157 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_config_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2363 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4814 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4508 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7347 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/test_exchanges.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.139120 OctoBot-Trading-2.4.0/tests/exchanges/traders/
+-rw-r--r--   0 runner    (1001) docker     (123)     4719 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/traders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    50864 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/traders/test_trader.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.139120 OctoBot-Trading-2.4.0/tests/exchanges/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1496 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/types/test_websocket_exchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.139120 OctoBot-Trading-2.4.0/tests/exchanges/util/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14461 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/util/test_exchange_market_status_fixer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5354 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/exchanges/util/test_exchange_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/modes/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/modes/script_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)     3033 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/script_keywords/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/modes/script_keywords/basic_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/script_keywords/basic_keywords/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10968 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/script_keywords/basic_keywords/test_account_balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4933 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/script_keywords/basic_keywords/test_amount.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/modes/script_keywords/dsl/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/script_keywords/dsl/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5707 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/script_keywords/dsl/test_quantity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8929 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/test_abstract_mode_consumer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14658 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/modes/test_abstract_trading_mode.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/personal_data/
+-rw-r--r--   0 runner    (1001) docker     (123)     1311 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/personal_data/orders/
+-rw-r--r--   0 runner    (1001) docker     (123)     4495 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/
+-rw-r--r--   0 runner    (1001) docker     (123)     1157 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19148 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1292 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/test_group_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6753 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3919 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_cancel_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1439 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_close_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2808 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_fill_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_open_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4160 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4799 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_order_state_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1837 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1784 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_pending_creation_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25332 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_decimal_order_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5685 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_double_filled_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18703 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20330 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_order_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10685 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_order_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25593 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_order_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11223 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_orders_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3408 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/test_orders_storage_operations.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.147120 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.151120 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2912 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_buy_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5127 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_sell_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3242 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4868 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_stop_loss_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5061 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_take_profit_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.151120 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/market/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/market/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1650 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/market/test_buy_market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1732 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/market/test_sell_market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      717 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/test_unknown_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.151120 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/trailing/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/trailing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      717 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8964 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.151120 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.151120 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8347 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/test_future_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4557 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/test_margin_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3401 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/test_spot_asset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.151120 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/history/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/history/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3265 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31055 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2543 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)    52120 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5687 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5661 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio_profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11149 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio_value_holder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8684 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_value_converter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    85551 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/test_future_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1807 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/test_margin_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4838 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/test_spot_portfolio.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/personal_data/positions/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/personal_data/positions/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/channel/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/personal_data/positions/states/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    67901 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/test_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3185 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/test_position_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6235 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/test_positions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/personal_data/positions/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37450 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/types/test_inverse_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45257 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/positions/types/test_linear_position.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/personal_data/trades/
+-rw-r--r--   0 runner    (1001) docker     (123)     1381 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/trades/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10436 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/trades/test_trade_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3506 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/trades/test_trade_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14243 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/trades/test_trade_pnl.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/personal_data/transactions/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/transactions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6321 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/transactions/test_transaction_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12957 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/personal_data/transactions/test_transactions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.155120 OctoBot-Trading-2.4.0/tests/signals/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/signals/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29656 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/signals/test_trading_signal_bundle_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10119 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/signals/test_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.159120 OctoBot-Trading-2.4.0/tests/test_utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/test_utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/test_utils/order_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4860 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/test_utils/random_numbers.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.159120 OctoBot-Trading-2.4.0/tests/util/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9443 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests/util/test_config_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.159120 OctoBot-Trading-2.4.0/tests_additional/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-02 22:02:13.163120 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/
+-rw-r--r--   0 runner    (1001) docker     (123)     3953 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10848 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/real_exchange_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2984 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/real_futures_exchange_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7562 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_ascendex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7549 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_binance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9080 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bitfinex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8436 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bitget.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7725 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bithumb.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7483 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bitso.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7587 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bitstamp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7709 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bittrex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8007 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bybit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9037 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bybit_futures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7131 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_coinbase.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7653 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_coinex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7607 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_cryptocom.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7374 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_gateio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7670 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_hitbtc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7671 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_hollaex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7253 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_huobi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_huobipro.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8376 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_kraken.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7920 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_kucoin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9208 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_kucoin_futures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7964 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_ndax.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3628 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_okcoin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7589 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_okx.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8042 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_okx_futures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7593 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_phemex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7282 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_poloniex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7438 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_upbit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9261 2023-05-02 22:01:11.000000 OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_wavesexchange.py
```

### Comparing `OctoBot-Trading-2.3.7/CHANGELOG.md` & `OctoBot-Trading-2.4.0/CHANGELOG.md`

 * *Files 22% similar despite different names*

```diff
@@ -1,13 +1,191 @@
 # Changelog
 All notable changes to this project will be documented in this file.
 
 The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
 and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
 
+## [2.4.0] - 2023-05-02
+### Updated
+- Supported python versions
+### Removed
+- Cython
+
+## [2.3.39] - 2023-04-26
+### Updated
+- [Websockets] improve exchange reconnect 
+
+## [2.3.38] - 2023-04-25
+### Updated
+- [Websockets] exchange reconnect 
+
+## [2.3.37] - 2023-04-21
+### Updated
+- [CCXT] bump to version 3.0.74 
+- [Exchanges] handle authentication requiring exchanges (coinbase)
+### Fixed
+- [Orders] Orders creation related issues
+- [Websockets] Candles warning spam
+
+## [2.3.36] - 2023-04-17
+### Updated
+- [Websockets] Handle partially managed timeframes
+- [TradingModes] Order creation errors explanations 
+### Fixed
+- [Websockets] Error spam
+- [PortfolioHistory] Invalid saved value
+
+## [2.3.35] - 2023-03-30
+### Added
+- [Orders] historical orders update
+### Updated
+- [OrdersChannel] add update_type
+
+## [2.3.34] - 2023-03-27
+### Updated
+- [Exchanges] Inherit AbstractTentacle
+### Fixed
+- [PNL] Invalid orders error
+
+## [2.3.33] - 2023-03-24
+### Fixed
+- [Orders] Reading typing
+
+## [2.3.32] - 2023-03-23
+### Fixed
+- [Orders] default_exchange_update_order_status type error
+
+## [2.3.31] - 2023-03-23
+### Fixed
+- [Profitability] missing price warning
+
+## [2.3.30] - 2023-03-22
+### Added
+- [PNL] accurate fees
+- [API] price convertor
+### Fixed
+- [ExchangeRequests] handle time sync issue in each request
+
+## [2.3.29] - 2023-03-20
+### Fixed
+- [OrderStorage] fix saved orders typing
+
+## [2.3.28] - 2023-03-19
+### Fixed
+- [PortfolioValue] trading pairs origin price computation
+
+## [2.3.27] - 2023-03-16
+### Added
+- [Portfolio] indirect currency valuation
+### Fixed
+- [Portfolio] price initialisation
+
+## [2.3.26] - 2023-03-15
+### Added
+- [Orders] storage system to keep track of groups, chained orders, entries and tags
+- [Exchanges] support for crypto.com
+### Updated
+- [Exchanges] fees checking to ensure closed order fees availability
+### Fixed
+- [PNL] PNL when entry is a sell order
+
+## [2.3.25] - 2023-03-09
+### Added
+- [Exchanges] get_leverage_tiers 
+### Updated
+[Market Status] Allow missing price limits
+### Fixed
+- [Funding] Skip funding fetch on spot pairs
+
+## [2.3.24] - 2023-03-03
+### Added
+- [PNL] TradesPNL system
+- [Futures] Margin mode API
+- [Positions] Active positions can now be awaited
+- [Orders] Accurate cancel order error management
+### Updated
+- [Orders] Better order synchronization from exchange 
+- [Community] Optimize auth storage 
+- [CCXT] to ccxt==2.8.4 
+### Fixed
+- [Orders] Cancel order error 
+- [Websocket] Rare on-disconnect crash 
+- [Futures] Funding issues
+
+## [2.3.23] - 2023-02-17
+### Fixed
+- [Cython] Header
+
+## [2.3.22] - 2023-02-16
+### Fixed
+- [Exchange] Infinite loop error
+
+## [2.3.21] - 2023-02-14
+### Fixed
+- [Portfolio] Non trading exchanges portfolio errors
+
+## [2.3.20] - 2023-02-13
+### Fixed
+- [CCXT] Don't clear throttler queue on close
+
+## [2.3.19] - 2023-02-12
+### Updated
+- [Memory] Improve memory management
+
+## [2.3.18] - 2023-02-11
+### Fixed
+- [Orders] Restore portfolio refresh of exchange missing funds error
+
+## [2.3.17] - 2023-02-11
+### Added
+- [History] Now save and load portfolio and trades history
+### Updated
+- [OrdersManager] Handle since and until params
+- [Errors] Improve error management
+
+## [2.3.16] - 2023-02-05
+### Added
+- [API] get_exchange_backtesting_time_window
+### Updated
+- [Order groups] Handled pending cancel orders
+- [Trading modes] Wait for open orders init before trading
+
+## [2.3.15] - 2023-01-30
+### Updated
+- [FuturesTrading] Make contract error more understandable
+
+## [2.3.14] - 2023-01-30
+### Updated
+- [Exchanges] Remove kline warning, replace it by debug log
+
+## [2.3.13] - 2023-01-27
+### Updated
+- [Exchanges] Improve futures support
+- [Websockets] Reconnect error management
+
+## [2.3.12] - 2023-01-25
+### Fixed
+- [Websockets] Recreate a full ccxt client on reconnection
+
+## [2.3.11] - 2023-01-23
+### Fixed
+- [Websockets] Reconnection on long lasting connections
+
+## [2.3.10] - 2023-01-18
+### Fixed
+- [Ticker] Simulated ticker
+
+## [2.3.9] - 2023-01-18
+### Added
+- [Storage] Add authenticated data call on portfolio and trades update
+
+## [2.3.8] - 2023-01-15
+### Fixed
+- [CandlesManager] Typing issue
+
 ## [2.3.7] - 2023-01-11
 ### Updated
 - [Orders] Properly handle pending creation orders for exchanges that work this way (ex: bybit)
 ### Fixed
 - [Orders] Initial open order fetch timeout error### Fixed
 - [Adapters] Ticker, OHLCV and order issues
```

### Comparing `OctoBot-Trading-2.3.7/LICENSE` & `OctoBot-Trading-2.4.0/LICENSE`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/PKG-INFO` & `OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/PKG-INFO`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,29 @@
 Metadata-Version: 2.1
 Name: OctoBot-Trading
-Version: 2.3.7
+Version: 2.4.0
 Summary: OctoBot project trading package
 Home-page: https://github.com/Drakkar-Software/OctoBot-Trading
 Author: Drakkar-Software
-Author-email: drakkar-software@protonmail.com
+Author-email: contact@drakkar.software
 License: LGPL-3.0
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Cython
 Classifier: Operating System :: OS Independent
 Classifier: Operating System :: MacOS :: MacOS X
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: POSIX
 Requires-Python: >=3.8
 License-File: LICENSE
 
-# OctoBot-Trading [2.3.7](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
+# OctoBot-Trading [2.4.0](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/903b6b22bceb4661b608a86fea655f69)](https://app.codacy.com/gh/Drakkar-Software/OctoBot-Trading?utm_source=github.com&utm_medium=referral&utm_content=Drakkar-Software/OctoBot-Trading&utm_campaign=Badge_Grade_Dashboard)
 [![PyPI](https://img.shields.io/pypi/v/OctoBot-Trading.svg)](https://pypi.python.org/pypi/OctoBot-Trading/)
 [![Coverage Status](https://coveralls.io/repos/github/Drakkar-Software/OctoBot-Trading/badge.svg?branch=master)](https://coveralls.io/github/Drakkar-Software/OctoBot-Trading?branch=master)
 [![Github-Action-CI](https://github.com/Drakkar-Software/OctoBot-Trading/workflows/OctoBot-Trading-CI/badge.svg)](https://github.com/Drakkar-Software/OctoBot-Trading/actions)
 [![Build Status](https://cloud.drone.io/api/badges/Drakkar-Software/OctoBot-Trading/status.svg)](https://cloud.drone.io/Drakkar-Software/OctoBot-Trading)
 
 OctoBot trading package.
+
+OctoBot trading is currently support exchange connections via CCXT. 
+If you wish to add new connectors, please contact the OctoBot team.
```

### Comparing `OctoBot-Trading-2.3.7/OctoBot_Trading.egg-info/SOURCES.txt` & `OctoBot-Trading-2.4.0/OctoBot_Trading.egg-info/SOURCES.txt`

 * *Files 18% similar despite different names*

```diff
@@ -6,228 +6,133 @@
 setup.py
 OctoBot_Trading.egg-info/PKG-INFO
 OctoBot_Trading.egg-info/SOURCES.txt
 OctoBot_Trading.egg-info/dependency_links.txt
 OctoBot_Trading.egg-info/not-zip-safe
 OctoBot_Trading.egg-info/requires.txt
 OctoBot_Trading.egg-info/top_level.txt
-octobot_trading/__init__.pxd
 octobot_trading/__init__.py
 octobot_trading/constants.py
 octobot_trading/enums.py
 octobot_trading/errors.py
-octobot_trading/exchange_channel.pxd
 octobot_trading/exchange_channel.py
-octobot_trading/octobot_channel_consumer.pxd
 octobot_trading/octobot_channel_consumer.py
 octobot_trading/api/__init__.py
 octobot_trading/api/channels.py
 octobot_trading/api/contracts.py
 octobot_trading/api/exchange.py
 octobot_trading/api/modes.py
 octobot_trading/api/orders.py
 octobot_trading/api/portfolio.py
 octobot_trading/api/positions.py
 octobot_trading/api/profitability.py
 octobot_trading/api/storage.py
 octobot_trading/api/symbol_data.py
 octobot_trading/api/trader.py
 octobot_trading/api/trades.py
-octobot_trading/exchange_data/__init__.pxd
 octobot_trading/exchange_data/__init__.py
-octobot_trading/exchange_data/exchange_symbol_data.pxd
 octobot_trading/exchange_data/exchange_symbol_data.py
-octobot_trading/exchange_data/exchange_symbols_data.pxd
 octobot_trading/exchange_data/exchange_symbols_data.py
-octobot_trading/exchange_data/contracts/__init__.pxd
 octobot_trading/exchange_data/contracts/__init__.py
 octobot_trading/exchange_data/contracts/contract_factory.py
-octobot_trading/exchange_data/contracts/future_contract.pxd
 octobot_trading/exchange_data/contracts/future_contract.py
-octobot_trading/exchange_data/contracts/margin_contract.pxd
 octobot_trading/exchange_data/contracts/margin_contract.py
-octobot_trading/exchange_data/funding/__init__.pxd
 octobot_trading/exchange_data/funding/__init__.py
-octobot_trading/exchange_data/funding/funding_manager.pxd
 octobot_trading/exchange_data/funding/funding_manager.py
-octobot_trading/exchange_data/funding/channel/__init__.pxd
 octobot_trading/exchange_data/funding/channel/__init__.py
-octobot_trading/exchange_data/funding/channel/funding.pxd
 octobot_trading/exchange_data/funding/channel/funding.py
-octobot_trading/exchange_data/funding/channel/funding_updater.pxd
 octobot_trading/exchange_data/funding/channel/funding_updater.py
-octobot_trading/exchange_data/funding/channel/funding_updater_simulator.pxd
 octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py
-octobot_trading/exchange_data/kline/__init__.pxd
 octobot_trading/exchange_data/kline/__init__.py
-octobot_trading/exchange_data/kline/kline_manager.pxd
 octobot_trading/exchange_data/kline/kline_manager.py
-octobot_trading/exchange_data/kline/channel/__init__.pxd
 octobot_trading/exchange_data/kline/channel/__init__.py
-octobot_trading/exchange_data/kline/channel/kline.pxd
 octobot_trading/exchange_data/kline/channel/kline.py
-octobot_trading/exchange_data/kline/channel/kline_updater.pxd
 octobot_trading/exchange_data/kline/channel/kline_updater.py
-octobot_trading/exchange_data/kline/channel/kline_updater_simulator.pxd
 octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py
-octobot_trading/exchange_data/ohlcv/__init__.pxd
 octobot_trading/exchange_data/ohlcv/__init__.py
-octobot_trading/exchange_data/ohlcv/candles_adapter.pxd
 octobot_trading/exchange_data/ohlcv/candles_adapter.py
-octobot_trading/exchange_data/ohlcv/candles_manager.pxd
 octobot_trading/exchange_data/ohlcv/candles_manager.py
-octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.pxd
 octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py
-octobot_trading/exchange_data/ohlcv/channel/__init__.pxd
 octobot_trading/exchange_data/ohlcv/channel/__init__.py
-octobot_trading/exchange_data/ohlcv/channel/ohlcv.pxd
 octobot_trading/exchange_data/ohlcv/channel/ohlcv.py
-octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.pxd
 octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py
-octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.pxd
 octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py
-octobot_trading/exchange_data/order_book/__init__.pxd
 octobot_trading/exchange_data/order_book/__init__.py
-octobot_trading/exchange_data/order_book/order_book_manager.pxd
 octobot_trading/exchange_data/order_book/order_book_manager.py
-octobot_trading/exchange_data/order_book/channel/__init__.pxd
 octobot_trading/exchange_data/order_book/channel/__init__.py
-octobot_trading/exchange_data/order_book/channel/order_book.pxd
 octobot_trading/exchange_data/order_book/channel/order_book.py
-octobot_trading/exchange_data/order_book/channel/order_book_updater.pxd
 octobot_trading/exchange_data/order_book/channel/order_book_updater.py
-octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.pxd
 octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py
-octobot_trading/exchange_data/prices/__init__.pxd
 octobot_trading/exchange_data/prices/__init__.py
-octobot_trading/exchange_data/prices/price_events_manager.pxd
 octobot_trading/exchange_data/prices/price_events_manager.py
-octobot_trading/exchange_data/prices/prices_manager.pxd
 octobot_trading/exchange_data/prices/prices_manager.py
-octobot_trading/exchange_data/prices/channel/__init__.pxd
 octobot_trading/exchange_data/prices/channel/__init__.py
-octobot_trading/exchange_data/prices/channel/price.pxd
 octobot_trading/exchange_data/prices/channel/price.py
-octobot_trading/exchange_data/prices/channel/prices_updater.pxd
 octobot_trading/exchange_data/prices/channel/prices_updater.py
-octobot_trading/exchange_data/prices/channel/prices_updater_simulator.pxd
 octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py
-octobot_trading/exchange_data/recent_trades/__init__.pxd
 octobot_trading/exchange_data/recent_trades/__init__.py
-octobot_trading/exchange_data/recent_trades/recent_trades_manager.pxd
 octobot_trading/exchange_data/recent_trades/recent_trades_manager.py
-octobot_trading/exchange_data/recent_trades/channel/__init__.pxd
 octobot_trading/exchange_data/recent_trades/channel/__init__.py
-octobot_trading/exchange_data/recent_trades/channel/recent_trade.pxd
 octobot_trading/exchange_data/recent_trades/channel/recent_trade.py
-octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.pxd
 octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py
-octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.pxd
 octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py
-octobot_trading/exchange_data/ticker/__init__.pxd
 octobot_trading/exchange_data/ticker/__init__.py
-octobot_trading/exchange_data/ticker/ticker_manager.pxd
 octobot_trading/exchange_data/ticker/ticker_manager.py
-octobot_trading/exchange_data/ticker/channel/__init__.pxd
 octobot_trading/exchange_data/ticker/channel/__init__.py
-octobot_trading/exchange_data/ticker/channel/ticker.pxd
 octobot_trading/exchange_data/ticker/channel/ticker.py
-octobot_trading/exchange_data/ticker/channel/ticker_updater.pxd
 octobot_trading/exchange_data/ticker/channel/ticker_updater.py
-octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.pxd
 octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py
-octobot_trading/exchanges/__init__.pxd
 octobot_trading/exchanges/__init__.py
-octobot_trading/exchanges/abstract_exchange.pxd
 octobot_trading/exchanges/abstract_exchange.py
-octobot_trading/exchanges/abstract_websocket_exchange.pxd
 octobot_trading/exchanges/abstract_websocket_exchange.py
-octobot_trading/exchanges/basic_exchange_wrapper.pxd
 octobot_trading/exchanges/basic_exchange_wrapper.py
-octobot_trading/exchanges/exchange_builder.pxd
 octobot_trading/exchanges/exchange_builder.py
-octobot_trading/exchanges/exchange_channels.pxd
 octobot_trading/exchanges/exchange_channels.py
-octobot_trading/exchanges/exchange_factory.pxd
 octobot_trading/exchanges/exchange_factory.py
-octobot_trading/exchanges/exchange_manager.pxd
 octobot_trading/exchanges/exchange_manager.py
-octobot_trading/exchanges/exchange_websocket_factory.pxd
 octobot_trading/exchanges/exchange_websocket_factory.py
-octobot_trading/exchanges/exchanges.pxd
 octobot_trading/exchanges/exchanges.py
 octobot_trading/exchanges/adapters/__init__.py
 octobot_trading/exchanges/adapters/abstract_adapter.py
-octobot_trading/exchanges/config/__init__.pxd
 octobot_trading/exchanges/config/__init__.py
-octobot_trading/exchanges/config/backtesting_exchange_config.pxd
 octobot_trading/exchanges/config/backtesting_exchange_config.py
-octobot_trading/exchanges/config/exchange_config_data.pxd
 octobot_trading/exchanges/config/exchange_config_data.py
-octobot_trading/exchanges/connectors/__init__.pxd
 octobot_trading/exchanges/connectors/__init__.py
-octobot_trading/exchanges/connectors/ccxt/__init__.pxd
 octobot_trading/exchanges/connectors/ccxt/__init__.py
 octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py
-octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.pxd
 octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py
-octobot_trading/exchanges/connectors/ccxt/ccxt_connector.pxd
 octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py
-octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.pxd
 octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py
 octobot_trading/exchanges/connectors/ccxt/constants.py
 octobot_trading/exchanges/connectors/ccxt/enums.py
-octobot_trading/exchanges/connectors/simulator/__init__.pxd
 octobot_trading/exchanges/connectors/simulator/__init__.py
 octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py
-octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.pxd
 octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py
-octobot_trading/exchanges/implementations/__init__.pxd
 octobot_trading/exchanges/implementations/__init__.py
-octobot_trading/exchanges/implementations/default_rest_exchange.pxd
 octobot_trading/exchanges/implementations/default_rest_exchange.py
-octobot_trading/exchanges/implementations/default_websocket_exchange.pxd
 octobot_trading/exchanges/implementations/default_websocket_exchange.py
-octobot_trading/exchanges/implementations/exchange_simulator.pxd
 octobot_trading/exchanges/implementations/exchange_simulator.py
-octobot_trading/exchanges/traders/__init__.pxd
 octobot_trading/exchanges/traders/__init__.py
-octobot_trading/exchanges/traders/trader.pxd
 octobot_trading/exchanges/traders/trader.py
-octobot_trading/exchanges/traders/trader_simulator.pxd
 octobot_trading/exchanges/traders/trader_simulator.py
-octobot_trading/exchanges/types/__init__.pxd
 octobot_trading/exchanges/types/__init__.py
-octobot_trading/exchanges/types/rest_exchange.pxd
 octobot_trading/exchanges/types/rest_exchange.py
-octobot_trading/exchanges/types/websocket_exchange.pxd
 octobot_trading/exchanges/types/websocket_exchange.py
-octobot_trading/exchanges/util/__init__.pxd
 octobot_trading/exchanges/util/__init__.py
-octobot_trading/exchanges/util/exchange_market_status_fixer.pxd
 octobot_trading/exchanges/util/exchange_market_status_fixer.py
-octobot_trading/exchanges/util/exchange_util.pxd
 octobot_trading/exchanges/util/exchange_util.py
-octobot_trading/exchanges/util/websockets_util.pxd
 octobot_trading/exchanges/util/websockets_util.py
-octobot_trading/modes/__init__.pxd
 octobot_trading/modes/__init__.py
 octobot_trading/modes/abstract_trading_mode.py
 octobot_trading/modes/mode_config.py
-octobot_trading/modes/modes_factory.pxd
 octobot_trading/modes/modes_factory.py
-octobot_trading/modes/modes_util.pxd
 octobot_trading/modes/modes_util.py
-octobot_trading/modes/channel/__init__.pxd
 octobot_trading/modes/channel/__init__.py
-octobot_trading/modes/channel/abstract_mode_consumer.pxd
 octobot_trading/modes/channel/abstract_mode_consumer.py
-octobot_trading/modes/channel/abstract_mode_producer.pxd
 octobot_trading/modes/channel/abstract_mode_producer.py
-octobot_trading/modes/channel/mode.pxd
 octobot_trading/modes/channel/mode.py
 octobot_trading/modes/script_keywords/__init__.py
 octobot_trading/modes/script_keywords/context_management.py
 octobot_trading/modes/script_keywords/basic_keywords/__init__.py
 octobot_trading/modes/script_keywords/basic_keywords/account_balance.py
 octobot_trading/modes/script_keywords/basic_keywords/amount.py
 octobot_trading/modes/script_keywords/basic_keywords/configuration.py
@@ -235,243 +140,145 @@
 octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py
 octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py
 octobot_trading/modes/script_keywords/dsl/__init__.py
 octobot_trading/modes/script_keywords/dsl/quantity.py
 octobot_trading/modes/script_keywords/dsl/values.py
 octobot_trading/modes/scripted_trading_mode/__init__.py
 octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py
-octobot_trading/personal_data/__init__.pxd
 octobot_trading/personal_data/__init__.py
-octobot_trading/personal_data/exchange_personal_data.pxd
 octobot_trading/personal_data/exchange_personal_data.py
-octobot_trading/personal_data/state.pxd
 octobot_trading/personal_data/state.py
-octobot_trading/personal_data/orders/__init__.pxd
 octobot_trading/personal_data/orders/__init__.py
-octobot_trading/personal_data/orders/decimal_order_adapter.pxd
 octobot_trading/personal_data/orders/decimal_order_adapter.py
-octobot_trading/personal_data/orders/order.pxd
 octobot_trading/personal_data/orders/order.py
-octobot_trading/personal_data/orders/order_adapter.pxd
 octobot_trading/personal_data/orders/order_adapter.py
-octobot_trading/personal_data/orders/order_factory.pxd
 octobot_trading/personal_data/orders/order_factory.py
-octobot_trading/personal_data/orders/order_group.pxd
 octobot_trading/personal_data/orders/order_group.py
-octobot_trading/personal_data/orders/order_state.pxd
 octobot_trading/personal_data/orders/order_state.py
-octobot_trading/personal_data/orders/order_util.pxd
 octobot_trading/personal_data/orders/order_util.py
-octobot_trading/personal_data/orders/orders_manager.pxd
 octobot_trading/personal_data/orders/orders_manager.py
-octobot_trading/personal_data/orders/channel/__init__.pxd
+octobot_trading/personal_data/orders/orders_storage_operations.py
 octobot_trading/personal_data/orders/channel/__init__.py
-octobot_trading/personal_data/orders/channel/orders.pxd
 octobot_trading/personal_data/orders/channel/orders.py
-octobot_trading/personal_data/orders/channel/orders_updater.pxd
 octobot_trading/personal_data/orders/channel/orders_updater.py
-octobot_trading/personal_data/orders/channel/orders_updater_simulator.pxd
 octobot_trading/personal_data/orders/channel/orders_updater_simulator.py
-octobot_trading/personal_data/orders/groups/__init__.pxd
 octobot_trading/personal_data/orders/groups/__init__.py
-octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.pxd
 octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py
-octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.pxd
+octobot_trading/personal_data/orders/groups/group_util.py
 octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py
-octobot_trading/personal_data/orders/states/__init__.pxd
 octobot_trading/personal_data/orders/states/__init__.py
-octobot_trading/personal_data/orders/states/cancel_order_state.pxd
 octobot_trading/personal_data/orders/states/cancel_order_state.py
-octobot_trading/personal_data/orders/states/close_order_state.pxd
 octobot_trading/personal_data/orders/states/close_order_state.py
-octobot_trading/personal_data/orders/states/fill_order_state.pxd
 octobot_trading/personal_data/orders/states/fill_order_state.py
-octobot_trading/personal_data/orders/states/open_order_state.pxd
 octobot_trading/personal_data/orders/states/open_order_state.py
-octobot_trading/personal_data/orders/states/order_state_factory.pxd
 octobot_trading/personal_data/orders/states/order_state_factory.py
-octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.pxd
 octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py
-octobot_trading/personal_data/orders/states/pending_creation_order_state.pxd
 octobot_trading/personal_data/orders/states/pending_creation_order_state.py
-octobot_trading/personal_data/orders/types/__init__.pxd
 octobot_trading/personal_data/orders/types/__init__.py
-octobot_trading/personal_data/orders/types/unknown_order.pxd
 octobot_trading/personal_data/orders/types/unknown_order.py
-octobot_trading/personal_data/orders/types/limit/__init__.pxd
+octobot_trading/personal_data/orders/types/unsupported_order.py
 octobot_trading/personal_data/orders/types/limit/__init__.py
-octobot_trading/personal_data/orders/types/limit/buy_limit_order.pxd
 octobot_trading/personal_data/orders/types/limit/buy_limit_order.py
-octobot_trading/personal_data/orders/types/limit/limit_order.pxd
 octobot_trading/personal_data/orders/types/limit/limit_order.py
-octobot_trading/personal_data/orders/types/limit/sell_limit_order.pxd
 octobot_trading/personal_data/orders/types/limit/sell_limit_order.py
-octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.pxd
 octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py
-octobot_trading/personal_data/orders/types/limit/stop_loss_order.pxd
 octobot_trading/personal_data/orders/types/limit/stop_loss_order.py
-octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.pxd
 octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py
-octobot_trading/personal_data/orders/types/limit/take_profit_order.pxd
 octobot_trading/personal_data/orders/types/limit/take_profit_order.py
-octobot_trading/personal_data/orders/types/market/__init__.pxd
 octobot_trading/personal_data/orders/types/market/__init__.py
-octobot_trading/personal_data/orders/types/market/buy_market_order.pxd
 octobot_trading/personal_data/orders/types/market/buy_market_order.py
-octobot_trading/personal_data/orders/types/market/market_order.pxd
 octobot_trading/personal_data/orders/types/market/market_order.py
-octobot_trading/personal_data/orders/types/market/sell_market_order.pxd
 octobot_trading/personal_data/orders/types/market/sell_market_order.py
-octobot_trading/personal_data/orders/types/trailing/__init__.pxd
 octobot_trading/personal_data/orders/types/trailing/__init__.py
-octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.pxd
 octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py
-octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.pxd
 octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py
-octobot_trading/personal_data/portfolios/__init__.pxd
 octobot_trading/personal_data/portfolios/__init__.py
-octobot_trading/personal_data/portfolios/asset.pxd
 octobot_trading/personal_data/portfolios/asset.py
-octobot_trading/personal_data/portfolios/portfolio.pxd
 octobot_trading/personal_data/portfolios/portfolio.py
-octobot_trading/personal_data/portfolios/portfolio_factory.pxd
 octobot_trading/personal_data/portfolios/portfolio_factory.py
-octobot_trading/personal_data/portfolios/portfolio_manager.pxd
 octobot_trading/personal_data/portfolios/portfolio_manager.py
-octobot_trading/personal_data/portfolios/portfolio_profitability.pxd
 octobot_trading/personal_data/portfolios/portfolio_profitability.py
-octobot_trading/personal_data/portfolios/portfolio_util.pxd
 octobot_trading/personal_data/portfolios/portfolio_util.py
-octobot_trading/personal_data/portfolios/portfolio_value_holder.pxd
 octobot_trading/personal_data/portfolios/portfolio_value_holder.py
-octobot_trading/personal_data/portfolios/sub_portfolio.pxd
 octobot_trading/personal_data/portfolios/sub_portfolio.py
-octobot_trading/personal_data/portfolios/assets/__init__.pxd
+octobot_trading/personal_data/portfolios/value_converter.py
 octobot_trading/personal_data/portfolios/assets/__init__.py
-octobot_trading/personal_data/portfolios/assets/future_asset.pxd
 octobot_trading/personal_data/portfolios/assets/future_asset.py
-octobot_trading/personal_data/portfolios/assets/margin_asset.pxd
 octobot_trading/personal_data/portfolios/assets/margin_asset.py
-octobot_trading/personal_data/portfolios/assets/spot_asset.pxd
 octobot_trading/personal_data/portfolios/assets/spot_asset.py
-octobot_trading/personal_data/portfolios/channel/__init__.pxd
 octobot_trading/personal_data/portfolios/channel/__init__.py
-octobot_trading/personal_data/portfolios/channel/balance.pxd
 octobot_trading/personal_data/portfolios/channel/balance.py
-octobot_trading/personal_data/portfolios/channel/balance_updater.pxd
 octobot_trading/personal_data/portfolios/channel/balance_updater.py
-octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.pxd
 octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py
-octobot_trading/personal_data/portfolios/history/__init__.pxd
 octobot_trading/personal_data/portfolios/history/__init__.py
-octobot_trading/personal_data/portfolios/history/historical_asset_value.pxd
 octobot_trading/personal_data/portfolios/history/historical_asset_value.py
-octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.pxd
 octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py
-octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.pxd
 octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py
-octobot_trading/personal_data/portfolios/types/__init__.pxd
 octobot_trading/personal_data/portfolios/types/__init__.py
-octobot_trading/personal_data/portfolios/types/future_portfolio.pxd
 octobot_trading/personal_data/portfolios/types/future_portfolio.py
-octobot_trading/personal_data/portfolios/types/margin_portfolio.pxd
 octobot_trading/personal_data/portfolios/types/margin_portfolio.py
-octobot_trading/personal_data/portfolios/types/spot_portfolio.pxd
 octobot_trading/personal_data/portfolios/types/spot_portfolio.py
-octobot_trading/personal_data/positions/__init__.pxd
 octobot_trading/personal_data/positions/__init__.py
-octobot_trading/personal_data/positions/position.pxd
 octobot_trading/personal_data/positions/position.py
-octobot_trading/personal_data/positions/position_factory.pxd
 octobot_trading/personal_data/positions/position_factory.py
-octobot_trading/personal_data/positions/position_state.pxd
 octobot_trading/personal_data/positions/position_state.py
-octobot_trading/personal_data/positions/position_util.pxd
 octobot_trading/personal_data/positions/position_util.py
-octobot_trading/personal_data/positions/positions_manager.pxd
 octobot_trading/personal_data/positions/positions_manager.py
-octobot_trading/personal_data/positions/channel/__init__.pxd
 octobot_trading/personal_data/positions/channel/__init__.py
-octobot_trading/personal_data/positions/channel/positions.pxd
 octobot_trading/personal_data/positions/channel/positions.py
-octobot_trading/personal_data/positions/channel/positions_updater.pxd
 octobot_trading/personal_data/positions/channel/positions_updater.py
-octobot_trading/personal_data/positions/channel/positions_updater_simulator.pxd
 octobot_trading/personal_data/positions/channel/positions_updater_simulator.py
-octobot_trading/personal_data/positions/states/__init__.pxd
 octobot_trading/personal_data/positions/states/__init__.py
-octobot_trading/personal_data/positions/states/liquidate_position_state.pxd
+octobot_trading/personal_data/positions/states/active_position_state.py
+octobot_trading/personal_data/positions/states/idle_position_state.py
 octobot_trading/personal_data/positions/states/liquidate_position_state.py
-octobot_trading/personal_data/positions/states/open_position_state.pxd
-octobot_trading/personal_data/positions/states/open_position_state.py
-octobot_trading/personal_data/positions/states/position_state_factory.pxd
 octobot_trading/personal_data/positions/states/position_state_factory.py
-octobot_trading/personal_data/positions/types/__init__.pxd
 octobot_trading/personal_data/positions/types/__init__.py
-octobot_trading/personal_data/positions/types/inverse_position.pxd
 octobot_trading/personal_data/positions/types/inverse_position.py
-octobot_trading/personal_data/positions/types/linear_position.pxd
 octobot_trading/personal_data/positions/types/linear_position.py
-octobot_trading/personal_data/trades/__init__.pxd
 octobot_trading/personal_data/trades/__init__.py
-octobot_trading/personal_data/trades/trade.pxd
 octobot_trading/personal_data/trades/trade.py
-octobot_trading/personal_data/trades/trade_factory.pxd
 octobot_trading/personal_data/trades/trade_factory.py
-octobot_trading/personal_data/trades/trades_manager.pxd
+octobot_trading/personal_data/trades/trade_pnl.py
 octobot_trading/personal_data/trades/trades_manager.py
 octobot_trading/personal_data/trades/trades_util.py
-octobot_trading/personal_data/trades/channel/__init__.pxd
 octobot_trading/personal_data/trades/channel/__init__.py
-octobot_trading/personal_data/trades/channel/trades.pxd
 octobot_trading/personal_data/trades/channel/trades.py
-octobot_trading/personal_data/trades/channel/trades_updater.pxd
 octobot_trading/personal_data/trades/channel/trades_updater.py
-octobot_trading/personal_data/transactions/__init__.pxd
 octobot_trading/personal_data/transactions/__init__.py
-octobot_trading/personal_data/transactions/transaction.pxd
 octobot_trading/personal_data/transactions/transaction.py
-octobot_trading/personal_data/transactions/transaction_factory.pxd
 octobot_trading/personal_data/transactions/transaction_factory.py
-octobot_trading/personal_data/transactions/transactions_manager.pxd
 octobot_trading/personal_data/transactions/transactions_manager.py
-octobot_trading/personal_data/transactions/types/__init__.pxd
 octobot_trading/personal_data/transactions/types/__init__.py
-octobot_trading/personal_data/transactions/types/blockchain_transaction.pxd
 octobot_trading/personal_data/transactions/types/blockchain_transaction.py
-octobot_trading/personal_data/transactions/types/fee_transaction.pxd
 octobot_trading/personal_data/transactions/types/fee_transaction.py
-octobot_trading/personal_data/transactions/types/realised_pnl_transaction.pxd
 octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py
-octobot_trading/personal_data/transactions/types/transfer_transaction.pxd
 octobot_trading/personal_data/transactions/types/transfer_transaction.py
 octobot_trading/signals/__init__.py
 octobot_trading/signals/signal_creation.py
 octobot_trading/signals/trading_signal_bundle_builder.py
 octobot_trading/signals/util.py
 octobot_trading/signals/channel/__init__.py
 octobot_trading/signals/channel/remote_trading_signal.py
 octobot_trading/signals/channel/remote_trading_signal_channel_factory.py
 octobot_trading/signals/channel/signal_producer.py
 octobot_trading/storage/__init__.py
 octobot_trading/storage/abstract_storage.py
 octobot_trading/storage/candles_storage.py
+octobot_trading/storage/orders_storage.py
 octobot_trading/storage/portfolio_storage.py
 octobot_trading/storage/storage_manager.py
 octobot_trading/storage/trades_storage.py
 octobot_trading/storage/transactions_storage.py
-octobot_trading/supervisors/__init__.pxd
+octobot_trading/storage/util.py
 octobot_trading/supervisors/__init__.py
 octobot_trading/supervisors/abstract_portfolio_supervisor.py
 octobot_trading/supervisors/abstract_supervisor.py
-octobot_trading/util/__init__.pxd
 octobot_trading/util/__init__.py
-octobot_trading/util/config_util.pxd
 octobot_trading/util/config_util.py
-octobot_trading/util/initializable.pxd
 octobot_trading/util/initializable.py
 octobot_trading/util/initialization_util.py
 octobot_trading/util/simulator_updater_utils.py
 octobot_trading/util/test_tools/__init__.py
 octobot_trading/util/test_tools/exchanges_test_tools.py
 octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py
 octobot_trading/util/test_tools/websocket_test_tools.py
@@ -543,16 +350,19 @@
 tests/personal_data/orders/__init__.py
 tests/personal_data/orders/test_decimal_order_adapter.py
 tests/personal_data/orders/test_double_filled_order.py
 tests/personal_data/orders/test_order.py
 tests/personal_data/orders/test_order_adapter.py
 tests/personal_data/orders/test_order_factory.py
 tests/personal_data/orders/test_order_util.py
+tests/personal_data/orders/test_orders_manager.py
+tests/personal_data/orders/test_orders_storage_operations.py
 tests/personal_data/orders/groups/__init__.py
 tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py
+tests/personal_data/orders/groups/test_group_util.py
 tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py
 tests/personal_data/orders/states/__init__.py
 tests/personal_data/orders/states/test_cancel_order_state.py
 tests/personal_data/orders/states/test_close_order_state.py
 tests/personal_data/orders/states/test_fill_order_state.py
 tests/personal_data/orders/states/test_open_order_state.py
 tests/personal_data/orders/states/test_order_state.py
@@ -576,14 +386,15 @@
 tests/personal_data/orders/types/trailing/test_trailing_stop_order.py
 tests/personal_data/portfolios/__init__.py
 tests/personal_data/portfolios/test_asset.py
 tests/personal_data/portfolios/test_portfolio.py
 tests/personal_data/portfolios/test_portfolio_manager.py
 tests/personal_data/portfolios/test_portfolio_profitability.py
 tests/personal_data/portfolios/test_portfolio_value_holder.py
+tests/personal_data/portfolios/test_value_converter.py
 tests/personal_data/portfolios/assets/__init__.py
 tests/personal_data/portfolios/assets/test_future_asset.py
 tests/personal_data/portfolios/assets/test_margin_asset.py
 tests/personal_data/portfolios/assets/test_spot_asset.py
 tests/personal_data/portfolios/history/__init__.py
 tests/personal_data/portfolios/history/test_historical_asset_value_factory.py
 tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py
@@ -599,46 +410,52 @@
 tests/personal_data/positions/states/__init__.py
 tests/personal_data/positions/types/__init__.py
 tests/personal_data/positions/types/test_inverse_position.py
 tests/personal_data/positions/types/test_linear_position.py
 tests/personal_data/trades/__init__.py
 tests/personal_data/trades/test_trade_factory.py
 tests/personal_data/trades/test_trade_manager.py
+tests/personal_data/trades/test_trade_pnl.py
 tests/personal_data/transactions/__init__.py
 tests/personal_data/transactions/test_transaction_factory.py
 tests/personal_data/transactions/test_transactions_manager.py
 tests/signals/__init__.py
 tests/signals/test_trading_signal_bundle_builder.py
 tests/signals/test_util.py
 tests/test_utils/__init__.py
 tests/test_utils/order_util.py
 tests/test_utils/random_numbers.py
 tests/util/__init__.py
 tests/util/test_config_util.py
 tests_additional/__init__.py
 tests_additional/real_exchanges/__init__.py
 tests_additional/real_exchanges/real_exchange_tester.py
+tests_additional/real_exchanges/real_futures_exchange_tester.py
 tests_additional/real_exchanges/test_ascendex.py
 tests_additional/real_exchanges/test_binance.py
 tests_additional/real_exchanges/test_bitfinex.py
 tests_additional/real_exchanges/test_bitget.py
 tests_additional/real_exchanges/test_bithumb.py
 tests_additional/real_exchanges/test_bitso.py
 tests_additional/real_exchanges/test_bitstamp.py
 tests_additional/real_exchanges/test_bittrex.py
 tests_additional/real_exchanges/test_bybit.py
-tests_additional/real_exchanges/test_coinbasepro.py
+tests_additional/real_exchanges/test_bybit_futures.py
+tests_additional/real_exchanges/test_coinbase.py
 tests_additional/real_exchanges/test_coinex.py
+tests_additional/real_exchanges/test_cryptocom.py
 tests_additional/real_exchanges/test_gateio.py
 tests_additional/real_exchanges/test_hitbtc.py
 tests_additional/real_exchanges/test_hollaex.py
 tests_additional/real_exchanges/test_huobi.py
 tests_additional/real_exchanges/test_huobipro.py
 tests_additional/real_exchanges/test_kraken.py
 tests_additional/real_exchanges/test_kucoin.py
+tests_additional/real_exchanges/test_kucoin_futures.py
 tests_additional/real_exchanges/test_ndax.py
 tests_additional/real_exchanges/test_okcoin.py
 tests_additional/real_exchanges/test_okx.py
+tests_additional/real_exchanges/test_okx_futures.py
 tests_additional/real_exchanges/test_phemex.py
 tests_additional/real_exchanges/test_poloniex.py
 tests_additional/real_exchanges/test_upbit.py
 tests_additional/real_exchanges/test_wavesexchange.py
```

### Comparing `OctoBot-Trading-2.3.7/PKG-INFO` & `OctoBot-Trading-2.4.0/PKG-INFO`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,29 @@
 Metadata-Version: 2.1
 Name: OctoBot-Trading
-Version: 2.3.7
+Version: 2.4.0
 Summary: OctoBot project trading package
 Home-page: https://github.com/Drakkar-Software/OctoBot-Trading
 Author: Drakkar-Software
-Author-email: drakkar-software@protonmail.com
+Author-email: contact@drakkar.software
 License: LGPL-3.0
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Cython
 Classifier: Operating System :: OS Independent
 Classifier: Operating System :: MacOS :: MacOS X
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: POSIX
 Requires-Python: >=3.8
 License-File: LICENSE
 
-# OctoBot-Trading [2.3.7](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
+# OctoBot-Trading [2.4.0](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/903b6b22bceb4661b608a86fea655f69)](https://app.codacy.com/gh/Drakkar-Software/OctoBot-Trading?utm_source=github.com&utm_medium=referral&utm_content=Drakkar-Software/OctoBot-Trading&utm_campaign=Badge_Grade_Dashboard)
 [![PyPI](https://img.shields.io/pypi/v/OctoBot-Trading.svg)](https://pypi.python.org/pypi/OctoBot-Trading/)
 [![Coverage Status](https://coveralls.io/repos/github/Drakkar-Software/OctoBot-Trading/badge.svg?branch=master)](https://coveralls.io/github/Drakkar-Software/OctoBot-Trading?branch=master)
 [![Github-Action-CI](https://github.com/Drakkar-Software/OctoBot-Trading/workflows/OctoBot-Trading-CI/badge.svg)](https://github.com/Drakkar-Software/OctoBot-Trading/actions)
 [![Build Status](https://cloud.drone.io/api/badges/Drakkar-Software/OctoBot-Trading/status.svg)](https://cloud.drone.io/Drakkar-Software/OctoBot-Trading)
 
 OctoBot trading package.
+
+OctoBot trading is currently support exchange connections via CCXT. 
+If you wish to add new connectors, please contact the OctoBot team.
```

### Comparing `OctoBot-Trading-2.3.7/README.md` & `OctoBot-Trading-2.4.0/README.md`

 * *Files 27% similar despite different names*

```diff
@@ -1,8 +1,11 @@
-# OctoBot-Trading [2.3.7](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
+# OctoBot-Trading [2.4.0](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/903b6b22bceb4661b608a86fea655f69)](https://app.codacy.com/gh/Drakkar-Software/OctoBot-Trading?utm_source=github.com&utm_medium=referral&utm_content=Drakkar-Software/OctoBot-Trading&utm_campaign=Badge_Grade_Dashboard)
 [![PyPI](https://img.shields.io/pypi/v/OctoBot-Trading.svg)](https://pypi.python.org/pypi/OctoBot-Trading/)
 [![Coverage Status](https://coveralls.io/repos/github/Drakkar-Software/OctoBot-Trading/badge.svg?branch=master)](https://coveralls.io/github/Drakkar-Software/OctoBot-Trading?branch=master)
 [![Github-Action-CI](https://github.com/Drakkar-Software/OctoBot-Trading/workflows/OctoBot-Trading-CI/badge.svg)](https://github.com/Drakkar-Software/OctoBot-Trading/actions)
 [![Build Status](https://cloud.drone.io/api/badges/Drakkar-Software/OctoBot-Trading/status.svg)](https://cloud.drone.io/Drakkar-Software/OctoBot-Trading)
 
-OctoBot trading package.
+OctoBot trading package.
+
+OctoBot trading is currently support exchange connections via CCXT. 
+If you wish to add new connectors, please contact the OctoBot team.
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/__init__.pxd` & `OctoBot-Trading-2.4.0/tests/api/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py`

 * *Files 13% similar despite different names*

```diff
@@ -10,9 +10,12 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-PROJECT_NAME = "OctoBot-Trading"
-VERSION = "2.3.7"  # major.minor.revision
+import octobot_trading.exchanges.adapters as adapters
+
+
+class ExchangeSimulatorAdapter(adapters.AbstractAdapter):
+    pass
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -45,14 +45,15 @@
     create_new_candles_manager,
     force_set_mark_price,
     is_mark_price_initialized,
     get_config_symbols,
 )
 from octobot_trading.api.trades import (
     get_trade_history,
+    get_completed_pnl_history,
     get_total_paid_trading_fees,
     get_trade_exchange_name,
     parse_trade_type,
     trade_to_dict,
     get_win_rate,
 )
 from octobot_trading.api.channels import (
@@ -70,14 +71,15 @@
     get_exchange_manager_from_exchange_id,
     get_exchange_managers_from_exchange_ids,
     get_trading_exchanges,
     is_exchange_trading,
     get_exchange_manager_id,
     get_exchange_manager_is_sandboxed,
     get_exchange_current_time,
+    get_exchange_backtesting_time_window,
     get_exchange_allowed_time_lag,
     get_exchange_id_from_matrix_id,
     get_matrix_id_from_exchange_id,
     get_all_exchange_ids_from_matrix_id,
     get_exchange_configuration_from_exchange,
     get_all_exchange_ids_with_same_matrix_id,
     get_exchange_names,
@@ -106,14 +108,15 @@
     get_base_currency,
     get_fees,
     get_max_handled_pair_with_time_frame,
     get_currently_handled_pair_with_time_frame,
     get_required_historical_candles_count,
     is_overloaded,
     store_history_in_run_storage,
+    get_enabled_exchanges_names,
     cancel_ccxt_throttle_task,
     stop_exchange,
 )
 from octobot_trading.api.modes import (
     get_trading_modes,
     get_trading_mode_symbol,
     get_trading_mode_followed_strategy_signals_identifier,
@@ -137,26 +140,28 @@
     sell_all_everything_for_reference_market,
     sell_currency_for_reference_market,
     get_current_bot_live_id,
 )
 from octobot_trading.api.portfolio import (
     get_portfolio,
     get_portfolio_historical_values,
-    reset_portfolio_historical_values,
     get_portfolio_currency,
     get_origin_portfolio,
+    set_simulated_portfolio_initial_config,
     refresh_real_trader_portfolio,
     format_portfolio,
     get_draw_down,
     get_coefficient_of_determination,
+    get_global_portfolio_currencies_values,
 )
 from octobot_trading.api.profitability import (
     get_profitability_stats,
     get_origin_portfolio_value,
     get_current_portfolio_value,
+    get_currency_ref_market_value,
     get_current_holdings_values,
     get_current_crypto_currency_value,
     get_reference_market,
     get_initializing_currencies_prices,
 )
 from octobot_trading.api.orders import (
     get_open_orders,
@@ -175,21 +180,26 @@
     get_positions,
     close_position,
 )
 from octobot_trading.api.contracts import (
     is_inverse_future_contract,
     is_perpetual_future_contract,
     get_pair_contracts,
+    is_handled_contract,
 )
 from octobot_trading.api.storage import (
     clear_trades_storage_history,
     clear_candles_storage_history,
+    clear_database_storage_history,
     clear_transactions_storage_history,
     clear_portfolio_storage_history,
     clear_orders_storage_history,
+    get_account_type,
+    get_account_type_from_run_metadata,
+    get_account_type_from_exchange_manager,
 )
 
 __all__ = [
     "get_symbol_data",
     "get_symbol_candles_manager",
     "get_symbol_historical_candles",
     "create_preloaded_candles_manager",
@@ -205,14 +215,15 @@
     "get_symbol_volume_candles",
     "get_symbol_time_candles",
     "create_new_candles_manager",
     "force_set_mark_price",
     "is_mark_price_initialized",
     "get_config_symbols",
     "get_trade_history",
+    "get_completed_pnl_history",
     "get_total_paid_trading_fees",
     "get_trade_exchange_name",
     "parse_trade_type",
     "trade_to_dict",
     "get_win_rate",
     "subscribe_to_ohlcv_channel",
     "subscribe_to_trades_channel",
@@ -226,14 +237,15 @@
     "get_exchange_manager_from_exchange_id",
     "get_exchange_managers_from_exchange_ids",
     "get_trading_exchanges",
     "is_exchange_trading",
     "get_exchange_manager_id",
     "get_exchange_manager_is_sandboxed",
     "get_exchange_current_time",
+    "get_exchange_backtesting_time_window",
     "get_exchange_allowed_time_lag",
     "get_exchange_id_from_matrix_id",
     "get_matrix_id_from_exchange_id",
     "get_all_exchange_ids_from_matrix_id",
     "get_exchange_configuration_from_exchange",
     "get_all_exchange_ids_with_same_matrix_id",
     "get_exchange_names",
@@ -262,14 +274,15 @@
     "get_base_currency",
     "get_fees",
     "get_max_handled_pair_with_time_frame",
     "get_currently_handled_pair_with_time_frame",
     "get_required_historical_candles_count",
     "is_overloaded",
     "store_history_in_run_storage",
+    "get_enabled_exchanges_names",
     "cancel_ccxt_throttle_task",
     "stop_exchange",
     "get_trading_modes",
     "get_trading_mode_symbol",
     "get_trading_mode_followed_strategy_signals_identifier",
     "get_trading_mode_current_state",
     "get_activated_trading_mode",
@@ -287,24 +300,26 @@
     "get_trader_risk",
     "set_trader_risk",
     "sell_all_everything_for_reference_market",
     "sell_currency_for_reference_market",
     "get_current_bot_live_id",
     "get_portfolio",
     "get_portfolio_historical_values",
-    "reset_portfolio_historical_values",
     "get_portfolio_currency",
     "get_origin_portfolio",
+    "set_simulated_portfolio_initial_config",
     "refresh_real_trader_portfolio",
     "get_draw_down",
     "get_coefficient_of_determination",
+    "get_global_portfolio_currencies_values",
     "get_origin_portfolio_value",
     "get_profitability_stats",
     "format_portfolio",
     "get_current_portfolio_value",
+    "get_currency_ref_market_value",
     "get_current_holdings_values",
     "get_current_crypto_currency_value",
     "get_reference_market",
     "get_initializing_currencies_prices",
     "get_open_orders",
     "get_order_exchange_name",
     "order_to_dict",
@@ -316,13 +331,18 @@
     "cancel_all_open_orders_with_currency",
     "cancel_order_with_id",
     "get_positions",
     "close_position",
     "is_inverse_future_contract",
     "is_perpetual_future_contract",
     "get_pair_contracts",
+    "is_handled_contract",
     "clear_trades_storage_history",
     "clear_candles_storage_history",
+    "clear_database_storage_history",
+    "get_account_type",
+    "get_account_type_from_run_metadata",
+    "get_account_type_from_exchange_manager",
     "clear_transactions_storage_history",
     "clear_portfolio_storage_history",
     "clear_orders_storage_history",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/channels.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/channels.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/contracts.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/contracts.py`

 * *Files 15% similar despite different names*

```diff
@@ -22,7 +22,11 @@
 
 def is_perpetual_future_contract(contract_type):
     return exchange_data.FutureContract(None, None, contract_type).is_perpetual_contract()
 
 
 def get_pair_contracts(exchange_manager) -> dict:
     return exchange_manager.exchange.pair_contracts
+
+
+def is_handled_contract(contract) -> bool:
+    return contract.is_handled_contract()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/exchange.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/exchange.py`

 * *Files 4% similar despite different names*

```diff
@@ -104,14 +104,22 @@
     return exchange_manager.is_sandboxed
 
 
 def get_exchange_current_time(exchange_manager) -> float:
     return exchange_manager.exchange.get_exchange_current_time()
 
 
+def get_exchange_backtesting_time_window(exchange_manager) -> (float, float):
+    return backtesting_api.get_backtesting_starting_time(
+        exchange_manager.exchange.backtesting
+    ), backtesting_api.get_backtesting_ending_time(
+        exchange_manager.exchange.backtesting
+    )
+
+
 def get_exchange_allowed_time_lag(exchange_manager) -> float:
     return exchange_manager.exchange.allowed_time_lag
 
 
 def get_exchange_id_from_matrix_id(exchange_name: str, matrix_id: str) -> str:
     for exchange_configuration in get_exchange_configurations_from_exchange_name(exchange_name).values():
         if exchange_configuration.matrix_id == matrix_id:
@@ -192,15 +200,14 @@
     return exchange_manager.has_websocket
 
 
 def supports_websockets(exchange_name: str, tentacles_setup_config) -> bool:
     return exchanges.supports_websocket(exchange_name, tentacles_setup_config)
 
 
-# TODO remove after ccxt symbols update
 def get_trading_pairs(exchange_manager) -> list:
     return exchange_manager.exchange_config.traded_symbol_pairs
 
 
 def get_all_exchange_symbols(exchange_manager) -> list:
     return exchange_manager.client_symbols
 
@@ -260,28 +267,37 @@
     return trading_backend.is_sponsoring(exchange_name)
 
 
 def is_valid_account(exchange_manager) -> bool:
     return exchange_manager.is_valid_account
 
 
-def get_historical_ohlcv(exchange_manager, symbol, time_frame, start_time, end_time):
-    return exchanges.get_historical_ohlcv(exchange_manager, symbol, time_frame, start_time, end_time)
+def get_historical_ohlcv(
+        exchange_manager, symbol, time_frame, start_time, end_time,
+        request_retry_timeout=octobot_trading.constants.HISTORICAL_CANDLES_FETCH_DEFAULT_TIMEOUT
+):
+    return exchanges.get_historical_ohlcv(
+        exchange_manager, symbol, time_frame, start_time, end_time, request_retry_timeout=request_retry_timeout
+    )
 
 
 def get_bot_id(exchange_manager):
     return exchange_manager.bot_id
 
 
 def get_supported_exchange_types(exchange_name) -> list:
     return exchanges.get_supported_exchange_types(exchange_name)
 
 
 async def store_history_in_run_storage(exchange_manager):
     await exchange_manager.storage_manager.store_history()
 
 
+def get_enabled_exchanges_names(config) -> list:
+    return exchanges.get_enabled_exchanges(config)
+
+
 def cancel_ccxt_throttle_task():
     for task in asyncio.all_tasks():
         # manually cancel ccxt async throttle task since it apparently can't be cancelled otherwise
         if str(task._coro).startswith("<coroutine object Throttler.looper at"):
             task.cancel()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/modes.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/modes.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/orders.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/orders.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/portfolio.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/portfolio.py`

 * *Files 15% similar despite different names*

```diff
@@ -24,35 +24,55 @@
     return format_portfolio(
         exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio,
         as_decimal
     )
 
 
 def get_portfolio_historical_values(exchange_manager, currency, time_frame, from_timestamp=None, to_timestamp=None) \
-        -> dict:
-    return exchange_manager.exchange_personal_data.portfolio_manager.get_portfolio_historical_values(
-        currency, time_frame, from_timestamp, to_timestamp
-    )
-
-
-async def reset_portfolio_historical_values(exchange_manager):
-    await exchange_manager.exchange_personal_data.portfolio_manager.historical_portfolio_value_manager.reset_history()
+        -> list:
+    if exchange_manager.exchange_personal_data.portfolio_manager:
+        return exchange_manager.exchange_personal_data.portfolio_manager.get_portfolio_historical_values(
+            currency, time_frame, from_timestamp, to_timestamp
+        )
+    return []
+
+
+def get_global_portfolio_currencies_values(exchange_managers: list) -> dict:
+    currencies_values = {}
+    for exchange in exchange_managers:
+        this_currency_values = (
+            exchange.exchange_personal_data.portfolio_manager \
+                .portfolio_value_holder.get_current_crypto_currencies_values()
+        )
+        for currency, value in this_currency_values.items():
+            if currency not in currencies_values:
+                currencies_values[currency] = value
+            else:
+                currencies_values[currency] += value
+    return currencies_values
 
 
 def get_portfolio_currency(exchange_manager, currency) -> personal_data.Asset:
     return exchange_manager.exchange_personal_data.portfolio_manager.portfolio.get_currency_portfolio(currency)
 
 
 def get_origin_portfolio(exchange_manager, as_decimal=True) -> dict:
     return format_portfolio(
         exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.origin_portfolio.portfolio,
         as_decimal
     )
 
 
+def set_simulated_portfolio_initial_config(exchange_manager, portfolio_content):
+    if exchange_manager.exchange_personal_data.portfolio_manager:
+        exchange_manager.exchange_personal_data.portfolio_manager.set_simulated_portfolio_initial_config(
+            portfolio_content
+        )
+
+
 def format_portfolio(portfolio, as_decimal) -> dict:
     if as_decimal:
         return portfolio
     return personal_data.portfolio_to_float(portfolio)
 
 
 async def refresh_real_trader_portfolio(exchange_manager) -> bool:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/positions.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/positions.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/profitability.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/profitability.py`

 * *Files 24% similar despite different names*

```diff
@@ -11,14 +11,16 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import decimal
 
+import octobot_trading.constants as constants
+import octobot_trading.errors as errors
 import octobot_trading.util as util
 
 
 def get_profitability_stats(exchange_manager) -> tuple:
     port_profit = exchange_manager.exchange_personal_data.portfolio_manager.portfolio_profitability
     return port_profit.profitability, \
         port_profit.profitability_percent, \
@@ -32,23 +34,44 @@
 
 
 def get_current_portfolio_value(exchange_manager) -> float:
     return exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.portfolio_current_value
 
 
 def get_current_crypto_currency_value(exchange_manager, currency) -> decimal.Decimal:
-    return exchange_manager.exchange_personal_data.portfolio_manager. \
-        portfolio_value_holder.current_crypto_currencies_values[currency]
+    try:
+        return exchange_manager.exchange_personal_data.portfolio_manager. \
+            portfolio_value_holder.current_crypto_currencies_values[currency]
+    except KeyError:
+        try:
+            # try using last prices by trading pair
+            return exchange_manager.exchange_personal_data.portfolio_manager. \
+                portfolio_value_holder.value_converter.convert_currency_value_using_last_prices(
+                    constants.ONE,
+                    currency,
+                    exchange_manager.exchange_personal_data.portfolio_manager.reference_market
+                )
+        except errors.MissingPriceDataError as err:
+            raise KeyError from err
+
+
+def get_currency_ref_market_value(exchange_manager, currency):
+    try:
+        return exchange_manager.exchange_personal_data.portfolio_manager. \
+            portfolio_value_holder.value_converter.evaluate_value(currency, constants.ONE) or None
+    except errors.MissingPriceDataError:
+        return None
 
 
 def get_current_holdings_values(exchange_manager) -> dict:
     return exchange_manager.exchange_personal_data.portfolio_manager.\
         portfolio_value_holder.get_current_holdings_values()
 
 
 def get_reference_market(config) -> str:
     return util.get_reference_market(config)
 
 
 def get_initializing_currencies_prices(exchange_manager) -> set:
     return set() if exchange_manager.exchange_personal_data.portfolio_manager is None else \
-        exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.initializing_symbol_prices
+        exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
+        value_converter.initializing_symbol_prices
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/storage.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/storage.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,27 +9,53 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import octobot_trading.storage as storage
 
 
 async def clear_trades_storage_history(exchange_manager, flush=True):
-    await exchange_manager.storage_manager.trades_storage.clear_history(flush=flush)
+    if exchange_manager.storage_manager.trades_storage:
+        await exchange_manager.storage_manager.trades_storage.clear_history(flush=flush)
+    if exchange_manager.exchange_personal_data.trades_manager:
+        await exchange_manager.exchange_personal_data.trades_manager.reload_history(True)
 
 
 async def clear_orders_storage_history(exchange_manager, flush=True):
-    await exchange_manager.storage_manager.orders_storage.clear_history(flush=flush)
+    if exchange_manager.storage_manager.orders_storage:
+        await exchange_manager.storage_manager.orders_storage.clear_history(flush=flush)
 
 
 async def clear_transactions_storage_history(exchange_manager, flush=True):
-    await exchange_manager.storage_manager.transactions_storage.clear_history(flush=flush)
+    if exchange_manager.storage_manager.transactions_storage:
+        await exchange_manager.storage_manager.transactions_storage.clear_history(flush=flush)
 
 
 async def clear_portfolio_storage_history(exchange_manager, flush=True):
-    await exchange_manager.storage_manager.portfolio_storage.clear_history(flush=flush)
+    if exchange_manager.storage_manager.portfolio_storage:
+        await exchange_manager.storage_manager.portfolio_storage.clear_history(flush=flush)
+    if exchange_manager.exchange_personal_data.portfolio_manager:
+        await exchange_manager.exchange_personal_data.portfolio_manager.reset_history()
 
 
 async def clear_candles_storage_history(exchange_manager, flush=True):
-    await exchange_manager.storage_manager.candles_storage.clear_history(flush=flush)
+    if exchange_manager.storage_manager.candles_storage:
+        await exchange_manager.storage_manager.candles_storage.clear_history(flush=flush)
+
+
+async def clear_database_storage_history(storage_class, database, flush=True):
+    await storage_class.clear_database_history(database, flush=flush)
+
+
+def get_account_type(is_future, is_margin, is_sandboxed, is_trader_simulated) -> str:
+    return storage.get_account_type_suffix(is_future, is_margin, is_sandboxed, is_trader_simulated)
+
+
+def get_account_type_from_run_metadata(run_metadata) -> str:
+    return storage.get_account_type_suffix_from_run_metadata(run_metadata)
+
+
+def get_account_type_from_exchange_manager(exchange_manager) -> str:
+    return storage.get_account_type_suffix_from_exchange_manager(exchange_manager)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/symbol_data.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/symbol_data.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/trader.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/trader.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/api/trades.py` & `OctoBot-Trading-2.4.0/octobot_trading/api/trades.py`

 * *Files 16% similar despite different names*

```diff
@@ -13,33 +13,45 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import decimal
 
 import octobot_trading.enums
 import octobot_trading.personal_data as personal_data
+import octobot_commons.symbols as commons_symbols
 
 
-def get_trade_history(exchange_manager, symbol=None, since=None, as_dict=False, include_cancelled=False) -> list:
-    return [trade.to_dict() if as_dict else trade
-            for trade in exchange_manager.exchange_personal_data.trades_manager.trades.values()
-            if _trade_filter(trade, symbol, since, include_cancelled)]
+def get_trade_history(
+        exchange_manager, quote=None, symbol=None, since=None, as_dict=False, include_cancelled=False
+) -> list:
+    return [
+        trade.to_dict() if as_dict else trade
+        for trade in exchange_manager.exchange_personal_data.trades_manager.trades.values()
+        if _trade_filter(trade, quote, symbol, since, include_cancelled)
+    ]
 
 
-def _trade_filter(trade, symbol=None, timestamp=None, include_cancelled=False) -> bool:
+def get_completed_pnl_history(exchange_manager, quote=None, symbol=None, since=None) -> list:
+    return exchange_manager.exchange_personal_data.trades_manager.get_completed_trades_pnl(
+        get_trade_history(
+            exchange_manager, quote=quote, symbol=symbol, since=since, as_dict=False, include_cancelled=False
+        )
+    )
+
+
+def _trade_filter(trade, quote=None, symbol=None, timestamp=None, include_cancelled=False) -> bool:
     if trade.status is octobot_trading.enums.OrderStatus.CANCELED and not include_cancelled:
         return False
-    if symbol is None and timestamp is None:
-        return True
-    elif symbol is None and timestamp is not None:
-        return _is_trade_after(trade, timestamp)
-    elif symbol is not None and timestamp is None:
-        return trade.symbol == symbol
-    else:
-        return trade.symbol == symbol and _is_trade_after(trade, timestamp)
+    if timestamp is not None and not _is_trade_after(trade, timestamp):
+        return False
+    if quote is not None and commons_symbols.parse_symbol(trade.symbol).quote != quote:
+        return False
+    elif symbol is not None and trade.symbol != symbol:
+        return False
+    return True
 
 
 def _is_trade_after(trade, timestamp) -> bool:
     return trade.executed_time > timestamp or trade.canceled_time > timestamp
 
 
 def get_total_paid_trading_fees(exchange_manager) -> dict:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/constants.py` & `OctoBot-Trading-2.4.0/octobot_trading/constants.py`

 * *Files 11% similar despite different names*

```diff
@@ -47,49 +47,84 @@
 CONFIG_SELL_ORDER_AMOUNT = "sell_order_amount"
 
 # Exchange
 DEFAULT_EXCHANGE_TIME_LAG = 10
 DEFAULT_BACKTESTING_TIME_LAG = 0
 INFINITE_MAX_HANDLED_PAIRS_WITH_TIMEFRAME = -1
 DEFAULT_CANDLE_HISTORY_SIZE = 200
+NO_DATA_LIMIT = -1
 DEFAULT_FAILED_REQUEST_RETRY_TIME = 1
 DEFAULT_REQUEST_TIMEOUT = int(os.getenv("DEFAULT_REQUEST_TIMEOUT", "20000"))    # default ccxt is 10s, use 20
 ENABLE_EXCHANGE_HTTP_PROXY_FROM_ENV = os_util.parse_boolean_environment_var(
     "ENABLE_EXCHANGE_HTTP_PROXY_FROM_ENV", "True")
 ENABLE_CCXT_VERBOSE = os_util.parse_boolean_environment_var("ENABLE_CCXT_VERBOSE", "False")
 ENABLE_CCXT_RATE_LIMIT = os_util.parse_boolean_environment_var("ENABLE_CCXT_RATE_LIMIT", "True")
 THROTTLED_WS_UPDATES = float(os.getenv("THROTTLED_WS_UPDATES", "0.1"))  # avoid spamming CPU
+ENABLE_LIVE_CANDLES_STORAGE = os_util.parse_boolean_environment_var("ENABLE_LIVE_CANDLES_STORAGE", "False")
+ENABLE_HISTORICAL_ORDERS_UPDATES_STORAGE = os_util.parse_boolean_environment_var("ENABLE_HISTORICAL_ORDERS_UPDATES_STORAGE", "False")
 
 # Decimal default values (decimals are immutable, can be stored as constant)
 ZERO = decimal.Decimal(0)
 ONE = decimal.Decimal(1)
 ONE_HUNDRED = decimal.Decimal(100)
 NaN = decimal.Decimal("nan")
 
-FULL_CANDLE_HISTORY_EXCHANGES = ["bequant", "binance", "binanceus", "binanceusdm", "bitcoincom",
-                                 "bitfinex", "bitfinex2", "bitmex", "idex", "bybit"]
-
-TESTED_EXCHANGES = ["binance", "okx", "gateio", "huobi", "bitget",
-                    "ascendex", "kucoin", "coinbasepro", "bybit", "phemex", "hollaex"]
-DEFAULT_FUTURE_EXCHANGES = ["bybit"]
+# exchanges where test_get_historical_symbol_prices is successful can be listed here
+FULL_CANDLE_HISTORY_EXCHANGES = [
+    "ascendex",
+    "binance",
+    "bitfinex2",
+    "bitstamp",
+    "bittrex",
+    "bybit",
+    "gateio",
+    "hitbtc",
+    "hollaex",
+    "huobi",
+    "huobipro",
+    "kucoin",
+    "okcoin",
+    "okx",
+]
+
+DEFAULT_FUTURE_EXCHANGES = ["binanceusdm", "bybit"]
+TESTED_EXCHANGES = [
+    "binance",
+    "okx",
+    "gateio",
+    "huobi",
+    "bitget",
+    "ascendex",
+    "kucoin",
+    "coinbase",
+    "bybit",
+    "cryptocom",
+    "phemex",
+    "hollaex",
+]
+DEFAULT_FUTURE_EXCHANGES = ["binanceusdm", "bybit"]
 SIMULATOR_TESTED_EXCHANGES = ["bitfinex2", "bithumb", "bitstamp", "bittrex", "coinex",
                               "hitbtc", "kraken", "poloniex", "bitso", "ndax", "upbit",
                               "wavesexchange"]
 
 CONFIG_DEFAULT_FEES = 0.001
 CONFIG_DEFAULT_SIMULATOR_FEES = 0
 
 DEFAULT_SYMBOL_LEVERAGE = ONE
 DEFAULT_SYMBOL_MAX_LEVERAGE = ONE_HUNDRED
 DEFAULT_SYMBOL_MARGIN_TYPE = enums.MarginType.ISOLATED
 DEFAULT_SYMBOL_CONTRACT_TYPE = enums.FutureContractType.LINEAR_PERPETUAL
+DEFAULT_SYMBOL_CONTRACT_SIZE = ONE
 DEFAULT_SYMBOL_POSITION_MODE = enums.PositionMode.ONE_WAY
 DEFAULT_SYMBOL_FUNDING_RATE = decimal.Decimal("0.00005")
 DEFAULT_SYMBOL_MAINTENANCE_MARGIN_RATE = decimal.Decimal("0.01")
 
+# used to force margin type update before positions init (if necessary)
+FORCED_MARGIN_TYPE = enums.MarginType(os.getenv("FORCED_MARGIN_TYPE", enums.MarginType.ISOLATED.value))
+
 # API
 API_LOGGER_TAG = "TradingApi"
 
 # Channels
 # Exchange public data
 TICKER_CHANNEL = "Ticker"
 MINI_TICKER_CHANNEL = "MiniTicker"
@@ -104,18 +139,19 @@
 
 # Exchange personal data
 TRADES_CHANNEL = "Trades"
 ORDERS_CHANNEL = "Orders"
 BALANCE_CHANNEL = "Balance"
 BALANCE_PROFITABILITY_CHANNEL = "BalanceProfitability"
 POSITIONS_CHANNEL = "Positions"
-INDIVIDUAL_ORDER_SYNC_TIMEOUT = 3 * commons_constants.MINUTE_TO_SECONDS
+INDIVIDUAL_ORDER_SYNC_TIMEOUT = 1 * commons_constants.MINUTE_TO_SECONDS
 
 # History
 DEFAULT_SAVED_HISTORICAL_TIMEFRAMES = [commons_enums.TimeFrames.ONE_DAY]
+HISTORICAL_CANDLES_FETCH_DEFAULT_TIMEOUT = 30
 
 # 946742400 is 01/01/2000, if trade time is lower, there is an issue.
 MINIMUM_VAL_TRADE_TIME = 946688400
 
 # Internal
 MODE_CHANNEL = "Mode"
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/enums.py` & `OctoBot-Trading-2.4.0/octobot_trading/enums.py`

 * *Files 12% similar despite different names*

```diff
@@ -17,31 +17,43 @@
 
 
 class TradeOrderSide(enum.Enum):
     BUY = "buy"
     SELL = "sell"
 
 
+class HistoricalPortfolioValue(enum.Enum):
+    TIME = "time"
+    VALUE = "value"
+
+
 class PositionSide(enum.Enum):
     LONG = "long"
     SHORT = "short"
     BOTH = "both"  # for one-way mode
     UNKNOWN = "unknown"
 
 
 class TradeOrderType(enum.Enum):
     LIMIT = "limit"
     MARKET = "market"
+    # stop loss == reduce only on futures
     STOP_LOSS = "stop_loss"
     STOP_LOSS_LIMIT = "stop_loss_limit"
+    # conditional orders
+    # TODO handle them
+    CONDITIONAL_MARKET = "stop_market"
+    CONDITIONAL_LIMIT = "stop_limit"
+    
     TAKE_PROFIT = "take_profit"
     TAKE_PROFIT_LIMIT = "take_profit_limit"
     TRAILING_STOP = "trailing_stop"
     TRAILING_STOP_LIMIT = "trailing_stop_limit"
     LIMIT_MAKER = "limit_maker"  # LIMIT_MAKER is a limit order that is rejected if would be filled as taker
+    UNSUPPORTED = "unsupported"
     UNKNOWN = "unknown"  # default value when the order type info is missing in the exchange data
 
 
 class EvaluatorStates(enum.Enum):
     SHORT = "SHORT"
     VERY_SHORT = "VERY_SHORT"
     LONG = "LONG"
@@ -143,22 +155,18 @@
     STOP_LOSS_LIMIT = "stop_limit"
     SELL_MARKET = "sell_market"
     SELL_LIMIT = "sell_limit"
     TRAILING_STOP = "trailing_stop"
     TRAILING_STOP_LIMIT = "trailing_stop_limit"
     TAKE_PROFIT = "take_profit"
     TAKE_PROFIT_LIMIT = "take_profit_limit"
+    UNSUPPORTED = 'unsupported'
     UNKNOWN = "unknown"  # default value when the order type info is missing in the exchange data
 
 
-class TraderPositionType(enum.Enum):
-    CROSS = "cross"
-    ISOLATED = "isolated"
-
-
 class PositionMode(enum.Enum):
     HEDGE = "hedge_mode"
     ONE_WAY = "one_way_mode"
 
 
 class ExchangeConstantsFundingColumns(enum.Enum):
     SYMBOL = "symbol"
@@ -287,18 +295,20 @@
     SYMBOL = "symbol"
     TIMESTAMP = "timestamp"
 
 
 class ExchangeConstantsOrderColumns(enum.Enum):
     INFO = "info"
     ID = "id"
+    ORDER_ID = "order_id"
     TIMESTAMP = "timestamp"
     DATETIME = 'datetime'
     LAST_TRADE_TIMESTAMP = "lastTradeTimestamp"
     SYMBOL = "symbol"
+    MARKET = "market"
     QUANTITY_CURRENCY = "quantity_currency"
     TYPE = "type"
     SIDE = "side"
     PRICE = "price"
     AMOUNT = "amount"
     COST = "cost"
     AVERAGE = "average"
@@ -309,16 +319,20 @@
     TRADES = "trades"
     MAKER = "maker"
     TAKER = "taker"
     ORDER = "order"
     TAKER_OR_MAKER = "takerOrMaker"
     REDUCE_ONLY = "reduceOnly"
     STOP_PRICE = "stopPrice"
+    STOP_LOSS_PRICE = "stopLossPrice"
+    TAKE_PROFIT_PRICE = "takeProfitPrice"
     TRIGGER_ABOVE = "triggerAbove"
     TAG = "tag"
+    SELF_MANAGED = "self-managed"
+    ENTRIES = "entries"
 
 
 class ExchangeConstantsPositionColumns(enum.Enum):
     ID = "id"
     TIMESTAMP = "timestamp"
     SYMBOL = "symbol"
     ENTRY_PRICE = "entry_price"
@@ -332,14 +346,15 @@
     SIZE = "size"
     NOTIONAL = "notional"
     INITIAL_MARGIN = "initial_margin"
     COLLATERAL = "collateral"
     LEVERAGE = "leverage"
     MARGIN_TYPE = "margin_type"
     CONTRACT_TYPE = "contract_type"
+    CONTRACT_SIZE = "contract_size"
     POSITION_MODE = "position_mode"
     MAINTENANCE_MARGIN_RATE = "maintenance_margin_rate"
     STATUS = "status"
     SIDE = "side"
 
 
 class ExchangeConstantsLiquidationColumns(enum.Enum):
@@ -347,32 +362,42 @@
     TIMESTAMP = "timestamp"
     SYMBOL = "symbol"
     PRICE = "price"
     QUANTITY = "quantity"
     SIDE = "side"
 
 
-class ExchangeConstantsFeesColumns(enum.Enum):
-    TYPE = "type"
-    CURRENCY = "currency"
-    RATE = "rate"
-    COST = "cost"
-
-
 class ExchangeConstantsMarketPropertyColumns(enum.Enum):
     TAKER = "taker"  # trading
     MAKER = "maker"  # trading
     FEE = "fee"  # withdraw
 
 
+class ExchangeConstantsLeveragePropertyColumns(enum.Enum):
+    LEVERAGE = "leverage"
+    RAW = "raw"
+
+
+class ExchangeConstantsLeverageTiersColumns(enum.Enum):
+    TIER = "tier"
+    CURRENCY = "currency"
+    MIN_NOTIONAL = "min_notional"
+    MAX_NOTIONAL = "max_notional"
+    MAINTENANCE_MARGIN_RATE = "maintenance_margin_rate"
+    MAX_LEVERAGE = "max_leverage"
+    INFO = "info"
+
+
 class FeePropertyColumns(enum.Enum):
     TYPE = "type"  # taker of maker
     CURRENCY = "currency"  # currency the fee is paid in
     RATE = "rate"  # multiplier applied to compute fee
     COST = "cost"  # fee amount
+    IS_FROM_EXCHANGE = "is_from_exchange"   # True when the fee value has been fetched from exchange
+    EXCHANGE_ORIGINAL_COST = "exchange_original_cost"  # fee amount as fetched from exchange
 
 
 class FeesCurrencySide(enum.Enum):
     CURRENCY = "currency"
     MARKET = "market"
     UNDEFINED = "undefined"
 
@@ -385,14 +410,15 @@
     OPTION = "option"
 
 
 class MarkPriceSources(enum.Enum):
     EXCHANGE_MARK_PRICE = "exchange_mark_price"
     RECENT_TRADE_AVERAGE = "recent_trade_average"
     TICKER_CLOSE_PRICE = "ticker_close_price"
+    CANDLE_CLOSE_PRICE = "candle_close_price"
 
 
 class WebsocketFeeds(enum.Enum):
     L1_BOOK = 'l1_book'
     L2_BOOK = 'l2_book'
     L3_BOOK = 'l3_book'
     BOOK_TICKER = 'book_ticker'
@@ -497,14 +523,41 @@
     GROUP_ID = "group_id"
     GROUP_TYPE = "group_type"
     TAG = "tag"
     SHARED_SIGNAL_ORDER_ID = "shared_signal_order_id"
     BUNDLED_WITH = "bundled_with"
     CHAINED_TO = "chained_to"
     ADDITIONAL_ORDERS = "additional_orders"
+    ASSOCIATED_ORDER_IDS = "associated_order_ids"
+    UPDATE_WITH_TRIGGERING_ORDER_FEES = "update_with_triggering_order_fees"
 
 
 class TradingSignalOrdersActions(enum.Enum):
     CREATE = "create"
     ADD_TO_GROUP = "add_to_group"
     EDIT = "edit"
     CANCEL = "cancel"
+
+
+class StoredOrdersAttr(enum.Enum):
+    GROUP = "gr"
+    GROUP_ID = "gi"
+    GROUP_TYPE = "gt"
+    CHAINED_ORDERS = "co"
+    EXCHANGE_CREATION_PARAMS = "ecp"
+    TRADER_CREATION_KWARGS = "tck"
+    SHARED_SIGNAL_ORDER_ID = "ssoi"
+    HAS_BEEN_BUNDLED = "hbb"
+    ENTRIES = "en"
+    UPDATE_TIME = "ut"
+    UPDATE_TYPE = "uty"
+    ORDER_ID = "oid"
+    ORDER_STATUS = "s"
+    ORDER_DETAILS = "d"
+    UPDATE_WITH_TRIGGERING_ORDER_FEES = "utf"
+
+
+class OrderUpdateType(enum.Enum):
+    NEW = "new"
+    CLOSED = "closed"
+    EDIT = "edit"
+    STATE_CHANGE = "state_transition"
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/errors.py` & `OctoBot-Trading-2.4.0/octobot_trading/errors.py`

 * *Files 22% similar despite different names*

```diff
@@ -47,14 +47,44 @@
 
 class OrderCancelError(Exception):
     """
     Raised upon a failed order cancel
     """
 
 
+class UnexpectedExchangeSideOrderStateError(Exception):
+    """
+    Raised when an order is in an unexpected state when fetched from exchange
+    """
+
+
+class OpenOrderError(UnexpectedExchangeSideOrderStateError):
+    """
+    Raised when an order is unexpectedly open
+    """
+
+
+class FilledOrderError(UnexpectedExchangeSideOrderStateError):
+    """
+    Raised when an order is unexpectedly filled
+    """
+
+
+class CancellingOrderError(UnexpectedExchangeSideOrderStateError):
+    """
+    Raised when an order is unexpectedly cancelling
+    """
+
+
+class ClosedOrderError(UnexpectedExchangeSideOrderStateError):
+    """
+    Raised when an order is unexpectedly closed
+    """
+
+
 class NotSupported(Exception):
     """
     Raised when an exchange doesn't support the required element
     """
 
 
 class FailedRequest(Exception):
@@ -166,14 +196,20 @@
 
 class MissingPriceDataError(Exception):
     """
     Raised when a price info is missing
     """
 
 
+class PendingPriceDataError(Exception):
+    """
+    Raised when a price info is waiting to be updated
+    """
+
+
 class UnreachableExchange(Exception):
     """
     Raised when an exchange cant be reached (likely when it's offline)
     """
 
 
 class InvalidArgumentError(Exception):
@@ -194,7 +230,19 @@
     """
 
 
 class UnexpectedAdapterError(Exception):
     """
     Raised when an unexpected error occurs in an adapter
     """
+
+
+class IncompletePNLError(Exception):
+    """
+    Raised when a pnl computation is asked on a invalid pnl
+    """
+
+
+class InitializingError(Exception):
+    """
+    Raised when OctoBot is still in initialization
+    """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_channel.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/funding.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,40 +9,55 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport async_channel.channels as channels
-cimport async_channel.consumer as consumers
-cimport async_channel.producer as producers
+import asyncio
 
-cdef class ExchangeChannel(channels.Channel):
-    cdef public object exchange_manager
-    cdef public object exchange
+import async_channel.constants as constants
+import octobot_trading.exchange_channel as exchanges_channel
 
-    cdef int filter_send_counter
-    cdef bint should_send_filter
 
-    cpdef object get_filtered_consumers(self, str cryptocurrency=*, str symbol=*)
-
-cdef class TimeFrameExchangeChannel(ExchangeChannel):
-    cpdef object get_filtered_consumers(self, str cryptocurrency=*, str symbol=*, str time_frame=*)
-
-cdef class ExchangeChannelConsumer(consumers.Consumer):
-    pass
-
-cdef class ExchangeChannelProducer(producers.Producer):
-    cpdef void trigger_single_update(self)
-
-cdef class ExchangeChannelInternalConsumer(consumers.InternalConsumer):
-    pass
-
-cdef class ExchangeChannelSupervisedConsumer(consumers.SupervisedConsumer):
-    pass
-
-cpdef ExchangeChannel get_chan(str chan_name, str exchange_id)
-cpdef dict get_exchange_channels(str exchange_id)
-cpdef void set_chan(ExchangeChannel chan, str name)
-cpdef void del_exchange_channel_container(str exchange_id)
-cpdef void del_chan(str name, str exchange_id)
+class FundingProducer(exchanges_channel.ExchangeChannelProducer):
+    async def push(self, symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp):
+        await self.perform(symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp)
+
+    async def perform(self, symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp):
+        try:
+            if self.channel.get_filtered_consumers(
+                    symbol=constants.CHANNEL_WILDCARD) or self.channel.get_filtered_consumers(symbol=symbol):
+                await self.channel.exchange_manager.get_symbol_data(symbol) \
+                    .handle_funding_update(funding_rate,
+                                           predicted_funding_rate,
+                                           next_funding_time,
+                                           timestamp)
+                await self.send(self.channel.exchange_manager.exchange.
+                                get_pair_cryptocurrency(symbol),
+                                symbol,
+                                funding_rate,
+                                predicted_funding_rate,
+                                next_funding_time,
+                                timestamp)
+        except asyncio.CancelledError:
+            self.logger.info("Update tasks cancelled.")
+        except Exception as e:
+            self.logger.exception(e, True, f"Exception when triggering update: {e}")
+
+    async def send(self, cryptocurrency, symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp):
+        for consumer in self.channel.get_filtered_consumers(symbol=symbol):
+            await consumer.queue.put({
+                "exchange": self.channel.exchange_manager.exchange_name,
+                "exchange_id": self.channel.exchange_manager.id,
+                "cryptocurrency": cryptocurrency,
+                "symbol": symbol,
+                "funding_rate": funding_rate,
+                "predicted_funding_rate": predicted_funding_rate,
+                "next_funding_time": next_funding_time,
+                "timestamp": timestamp
+            })
+
+
+class FundingChannel(exchanges_channel.ExchangeChannel):
+    PRODUCER_CLASS = FundingProducer
+    CONSUMER_CLASS = exchanges_channel.ExchangeChannelConsumer
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_channel.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_channel.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=E0203
+# pylint: disable=E0203, W0237
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -49,20 +49,21 @@
     """
     Producer adapted for ExchangeChannel
     """
 
     def __init__(self, channel):
         super().__init__(channel)
         self.logger = logging.get_logger(f"{self.__class__.__name__}[{channel.exchange_manager.exchange_name}]")
+        self.single_update_task = None
 
     async def fetch_and_push(self):
         self.logger.error("self.fetch_and_push() is not implemented")
 
     def trigger_single_update(self):
-        asyncio.create_task(self.fetch_and_push())
+        self.single_update_task = asyncio.create_task(self.fetch_and_push())
 
     async def wait_for_dependencies(self, paths, timeout):
         for path in paths:
             if not await commons_tree.EventProvider.instance().wait_for_event(
                 self.channel.exchange_manager.bot_id,
                 path,
                 timeout
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,21 +10,27 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.contracts cimport margin_contract
-from octobot_trading.exchange_data.contracts.margin_contract cimport (
+from octobot_trading.exchange_data.contracts import margin_contract
+from octobot_trading.exchange_data.contracts.margin_contract import (
     MarginContract,
 )
 
-from octobot_trading.exchange_data.contracts cimport future_contract
-from octobot_trading.exchange_data.contracts.future_contract cimport (
+from octobot_trading.exchange_data.contracts import future_contract
+from octobot_trading.exchange_data.contracts.future_contract import (
     FutureContract,
 )
 
+from octobot_trading.exchange_data.contracts import contract_factory
+from octobot_trading.exchange_data.contracts.contract_factory import (
+    update_contracts_from_positions,
+)
+
 __all__ = [
     "MarginContract",
     "FutureContract",
+    "update_contracts_from_positions",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -10,27 +10,27 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.contracts import margin_contract
-from octobot_trading.exchange_data.contracts.margin_contract import (
-    MarginContract,
-)
+from octobot_trading.exchange_data.kline import channel
+from octobot_trading.exchange_data.kline import kline_manager
 
-from octobot_trading.exchange_data.contracts import future_contract
-from octobot_trading.exchange_data.contracts.future_contract import (
-    FutureContract,
+from octobot_trading.exchange_data.kline.kline_manager import (
+    KlineManager,
 )
-
-from octobot_trading.exchange_data.contracts import contract_factory
-from octobot_trading.exchange_data.contracts.contract_factory import (
-    update_contracts_from_positions,
+from octobot_trading.exchange_data.kline.channel import (
+    KlineUpdater,
+    KlineUpdaterSimulator,
+    KlineProducer,
+    KlineChannel,
 )
 
 __all__ = [
-    "MarginContract",
-    "FutureContract",
-    "update_contracts_from_positions",
+    "KlineUpdaterSimulator",
+    "KlineProducer",
+    "KlineChannel",
+    "KlineManager",
+    "KlineUpdater",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/contract_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/contract_factory.py`

 * *Files 8% similar despite different names*

```diff
@@ -15,35 +15,41 @@
 #  License along with this library.
 import octobot_commons.logging as logging
 
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 
 
-def update_contracts_from_positions(exchange_manager, positions):
+def update_contracts_from_positions(exchange_manager, positions) -> bool:
+    updated = False
     for position in positions:
         pair = position.get(enums.ExchangeConstantsPositionColumns.SYMBOL.value, None)
         if pair and pair not in exchange_manager.exchange.pair_contracts:
             contract = exchange_manager.exchange.create_pair_contract(
                 pair=pair,
                 current_leverage=position.get(
                     enums.ExchangeConstantsPositionColumns.LEVERAGE.value, constants.ZERO),
+                contract_size=position.get(
+                    enums.ExchangeConstantsPositionColumns.CONTRACT_SIZE.value, constants.DEFAULT_SYMBOL_CONTRACT_SIZE),
                 margin_type=position.get(enums.ExchangeConstantsPositionColumns.MARGIN_TYPE.value, None),
                 contract_type=position.get(enums.ExchangeConstantsPositionColumns.CONTRACT_TYPE.value, None),
                 position_mode=position.get(enums.ExchangeConstantsPositionColumns.POSITION_MODE.value, None),
                 maintenance_margin_rate=position.get(
                     enums.ExchangeConstantsPositionColumns.MAINTENANCE_MARGIN_RATE.value,
                     constants.DEFAULT_SYMBOL_MAINTENANCE_MARGIN_RATE)
             )
             # contracts are updated from positions are fully initialized
-            if not contract.is_handled_contract():
+            if contract.is_handled_contract():
+                updated = True
+            else:
                 message = f"Unhandled contract {contract}. This contract can't be traded"
                 if pair in exchange_manager.exchange_config.traded_symbol_pairs:
                     # inform user that the contract can't be used
                     _get_logger().error(message)
                 else:
                     # no need to inform as the contract is not requested
                     _get_logger().debug(message)
+    return updated
 
 
 def _get_logger():
     return logging.get_logger("contract_factory")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/future_contract.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/default_rest_exchange.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,40 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.contracts.margin_contract as margin_contract
+import octobot_trading.enums as trading_enums
+import octobot_trading.exchanges.types.rest_exchange as rest_exchange
 
 
-cdef class FutureContract(margin_contract.MarginContract):
-    cdef readonly object contract_type
-    cdef readonly object position_mode
-    cdef public object maintenance_margin_rate
+class DefaultRestExchange(rest_exchange.RestExchange):
+    @classmethod
+    def get_name(cls) -> str:
+        return cls.__name__
 
-    cdef readonly double minimum_tick_size
+    @classmethod
+    def is_default_exchange(cls) -> bool:
+        return True
 
-    cdef readonly object take_profit_stop_loss_mode
+    @classmethod
+    def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
+        return isinstance(exchange_candidate_name, str)
 
-    cpdef bint is_inverse_contract(self)
-    cpdef bint is_perpetual_contract(self)
-    cpdef bint is_one_way_position_mode(self)
-    cpdef void set_position_mode(self, bint is_one_way=*, bint is_hedge=*)
-    cpdef void set_take_profit_stop_loss_mode(self, object set_take_profit_stop_loss_mode)
-    cpdef object get_fees_currency_side(self)
-    cpdef bint is_handled_contract(self)
+    async def switch_to_account(self, account_type: trading_enums.AccountTypes):
+        # Currently not supported
+        pass
+
+    @classmethod
+    def load_user_inputs_from_class(cls, tentacles_setup_config, tentacle_config):
+        # default exchange can't be configured
+        return {}
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/future_contract.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/future_contract.py`

 * *Files 4% similar despite different names*

```diff
@@ -42,15 +42,16 @@
         if self.is_handled_contract():
             return (f"{self.pair} "
                     f"{'inverse' if self.is_inverse_contract() else 'linear'} "
                     f"{'perpetual' if self.is_perpetual_contract() else 'future'} "
                     f"{self.margin_type.value} x{self.current_leverage}")
         return (f"{self.pair} "
                 f"unhandled contract "
-                f"{self.margin_type.value} x{self.current_leverage}")
+                f"{self.margin_type.value if self.margin_type else 'unknown margin type'} "
+                f"x{self.current_leverage}")
 
     def is_inverse_contract(self):
         """
         Inverse Contract is a contract using the coin itself as collateral
         if not inverted the contract uses fiat as the collateral
         :return: True if the contract is an inverse contract
         """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/contracts/margin_contract.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/contracts/margin_contract.py`

 * *Files 10% similar despite different names*

```diff
@@ -58,7 +58,13 @@
     def set_margin_type(self, is_isolated=True, is_cross=False):
         """
         Set the contract margin type
         :param is_isolated: should be True if the margin type is isolated
         :param is_cross: should be True if the margin type is cross
         """
         self.margin_type = enums.MarginType.ISOLATED if is_isolated and not is_cross else enums.MarginType.CROSS
+
+    def is_handled_contract(self):
+        """
+        :return: False if this contract can't be traded in OctoBot
+        """
+        return True
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/exchange_symbol_data.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/exchange_symbol_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -46,30 +46,38 @@
             if self.exchange_manager.is_margin or self.exchange_manager.is_future else None
 
         self.symbol_candles = {}
         self.symbol_klines = {}
 
         self.logger = logging.get_logger(f"{self.__class__.__name__} - {self.symbol}")
 
+    def stop(self):
+        self.price_events_manager.stop()
+        self.prices_manager.stop()
+        self.exchange_manager = None
+
     # candle functions
-    async def handle_candles_update(self, time_frame, new_symbol_candles_data, replace_all=False, partial=False):
+    async def handle_candles_update(self, time_frame, new_symbol_candles_data, replace_all=False, partial=False,
+                                    upsert=False):
         try:
             symbol_candles = self.symbol_candles[time_frame]
         except KeyError:
             self.symbol_candles[time_frame] = await self._create_candles_manager(time_frame, new_symbol_candles_data,
                                                                                  replace_all)
             self._set_initialized_event(
                 commons_enums.InitializationEventExchangeTopics.CANDLES.value,
                 time_frame.value
             )
             return
         if partial:
             symbol_candles.add_old_and_new_candles(new_symbol_candles_data)
         elif replace_all:
             symbol_candles.replace_all_candles(new_symbol_candles_data)
+        elif upsert:
+            symbol_candles.upsert_candle(new_symbol_candles_data)
         else:
             symbol_candles.add_new_candle(new_symbol_candles_data)
 
     async def _create_candles_manager(self, time_frame, new_symbol_candles_data, replace_all):
         if self.exchange_manager.is_backtesting:
             # try getting a preloaded candles manager
             symbol_candles = await backtesting_api.get_preloaded_candles_manager(
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/exchange_symbols_data.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/simulator/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,28 +1,29 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data as exchange_data
 
-cdef class ExchangeSymbolsData:
-    cdef public object logger
+from octobot_trading.exchanges.connectors.simulator import exchange_simulator_adapter
+from octobot_trading.exchanges.connectors.simulator.exchange_simulator_adapter import (
+    ExchangeSimulatorAdapter,
+)
+from octobot_trading.exchanges.connectors.simulator import exchange_simulator_connector
+from octobot_trading.exchanges.connectors.simulator.exchange_simulator_connector import (
+    ExchangeSimulatorConnector,
+)
 
-    cdef public dict exchange_symbol_data
-    cdef public dict config
-
-    cdef public object exchange
-    cdef public object exchange_manager
-
-    cpdef public exchange_data.ExchangeSymbolData get_exchange_symbol_data(self, str symbol, bint allow_creation=*)
+__all__ = [
+    "ExchangeSimulatorConnector",
+    "ExchangeSimulatorAdapter",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/exchange_symbols_data.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_factory.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,29 +9,21 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import octobot_commons.logging as logging
+import octobot_trading.personal_data.portfolios.types as portfolio_types
 
-from octobot_trading.exchange_data.exchange_symbol_data import ExchangeSymbolData
 
-
-class ExchangeSymbolsData:
-    def __init__(self, exchange_manager):
-        self.logger = logging.get_logger(self.__class__.__name__)
-        self.exchange_manager = exchange_manager
-        self.exchange = exchange_manager.exchange
-        self.config = exchange_manager.config
-        self.exchange_symbol_data = {}
-
-    def get_exchange_symbol_data(self, symbol, allow_creation=True):
-        try:
-            return self.exchange_symbol_data[symbol]
-        except KeyError as e:
-            if allow_creation:
-                # warning: should only be called in the async loop thread
-                self.exchange_symbol_data[symbol] = ExchangeSymbolData(self.exchange_manager, symbol)
-                return self.exchange_symbol_data[symbol]
-            raise e
+def create_portfolio_from_exchange_manager(exchange_manager):
+    """
+    Create a portfolio from an exchange manager
+    :param exchange_manager: the exchange manager related to the new portfolio instance
+    :return: the created portfolio instance
+    """
+    if exchange_manager.is_future:
+        return portfolio_types.FuturePortfolio(exchange_manager.get_exchange_name())
+    if exchange_manager.is_margin:
+        return portfolio_types.MarginPortfolio(exchange_manager.get_exchange_name())
+    return portfolio_types.SpotPortfolio(exchange_manager.get_exchange_name())
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -10,23 +10,25 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.funding cimport channel
-from octobot_trading.exchange_data.funding.channel cimport (
+from octobot_trading.exchange_data.funding import channel
+
+from octobot_trading.exchange_data.funding import funding_manager
+from octobot_trading.exchange_data.funding.channel import (
     FundingProducer,
     FundingChannel,
     FundingUpdaterSimulator,
     FundingUpdater,
 )
-from octobot_trading.exchange_data.funding cimport funding_manager
-from octobot_trading.exchange_data.funding.funding_manager cimport (
+
+from octobot_trading.exchange_data.funding.funding_manager import (
     FundingManager,
 )
 
 __all__ = [
     "FundingUpdaterSimulator",
     "FundingUpdater",
     "FundingManager",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -10,28 +10,29 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.funding import channel
-
-from octobot_trading.exchange_data.funding import funding_manager
-from octobot_trading.exchange_data.funding.channel import (
+from octobot_trading.exchange_data.funding.channel import funding
+from octobot_trading.exchange_data.funding.channel.funding import (
     FundingProducer,
     FundingChannel,
-    FundingUpdaterSimulator,
+)
+
+from octobot_trading.exchange_data.funding.channel import funding_updater
+from octobot_trading.exchange_data.funding.channel.funding_updater import (
     FundingUpdater,
 )
 
-from octobot_trading.exchange_data.funding.funding_manager import (
-    FundingManager,
+from octobot_trading.exchange_data.funding.channel import funding_updater_simulator
+from octobot_trading.exchange_data.funding.channel.funding_updater_simulator import (
+    FundingUpdaterSimulator,
 )
 
 __all__ = [
     "FundingUpdaterSimulator",
     "FundingUpdater",
-    "FundingManager",
     "FundingProducer",
     "FundingChannel",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -10,30 +10,33 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.funding.channel cimport funding
-from octobot_trading.exchange_data.funding.channel.funding cimport (
-    FundingProducer,
-    FundingChannel,
-)
+from octobot_trading.exchange_data.recent_trades import recent_trades_manager
+from octobot_trading.exchange_data.recent_trades import channel
 
-from octobot_trading.exchange_data.funding.channel cimport funding_updater
-from octobot_trading.exchange_data.funding.channel.funding_updater cimport (
-    FundingUpdater,
+from octobot_trading.exchange_data.recent_trades.recent_trades_manager import (
+    RecentTradesManager,
 )
-
-from octobot_trading.exchange_data.funding.channel cimport funding_updater_simulator
-from octobot_trading.exchange_data.funding.channel.funding_updater_simulator cimport (
-    FundingUpdaterSimulator,
+from octobot_trading.exchange_data.recent_trades.channel import (
+    RecentTradeUpdater,
+    RecentTradeProducer,
+    RecentTradeChannel,
+    LiquidationsProducer,
+    LiquidationsChannel,
+)
+from octobot_trading.exchange_data.recent_trades.channel.recent_trade_updater_simulator import (
+    RecentTradeUpdaterSimulator,
 )
-
 
 __all__ = [
-    "FundingUpdaterSimulator",
-    "FundingUpdater",
-    "FundingProducer",
-    "FundingChannel",
+    "RecentTradeProducer",
+    "RecentTradeChannel",
+    "LiquidationsProducer",
+    "LiquidationsChannel",
+    "RecentTradesManager",
+    "RecentTradeUpdater",
+    "RecentTradeUpdaterSimulator",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -10,29 +10,29 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.funding.channel import funding
-from octobot_trading.exchange_data.funding.channel.funding import (
-    FundingProducer,
-    FundingChannel,
+from octobot_trading.exchange_data.ohlcv.channel import ohlcv
+from octobot_trading.exchange_data.ohlcv.channel.ohlcv import (
+    OHLCVProducer,
+    OHLCVChannel,
 )
-
-from octobot_trading.exchange_data.funding.channel import funding_updater
-from octobot_trading.exchange_data.funding.channel.funding_updater import (
-    FundingUpdater,
+from octobot_trading.exchange_data.ohlcv.channel import ohlcv_updater
+from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater import (
+    OHLCVUpdater,
 )
 
-from octobot_trading.exchange_data.funding.channel import funding_updater_simulator
-from octobot_trading.exchange_data.funding.channel.funding_updater_simulator import (
-    FundingUpdaterSimulator,
+from octobot_trading.exchange_data.ohlcv.channel import ohlcv_updater_simulator
+from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater_simulator import (
+    OHLCVUpdaterSimulator,
 )
 
+
 __all__ = [
-    "FundingUpdaterSimulator",
-    "FundingUpdater",
-    "FundingProducer",
-    "FundingChannel",
+    "OHLCVUpdaterSimulator",
+    "OHLCVProducer",
+    "OHLCVChannel",
+    "OHLCVUpdater",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/adapters/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,15 +9,17 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_channel as exchanges_channel
 
 
-cdef class FundingProducer(exchanges_channel.ExchangeChannelProducer):
-    pass
+from octobot_trading.exchanges.adapters import abstract_adapter
+from octobot_trading.exchanges.adapters.abstract_adapter import (
+    AbstractAdapter,
+)
 
-cdef class FundingChannel(exchanges_channel.ExchangeChannel):
-    pass
+__all__ = [
+    "AbstractAdapter",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/real_futures_exchange_tester.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,55 +9,62 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import asyncio
+import octobot_trading.enums as enums
+import octobot_trading.constants as constants
 
-import async_channel.constants as constants
-import octobot_trading.exchange_channel as exchanges_channel
+from tests_additional.real_exchanges import get_exchange_manager
+from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 
 
-class FundingProducer(exchanges_channel.ExchangeChannelProducer):
-    async def push(self, symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp):
-        await self.perform(symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp)
-
-    async def perform(self, symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp):
-        try:
-            if self.channel.get_filtered_consumers(
-                    symbol=constants.CHANNEL_WILDCARD) or self.channel.get_filtered_consumers(symbol=symbol):
-                await self.channel.exchange_manager.get_symbol_data(symbol) \
-                    .handle_funding_update(funding_rate,
-                                           predicted_funding_rate,
-                                           next_funding_time,
-                                           timestamp)
-                await self.send(self.channel.exchange_manager.exchange.
-                                get_pair_cryptocurrency(symbol),
-                                symbol,
-                                funding_rate,
-                                predicted_funding_rate,
-                                next_funding_time,
-                                timestamp)
-        except asyncio.CancelledError:
-            self.logger.info("Update tasks cancelled.")
-        except Exception as e:
-            self.logger.exception(e, True, f"Exception when triggering update: {e}")
-
-    async def send(self, cryptocurrency, symbol, funding_rate, predicted_funding_rate, next_funding_time, timestamp):
-        for consumer in self.channel.get_filtered_consumers(symbol=symbol):
-            await consumer.queue.put({
-                "exchange": self.channel.exchange_manager.exchange_name,
-                "exchange_id": self.channel.exchange_manager.id,
-                "cryptocurrency": cryptocurrency,
-                "symbol": symbol,
-                "funding_rate": funding_rate,
-                "predicted_funding_rate": predicted_funding_rate,
-                "next_funding_time": next_funding_time,
-                "timestamp": timestamp
-            })
-
-
-class FundingChannel(exchanges_channel.ExchangeChannel):
-    PRODUCER_CLASS = FundingProducer
-    CONSUMER_CLASS = exchanges_channel.ExchangeChannelConsumer
+class RealFuturesExchangeTester(RealExchangeTester):
+    EXCHANGE_TYPE = enums.ExchangeTypes.FUTURE.value
+
+    async def test_get_funding_rate(self):
+        pass
+
+    async def get_funding_rate(self, **kwargs):
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+            return (
+                await exchange_manager.exchange.get_funding_rate(self.SYMBOL, **kwargs),
+                exchange_manager.exchange.parse_funding(
+                    await exchange_manager.exchange.get_price_ticker(self.SYMBOL),
+                    from_ticker=True
+                )
+            )
+
+    def _check_funding_rate(
+        self,
+        funding_rate,
+        has_rate=True,
+        has_last_time=True,
+        has_next_rate=True,
+        has_next_time=True
+    ):
+        """
+        Used data are
+        - funding rate (value)
+        - last_updated (timestamp)
+        - predicted_funding_rate (value)
+        - next_update (timestamp)
+        """
+        assert funding_rate
+        if has_rate:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value]
+        else:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value].is_nan()
+        if has_last_time:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value] <= self.get_time()
+        else:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value] == constants.ZERO
+        if has_next_rate:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value]
+        else:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value].is_nan()
+        if has_next_time:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value] >= self.get_time()
+        else:
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value] == constants.ZERO
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# cython: language_level=3
+# pylint: disable=E0611
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,16 +10,17 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.funding.channel.funding as funding_channel
-cimport octobot_commons.async_job as async_job
+import octobot_trading.personal_data.portfolios.channel.balance_updater as balance_updater
 
 
-cdef class FundingUpdater(funding_channel.FundingProducer):
-    cdef async_job.AsyncJob fetch_funding_job
+class BalanceUpdaterSimulator(balance_updater.BalanceUpdater):
+    pass
+
+
+class BalanceProfitabilityUpdaterSimulator(balance_updater.BalanceProfitabilityUpdater):
+    pass
 
-    cdef bint _should_run(self)
-    cdef int _get_time_until_next_funding(self, int next_funding_time)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/funding_updater.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,21 +11,22 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import asyncio
-import decimal
 import typing
 
 import octobot_commons.async_job as async_job
 import octobot_commons.constants as common_constants
+import octobot_commons.symbols as common_symbols
 
 import octobot_trading.exchange_data.funding.channel.funding as funding_channel
+import octobot_trading.exchanges.exchange_websocket_factory as exchange_websocket_factory
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 import octobot_trading.errors as errors
 
 
 class FundingUpdater(funding_channel.FundingProducer):
     """
@@ -65,22 +66,25 @@
             await self.initialize()
 
     async def start(self) -> None:
         """
         Start updater jobs
         """
         if not self._should_run():
+            self.logger.debug("Ignoring updater start as funding can be found in different sources")
             return
 
         await self.initialize()
         await self.fetch_funding_job.run()
 
     async def _funding_fetch_and_push(self) -> list:
         next_funding_times = []
         for pair in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
+            if not common_symbols.parse_symbol(pair).is_future():
+                continue
             next_funding_time_candidate = await self.fetch_symbol_funding_rate(pair)
             if next_funding_time_candidate is not None:
                 next_funding_times.append(next_funding_time_candidate)
         return next_funding_times
 
     async def fetch_symbol_funding_rate(self, symbol: str) -> typing.Optional[int]:
         """
@@ -89,28 +93,31 @@
         :return: the next funding time
         """
         try:
             funding: dict = await self.channel.exchange_manager.exchange.get_funding_rate(symbol)
 
             if funding:
                 next_funding_time = funding[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value]
-                predicted_funding_rate = \
-                    funding.get(enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value, constants.NaN)
                 await self._push_funding(
                     symbol,
-                    decimal.Decimal(funding[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value]),
-                    predicted_funding_rate=decimal.Decimal(str(predicted_funding_rate or constants.NaN)),
+                    funding[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value],
+                    predicted_funding_rate=funding[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value],
                     next_funding_time=next_funding_time,
-                    last_funding_time=funding[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value])
+                    last_funding_time=funding[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value]
+                )
                 return next_funding_time
         except (errors.NotSupported, NotImplementedError) as ne:
             self.logger.exception(ne, True, f"get_funding_rate is not supported by "
                                             f"{self.channel.exchange_manager.exchange.name} : {ne}")
         except Exception as e:
-            self.logger.error(f"Fail to update funding rate on {self.channel.exchange_manager.exchange.name} : {e}")
+            self.logger.exception(
+                e,
+                True,
+                f"Fail to update funding rate on {self.channel.exchange_manager.exchange.name} for {symbol} : {e}"
+            )
         return None
 
     async def _push_funding(self, symbol, funding_rate, predicted_funding_rate=None,
                             next_funding_time=None, last_funding_time=None) -> None:
         """
         Push funding data to channel
         :param symbol: the funding symbol
@@ -136,17 +143,26 @@
     def _should_run(self):
         """
         Check if the funding update should run
         :return: the check result
         """
         if not self.channel.exchange_manager.is_future:
             return False
-        return not (
-                self.channel.exchange_manager.exchange.FUNDING_WITH_MARK_PRICE
-                or self.channel.exchange_manager.exchange.FUNDING_IN_TICKER
+        # if this is run, it means the funding channel is not directly updated by websockets
+        # therefore, it should run if:
+        # - ticker updater is on (ticker not managed by ws) and FUNDING_IN_TICKER is False
+        # - or ticker updater is off (ticker managed by ws) (as we are here, it means funding is not handled by ws)
+        is_ticker_updater_on = not exchange_websocket_factory.is_channel_managed_by_websocket(
+            self.channel.exchange_manager, constants.TICKER_CHANNEL
+        )
+        return (
+            (
+                is_ticker_updater_on and not self.channel.exchange_manager.exchange.FUNDING_IN_TICKER
+            )
+            or not is_ticker_updater_on
         )
 
     def _get_time_until_next_funding(self, next_funding_time):
         """
         Calculates the time between now and the next funding time (should not be > FUNDING_REFRESH_TIME_MAX)
         :param next_funding_time: the next funding time
         :return:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/unknown_order.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,19 +9,12 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport async_channel.consumer as consumer
-cimport octobot_backtesting.importers as importers
+import octobot_trading.personal_data.orders.types.unsupported_order as unsupported_order
 
-cimport octobot_trading.exchange_data.funding.channel.funding_updater as funding_updater
 
-cdef class FundingUpdaterSimulator(funding_updater.FundingUpdater):
-    cdef public consumer.Consumer time_consumer
-
-    cdef double initial_timestamp
-    cdef double last_pushed_timestamp
-
-    cdef importers.ExchangeDataImporter exchange_data_importer
+class UnknownOrder(unsupported_order.UnsupportedOrder):
+    """UnknownOrder is used when an exchange is giving an order without a type (ex: binance 2yo+ orders)"""
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/funding/funding_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/funding/funding_manager.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,15 +28,15 @@
         self.last_updated = 0
         self.reset_funding()
 
     async def initialize_impl(self):
         self.reset_funding()
 
     def initialized(self):
-        return self.funding_rate is not constants.NaN
+        return self.funding_rate.is_nan()
 
     def reset_funding(self):
         self.funding_rate = constants.NaN
         self.predicted_funding_rate = constants.NaN
         self.next_update = 0
         self.last_updated = 0
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,27 +10,33 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.kline cimport channel
-from octobot_trading.exchange_data.kline cimport kline_manager
+from octobot_trading.exchange_data.order_book import order_book_manager
+from octobot_trading.exchange_data.order_book import channel
 
-from octobot_trading.exchange_data.kline.kline_manager cimport (
-    KlineManager,
+from octobot_trading.exchange_data.order_book.channel import (
+    OrderBookUpdater,
+    OrderBookProducer,
+    OrderBookChannel,
+    OrderBookTickerProducer,
+    OrderBookTickerChannel,
 )
-from octobot_trading.exchange_data.kline.channel cimport (
-    KlineUpdater,
-    KlineUpdaterSimulator,
-    KlineProducer,
-    KlineChannel,
+from octobot_trading.exchange_data.order_book.order_book_manager import (
+    OrderBookManager,
+)
+from octobot_trading.exchange_data.order_book.channel.order_book_updater_simulator import (
+    OrderBookUpdaterSimulator,
 )
 
 __all__ = [
-    "KlineUpdaterSimulator",
-    "KlineProducer",
-    "KlineChannel",
-    "KlineManager",
-    "KlineUpdater",
+    "OrderBookUpdater",
+    "OrderBookProducer",
+    "OrderBookChannel",
+    "OrderBookTickerProducer",
+    "OrderBookTickerChannel",
+    "OrderBookManager",
+    "OrderBookUpdaterSimulator",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/traders/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,27 +10,20 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.kline import channel
-from octobot_trading.exchange_data.kline import kline_manager
-
-from octobot_trading.exchange_data.kline.kline_manager import (
-    KlineManager,
+from octobot_trading.exchanges.traders import trader
+from octobot_trading.exchanges.traders.trader import (
+    Trader,
 )
-from octobot_trading.exchange_data.kline.channel import (
-    KlineUpdater,
-    KlineUpdaterSimulator,
-    KlineProducer,
-    KlineChannel,
+from octobot_trading.exchanges.traders import trader_simulator
+from octobot_trading.exchanges.traders.trader_simulator import (
+    TraderSimulator,
 )
 
 __all__ = [
-    "KlineUpdaterSimulator",
-    "KlineProducer",
-    "KlineChannel",
-    "KlineManager",
-    "KlineUpdater",
+    "TraderSimulator",
+    "Trader",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,25 +10,28 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.kline.channel cimport kline
-from octobot_trading.exchange_data.kline.channel.kline cimport (
+
+from octobot_trading.exchange_data.kline.channel import kline
+from octobot_trading.exchange_data.kline.channel.kline import (
     KlineProducer,
     KlineChannel,
 )
-from octobot_trading.exchange_data.kline.channel cimport kline_updater
-from octobot_trading.exchange_data.kline.channel.kline_updater cimport (
+
+from octobot_trading.exchange_data.kline.channel import kline_updater
+from octobot_trading.exchange_data.kline.channel.kline_updater import (
     KlineUpdater,
 )
-from octobot_trading.exchange_data.kline.channel cimport kline_updater_simulator
-from octobot_trading.exchange_data.kline.channel.kline_updater_simulator cimport (
+
+from octobot_trading.exchange_data.kline.channel import kline_updater_simulator
+from octobot_trading.exchange_data.kline.channel.kline_updater_simulator import (
     KlineUpdaterSimulator,
 )
 
 __all__ = [
     "KlineUpdaterSimulator",
     "KlineProducer",
     "KlineChannel",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -10,30 +10,27 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-
-from octobot_trading.exchange_data.kline.channel import kline
-from octobot_trading.exchange_data.kline.channel.kline import (
-    KlineProducer,
-    KlineChannel,
+from octobot_trading.exchange_data.prices.channel import price
+from octobot_trading.exchange_data.prices.channel.price import (
+    MarkPriceProducer,
+    MarkPriceChannel,
 )
-
-from octobot_trading.exchange_data.kline.channel import kline_updater
-from octobot_trading.exchange_data.kline.channel.kline_updater import (
-    KlineUpdater,
+from octobot_trading.exchange_data.prices.channel import prices_updater
+from octobot_trading.exchange_data.prices.channel.prices_updater import (
+    MarkPriceUpdater,
 )
-
-from octobot_trading.exchange_data.kline.channel import kline_updater_simulator
-from octobot_trading.exchange_data.kline.channel.kline_updater_simulator import (
-    KlineUpdaterSimulator,
+from octobot_trading.exchange_data.prices.channel import prices_updater_simulator
+from octobot_trading.exchange_data.prices.channel.prices_updater_simulator import (
+    MarkPriceUpdaterSimulator,
 )
 
 __all__ = [
-    "KlineUpdaterSimulator",
-    "KlineProducer",
-    "KlineChannel",
-    "KlineUpdater",
+    "MarkPriceUpdaterSimulator",
+    "MarkPriceProducer",
+    "MarkPriceChannel",
+    "MarkPriceUpdater",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline.pxd` & `OctoBot-Trading-2.4.0/tests/api/test_modes.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,15 +9,12 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_channel as exchanges_channel
 
+import pytest
 
-cdef class KlineProducer(exchanges_channel.ExchangeChannelProducer):
-    pass
-
-cdef class KlineChannel(exchanges_channel.TimeFrameExchangeChannel):
-    pass
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/kline.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater.pxd` & `OctoBot-Trading-2.4.0/tests/api/test_orders.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,13 +9,12 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.kline.channel.kline as kline_channel
 
+import pytest
 
-cdef class KlineUpdater(kline_channel.KlineProducer):
-    cdef list tasks
-    cdef int refresh_time
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/kline_updater.py`

 * *Files 5% similar despite different names*

```diff
@@ -58,22 +58,21 @@
             try:
                 started_time = time.time()
                 quick_sleep = False
                 for pair in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
                     candle: list = await self.channel.exchange_manager.exchange.get_kline_price(pair, time_frame)
                     try:
                         candle = candle[0]
-                        self.channel.exchange_manager.exchange.uniformize_candles_if_necessary(candle)
                         await self.push(time_frame, pair, candle)
                     except TypeError:
                         pass
                     except IndexError:
                         quick_sleep = True
-                        self.logger.warning(f"Not enough data to compute kline data in {time_frame} for {pair}. "
-                                            f"Kline will be updated with the next refresh.")
+                        self.logger.debug(f"Not enough data to compute kline data in {time_frame} for {pair}. "
+                                          f"Kline will be updated with the next refresh.")
 
                 sleep_time = max((self.QUICK_KLINE_REFRESH_TIME if quick_sleep else self.refresh_time)
                                  - (time.time() - started_time), 0)
                 await asyncio.sleep(sleep_time)
             except errors.FailedRequest as e:
                 self.logger.warning(str(e))
                 # avoid spamming on disconnected situation
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/sell_limit_order.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,20 +9,15 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_backtesting.importers as importers
-cimport async_channel.consumer as consumer
+import octobot_trading.enums as enums
+import octobot_trading.personal_data.orders.types.limit.limit_order as limit_order
 
-cimport octobot_trading.exchange_data.kline.channel.kline_updater as kline_updater
 
-cdef class KlineUpdaterSimulator(kline_updater.KlineUpdater):
-    cdef importers.ExchangeDataImporter exchange_data_importer
+class SellLimitOrder(limit_order.LimitOrder):
+    def __init__(self, trader, side=enums.TradeOrderSide.SELL):
+        super().__init__(trader, side)
 
-    cdef str exchange_name
-
-    cdef double last_timestamp_pushed
-
-    cdef public consumer.Consumer time_consumer
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/kline_manager.pxd` & `OctoBot-Trading-2.4.0/tests/api/test_portfolio.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,29 +1,20 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.util as util
 
+import pytest
 
-cdef class KlineManager(util.Initializable):
-    cdef object logger
-
-    cdef public list kline
-
-    cdef void _reset_kline(self)
-    cdef void _update_kline_key(self, int kline_key, list kline_update)
-    cdef void _update_kline_init_only_key(self, int kline_key, list kline_update)
-
-    cpdef void kline_update(self, list kline)
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/kline/kline_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/kline/kline_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,49 +10,50 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.ohlcv cimport candles_manager
-from octobot_trading.exchange_data.ohlcv cimport preloaded_candles_manager
-from octobot_trading.exchange_data.ohlcv cimport candles_adapter
-from octobot_trading.exchange_data.ohlcv cimport channel
+from octobot_trading.exchange_data.ohlcv import candles_manager
+from octobot_trading.exchange_data.ohlcv import candles_adapter
+from octobot_trading.exchange_data.ohlcv import channel
 
-from octobot_trading.exchange_data.ohlcv.candles_manager cimport (
+from octobot_trading.exchange_data.ohlcv.candles_manager import (
     CandlesManager,
 )
-from octobot_trading.exchange_data.ohlcv.preloaded_candles_manager cimport (
+from octobot_trading.exchange_data.ohlcv.preloaded_candles_manager import (
     PreloadedCandlesManager,
 )
-from octobot_trading.exchange_data.ohlcv.candles_adapter cimport (
+from octobot_trading.exchange_data.ohlcv.candles_adapter import (
     get_symbol_close_candles,
     get_symbol_open_candles,
     get_symbol_high_candles,
     get_symbol_low_candles,
     get_symbol_volume_candles,
     get_symbol_time_candles,
+    get_candle_as_list,
 )
-from octobot_trading.exchange_data.ohlcv.channel cimport (
+from octobot_trading.exchange_data.ohlcv.channel import (
     OHLCVUpdaterSimulator,
     OHLCVProducer,
     OHLCVChannel,
 )
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater cimport (
+from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater import (
     OHLCVUpdater,
 )
 
 __all__ = [
     "CandlesManager",
     "PreloadedCandlesManager",
     "get_symbol_close_candles",
     "get_symbol_open_candles",
     "get_symbol_high_candles",
     "get_symbol_low_candles",
     "get_symbol_volume_candles",
     "get_symbol_time_candles",
+    "get_candle_as_list",
     "OHLCVUpdaterSimulator",
     "OHLCVProducer",
     "OHLCVChannel",
     "OHLCVUpdater",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -10,50 +10,36 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.ohlcv import candles_manager
-from octobot_trading.exchange_data.ohlcv import candles_adapter
-from octobot_trading.exchange_data.ohlcv import channel
 
-from octobot_trading.exchange_data.ohlcv.candles_manager import (
-    CandlesManager,
+from octobot_trading.exchange_data.order_book.channel import order_book
+from octobot_trading.exchange_data.order_book.channel.order_book import (
+    OrderBookProducer,
+    OrderBookChannel,
+    OrderBookTickerProducer,
+    OrderBookTickerChannel,
 )
-from octobot_trading.exchange_data.ohlcv.preloaded_candles_manager import (
-    PreloadedCandlesManager,
-)
-from octobot_trading.exchange_data.ohlcv.candles_adapter import (
-    get_symbol_close_candles,
-    get_symbol_open_candles,
-    get_symbol_high_candles,
-    get_symbol_low_candles,
-    get_symbol_volume_candles,
-    get_symbol_time_candles,
-    get_candle_as_list,
+
+from octobot_trading.exchange_data.order_book.channel import order_book_updater
+from octobot_trading.exchange_data.order_book.channel.order_book_updater import (
+    OrderBookUpdater,
 )
-from octobot_trading.exchange_data.ohlcv.channel import (
-    OHLCVUpdaterSimulator,
-    OHLCVProducer,
-    OHLCVChannel,
+
+from octobot_trading.exchange_data.order_book.channel import (
+    order_book_updater_simulator,
 )
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater import (
-    OHLCVUpdater,
+from octobot_trading.exchange_data.order_book.channel.order_book_updater_simulator import (
+    OrderBookUpdaterSimulator,
 )
 
 __all__ = [
-    "CandlesManager",
-    "PreloadedCandlesManager",
-    "get_symbol_close_candles",
-    "get_symbol_open_candles",
-    "get_symbol_high_candles",
-    "get_symbol_low_candles",
-    "get_symbol_volume_candles",
-    "get_symbol_time_candles",
-    "get_candle_as_list",
-    "OHLCVUpdaterSimulator",
-    "OHLCVProducer",
-    "OHLCVChannel",
-    "OHLCVUpdater",
+    "OrderBookUpdater",
+    "OrderBookProducer",
+    "OrderBookChannel",
+    "OrderBookTickerProducer",
+    "OrderBookTickerChannel",
+    "OrderBookUpdaterSimulator",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/candles_adapter.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/candles_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/candles_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/candles_manager.py`

 * *Files 6% similar despite different names*

```diff
@@ -123,14 +123,28 @@
         return candles
 
     def replace_all_candles(self, all_candles_data):
         self._reset_candles()
         self._set_all_candles(all_candles_data)
         self.candles_initialized = True
 
+    def upsert_candle(self, updated_candle):
+        updated_candle_time = updated_candle[enums.PriceIndexes.IND_PRICE_TIME.value]
+        for index, candle_time in enumerate(self.time_candles):
+            if candle_time == updated_candle_time:
+                self.close_candles[index] = updated_candle[enums.PriceIndexes.IND_PRICE_CLOSE.value]
+                self.open_candles[index] = updated_candle[enums.PriceIndexes.IND_PRICE_OPEN.value]
+                self.high_candles[index] = updated_candle[enums.PriceIndexes.IND_PRICE_HIGH.value]
+                self.low_candles[index] = updated_candle[enums.PriceIndexes.IND_PRICE_LOW.value]
+                self.volume_candles[index] = updated_candle[enums.PriceIndexes.IND_PRICE_VOL.value]
+                return
+
+        # candle not in db, add it
+        self.add_new_candle(updated_candle)
+
     def add_old_and_new_candles(self, candles_data):
         """
         Same as add_new_candle but also checks if old candles are missing
         :param candles_data: new candles data
         :return:
         """
         # check old candles
@@ -151,15 +165,15 @@
         if self._should_add_new_candle(new_candle_data[enums.PriceIndexes.IND_PRICE_TIME.value]):
             try:
                 self._check_max_candles()
                 self.close_candles[self.close_candles_index] = new_candle_data[enums.PriceIndexes.IND_PRICE_CLOSE.value]
                 self.open_candles[self.open_candles_index] = new_candle_data[enums.PriceIndexes.IND_PRICE_OPEN.value]
                 self.high_candles[self.high_candles_index] = new_candle_data[enums.PriceIndexes.IND_PRICE_HIGH.value]
                 self.low_candles[self.low_candles_index] = new_candle_data[enums.PriceIndexes.IND_PRICE_LOW.value]
-                self.time_candles[self.time_candles_index] = new_candle_data[enums.PriceIndexes.IND_PRICE_TIME.value]
+                self.time_candles[self.time_candles_index] = float(new_candle_data[enums.PriceIndexes.IND_PRICE_TIME.value])
                 self.volume_candles[self.volume_candles_index] = new_candle_data[enums.PriceIndexes.IND_PRICE_VOL.value]
                 self._inc_candle_index()
             except IndexError as e:
                 self.logger.error(f"Fail to add new candle {new_candle_data} : {e}")
 
     # private
     def _set_all_candles(self, new_candles_data):
@@ -195,14 +209,14 @@
         else:
             self.reached_max = True
 
     def _extract_limited_data(self, data, limit=-1, max_limit=-1):
         max_handled_limit: int = self.max_candles_count if self.reached_max else max_limit
         if limit == -1:
             if max_limit == -1:
-                return np.array(data)
-            return np.array(data[:max_handled_limit])
+                return np.array(data, dtype=np.float64)
+            return np.array(data[:max_handled_limit], dtype=np.float64)
 
         if max_limit == -1:
-            return np.array(data[-min(limit, len(data)):])
+            return np.array(data[-min(limit, len(data)):], dtype=np.float64)
         else:
-            return np.array(data[max(0, max_handled_limit - limit): max_handled_limit])
+            return np.array(data[max(0, max_handled_limit - limit): max_handled_limit], dtype=np.float64)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -10,29 +10,25 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-
-from octobot_trading.exchange_data.ohlcv.channel cimport ohlcv
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv cimport (
-    OHLCVProducer,
-    OHLCVChannel,
+from octobot_trading.exchanges.implementations import default_websocket_exchange
+from octobot_trading.exchanges.implementations.default_websocket_exchange import (
+    DefaultWebSocketExchange,
 )
-from octobot_trading.exchange_data.ohlcv.channel cimport ohlcv_updater
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater cimport (
-    OHLCVUpdater,
+from octobot_trading.exchanges.implementations import default_rest_exchange
+from octobot_trading.exchanges.implementations.default_rest_exchange import (
+    DefaultRestExchange,
 )
-
-from octobot_trading.exchange_data.ohlcv.channel cimport ohlcv_updater_simulator
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater_simulator cimport (
-    OHLCVUpdaterSimulator,
+from octobot_trading.exchanges.implementations import exchange_simulator
+from octobot_trading.exchanges.implementations.exchange_simulator import (
+    ExchangeSimulator,
 )
 
 __all__ = [
-    "OHLCVUpdaterSimulator",
-    "OHLCVProducer",
-    "OHLCVChannel",
-    "OHLCVUpdater",
+    "DefaultWebSocketExchange",
+    "DefaultRestExchange",
+    "ExchangeSimulator",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/channel/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -10,29 +10,23 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.ohlcv.channel import ohlcv
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv import (
-    OHLCVProducer,
-    OHLCVChannel,
-)
-from octobot_trading.exchange_data.ohlcv.channel import ohlcv_updater
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater import (
-    OHLCVUpdater,
+from octobot_trading.personal_data.trades.channel import trades
+from octobot_trading.personal_data.trades.channel.trades import (
+    TradesProducer,
+    TradesChannel,
 )
 
-from octobot_trading.exchange_data.ohlcv.channel import ohlcv_updater_simulator
-from octobot_trading.exchange_data.ohlcv.channel.ohlcv_updater_simulator import (
-    OHLCVUpdaterSimulator,
+from octobot_trading.personal_data.trades.channel import trades_updater
+from octobot_trading.personal_data.trades.channel.trades_updater import (
+    TradesUpdater,
 )
 
-
 __all__ = [
-    "OHLCVUpdaterSimulator",
-    "OHLCVProducer",
-    "OHLCVChannel",
-    "OHLCVUpdater",
+    "TradesProducer",
+    "TradesChannel",
+    "TradesUpdater",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/types/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,15 +9,21 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_channel as exchanges_channel
 
+from octobot_trading.exchanges.types import websocket_exchange
+from octobot_trading.exchanges.types.websocket_exchange import (
+    WebSocketExchange,
+)
+from octobot_trading.exchanges.types import rest_exchange
+from octobot_trading.exchanges.types.rest_exchange import (
+    RestExchange,
+)
 
-cdef class OHLCVProducer(exchanges_channel.ExchangeChannelProducer):
-    pass
-
-cdef class OHLCVChannel(exchanges_channel.TimeFrameExchangeChannel):
-    pass
+__all__ = [
+    "WebSocketExchange",
+    "RestExchange",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py`

 * *Files 2% similar despite different names*

```diff
@@ -25,15 +25,15 @@
         await self.perform(time_frame, symbol, candle, replace_all, partial)
 
     async def perform(self, time_frame, symbol, candle, replace_all=False, partial=False):
         try:
             if self.channel.get_filtered_consumers(symbol=constants.CHANNEL_WILDCARD) or \
                     self.channel.get_filtered_consumers(symbol=symbol, time_frame=time_frame.value):
                 await self.channel.exchange_manager.get_symbol_data(symbol) \
-                    .handle_candles_update(time_frame, candle, replace_all=replace_all, partial=partial)
+                    .handle_candles_update(time_frame, candle, replace_all=replace_all, partial=partial, upsert=False)
                 if candle and (partial or replace_all):
                     candle = candle[-1]
                 await self.send(cryptocurrency=self.channel.exchange_manager.exchange.
                                 get_pair_cryptocurrency(symbol),
                                 time_frame=time_frame.value,
                                 symbol=symbol,
                                 candle=candle)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/util/initializable.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,21 +9,27 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.ohlcv.channel.ohlcv as ohlcv_channel
 
+import abc
 
-cdef class OHLCVUpdater(ohlcv_channel.OHLCVProducer):
-    cdef list tasks
 
-    cdef bint is_initialized
-    cdef dict initialized_candles_by_tf_by_symbol
+class Initializable:
 
-    cdef list _get_traded_pairs(self)
-    cdef list _get_time_frames(self)
-    cdef int _get_historical_candles_count(self)
-    cdef double _ensure_correct_sleep_time(self, double sleep_time_candidate, double time_frame_sleep)
-    cdef void _set_initialized(self, str pair, object time_frame, bint initialized)
+    def __init__(self):
+        self.is_initialized = False
+
+    # calls initialize_impl if not initialized
+    async def initialize(self, force=False, **kwargs):
+        if not self.is_initialized or force:
+            await self.initialize_impl(**kwargs)
+            self.is_initialized = True
+            return True
+        return False
+
+    @abc.abstractmethod
+    async def initialize_impl(self, **kwargs):
+        raise NotImplementedError("initialize_impl not implemented")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,20 +12,22 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import asyncio
 import time
+import decimal
 
 import octobot_commons.constants as common_constants
 import octobot_commons.enums as common_enums
 
 import octobot_trading.errors as errors
 import octobot_trading.constants as constants
+import octobot_trading.enums as enums
 import octobot_trading.exchange_data.ohlcv.channel.ohlcv as ohlcv_channel
 import octobot_trading.exchanges as exchanges
 
 
 class OHLCVUpdater(ohlcv_channel.OHLCVProducer):
     CHANNEL_NAME = constants.OHLCV_CHANNEL
     OHLCV_LIMIT = 5  # should be < to candle manager's MAX_CANDLES_COUNT
@@ -39,36 +41,47 @@
     OHLCV_INITIALIZATION_RETRY_DELAY = 10
 
     def __init__(self, channel):
         super().__init__(channel)
         self.tasks = []
         self.is_initialized = False
         self.initialized_candles_by_tf_by_symbol = {}
+        self._logged_historical_candles_incompatibility = False
 
     async def start(self):
         """
         Creates OHLCV refresh tasks
         """
+        if self.single_update_task and not self.single_update_task.done():
+            await asyncio.wait_for(self.single_update_task, self.OHLCV_INITIALIZATION_TIMEOUT)
         if not self.is_initialized:
             await self._initialize(False)
         if self.channel is not None:
             if self.channel.is_paused:
                 await self.pause()
             else:
                 self.tasks = [
-                    asyncio.create_task(self._candle_callback(time_frame, pair))
+                    asyncio.create_task(self._candle_update_loop(time_frame, pair))
                     for time_frame in self.channel.exchange_manager.exchange_config.traded_time_frames
-                    for pair in self.channel.exchange_manager.exchange_config.traded_symbol_pairs]
+                    for pair in self.channel.exchange_manager.exchange_config.traded_symbol_pairs
+                    if self._should_maintain_candle(time_frame, pair)
+                ]
 
     def _get_traded_pairs(self):
         return self.channel.exchange_manager.exchange_config.traded_symbol_pairs
 
     def _get_time_frames(self):
         return self.channel.exchange_manager.exchange_config.traded_time_frames
 
+    def _should_maintain_candle(self, time_frame, pair):
+        return not (
+            exchanges.is_channel_managed_by_websocket(self.channel.exchange_manager, self.CHANNEL_NAME)
+            and self.channel.exchange_manager.exchange_web_socket.is_time_frame_supported(time_frame)
+        )
+
     async def fetch_and_push(self):
         return await self._initialize(True)
 
     async def _initialize(self, push_initialization_candles):
         try:
             initial_candles_data = await asyncio.gather(*[
                 self._initialize_candles(time_frame, pair, True)
@@ -83,20 +96,21 @@
             self.logger.debug("Candle history initial fetch completed")
             self.is_initialized = True
 
     def _get_historical_candles_count(self):
         if self.channel.exchange_manager.exchange_config.required_historical_candles_count > 0:
             if self.channel.exchange_manager.exchange_name in constants.FULL_CANDLE_HISTORY_EXCHANGES:
                 return self.channel.exchange_manager.exchange_config.required_historical_candles_count
-            else:
+            if not self._logged_historical_candles_incompatibility:
                 self.logger.warning(f"Can't initialize the required "
                                     f"{self.channel.exchange_manager.exchange_config.required_historical_candles_count}"
                                     f" historical candles: {self.channel.exchange_manager.exchange_name} is not "
                                     f"supporting large candles history. Using the {self.OHLCV_OLD_LIMIT} "
                                     f"latest candles instead.")
+                self._logged_historical_candles_incompatibility = True
         return self.OHLCV_OLD_LIMIT
 
     async def _get_init_candles(self, time_frame, pair):
         historical_candles_count_limit = self._get_historical_candles_count()
         if historical_candles_count_limit > constants.DEFAULT_CANDLE_HISTORY_SIZE:
             tf_seconds = common_enums.TimeFramesMinutes[time_frame] * common_constants.MINUTE_TO_SECONDS
             end_time = time.time() * common_constants.MSECONDS_TO_SECONDS
@@ -124,29 +138,39 @@
         try:
             candles: list = await self._get_init_candles(time_frame, pair)
         except errors.FailedRequest as e:
             self.logger.warning(str(e))
         if candles and len(candles) > 1:
             self._set_initialized(pair, time_frame, True)
             await self.channel.exchange_manager.get_symbol_data(pair) \
-                .handle_candles_update(time_frame, candles[:-1], replace_all=True, partial=False)
+                .handle_candles_update(time_frame, candles[:-1], replace_all=True, partial=False, upsert=False)
             self.logger.debug(f"Candle history loaded for {pair} on {time_frame}")
+            self._set_mark_price_from_candle(pair, candles[-1])
             return pair, time_frame, candles
         elif should_retry:
             # When candle history cannot be loaded, retry to load it later
             self.logger.warning(f"Failed to initialize candle history for {pair} on {time_frame}. Retrying in "
                                 f"{self.OHLCV_INITIALIZATION_RETRY_DELAY} seconds")
             # retry only once
             await asyncio.sleep(self.OHLCV_INITIALIZATION_RETRY_DELAY)
             return await self._initialize_candles(time_frame, pair, False)
         else:
             self.logger.warning(f"Failed to initialize candle history for {pair} on {time_frame}. Retrying on "
                                 f"the next time frame update")
             return None
 
+    def _set_mark_price_from_candle(self, pair, candle):
+        # Initialize mark price with last candle close to allow trading low liquidity markets. Those that might
+        # take some time to produce a trade and therefore initialize their mark price, which is
+        # required to create orders and might block the trading initialization
+        self.channel.exchange_manager.get_symbol_data(pair).handle_mark_price_update(
+            decimal.Decimal(str(candle[common_enums.PriceIndexes.IND_PRICE_CLOSE.value])),
+            enums.MarkPriceSources.TICKER_CLOSE_PRICE.value
+        )
+
     async def _push_initial_candles(self, initial_candles_data):
         self.logger.debug("Pushing completed initialization candles")
         for initial_candles_tuple in initial_candles_data:
             if initial_candles_tuple is not None:
                 pair, time_frame, candles = initial_candles_tuple
                 await self._push_complete_candles(time_frame, pair, candles)
 
@@ -159,15 +183,16 @@
             for time_frame, initialized in self.initialized_candles_by_tf_by_symbol[pair].items()
             if not initialized
         )
         # call gather only if init_coroutines is not empty for optimization purposes
         if init_coroutines:
             await asyncio.gather(*init_coroutines)
 
-    async def _candle_callback(self, time_frame, pair):
+    async def _candle_update_loop(self, time_frame, pair):
+        self.logger.debug(f"Starting ohlcv updater loop for {pair} on {time_frame}")
         time_frame_seconds: int = common_enums.TimeFramesMinutes[time_frame] * common_constants.MINUTE_TO_SECONDS
         time_frame_sleep: int = time_frame_seconds
         last_candle_timestamp: float = 0
         missing_data_sleep_time = min(int(time_frame_seconds / 6), self.OHLCV_MISSING_DATA_REFRESH_RETRY_MAX_DELAY)
 
         while not self.should_stop and not self.channel.is_paused:
             try:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py`

 * *Files 1% similar despite different names*

```diff
@@ -153,12 +153,13 @@
             self.last_candles_by_pair_by_time_frame[pair] = {}
         if ohlcv_data:
             # init historical candles
             await self.channel.exchange_manager.get_symbol_data(pair) \
                 .handle_candles_update(time_frame,
                                        [ohlcv[-1] for ohlcv in ohlcv_data],
                                        replace_all=True,
-                                       partial=False)
+                                       partial=False,
+                                       upsert=False)
             self.last_candles_by_pair_by_time_frame[pair][time_frame.value] = ohlcv_data[-1]
             self.require_last_init_candles_pairs_push = True
         # self.initial_timestamp - 1 to re-select this candle and push it when init step will be over
         self.last_timestamp_pushed = self.initial_timestamp - 1
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py`

 * *Files 3% similar despite different names*

```diff
@@ -49,15 +49,15 @@
         self.open_candles = self._get_candle_values_array(new_candles_data, enums.PriceIndexes.IND_PRICE_OPEN.value)
         self.high_candles = self._get_candle_values_array(new_candles_data, enums.PriceIndexes.IND_PRICE_HIGH.value)
         self.low_candles = self._get_candle_values_array(new_candles_data, enums.PriceIndexes.IND_PRICE_LOW.value)
         self.time_candles = self._get_candle_values_array(new_candles_data, enums.PriceIndexes.IND_PRICE_TIME.value)
         self.volume_candles = self._get_candle_values_array(new_candles_data, enums.PriceIndexes.IND_PRICE_VOL.value)
 
     def _get_candle_values_array(self, candles, key):
-        return np.array([candle[key] for candle in candles])
+        return np.array([candle[key] for candle in candles], dtype=np.float64)
 
     def _get_candle_index(self, candle):
         # Uses the given candle to find the index on the associated candle in preloaded candles.
         # The goal of this method is to quickly identify where the limit between past and future candles
         # should be when handling preloaded candles.
 
         # return actual index + 1 as it is used as a select length
@@ -86,20 +86,20 @@
         self.time_candles_index = current_index
         self.volume_candles_index = current_index
 
     def _extract_limited_data(self, data, limit=-1, max_limit=-1):
         if limit == -1:
             if max_limit == -1:
                 return data
-            return np.array(data[:max_limit])
+            return np.array(data[:max_limit], dtype=np.float64)
 
         if max_limit == -1:
-            return np.array(data[-min(limit, len(data)):])
+            return np.array(data[-min(limit, len(data)):], dtype=np.float64)
         else:
-            return np.array(data[max(0, max_limit - limit): max_limit])
+            return np.array(data[max(0, max_limit - limit): max_limit], dtype=np.float64)
 
     def add_new_candle(self, new_candle_data):
         self.logger.error("add_new_candle should not be called")
 
     def _reset_candles(self):
         self.candles_initialized = False
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position_util.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,21 +9,15 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_channel as exchanges_channel
+import octobot_trading.enums as enums
 
 
-cdef class OrderBookProducer(exchanges_channel.ExchangeChannelProducer):
-    pass
-
-cdef class OrderBookChannel(exchanges_channel.ExchangeChannel):
-    pass
-
-cdef class OrderBookTickerProducer(exchanges_channel.ExchangeChannelProducer):
-    pass
-
-cdef class OrderBookTickerChannel(exchanges_channel.ExchangeChannel):
-    pass
+def parse_position_status(raw_position):
+    try:
+        return enums.PositionStatus(raw_position[enums.ExchangeConstantsPositionColumns.STATUS.value])
+    except KeyError:
+        return None
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/order_book.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/sell_market_order.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,12 +9,14 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.order_book.channel.order_book as order_book_channel
+import octobot_trading.enums as enums
+import octobot_trading.personal_data.orders.types.market.market_order as market_order
 
 
-cdef class OrderBookUpdater(order_book_channel.OrderBookProducer):
-    cdef int refresh_time
+class SellMarketOrder(market_order.MarketOrder):
+    def __init__(self, trader, side=None):
+        super().__init__(trader, side=enums.TradeOrderSide.SELL)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/order_book_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/buy_limit_order.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,20 +9,15 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport async_channel.consumer as consumer
-cimport octobot_backtesting.importers as importers
-cimport octobot_trading.exchange_data.order_book.channel.order_book_updater as order_book_updater
 
+import octobot_trading.enums as enums
+import octobot_trading.personal_data.orders.types.limit.limit_order as limit_order
 
-cdef class OrderBookUpdaterSimulator(order_book_updater.OrderBookUpdater):
-    cdef importers.ExchangeDataImporter exchange_data_importer
 
-    cdef str exchange_name
-
-    cdef double last_timestamp_pushed
-
-    cdef public consumer.Consumer time_consumer
+class BuyLimitOrder(limit_order.LimitOrder):
+    def __init__(self, trader, side=enums.TradeOrderSide.BUY):
+        super().__init__(trader, side)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/order_book/order_book_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/order_book/order_book_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,29 +10,29 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.prices cimport channel
-from octobot_trading.exchange_data.prices cimport prices_manager
-from octobot_trading.exchange_data.prices cimport price_events_manager
+from octobot_trading.exchange_data.prices import channel
+from octobot_trading.exchange_data.prices import prices_manager
+from octobot_trading.exchange_data.prices import price_events_manager
 
-from octobot_trading.exchange_data.prices.channel cimport (
+from octobot_trading.exchange_data.prices.channel import (
     MarkPriceUpdater,
     MarkPriceUpdaterSimulator,
     MarkPriceProducer,
     MarkPriceChannel,
 )
-from octobot_trading.exchange_data.prices.prices_manager cimport (
+from octobot_trading.exchange_data.prices.prices_manager import (
     PricesManager,
     calculate_mark_price_from_recent_trade_prices,
 )
-from octobot_trading.exchange_data.prices.price_events_manager cimport (
+from octobot_trading.exchange_data.prices.price_events_manager import (
     PriceEventsManager,
 )
 
 __all__ = [
     "MarkPriceUpdaterSimulator",
     "MarkPriceProducer",
     "MarkPriceChannel",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,34 +10,30 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.prices import channel
-from octobot_trading.exchange_data.prices import prices_manager
-from octobot_trading.exchange_data.prices import price_events_manager
-
-from octobot_trading.exchange_data.prices.channel import (
-    MarkPriceUpdater,
-    MarkPriceUpdaterSimulator,
-    MarkPriceProducer,
-    MarkPriceChannel,
-)
-from octobot_trading.exchange_data.prices.prices_manager import (
-    PricesManager,
-    calculate_mark_price_from_recent_trade_prices,
-)
-from octobot_trading.exchange_data.prices.price_events_manager import (
-    PriceEventsManager,
-)
-
-__all__ = [
-    "MarkPriceUpdaterSimulator",
-    "MarkPriceProducer",
-    "MarkPriceChannel",
-    "PricesManager",
-    "calculate_mark_price_from_recent_trade_prices",
-    "MarkPriceUpdater",
-    "PriceEventsManager",
-]
+import pytest
+
+# avoid circular imports when launching tests from this folder
+import octobot_trading.api  # TODO fix circular import when importing octobot_trading.exchange_data first
+
+from octobot_trading.exchange_data.prices.price_events_manager import PriceEventsManager
+from octobot_trading.exchange_data.prices.prices_manager import PricesManager
+from octobot_trading.exchange_data.recent_trades.recent_trades_manager import RecentTradesManager
+
+
+@pytest.fixture()
+def price_events_manager(event_loop):
+    return PriceEventsManager()
+
+
+@pytest.fixture()
+def prices_manager(event_loop, backtesting_exchange_manager):
+    return PricesManager(backtesting_exchange_manager)
+
+
+@pytest.fixture()
+def recent_trades_manager(event_loop):
+    return RecentTradesManager()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/signals/channel/remote_trading_signal_channel_factory.py`

 * *Files 27% similar despite different names*

```diff
@@ -9,28 +9,29 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import octobot_commons.channels_name as channels_names
+import async_channel.util as channel_creator
+import async_channel.channels as channels
+import octobot_trading.signals.channel.remote_trading_signal as remote_trading_signal
+import octobot_trading.signals.channel.signal_producer as signal_producer
 
-from octobot_trading.exchange_data.prices.channel cimport price
-from octobot_trading.exchange_data.prices.channel.price cimport (
-    MarkPriceProducer,
-    MarkPriceChannel,
-)
-from octobot_trading.exchange_data.prices.channel cimport prices_updater
-from octobot_trading.exchange_data.prices.channel.prices_updater cimport (
-    MarkPriceUpdater,
-)
-from octobot_trading.exchange_data.prices.channel cimport prices_updater_simulator
-from octobot_trading.exchange_data.prices.channel.prices_updater_simulator cimport (
-    MarkPriceUpdaterSimulator,
-)
 
-__all__ = [
-    "MarkPriceUpdaterSimulator",
-    "MarkPriceProducer",
-    "MarkPriceChannel",
-    "MarkPriceUpdater",
-]
+async def create_remote_trading_signal_channel_if_missing(exchange_manager) -> \
+        (remote_trading_signal.RemoteTradingSignalsChannel, bool):
+    try:
+        return channels.get_chan(channels_names.OctoBotCommunityChannelsName.REMOTE_TRADING_SIGNALS_CHANNEL.value), \
+               False
+    except KeyError:
+        channel = await channel_creator.create_channel_instance(remote_trading_signal.RemoteTradingSignalsChannel,
+                                                                channels.set_chan)
+        # also create the associated producer
+        producer = signal_producer.RemoteTradingSignalProducer(
+            channel,
+            exchange_manager.bot_id
+        )
+        await channel.register_producer(producer)
+        return channel, True
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,27 +10,31 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.prices.channel import price
-from octobot_trading.exchange_data.prices.channel.price import (
-    MarkPriceProducer,
-    MarkPriceChannel,
-)
-from octobot_trading.exchange_data.prices.channel import prices_updater
-from octobot_trading.exchange_data.prices.channel.prices_updater import (
-    MarkPriceUpdater,
+from octobot_trading.exchange_data.ticker import ticker_manager
+from octobot_trading.exchange_data.ticker import channel
+
+from octobot_trading.exchange_data.ticker.ticker_manager import (
+    TickerManager,
 )
-from octobot_trading.exchange_data.prices.channel import prices_updater_simulator
-from octobot_trading.exchange_data.prices.channel.prices_updater_simulator import (
-    MarkPriceUpdaterSimulator,
+from octobot_trading.exchange_data.ticker.channel import (
+    TickerProducer,
+    TickerChannel,
+    TickerUpdater,
+    TickerUpdaterSimulator,
+    MiniTickerProducer,
+    MiniTickerChannel,
 )
 
 __all__ = [
-    "MarkPriceUpdaterSimulator",
-    "MarkPriceProducer",
-    "MarkPriceChannel",
-    "MarkPriceUpdater",
+    "TickerManager",
+    "TickerUpdater",
+    "TickerProducer",
+    "TickerChannel",
+    "MiniTickerProducer",
+    "MiniTickerChannel",
+    "TickerUpdaterSimulator",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/price.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/active_position_state.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,15 +9,22 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_channel as exchanges_channel
+import octobot_trading.personal_data.positions.states.idle_position_state as idle_position_state
 
 
-cdef class MarkPriceProducer(exchanges_channel.ExchangeChannelProducer):
-    pass
+class ActivePositionState(idle_position_state.IdlePositionState):
+    """
+    ActivePositionState is the state of a position that has a non-zero size
+    """
+    def is_active(self) -> bool:
+        """
+        :return: True if the Position has a non-zero size
+        """
+        return True
 
-cdef class MarkPriceChannel(exchanges_channel.ExchangeChannel):
-    pass
+    def _is_compatible_size(self):
+        return not self.position.is_idle()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/price.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/price.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/constants.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,13 +9,10 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.prices.channel.price as prices_channel
 
-cdef class MarkPriceUpdater(prices_channel.MarkPriceProducer):
-    cdef object recent_trades_consumer
-    cdef object ticker_consumer
-    cdef int refresh_time
+CCXT_INFO = "info"
+CCXT_OPTIONS = "options"
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/prices_updater.py`

 * *Files 2% similar despite different names*

```diff
@@ -80,29 +80,33 @@
     async def handle_recent_trades_update(self, exchange: str, exchange_id: str,
                                           cryptocurrency: str, symbol: str, recent_trades: list):
         """
         Recent trades channel consumer callback
         """
         try:
             mark_price = prices_manager.calculate_mark_price_from_recent_trade_prices(
-                [decimal.Decimal(str(last_price[enums.ExchangeConstantsOrderColumns.PRICE.value]))
-                 for last_price in recent_trades])
+                [
+                    decimal.Decimal(str(last_price[enums.ExchangeConstantsOrderColumns.PRICE.value]))
+                    for last_price in recent_trades
+                ]
+            )
 
             await self.push(symbol, mark_price, mark_price_source=enums.MarkPriceSources.RECENT_TRADE_AVERAGE.value)
         except Exception as e:
             self.logger.exception(e, True, f"Fail to handle recent trades update : {e}")
 
     async def handle_ticker_update(self, exchange: str, exchange_id: str,
                                    cryptocurrency: str, symbol: str, ticker: dict):
         """
         Ticker channel consumer callback
         """
         try:
-            await self.push(symbol, decimal.Decimal(str(ticker[enums.ExchangeConstantsTickersColumns.CLOSE.value])),
-                            mark_price_source=enums.MarkPriceSources.TICKER_CLOSE_PRICE.value)
+            if ticker[enums.ExchangeConstantsTickersColumns.CLOSE.value]:
+                await self.push(symbol, decimal.Decimal(str(ticker[enums.ExchangeConstantsTickersColumns.CLOSE.value])),
+                                mark_price_source=enums.MarkPriceSources.TICKER_CLOSE_PRICE.value)
         except Exception as e:
             self.logger.exception(e, True, f"Fail to handle ticker update : {e}")
 
     async def start_fetching(self):
         """
         Mark price updater from exchange data
         """
@@ -144,15 +148,15 @@
                      decimal.Decimal(str(funding_rate[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value])),
                      decimal.Decimal(str(predicted_funding_rate or constants.NaN)),
                      funding_rate[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value],
                      funding_rate[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value])
 
     def _should_fetch_on_exchange(self) -> bool:
         return not (
-                self.channel.exchange_manager.exchange.FUNDING_WITH_MARK_PRICE
-                or self.channel.exchange_manager.exchange.MARK_PRICE_IN_TICKER
-                or self.channel.exchange_manager.exchange.MARK_PRICE_IN_POSITION
+            self.channel.exchange_manager.exchange.FUNDING_WITH_MARK_PRICE
+            or self.channel.exchange_manager.exchange.MARK_PRICE_IN_TICKER
+            or self.channel.exchange_manager.exchange.MARK_PRICE_IN_POSITION
         )
 
     def _should_subscribe(self):
         return not self.channel.exchange_manager.is_future or \
             not self.channel.exchange_manager.exchange.MARK_PRICE_IN_POSITION
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,12 +9,10 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_backtesting.importers as importers
-cimport octobot_trading.exchange_data.prices.channel.prices_updater as prices_updater
 
-cdef class MarkPriceUpdaterSimulator(prices_updater.MarkPriceUpdater):
-    cdef importers.ExchangeDataImporter exchange_data_importer
+PROJECT_NAME = "OctoBot-Trading"
+VERSION = "2.4.0"  # major.minor.revision
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/price_events_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/price_events_manager.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,20 +28,24 @@
 
     """
     The price event index from a price event tuple
     """
     PRICE_EVENT_INDEX = 2
     PRICE_KEY = "price"
     TIME_KEY = "time"
+    MAX_LAST_RECENT_PRICES = 50
 
     def __init__(self):
         self.logger = logging.get_logger(self.__class__.__name__)
         self.events = []
         self._last_recent_prices = []
 
+    def stop(self):
+        self.reset()
+
     def reset(self):
         """
         Reset price events
         """
         self.clear_recent_prices()
         self.events.clear()
 
@@ -76,14 +80,20 @@
         self._last_recent_prices = []
 
     def _add_recent_price(self, price, timestamp):
         self._last_recent_prices.append({
             self.PRICE_KEY: price,
             self.TIME_KEY: timestamp
         })
+        self._ensure_last_prices_length()
+
+    def _ensure_last_prices_length(self):
+        if len(self._last_recent_prices) > self.MAX_LAST_RECENT_PRICES:
+            # only take the most recent prices
+            self._last_recent_prices = self._last_recent_prices[self.MAX_LAST_RECENT_PRICES // 2:]
 
     def new_event(self, price, timestamp, trigger_above, allow_instant_fill=True):
         """
         Create a new event at price and timestamp.
         This event can already be set should it be instantly triggered.
         Otherwise it will be set once the required price conditions are met
         :param price: the trigger price
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/prices/prices_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/prices/prices_manager.py`

 * *Files 5% similar despite different names*

```diff
@@ -44,14 +44,18 @@
         Initialize PricesManager attributes with default
         """
         self._reset_prices()
 
     def initialized(self):
         return self.mark_price is not constants.ZERO
 
+    def stop(self):
+        self._reset_prices()
+        self.exchange_manager = None
+
     def set_mark_price(self, mark_price, mark_price_source) -> bool:
         """
         Set the mark price if the mark price come from MarkPriceSources.EXCHANGE_MARK_PRICE
         Set the mark price if the mark price come from MarkPriceSources.RECENT_TRADE_AVERAGE and
         if it's not the first update for MarkPriceSources.RECENT_TRADE_AVERAGE
         Set the mark price if the mark price come from MarkPriceSources.TICKER_CLOSE_PRICE and
         if other sources have expired
@@ -70,16 +74,17 @@
                 self._set_mark_price_value(mark_price)
                 is_mark_price_updated = True
             else:
                 # set time at 0 to ensure invalid price but keep track of initialization
                 self.mark_price_from_sources[mark_price_source] = (mark_price, 0)
 
         # set mark price value if other sources have expired
-        elif mark_price_source == enums.MarkPriceSources.TICKER_CLOSE_PRICE.value and not \
-                self._are_other_sources_valid(enums.MarkPriceSources.TICKER_CLOSE_PRICE.value):
+        elif mark_price_source in (enums.MarkPriceSources.TICKER_CLOSE_PRICE.value,
+                                   enums.MarkPriceSources.CANDLE_CLOSE_PRICE.value) and not \
+                self._are_other_sources_valid(mark_price_source):
             self._set_mark_price_value(mark_price)
             is_mark_price_updated = True
 
         if is_mark_price_updated:
             self.mark_price_from_sources[mark_price_source] = \
                 (mark_price, self.exchange_manager.exchange.get_exchange_current_time())
         return is_mark_price_updated
@@ -96,18 +101,17 @@
                 self.exchange_manager.ensure_reachability()
                 if self.exchange_manager.is_backtesting:
                     # should never happen in backtesting: mark price is either available
                     # or exchange should be unreachable
                     raise asyncio.TimeoutError()
                 await asyncio.wait_for(self.valid_price_received_event.wait(), timeout)
             except asyncio.TimeoutError:
-                self.logger.warning("Timeout when waiting for current market price. This probably means that too many "
-                                    "trading pairs are being used at the same time and the exchange's rate limit is "
-                                    "preventing OctoBot from working properly. If this issue persists, please consider "
-                                    "using websocket connections.")
+                self.logger.warning("Timeout when waiting for current market price. This probably means that the "
+                                    "required mark price market as a very low liquidity. Market price will be "
+                                    "available as soon as a trade will happen on this market.")
                 raise
         return self.mark_price
 
     def _set_mark_price_value(self, mark_price):
         """
         Called when a new mark price value has been calculated or provided by the exchange
         """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -10,29 +10,29 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.recent_trades.channel cimport recent_trade
-from octobot_trading.exchange_data.recent_trades.channel.recent_trade cimport (
+from octobot_trading.exchange_data.recent_trades.channel import recent_trade
+from octobot_trading.exchange_data.recent_trades.channel.recent_trade import (
     RecentTradeProducer,
     RecentTradeChannel,
     LiquidationsProducer,
     LiquidationsChannel,
 )
-from octobot_trading.exchange_data.recent_trades.channel cimport recent_trade_updater
-from octobot_trading.exchange_data.recent_trades.channel.recent_trade_updater cimport (
+from octobot_trading.exchange_data.recent_trades.channel import recent_trade_updater
+from octobot_trading.exchange_data.recent_trades.channel.recent_trade_updater import (
     RecentTradeUpdater,
 )
-from octobot_trading.exchange_data.recent_trades.channel cimport (
+from octobot_trading.exchange_data.recent_trades.channel import (
     recent_trade_updater_simulator,
 )
-from octobot_trading.exchange_data.recent_trades.channel.recent_trade_updater_simulator cimport (
+from octobot_trading.exchange_data.recent_trades.channel.recent_trade_updater_simulator import (
     RecentTradeUpdaterSimulator,
 )
 
 __all__ = [
     "RecentTradeProducer",
     "RecentTradeChannel",
     "LiquidationsProducer",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.pxd` & `OctoBot-Trading-2.4.0/tests/api/test_profitability.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,12 +9,12 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.recent_trades.channel.recent_trade as recent_trade_channel
 
+import pytest
 
-cdef class RecentTradeUpdater(recent_trade_channel.RecentTradeProducer):
-    cdef int refresh_time
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/orders_updater_simulator.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# cython: language_level=3
+# pylint: disable=E0611
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,23 +10,26 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport async_channel.consumer as consumer
-cimport octobot_backtesting.importers as importers
-cimport octobot_trading.exchange_data.recent_trades.channel.recent_trade_updater as recent_trade_updater
 
-
-cdef class RecentTradeUpdaterSimulator(recent_trade_updater.RecentTradeUpdater):
-    cdef importers.ExchangeDataImporter exchange_data_importer
-
-    cdef str exchange_name
-
-    cdef double last_timestamp_pushed
-
-    cdef public consumer.Consumer time_consumer
-
-    cdef dict last_timestamp_pushed_by_symbol
-    cdef str recent_trades_time_frame
+import octobot_trading.exchange_channel as exchange_channel
+import octobot_trading.constants as constants
+import octobot_trading.personal_data.orders.channel.orders_updater as orders_updater
+
+
+class OrdersUpdaterSimulator(orders_updater.OrdersUpdater):
+    async def start(self):
+        self.channel.exchange_manager.exchange_personal_data.orders_manager.are_exchange_orders_initialized = True
+        await exchange_channel.get_chan(constants.RECENT_TRADES_CHANNEL, self.channel.exchange_manager.id) \
+            .new_consumer(self.ignore_recent_trades_update)
+        for symbol in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
+            self._set_initialized_event(symbol)
+
+    async def ignore_recent_trades_update(self, exchange: str, exchange_id: str,
+                                          cryptocurrency: str, symbol: str, recent_trades: list):
+        """
+        Used to subscribe at least one recent trades consumer during backtesting
+        """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/recent_trades_manager.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/dsl/values.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,30 +1,40 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.util as util
 
-cdef class RecentTradesManager(util.Initializable):
-    cdef object logger
+import enum
 
-    cdef public object recent_trades
-    cdef public object liquidations
 
-    cdef void _reset_recent_trades(self)
+class QuantityType(enum.Enum):
+    DELTA = ""
+    PERCENT = "%"
+    AVAILABLE = "a"
+    POSITION = "p"
+    ENTRY = "e"
+    AVAILABLE_PERCENT = "a%"
+    POSITION_PERCENT = "p%"
+    ENTRY_PERCENT = "e%"
+    FLAT = "@"
+    UNKNOWN = "?"
 
-    cpdef list set_all_recent_trades(self, list recent_trades)
-    cpdef list add_new_trades(self, list recent_trades)
-
-    cpdef list add_new_liquidations(self, list liquidations)
+    @staticmethod
+    def parse(value):
+        try:
+            # try reading directly as enum
+            return QuantityType(value), value
+        except ValueError:
+            # try with letters in reverse order
+            reversed_value = value[::-1]
+            return QuantityType(reversed_value), value
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py`

 * *Files 1% similar despite different names*

```diff
@@ -40,15 +40,16 @@
             return self.recent_trades
 
     def add_new_trades(self, recent_trades):
         if recent_trades:
             new_recent_trades: list = [
                 trade
                 for trade in recent_trades
-                if trade not in self.recent_trades]
+                if trade not in self.recent_trades
+            ]
             self.recent_trades.extend(new_recent_trades)
             return new_recent_trades
 
     def add_new_liquidations(self, liquidations):
         if liquidations:
             new_liquidations: list = [
                 liquidation
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,32 +10,31 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.ticker cimport ticker_manager
-
-from octobot_trading.exchange_data.ticker.ticker_manager cimport (
-    TickerManager,
-)
-
-from octobot_trading.exchange_data.ticker cimport channel
-from octobot_trading.exchange_data.ticker.channel cimport (
+from octobot_trading.exchange_data.ticker.channel import ticker
+from octobot_trading.exchange_data.ticker.channel.ticker import (
     TickerProducer,
     TickerChannel,
-    TickerUpdater,
-    TickerUpdaterSimulator,
     MiniTickerProducer,
     MiniTickerChannel,
 )
+from octobot_trading.exchange_data.ticker.channel import ticker_updater
+from octobot_trading.exchange_data.ticker.channel.ticker_updater import (
+    TickerUpdater,
+)
+from octobot_trading.exchange_data.ticker.channel import ticker_updater_simulator
+from octobot_trading.exchange_data.ticker.channel.ticker_updater_simulator import (
+    TickerUpdaterSimulator,
+)
 
 __all__ = [
-   "TickerManager",
     "TickerUpdater",
     "TickerProducer",
     "TickerChannel",
     "MiniTickerProducer",
     "MiniTickerChannel",
     "TickerUpdaterSimulator",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -10,31 +10,27 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchange_data.ticker import ticker_manager
-from octobot_trading.exchange_data.ticker import channel
-
-from octobot_trading.exchange_data.ticker.ticker_manager import (
-    TickerManager,
+from octobot_trading.exchanges.connectors import ccxt
+from octobot_trading.exchanges.connectors.ccxt import (
+    CCXTAdapter,
+    CCXTConnector,
+    CCXTWebsocketConnector,
 )
-from octobot_trading.exchange_data.ticker.channel import (
-    TickerProducer,
-    TickerChannel,
-    TickerUpdater,
-    TickerUpdaterSimulator,
-    MiniTickerProducer,
-    MiniTickerChannel,
+
+from octobot_trading.exchanges.connectors import simulator
+from octobot_trading.exchanges.connectors.simulator import (
+    ExchangeSimulatorAdapter,
+    ExchangeSimulatorConnector,
 )
 
 __all__ = [
-    "TickerManager",
-    "TickerUpdater",
-    "TickerProducer",
-    "TickerChannel",
-    "MiniTickerProducer",
-    "MiniTickerChannel",
-    "TickerUpdaterSimulator",
+    "CCXTAdapter",
+    "CCXTConnector",
+    "CCXTWebsocketConnector",
+    "ExchangeSimulatorAdapter",
+    "ExchangeSimulatorConnector",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/ticker.py`

 * *Files 4% similar despite different names*

```diff
@@ -22,14 +22,15 @@
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 
 
 class TickerProducer(exchanges_channel.ExchangeChannelProducer):
     async def push(self, symbol, ticker):
         await self.perform(symbol, ticker)
+        await self._on_ticker_push(symbol, ticker)
 
     async def perform(self, symbol, ticker):
         try:
             if self.channel.get_filtered_consumers(symbol=async_channel_constants.CHANNEL_WILDCARD) or \
                     self.channel.get_filtered_consumers(symbol=symbol):  #
                 if ticker:  # and price_ticker_is_initialized
                     self.channel.exchange_manager.get_symbol_data(symbol).handle_ticker_update(ticker)
@@ -58,14 +59,17 @@
             await self._push_future_data(symbol, ticker)
 
     async def _push_mini_ticker(self, pair, ticker):
         """
         Mini ticker
         """
         try:
+            if not ticker[enums.ExchangeConstantsTickersColumns.CLOSE.value]:
+                # no need to push when there is not even a close price (0 or None)
+                return
             await exchanges_channel.get_chan(
                 constants.MINI_TICKER_CHANNEL,
                 self.channel.exchange_manager.id
             ).get_internal_producer().push(
                 pair,
                 {
                     enums.ExchangeConstantsMiniTickerColumns.HIGH_PRICE.value:
@@ -102,25 +106,25 @@
                 mark_price_source=enums.MarkPriceSources.TICKER_CLOSE_PRICE.value
             )
         except Exception as e:
             self.logger.exception(e, True, f"Fail to update mark price from ticker : {e}")
 
     async def _push_funding_rate(self, symbol: str, ticker: dict):
         try:
-            ticker = self.channel.exchange_manager.exchange.parse_funding(ticker, from_ticker=True)
-            predicted_funding_rate = ticker.get(
-                enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value, constants.NaN
-            )
+            funding_from_ticker = self.channel.exchange_manager.exchange.parse_funding(ticker, from_ticker=True)
+            if not funding_from_ticker:
+                # not enough info, don't push possibly false data
+                return
             await exchanges_channel.get_chan(constants.FUNDING_CHANNEL, self.channel.exchange_manager.id)\
                 .get_internal_producer().push(
                     symbol,
-                    decimal.Decimal(str(ticker[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value])),
-                    decimal.Decimal(str(predicted_funding_rate or constants.NaN)),
-                    ticker[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value],
-                    ticker[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value]
+                    funding_from_ticker[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value],
+                    funding_from_ticker[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value],
+                    funding_from_ticker[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value],
+                    funding_from_ticker[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value],
             )
         except Exception as e:
             self.logger.exception(e, True, f"Fail to update funding rate from ticker : {e}")
 
 
 class TickerChannel(exchanges_channel.ExchangeChannel):
     PRODUCER_CLASS = TickerProducer
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater.pxd` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_huobipro.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,17 +9,19 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchange_data.ticker.channel.ticker as ticker_channel
+import pytest
 
-cdef class TickerUpdater(ticker_channel.TickerProducer):
-    cdef list _added_pairs
-    cdef bint is_fetching_future_data
-    cdef int refresh_time
+from tests_additional.real_exchanges.test_huobi import TestHuobiRealExchangeTester
+# required to catch async loop context exceptions
+from tests import event_loop
 
-    cdef list _get_pairs_to_update(self)
-    cdef bint _should_use_future(self)
-    cdef void _update_refresh_time(self)
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
+
+
+class TestHuobiproRealExchangeTester(TestHuobiRealExchangeTester):
+    EXCHANGE_NAME = "huobipro"
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/ticker_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/unsupported_order.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,24 +9,23 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport async_channel.consumer as consumer
-cimport octobot_backtesting.importers as importers
-cimport octobot_trading.exchange_data.ticker.channel.ticker_updater as ticker_updater
+import octobot_trading.personal_data.orders.order as order_class
+import octobot_trading.errors as errors
 
 
-cdef class TickerUpdaterSimulator(ticker_updater.TickerUpdater):
-    cdef importers.ExchangeDataImporter exchange_data_importer
-
-    cdef str exchange_name
-
-    cdef double last_timestamp_pushed
-
-    cdef public consumer.Consumer time_consumer
-
-    cdef dict last_timestamp_pushed_by_symbol
-    cdef str ticker_time_frame
-    cdef double ticker_time_frame_seconds
+class UnsupportedOrder(order_class.Order):
+    """
+    UnsupportedOrder is used when an exchange order is fetched but is on purpose set to unsupported.
+    Used to handle orders that are fetched but can't (yet) be handled in OctoBot.
+    """
+    async def update_order_status(self, force_refresh=False):
+        if self.trader.simulate:
+            # SHOULD NEVER HAPPEN
+            raise errors.NotSupported(
+                f"{self.get_name()} can't be updated and should not appear in simulation mode"
+            )
+        await self.default_exchange_update_order_status()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py`

 * *Files 2% similar despite different names*

```diff
@@ -82,15 +82,17 @@
         return {
             enums.ExchangeConstantsTickersColumns.TIMESTAMP.value: last_candle_timestamp,
             enums.ExchangeConstantsTickersColumns.LAST.value: candle[common_enums.PriceIndexes.IND_PRICE_CLOSE.value],
             enums.ExchangeConstantsTickersColumns.SYMBOL.value: symbol,
             enums.ExchangeConstantsTickersColumns.HIGH.value: candle[common_enums.PriceIndexes.IND_PRICE_HIGH.value],
             enums.ExchangeConstantsTickersColumns.LOW.value: candle[common_enums.PriceIndexes.IND_PRICE_LOW.value],
             enums.ExchangeConstantsTickersColumns.OPEN.value: candle[common_enums.PriceIndexes.IND_PRICE_OPEN.value],
-            enums.ExchangeConstantsTickersColumns.CLOSE.value: candle[common_enums.PriceIndexes.IND_PRICE_CLOSE.value]
+            enums.ExchangeConstantsTickersColumns.CLOSE.value: candle[common_enums.PriceIndexes.IND_PRICE_CLOSE.value],
+            enums.ExchangeConstantsTickersColumns.BASE_VOLUME.value:
+                candle[common_enums.PriceIndexes.IND_PRICE_VOL.value]
         }
 
     async def pause(self):
         if self.time_consumer is not None:
             await channels.get_chan(channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value). \
                 remove_consumer(self.time_consumer)
         self.is_running = False
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/ticker_manager.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/buy_market_order.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,30 +1,22 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.util as util
+import octobot_trading.enums as enums
+import octobot_trading.personal_data.orders.types.market.market_order as market_order
 
 
-cdef class TickerManager(util.Initializable):
-    cdef object logger
-
-    cdef public dict ticker
-    cdef public dict mini_ticker
-
-    cdef void reset_ticker(self)
-    cdef void reset_mini_ticker(self)
-
-    cpdef void ticker_update(self, dict ticker)
-    cpdef void mini_ticker_update(self, dict mini_ticker)
+class BuyMarketOrder(market_order.MarketOrder):
+    def __init__(self, trader, side=None):
+        super().__init__(trader, side=enums.TradeOrderSide.BUY)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchange_data/ticker/ticker_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchange_data/ticker/ticker_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -9,122 +9,176 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-from octobot_trading.exchanges cimport exchange_channels
-from octobot_trading.exchanges.exchange_channels cimport (
-    requires_refresh_trigger,
+from octobot_trading.exchanges import adapters
+from octobot_trading.exchanges.adapters import (
+    AbstractAdapter,
 )
-from octobot_trading.exchanges.exchanges cimport (
+from octobot_trading.exchanges import exchanges
+from octobot_trading.exchanges.exchanges import (
     ExchangeConfiguration,
     Exchanges,
 )
-
-from octobot_trading.exchanges.config.exchange_config_data cimport (
-    ExchangeConfig,
-)
-
-from octobot_trading.exchanges.traders cimport (
-    Trader,
-    TraderSimulator,
+from octobot_trading.exchanges import exchange_channels
+from octobot_trading.exchanges.exchange_channels import (
+    requires_refresh_trigger,
+    create_exchange_channels,
+    create_exchange_producers,
+    create_authenticated_producer_from_parent,
 )
 
-from octobot_trading.exchanges.abstract_exchange cimport (
+from octobot_trading.exchanges import abstract_exchange
+from octobot_trading.exchanges.abstract_exchange import (
     AbstractExchange,
 )
 
-from octobot_trading.exchanges.abstract_websocket_exchange cimport (
+from octobot_trading.exchanges import abstract_websocket_exchange
+from octobot_trading.exchanges.abstract_websocket_exchange import (
     AbstractWebsocketExchange,
 )
 
-from octobot_trading.exchanges.basic_exchange_wrapper cimport (
+from octobot_trading.exchanges import basic_exchange_wrapper
+from octobot_trading.exchanges.basic_exchange_wrapper import (
     BasicExchangeWrapper,
+    temporary_exchange_wrapper,
 )
 
-from octobot_trading.exchanges.exchange_manager cimport (
+from octobot_trading.exchanges import exchange_manager
+from octobot_trading.exchanges.exchange_manager import (
     ExchangeManager,
 )
-from octobot_trading.exchanges.util cimport (
-    ExchangeMarketStatusFixer,
-    is_ms_valid,
-    force_disable_web_socket,
-    check_web_socket_config,
-    search_websocket_class,
-)
-from octobot_trading.exchanges.types cimport (
-    WebSocketExchange,
-    RestExchange,
+
+from octobot_trading.exchanges import exchange_factory
+from octobot_trading.exchanges.exchange_factory import (
+    create_exchanges,
+    create_real_exchange,
+    initialize_real_exchange,
+    create_simulated_exchange,
+    init_simulated_exchange,
 )
-from octobot_trading.exchanges.util cimport (
+from octobot_trading.exchanges.util import (
     ExchangeMarketStatusFixer,
     is_ms_valid,
     get_rest_exchange_class,
     get_order_side,
-    force_disable_web_socket,
-    check_web_socket_config,
-    search_websocket_class,
+    log_time_sync_error,
+    get_partners_explanation_message,
+    get_enabled_exchanges,
+    is_compatible_account,
+    get_historical_ohlcv,
     get_exchange_type,
     get_default_exchange_type,
     get_supported_exchange_types,
+    update_raw_order_from_raw_trade,
+    is_missing_trading_fees,
+    apply_trades_fees,
     get_exchange_class_from_name,
+    force_disable_web_socket,
+    check_web_socket_config,
+    search_websocket_class,
+    supports_websocket,
 )
-
-from octobot_trading.exchanges cimport implementations
-from octobot_trading.exchanges.implementations cimport (
+from octobot_trading.exchanges import exchange_websocket_factory
+from octobot_trading.exchanges.exchange_websocket_factory import (
+    is_channel_managed_by_websocket,
+    is_channel_fully_managed_by_websocket,
+    is_websocket_feed_requiring_init,
+    search_and_create_websocket,
+)
+from octobot_trading.exchanges import config
+from octobot_trading.exchanges.config import (
+    ExchangeConfig,
+    BacktestingExchangeConfig,
+)
+from octobot_trading.exchanges import traders
+from octobot_trading.exchanges.traders import (
+    Trader,
+    TraderSimulator,
+)
+from octobot_trading.exchanges import types
+from octobot_trading.exchanges.types import (
+    WebSocketExchange,
+    RestExchange,
+)
+from octobot_trading.exchanges import implementations
+from octobot_trading.exchanges.implementations import (
     DefaultWebSocketExchange,
-    DefaultRestExchange,
     ExchangeSimulator,
+    DefaultRestExchange,
 )
-
-from octobot_trading.exchanges.exchange_builder cimport (
+from octobot_trading.exchanges import exchange_builder
+from octobot_trading.exchanges.exchange_builder import (
     ExchangeBuilder,
+    create_exchange_builder_instance,
 )
-
-from octobot_trading.exchanges cimport connectors
-from octobot_trading.exchanges.connectors cimport (
+from octobot_trading.exchanges import connectors
+from octobot_trading.exchanges.connectors import (
     CCXTWebsocketConnector,
     CCXTConnector,
+    CCXTAdapter,
     ExchangeSimulatorConnector,
-)
-
-from octobot_trading.exchanges cimport abstract_websocket_exchange
-from octobot_trading.exchanges.abstract_websocket_exchange cimport (
-    AbstractWebsocketExchange,
+    ExchangeSimulatorAdapter,
 )
 
 __all__ = [
-    "requires_refresh_trigger",
+    "AbstractAdapter",
     "ExchangeConfig",
+    "BacktestingExchangeConfig",
     "ExchangeManager",
     "ExchangeBuilder",
+    "create_exchange_builder_instance",
+    "create_exchanges",
+    "create_real_exchange",
+    "initialize_real_exchange",
+    "create_simulated_exchange",
+    "init_simulated_exchange",
     "ExchangeConfiguration",
     "Exchanges",
     "get_rest_exchange_class",
     "get_order_side",
+    "log_time_sync_error",
+    "get_partners_explanation_message",
+    "get_enabled_exchanges",
+    "is_compatible_account",
+    "get_historical_ohlcv",
+    "get_exchange_type",
+    "get_default_exchange_type",
+    "get_supported_exchange_types",
+    "update_raw_order_from_raw_trade",
+    "is_missing_trading_fees",
+    "apply_trades_fees",
+    "get_exchange_class_from_name",
     "AbstractExchange",
+    "is_channel_managed_by_websocket",
+    "is_channel_fully_managed_by_websocket",
+    "is_websocket_feed_requiring_init",
+    "search_and_create_websocket",
+    "requires_refresh_trigger",
+    "create_exchange_channels",
+    "create_exchange_producers",
+    "create_authenticated_producer_from_parent",
     "TraderSimulator",
     "Trader",
+    "DefaultWebSocketExchange",
+    "DefaultRestExchange",
     "ExchangeSimulator",
     "CCXTWebsocketConnector",
-    "CCXTConnector",
-    "ExchangeSimulatorConnector",
-    "AbstractWebsocketExchange",
-    "BasicExchangeWrapper",
-    "RestExchange",
     "WebSocketExchange",
+    "RestExchange",
     "ExchangeMarketStatusFixer",
     "is_ms_valid",
     "AbstractWebsocketExchange",
+    "BasicExchangeWrapper",
+    "temporary_exchange_wrapper",
     "force_disable_web_socket",
     "check_web_socket_config",
     "search_websocket_class",
-    "get_exchange_type",
-    "get_default_exchange_type",
-    "get_supported_exchange_types",
-    "get_exchange_class_from_name",
-    "DefaultWebSocketExchange",
-    "DefaultRestExchange",
-    "ExchangeSimulator",
+    "supports_websocket",
+    "CCXTConnector",
+    "CCXTAdapter",
+    "ExchangeSimulatorConnector",
+    "ExchangeSimulatorAdapter",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/abstract_exchange.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/abstract_exchange.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,61 +9,60 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import asyncio
 import typing
 import decimal
 import time
 
 import octobot_commons.constants
 import octobot_commons.enums as common_enums
 import octobot_commons.logging as logging
 import octobot_commons.timestamp_util as timestamp_util
-import octobot_commons.configuration as configuration
-
-import octobot_tentacles_manager.api as octobot_tentacles_manager_api
+import octobot_commons.tentacles_management as tentacles_management
 
 import octobot_trading.constants
 import octobot_trading.enums as enums
-import octobot_trading.util as util
 import octobot_trading.errors as errors
 
 
-class AbstractExchange(util.Initializable):
-    UI: configuration.UserInputFactory = configuration.UserInputFactory(
-        common_enums.UserInputTentacleTypes.EXCHANGE
-    )
+class AbstractExchange(tentacles_management.AbstractTentacle):
+    USER_INPUT_TENTACLE_TYPE = common_enums.UserInputTentacleTypes.EXCHANGE
     BUY_STR = enums.TradeOrderSide.BUY.value
     SELL_STR = enums.TradeOrderSide.SELL.value
 
     # order that should be self-managed by OctoBot
     # can be overridden locally to match exchange support
-    UNSUPPORTED_ORDERS = [enums.TraderOrderType.STOP_LOSS,
-                          enums.TraderOrderType.STOP_LOSS_LIMIT,
-                          enums.TraderOrderType.TAKE_PROFIT,
-                          enums.TraderOrderType.TAKE_PROFIT_LIMIT,
-                          enums.TraderOrderType.TRAILING_STOP,
-                          enums.TraderOrderType.TRAILING_STOP_LIMIT]
+    UNSUPPORTED_ORDERS = [
+        enums.TraderOrderType.STOP_LOSS,
+        enums.TraderOrderType.STOP_LOSS_LIMIT,
+        enums.TraderOrderType.TAKE_PROFIT,
+        enums.TraderOrderType.TAKE_PROFIT_LIMIT,
+        enums.TraderOrderType.TRAILING_STOP,
+        enums.TraderOrderType.TRAILING_STOP_LIMIT
+    ]
 
     # order that can be bundled together to create them all in one request
     # format: dict of bundled types by base order type
     # ex: SUPPORTED_BUNDLED_ORDERS[enums.TraderOrderType.BUY_MARKET] = \
     # [enums.TraderOrderType.STOP_LOSS, enums.TraderOrderType.TAKE_PROFIT]
     # can be overridden locally to match exchange support
     SUPPORTED_BUNDLED_ORDERS = {}
     ACCOUNTS = {}
 
     def __init__(self, config, exchange_manager):
         super().__init__()
         self.config = config
         self.exchange_manager = exchange_manager
         self.connector = None
+        self.is_initialized = False
 
         self.tentacle_config = {}
 
         # Initialized when initializing exchange connector
         self.symbols = set()
         self.time_frames = set()
 
@@ -74,15 +73,22 @@
         # exchange related constants
         self.allowed_time_lag = octobot_trading.constants.DEFAULT_EXCHANGE_TIME_LAG
         self.current_account = enums.AccountTypes.CASH
 
         self.is_unreachable = False
 
         if self.exchange_manager.tentacles_setup_config is not None:
-            self.load_user_inputs(self.exchange_manager.tentacles_setup_config, self.tentacle_config)
+            self.load_user_inputs_from_class(self.exchange_manager.tentacles_setup_config, self.tentacle_config)
+
+    async def initialize(self, force=False, **kwargs):
+        if not self.is_initialized or force:
+            await self.initialize_impl(**kwargs)
+            self.is_initialized = True
+            return True
+        return False
 
     async def initialize_impl(self):
         """
         Contains the exchange initialization code
         """
         raise NotImplementedError("initialize_impl not implemented")
 
@@ -269,28 +275,38 @@
         Get the user recent trades
         :param symbol: trades symbol
         :param since: the trade history starting timestamp
         :param limit: the history limit size
         :return: the user trades history list
         """
         raise NotImplementedError("get_my_recent_trades is not implemented")
+        
+    async def get_leverage_tiers(self, symbols: list = None, **kwargs: dict)-> dict:
+        """
+        :param symbols: the symbols or None
+        :return: the current leverage tiers by symbols
+        """
+        raise NotImplementedError("get_leverage_tiers is not implemented")
 
-    async def cancel_order(self, order_id: str, symbol: str = None, **kwargs: dict) -> enums.OrderStatus:
+    async def cancel_order(
+            self, order_id: str, symbol: str, order_type: enums.TraderOrderType, **kwargs: dict
+    ) -> enums.OrderStatus:
         """
         Cancel a order on the exchange
         :param order_id: the order id
         :param symbol: the order symbol
+        :param order_type: the type of the order
         :return: True if the order is successfully cancelled
         """
         raise NotImplementedError("cancel_order is not implemented")
 
     async def create_order(self, order_type: enums.TraderOrderType, symbol: str, quantity: decimal.Decimal,
                            price: decimal.Decimal = None, stop_price: decimal.Decimal = None,
                            side: enums.TradeOrderSide = None, current_price: decimal.Decimal = None,
-                           params: dict = None) \
+                           reduce_only: bool = False, params: dict = None) \
             -> typing.Optional[dict]:
         """
         Create a order on the exchange
         :param order_type: the order type
         :param symbol: the order symbol
         :param quantity: the order quantity
         :param price: the order price
@@ -320,18 +336,19 @@
         in one request
         """
         try:
             return bundled_order_type in self.SUPPORTED_BUNDLED_ORDERS[base_order.order_type]
         except KeyError:
             return False
 
-    def get_bundled_order_parameters(self, stop_loss_price=None, take_profit_price=None) -> dict:
+    def get_bundled_order_parameters(self, order, stop_loss_price=None, take_profit_price=None) -> dict:
         """
-        Returns True when this exchange supports orders created upon other orders fill (ex: a stop loss created at
-        the same time as a buy order)
+        Returns the updated params when this exchange supports orders created upon other orders fill
+        (ex: a stop loss created at the same time as a buy order)
+        :param order: the initial order
         :param stop_loss_price: the bundled order stop_loss price
         :param take_profit_price: the bundled order take_profit price
         :return: A dict with the necessary parameters to create the bundled order on exchange alongside the
         base order in one request
         """
         raise NotImplementedError("get_bundled_order_parameters is not implemented")
 
@@ -414,25 +431,29 @@
         """
         :return: the exchange sub account list if supported by the exchange
         """
         raise NotImplementedError("get_sub_account_list is not available on this exchange")
 
     async def retry_till_success(self, timeout, request_func, *args, **kwargs):
         t0 = time.time()
+        minimal_interval = 0.1
         attempt = 1
         while time.time() - t0 < timeout:
+            last_request_time = time.time()
             try:
                 result = await request_func(*args, **kwargs)
                 if attempt > 1:
                     self.logger.debug(f"Request retrier success for {request_func.__name__} after {attempt} attempts")
                 return result
             except errors.FailedRequest:
                 self.logger.debug(f"Request retrier failed for {request_func.__name__} (attempt {attempt})")
+                if time.time() - last_request_time < minimal_interval:
+                    await asyncio.sleep(minimal_interval)
                 attempt += 1
-        raise errors.FailedRequest(f"Failed to successfully run request {request_func.__name__} after {attempt} "
+        raise errors.FailedRequest(f"Failed to successfully run {request_func.__name__} request after {attempt} "
                                    f"attempts.")
 
     """
     Parsers
     """
 
     def parse_balance(self, balance):
@@ -512,21 +533,14 @@
     def parse_order_symbol(self, order):
         """
         :param order: the order dict
         :return: the order symbol
         """
         raise NotImplementedError("parse_order_symbol is not implemented")
 
-    def parse_status(self, status):
-        """
-        :param status: the raw status
-        :return: the OrderStatus instance related to the row status
-        """
-        raise NotImplementedError("parse_status is not implemented")
-
     def parse_side(self, side):
         """
         :param side: the raw side
         :return: the TradeOrderSide related to the side
         """
         raise NotImplementedError("parse_side is not implemented")
 
@@ -630,44 +644,7 @@
         order_desc = f"order_type: {order_type}, symbol: {symbol}, quantity: {str(quantity)}, price: {str(price)}," \
                      f" stop_price: {str(stop_price)}"
         self.logger.error(f"Failed to create order : {error.__class__.__name__} {error}: ({order_desc})")
 
     def handle_token_error(self, error):
         self.logger.error(f"Exchange configuration is invalid : please check your configuration ! "
                           f"({error.__class__.__name__}: {error})")
-
-    @classmethod
-    def load_user_inputs(cls, tentacles_setup_config, tentacle_config):
-        logger = logging.get_logger(cls.get_name())
-        inputs = {}
-        try:
-            tentacle_config.update(
-                octobot_tentacles_manager_api.get_tentacle_config(
-                    tentacles_setup_config, cls
-                )
-            )
-        except NotImplementedError:
-            # get_name not implemented, no tentacle config
-            return inputs
-        try:
-            with cls.UI.local_factory(cls, lambda: tentacle_config):
-                cls.init_user_inputs(inputs)
-        except Exception as e:
-            logger.exception(e, True, f"Error when initializing user inputs: {e}")
-        if tentacle_config:
-            logger.debug(f"Using config: {tentacle_config}")
-        return inputs
-
-    @classmethod
-    async def get_raw_config_and_user_inputs(
-            cls, _, tentacles_setup_config, __
-    ):
-        # use user inputs from init_user_inputs
-        tentacle_config = octobot_tentacles_manager_api.get_tentacle_config(tentacles_setup_config, cls)
-        user_inputs = cls.load_user_inputs(tentacles_setup_config, tentacle_config)
-        return tentacle_config, list(user_input.to_dict() for user_input in user_inputs.values())
-
-    @classmethod
-    def init_user_inputs(cls, inputs: dict) -> None:
-        """
-        Called at constructor, should define all the exchange's user inputs.
-        """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/abstract_websocket_exchange.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/abstract_websocket_exchange.py`

 * *Files 6% similar despite different names*

```diff
@@ -34,14 +34,19 @@
     INIT_REQUIRING_EXCHANGE_FEEDS = set()
 
     # Used to ignore a feed when at least one of the corresponding feed is supported
     IGNORED_FEED_PAIRS = {}
 
     SUPPORTS_LIVE_PAIR_ADDITION = False
 
+    TIME_FRAME_RELATED_FEEDS = [
+        octobot_trading.enums.WebsocketFeeds.CANDLE,
+        octobot_trading.enums.WebsocketFeeds.KLINE,
+    ]
+
     def __init__(self, config, exchange_manager):
         self.config = config
 
         self.exchange_manager = exchange_manager
         self.exchange = self.exchange_manager.exchange
         self.exchange_id = self.exchange_manager.id
 
@@ -58,23 +63,39 @@
         self.name = self.get_name()
         self.logger = logging.get_logger(f"WebSocket - {self.name}")
 
     def initialize(self, currencies=None, pairs=None, time_frames=None, channels=None):
         self.pairs = [self.get_exchange_pair(pair) for pair in pairs] if pairs else []
         # inner list required for cythonization
         self.channels = list(set([self.feed_to_exchange(channel) for channel in channels])) if channels else []
-        self.time_frames = time_frames if time_frames is not None else []
+        self.time_frames = [
+            time_frame
+            for time_frame in time_frames
+            if self.is_time_frame_supported(time_frame)
+        ] if time_frames is not None else []
         self.currencies = currencies if currencies else []
 
+    @classmethod
+    def update_exchange_feeds(cls, exchange_manager):
+        """
+        Called before exchange instantiation, should be used to patch cls.EXCHANGE_FEEDS if necessary
+        """
+
+    def is_time_frame_related_feed(self, feed):
+        return feed in self.TIME_FRAME_RELATED_FEEDS
+
+    def is_time_frame_supported(self, time_frame):
+        raise NotImplementedError("is_time_frame_supported is not implemented")
+
     def get_exchange_credentials(self):
         """
         Exchange credentials
         :return: key, secret, password
         """
-        return self.exchange_manager.get_exchange_credentials(self.logger, self.exchange_manager.exchange_name)
+        return self.exchange_manager.get_exchange_credentials(self.exchange_manager.exchange_name)
 
     async def push_to_channel(self, channel_name, *args, **kwargs):
         try:
             asyncio.run_coroutine_threadsafe(
                 exchange_channel.get_chan(channel_name, self.exchange_id).get_internal_producer().push(*args, **kwargs),
                 self.bot_mainloop)
         except Exception as e:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/adapters/__init__.py` & `OctoBot-Trading-2.4.0/tests/api/test_symbol_data.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,16 +10,11 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
+import pytest
 
-from octobot_trading.exchanges.adapters import abstract_adapter
-from octobot_trading.exchanges.adapters.abstract_adapter import (
-    AbstractAdapter,
-)
-
-__all__ = [
-    "AbstractAdapter",
-]
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/adapters/abstract_adapter.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/adapters/abstract_adapter.py`

 * *Files 10% similar despite different names*

```diff
@@ -36,24 +36,36 @@
 
 class AbstractAdapter:
     def __init__(self, connector):
         self.logger = logging.get_logger(self.__class__.__name__)
         self.connector = connector
 
     @_adapter
+    def adapt_orders(self, raw, **kwargs):
+        return [
+            self.adapt_order(element, **kwargs)
+            for element in raw
+        ]
+
+    @_adapter
     def adapt_order(self, raw, **kwargs):
         fixed = self.fix_order(raw, **kwargs)
         return self.parse_order(fixed, **kwargs)
 
     @_adapter
     def adapt_ohlcv(self, raw, **kwargs):
         fixed = self.fix_ohlcv(raw, **kwargs)
         return self.parse_ohlcv(fixed, **kwargs)
 
     @_adapter
+    def adapt_kline(self, raw, **kwargs):
+        fixed = self.fix_kline(raw, **kwargs)
+        return self.parse_kline(fixed, **kwargs)
+
+    @_adapter
     def adapt_ticker(self, raw, **kwargs):
         fixed = self.fix_ticker(raw, **kwargs)
         return self.parse_ticker(fixed, **kwargs)
 
     @_adapter
     def adapt_balance(self, raw, **kwargs):
         fixed = self.fix_balance(raw, **kwargs)
@@ -81,14 +93,24 @@
 
     @_adapter
     def adapt_funding_rate(self, raw, **kwargs):
         fixed = self.fix_funding_rate(raw, **kwargs)
         return self.parse_funding_rate(fixed, **kwargs)
 
     @_adapter
+    def adapt_leverage_tiers(self, raw, **kwargs):
+        fixed = self.fix_leverage_tiers(raw, **kwargs)
+        return self.parse_leverage_tiers(fixed, **kwargs) 
+
+    @_adapter
+    def adapt_leverage(self, raw, **kwargs):
+        fixed = self.fix_leverage(raw, **kwargs)
+        return self.parse_leverage(fixed, **kwargs)
+
+    @_adapter
     def adapt_funding_rate_history(self, raw, **kwargs):
         fixed = self.fix_funding_rate_history(raw, **kwargs)
         return self.parse_funding_rate_history(fixed, **kwargs)
 
     @_adapter
     def adapt_mark_price(self, raw, **kwargs):
         fixed = self.fix_mark_price(raw, **kwargs)
@@ -120,14 +142,21 @@
     def fix_ohlcv(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_ohlcv(self, fixed, **kwargs):
         raise NotImplementedError("parse_ohlcv is not implemented")
 
+    def fix_kline(self, raw, **kwargs):
+        # add generic logic if necessary
+        return raw
+
+    def parse_kline(self, fixed, **kwargs):
+        raise NotImplementedError("parse_kline is not implemented")
+
     def fix_ticker(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_ticker(self, fixed, **kwargs):
         raise NotImplementedError("parse_ticker is not implemented")
 
@@ -169,21 +198,35 @@
     def fix_funding_rate(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_funding_rate(self, fixed, **kwargs):
         raise NotImplementedError("parse_funding_rate is not implemented")
 
+    def fix_leverage(self, raw, **kwargs):
+        # add generic logic if necessary
+        return raw
+
+    def parse_leverage(self, fixed, **kwargs):
+        raise NotImplementedError("parse_leverage is not implemented")
+
     def fix_funding_rate_history(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_funding_rate_history(self, fixed, **kwargs):
         raise NotImplementedError("parse_funding_rate_history is not implemented")
 
+    def fix_leverage_tiers(self, raw, **kwargs):
+        # add generic logic if necessary
+        return raw
+
+    def parse_leverage_tiers(self, fixed, **kwargs):
+        raise NotImplementedError("parse_leverage_tiers is not implemented")
+
     def fix_mark_price(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_mark_price(self, fixed, **kwargs):
         raise NotImplementedError("parse_mark_price is not implemented")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/basic_exchange_wrapper.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/dsl/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -11,15 +10,18 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
+from octobot_trading.modes.script_keywords.dsl.quantity import (
+    parse_quantity,
+)
+from octobot_trading.modes.script_keywords.dsl.values import (
+    QuantityType,
+)
 
-cdef class BasicExchangeWrapper:
-    cdef public str exchange_class_string
-    cdef public object exchange_lib
-
-    cdef public object exchange
-
-    cdef object _exchange_factory(self) # return object to be able to propagate exceptions
+__all__ = [
+    "parse_quantity",
+    "QuantityType",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/basic_exchange_wrapper.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/basic_exchange_wrapper.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/config/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -11,20 +11,20 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
 
-from octobot_trading.exchanges.config cimport exchange_config_data
-from octobot_trading.exchanges.config.exchange_config_data cimport (
+from octobot_trading.exchanges.config import exchange_config_data
+from octobot_trading.exchanges.config.exchange_config_data import (
     ExchangeConfig,
 )
-from octobot_trading.exchanges.config cimport backtesting_exchange_config
-from octobot_trading.exchanges.config.backtesting_exchange_config cimport (
+from octobot_trading.exchanges.config import backtesting_exchange_config
+from octobot_trading.exchanges.config.backtesting_exchange_config import (
     BacktestingExchangeConfig,
 )
 
 __all__ = [
     "ExchangeConfig",
     "BacktestingExchangeConfig",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/backtesting_exchange_config.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,20 +1,28 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import octobot_trading.personal_data.orders.states.pending_creation_order_state as pending_creation_order_state
 
-cdef class BacktestingExchangeConfig:
-    cdef public object future_contract_type
-    cdef public object funding_rate
+
+class PendingCreationChainedOrderState(pending_creation_order_state.PendingCreationOrderState):
+    def is_created(self) -> bool:
+        """
+        :return: True if the Order is created
+        """
+        # order is to be triggered as chained order: not created
+        return False
+
+    async def update(self) -> None:
+        pass
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/backtesting_exchange_config.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/config/backtesting_exchange_config.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/config/exchange_config_data.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/config/exchange_config_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -41,17 +41,14 @@
         self.traded_cryptocurrencies = {}
 
         # list of exchange supported enabled pairs from self.config
         self.traded_symbol_pairs = []
         # Same as traded_symbol_pairs but with parsed symbols
         self.traded_symbols = []
 
-        # list of exchange supported pairs from self.config (used to initialize evaluators and more)
-        self.all_config_symbol_pairs = []
-
         # list of exchange supported pairs on which we want to collect data through updaters or websocket
         self.watched_pairs = []
 
         # list of required time frames from configuration that are available
         self.available_required_time_frames = []
 
         # list of exchange supported time frames that are also required (config + real time)
@@ -64,14 +61,21 @@
         self.required_historical_candles_count = constants.DEFAULT_IGNORED_VALUE
 
         self.backtesting_exchange_config = None
 
     async def initialize_impl(self):
         pass
 
+    def get_all_traded_currencies(self):
+        currencies = []
+        for symbol in self.traded_symbols:
+            currencies.append(symbol.base)
+            currencies.append(symbol.quote)
+        return list(set(currencies))
+
     def set_config_traded_pairs(self):  # TODO
         self._set_config_traded_pairs()
 
     def set_config_time_frame(self):  # TODO
         self._set_config_time_frame()
 
     def init_backtesting_exchange_config(self):
@@ -161,23 +165,22 @@
                                                                    traded_symbol_pairs_set,
                                                                    existing_pairs)
         self.traded_symbol_pairs = list(traded_symbol_pairs_set)
         self.traded_symbols = [
             octobot_commons.symbols.parse_symbol(symbol)
             for symbol in traded_symbol_pairs_set
         ]
-        self.all_config_symbol_pairs = list(existing_pairs)
 
         # only add self.traded_symbol_pairs to watched pairs as not every existing_pairs are being collected
         self.watched_pairs = copy.deepcopy(self.traded_symbol_pairs)
 
     def _set_config_traded_pair(self, cryptocurrency, traded_symbol_pairs_set, existing_pairs):
         try:
             is_enabled = util.is_currency_enabled(self.config, cryptocurrency, True)
-            if self.config[constants.CONFIG_CRYPTO_CURRENCIES][cryptocurrency][constants.CONFIG_CRYPTO_PAIRS]:
+            if self.config[constants.CONFIG_CRYPTO_CURRENCIES][cryptocurrency].get(constants.CONFIG_CRYPTO_PAIRS, []):
                 if self.config[constants.CONFIG_CRYPTO_CURRENCIES][cryptocurrency][constants.CONFIG_CRYPTO_PAIRS] != \
                         constants.CONFIG_SYMBOLS_WILDCARD:
                     self._populate_non_wildcard_pairs(cryptocurrency, existing_pairs, is_enabled)
                 else:
                     self._populate_wildcard_pairs(cryptocurrency, existing_pairs, is_enabled)
                 # add to global traded pairs
                 if is_enabled:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -10,20 +10,26 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchanges.connectors.ccxt cimport ccxt_connector
-from octobot_trading.exchanges.connectors.ccxt.ccxt_connector cimport (
+from octobot_trading.exchanges.connectors.ccxt import ccxt_adapter
+from octobot_trading.exchanges.connectors.ccxt.ccxt_adapter import (
+    CCXTAdapter,
+)
+from octobot_trading.exchanges.connectors.ccxt import ccxt_connector
+from octobot_trading.exchanges.connectors.ccxt.ccxt_connector import (
     CCXTConnector,
 )
-from octobot_trading.exchanges.connectors.ccxt cimport ccxt_websocket_connector
-from octobot_trading.exchanges.connectors.ccxt.ccxt_websocket_connector cimport (
+
+from octobot_trading.exchanges.connectors.ccxt import ccxt_websocket_connector
+from octobot_trading.exchanges.connectors.ccxt.ccxt_websocket_connector import (
     CCXTWebsocketConnector,
 )
 
 __all__ = [
+    "CCXTAdapter",
     "CCXTConnector",
     "CCXTWebsocketConnector",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py`

 * *Files 25% similar despite different names*

```diff
@@ -11,32 +11,38 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import logging
 import ccxt
+import ccxt.pro as ccxt_pro
 
+import octobot_commons.time_frame_manager as time_frame_manager
 import octobot_trading.constants as constants
+import octobot_trading.exchanges.connectors.ccxt.enums as ccxt_enums
+import octobot_trading.exchanges.util.exchange_util as exchange_util
 
 
 def create_client(exchange_class, exchange_name, exchange_manager, logger, 
                   options, headers, additional_config, 
                   should_authenticate, unauthenticated_exchange_fallback=None):
     """
     Exchange instance creation
     :return: the created ccxt (pro, async or sync) client
     """
     is_authenticated = False
     if not exchange_manager.exchange_only:
         # avoid logging version on temporary exchange_only exchanges
-        logger.info(f"Creating {exchange_class.__name__} exchange with ccxt in version {ccxt.__version__}")
+        exchange_type = exchange_util.get_exchange_type(exchange_manager)
+        logger.info(f"Creating {exchange_class.__name__} {exchange_type.name} "
+                    f"exchange with ccxt in version {ccxt.__version__}")
     if exchange_manager.ignore_config or exchange_manager.check_config(exchange_name):
         try:
-            key, secret, password = exchange_manager.get_exchange_credentials(logger, exchange_name)
+            key, secret, password = exchange_manager.get_exchange_credentials(exchange_name)
             if not (key and secret) and not exchange_manager.is_simulated:
                 logger.warning(f"No exchange API key set for {exchange_manager.exchange_name}. "
                                f"Enter your account details to enable real trading on this exchange.")
             if should_authenticate:
                 client = exchange_class(_get_client_config(options, headers, additional_config,
                                                            key, secret, password))
                 is_authenticated = True
@@ -54,22 +60,52 @@
         client = get_unauthenticated_exchange(exchange_class, options, headers, additional_config)
         logger.error("configuration issue: missing login information !")
     client.logger.setLevel(logging.INFO)
     _use_http_proxy_if_necessary(client)
     return client, is_authenticated
 
 
+async def close_client(client):
+    await client.close()
+    client.markets = {}
+    client.markets_by_id = {}
+    client.ids = []
+    client.last_json_response = {}
+    client.last_http_response = ""
+    client.last_response_headers = {}
+    client.markets_loading = None
+    client.currencies = {}
+    client.baseCurrencies = {}
+    client.quoteCurrencies = {}
+    client.currencies_by_id = {}
+    client.codes = []
+    client.symbols = {}
+    client.accounts = []
+    client.accounts_by_id = {}
+    client.ohlcvs = {}
+    client.trades = {}
+    client.orderbooks = {}
+
+
 def get_unauthenticated_exchange(exchange_class, options, headers, additional_config):
     client = exchange_class(_get_client_config(options, headers, additional_config))
     _use_http_proxy_if_necessary(client)
     return client
 
 
-def set_sandbox_mode(client, is_sandboxed):
-    client.setSandboxMode(is_sandboxed)
+def set_sandbox_mode(exchange_connector, is_sandboxed):
+    try:
+        exchange_connector.client.setSandboxMode(is_sandboxed)
+    except ccxt.NotSupported as e:
+        default_type = exchange_connector.client.options.get('defaultType', None)
+        additional_info = f" in type {default_type}" if default_type else ""
+        exchange_connector.logger.warning(f"{exchange_connector.name} does not support sandboxing {additional_info}: {e}")
+        # raise exception to stop this exchange and prevent dealing with a real funds exchange
+        raise e
+    return None
 
 
 def get_ccxt_client_login_options(exchange_manager):
     """
     :return: ccxt client login option dict, can be overwritten to custom exchange login
     """
     if exchange_manager.is_future:
@@ -85,14 +121,26 @@
     except (AttributeError, TypeError):
         # ccxt exchange load_markets failed
         return set()
 
 
 def get_time_frames(client):
     try:
+        if isinstance(client, ccxt_pro.Exchange):
+            # ccxt pro exchanges might have different timeframes in options
+            options_time_frames = client.safe_value(client.options, 'timeframes')
+            if options_time_frames:
+                values = set([
+                    time_frame
+                    for time_frame in options_time_frames
+                    if time_frame_manager.is_time_frame(time_frame)
+                ])
+                if values:
+                    return values
+        # use normal client timeframes (values of rest exchange)
         return set(client.timeframes)
     except (AttributeError, TypeError):
         # ccxt exchange describe() is invalid
         return set()
 
 
 def get_exchange_pair(client, pair) -> str:
@@ -109,14 +157,18 @@
         try:
             return client.market(pair)["base"]
         except KeyError:
             pass
     raise ValueError(f'{pair} is not supported')
 
 
+def get_contract_size(client, pair) -> float:
+    return client.markets[pair][ccxt_enums.ExchangeConstantsMarketStatusCCXTColumns.CONTRACT_SIZE.value]
+
+
 def add_headers(client, headers_dict):
     """
     Add new headers to ccxt client
     :param headers_dict: the additional header keys and values as dict
     """
     for header_key, header_value in headers_dict.items():
         client.headers[header_key] = header_value
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,70 +12,85 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import contextlib
 import decimal
-
 import ccxt.async_support as ccxt
 import typing
+import inspect
 
 import octobot_commons.enums
 import octobot_commons.symbols as commons_symbols
 
 import octobot_trading
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 import octobot_trading.errors
 import octobot_trading.exchanges as exchanges
 import octobot_trading.exchanges.abstract_exchange as abstract_exchange
 import octobot_trading.exchanges.connectors.ccxt.ccxt_adapter as ccxt_adapter
 import octobot_trading.exchanges.connectors.ccxt.ccxt_client_util as ccxt_client_util
+import octobot_trading.exchanges.connectors.ccxt.enums as ccxt_enums
+import octobot_trading.exchanges.connectors.ccxt.constants as ccxt_constants
 import octobot_trading.personal_data as personal_data
 from octobot_trading.enums import ExchangeConstantsOrderColumns as ecoc
 
 
 class CCXTConnector(abstract_exchange.AbstractExchange):
     """
     CCXT library connector. Everything ccxt related should be in this connector.
     When possible, each call is supposed to create only one request to the exchange.
     Uses self.adapter to parse (and fix if necessary) ccxt raw data.
 
     Always returns adapted data. Always throws octobot_trading errors
     Never returns row ccxt data or throw ccxt errors
     """
-    CCXT_ISOLATED = "ISOLATED"
-    CCXT_CROSSED = "CROSSED"
 
-    def __init__(self, config, exchange_manager, adapter_class=None, additional_config=None):
+    def __init__(
+            self, config, exchange_manager, adapter_class=None, additional_config=None, rest_name=None, force_auth=False
+    ):
         super().__init__(config, exchange_manager)
         self.client = None
         self.exchange_type = None
         self.adapter = self.get_adapter_class(adapter_class)(self)
         self.all_currencies_price_ticker = None
         self.is_authenticated = False
+        self.rest_name = rest_name or self.exchange_manager.exchange_class_string
+        self.force_authentication = force_auth
+
+        # used to save exchange local elements in subclasses
+        self.saved_data = {}
 
         self.additional_config = additional_config
         self.headers = {}
         self.options = {}
         # add default options
         self.add_options(
             ccxt_client_util.get_ccxt_client_login_options(self.exchange_manager)
         )
+        # add specific options
+        if self.additional_config:
+            specific_options = self.additional_config.pop(ccxt_constants.CCXT_OPTIONS, None)
+            if specific_options:
+                self.add_options(specific_options)
 
         self._create_exchange_type()
         self._create_client()
 
     async def initialize_impl(self):
         try:
             if self.exchange_manager.exchange.is_supporting_sandbox():
-                self.set_sandbox_mode(self.exchange_manager.is_sandboxed)
-
-            if self._should_authenticate() and not self.exchange_manager.exchange_only:
+                ccxt_client_util.set_sandbox_mode(
+                    self, self.exchange_manager.is_sandboxed)
+                
+            if self.force_authentication or (
+                self._should_authenticate() and not self.exchange_manager.exchange_only
+            ):
                 await self._ensure_auth()
 
             if self.exchange_manager.is_loading_markets:
                 with self.error_describer():
                     await self.load_symbol_markets()
 
             # initialize symbols and timeframes
@@ -87,15 +102,15 @@
         except ccxt.AuthenticationError:
             raise ccxt.AuthenticationError
 
     def get_adapter_class(self, adapter_class):
         return adapter_class or ccxt_adapter.CCXTAdapter
 
     @classmethod
-    def load_user_inputs(cls, tentacles_setup_config, tentacle_config):
+    def load_user_inputs_from_class(cls, tentacles_setup_config, tentacle_config):
         # no user input in connector
         pass
 
     async def load_symbol_markets(self, reload=False):
         await self.client.load_markets(reload=reload)
 
     def get_client_symbols(self):
@@ -105,18 +120,18 @@
         return ccxt_client_util.get_time_frames(self.client)
 
     @classmethod
     def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
         return isinstance(exchange_candidate_name, str)
 
     def _create_exchange_type(self):
-        if self.is_supporting_exchange(self.exchange_manager.exchange_class_string):
-            self.exchange_type = getattr(ccxt, self.exchange_manager.exchange_class_string)
+        if self.is_supporting_exchange(self.rest_name):
+            self.exchange_type = getattr(ccxt, self.rest_name)
         else:
-            self.exchange_type = self.exchange_manager.exchange_class_string
+            self.exchange_type = self.rest_name
 
     def add_headers(self, headers_dict):
         """
         Add new headers to ccxt client
         :param headers_dict: the additional header keys and values as dict
         """
         self.headers.update(headers_dict)
@@ -146,16 +161,18 @@
         self.client, self.is_authenticated = ccxt_client_util.create_client(
             self.exchange_type, self.name, self.exchange_manager, self.logger,
             self.options, self.headers, self.additional_config,
             self._should_authenticate(), self.unauthenticated_exchange_fallback
         )
 
     def _should_authenticate(self):
-        return not (self.exchange_manager.is_simulated or
-                    self.exchange_manager.is_backtesting)
+        return self.force_authentication or not (
+            self.exchange_manager.is_simulated or
+            self.exchange_manager.is_backtesting
+        )
 
     def unauthenticated_exchange_fallback(self, err):
         self.handle_token_error(err)
         return ccxt_client_util.get_unauthenticated_exchange(
             self.exchange_type,
             self.options, self.headers, self.additional_config
         )
@@ -179,18 +196,14 @@
         if not kwargs:
             kwargs = {}
         try:
             with self.error_describer():
                 return self.adapter.adapt_balance(
                     await self.client.fetch_balance(params=kwargs)
                 )
-
-        except ccxt.InvalidNonce as err:
-            exchanges.log_time_sync_error(self.logger, self.name, err, "real trader portfolio")
-            raise err
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
 
     async def get_symbol_prices(self,
                                 symbol: str,
                                 time_frame: octobot_commons.enums.TimeFrames,
                                 limit: int = None,
@@ -200,24 +213,27 @@
             with self.error_describer():
                 return self.adapter.adapt_ohlcv(
                     await self.client.fetch_ohlcv(symbol, time_frame.value, limit=limit, since=since, params=kwargs)
                 )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
-            raise octobot_trading.errors.FailedRequest(f"Failed to get_symbol_prices: {e.__class__.__name__} on {e}")
+            raise octobot_trading.errors.FailedRequest(f"Failed to get_symbol_prices: {e.__class__.__name__} on {e}") from e
 
     async def get_kline_price(self,
                               symbol: str,
                               time_frame: octobot_commons.enums.TimeFrames,
                               **kwargs: dict) -> typing.Optional[list]:
         try:
-            # default implementation
-            # already adapted in get_symbol_prices
-            return await self.get_symbol_prices(symbol, time_frame, limit=1, **kwargs)
+            with self.error_describer():
+                limit = kwargs.pop("limit", 1)
+                since = kwargs.pop("since", None)
+                return self.adapter.adapt_kline(
+                    await self.client.fetch_ohlcv(symbol, time_frame.value, limit=limit, since=since, params=kwargs)
+                )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
             raise octobot_trading.errors.FailedRequest(f"Failed to get_kline_price {e}")
 
     # return up to ten bidasks on each side of the order book stack
     async def get_order_book(self, symbol: str, limit: int = 5, **kwargs: dict) -> typing.Optional[dict]:
@@ -269,100 +285,160 @@
             raise octobot_trading.errors.FailedRequest(f"Failed to get_all_currencies_price_ticker {e}")
 
     # ORDERS
     async def get_order(self, order_id: str, symbol: str = None, **kwargs: dict) -> dict:
         if self.client.has['fetchOrder']:
             try:
                 with self.error_describer():
-                    params = kwargs.pop("params", {})
                     return self.adapter.adapt_order(
-                        await self.client.fetch_order(order_id, symbol, params=params, **kwargs)
+                        await self.client.fetch_order(order_id, symbol, params=kwargs),
+                        symbol=symbol
                     )
             except ccxt.OrderNotFound:
                 # some exchanges are throwing this error when an order is cancelled (ex: coinbase pro)
                 pass
             except ccxt.NotSupported as e:
                 # some exchanges are throwing this error when an order is cancelled (ex: coinbase pro)
                 raise octobot_trading.errors.NotSupported from e
+            except ccxt.ExchangeError as e:
+                # something went wrong and ccxt did not expect it
+                raise octobot_trading.errors.FailedRequest from e
         else:
             # When fetch_order is not supported, uses get_open_orders and extract order id
             open_orders = await self.get_open_orders(symbol=symbol)
             for order in open_orders:
                 if order.get(ecoc.ID.value, None) == order_id:
                     return order
         return None  # OrderNotFound
 
     async def get_all_orders(self, symbol: str = None, since: int = None,
                              limit: int = None, **kwargs: dict) -> list:
         if self.client.has['fetchOrders']:
             with self.error_describer():
-                return [
-                    self.adapter.adapt_order(order)
-                    for order in await self.client.fetch_orders(symbol=symbol, since=since, limit=limit, params=kwargs)
-                ]
+                return self.adapter.adapt_orders(
+                    await self.client.fetch_orders(symbol=symbol, since=since, limit=limit, params=kwargs),
+                    symbol=symbol
+                )
         else:
             raise octobot_trading.errors.NotSupported("This exchange doesn't support fetchOrders")
 
     async def get_open_orders(self, symbol: str = None, since: int = None,
                               limit: int = None, **kwargs: dict) -> list:
         if self.client.has['fetchOpenOrders']:
             with self.error_describer():
-                return [
-                    self.adapter.adapt_order(order)
-                    for order in await self.client.fetch_open_orders(symbol=symbol, since=since,
-                                                                     limit=limit, params=kwargs)
-                ]
+                return self.adapter.adapt_orders(
+                    await self.client.fetch_open_orders(symbol=symbol, since=since, limit=limit, params=kwargs),
+                    symbol=symbol
+                )
         else:
             raise octobot_trading.errors.NotSupported("This exchange doesn't support fetchOpenOrders")
 
     async def get_closed_orders(self, symbol: str = None, since: int = None,
                                 limit: int = None, **kwargs: dict) -> list:
-        if self.client.has['fetchClosedOrders']:
+        try:
             with self.error_describer():
-                return [
-                    self.adapter.adapt_order(order)
-                    for order in await self.client.fetch_closed_orders(symbol=symbol, since=since,
-                                                                       limit=limit, params=kwargs)
-                ]
-        else:
-            raise octobot_trading.errors.NotSupported("This exchange doesn't support fetchClosedOrders")
+                return self.adapter.adapt_orders(
+                    await self.client.fetch_closed_orders(symbol=symbol, since=since, limit=limit, params=kwargs),
+                    symbol=symbol
+                )
+        except ccxt.NotSupported as e:
+            # fetch_closed_orders is not supported
+            raise octobot_trading.errors.NotSupported from e
 
     async def get_my_recent_trades(self, symbol: str = None, since: int = None,
                                    limit: int = None, **kwargs: dict) -> list:
         if self.client.has['fetchMyTrades'] or self.client.has['fetchTrades']:
             with self.error_describer():
                 method = self.client.fetch_my_trades if self.client.has['fetchMyTrades'] else self.client.fetch_trades
-                return self.adapter.adapt_trades(await method(symbol=symbol, since=since, limit=limit, params=kwargs))
+                trades = self.adapter.adapt_trades(await method(symbol=symbol, since=since, limit=limit, params=kwargs))
+                if trades or not self.exchange_manager.exchange.ALLOW_TRADES_FROM_CLOSED_ORDERS:
+                    return trades
+                # on some exchanges, recent trades are only fetching very recent trade. also try closed orders
+                return await self.exchange_manager.exchange.get_closed_orders(
+                    symbol=symbol,
+                    since=since,
+                    limit=limit,
+                    **kwargs
+                )
         else:
             raise octobot_trading.errors.NotSupported("This exchange doesn't support fetchMyTrades nor fetchTrades")
 
     async def create_market_buy_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
-            await self.client.create_market_buy_order(symbol, quantity, params=params)
+            # use create_order instead of create_market_buy_order to pass the price argument
+            await self.client.create_order(
+                symbol, enums.TradeOrderType.MARKET.value, enums.TradeOrderSide.BUY.value, quantity,
+                price=price, params=params
+            ),
+            symbol=symbol, quantity=quantity
         )
 
     async def create_limit_buy_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
-            await self.client.create_limit_buy_order(symbol, quantity, price, params=params)
+            await self.client.create_limit_buy_order(symbol, quantity, price, params=params),
+            symbol=symbol, quantity=quantity
         )
 
     async def create_market_sell_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
-            await self.client.create_market_sell_order(symbol, quantity, params=params)
+            # use create_order instead of create_market_sell_order to pass the price argument
+            await self.client.create_order(
+                symbol, enums.TradeOrderType.MARKET.value, enums.TradeOrderSide.SELL.value, quantity,
+                price=price, params=params
+            ),
+            symbol=symbol, quantity=quantity
         )
 
     async def create_limit_sell_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
-            await self.client.create_limit_sell_order(symbol, quantity, price, params=params)
+            await self.client.create_limit_sell_order(symbol, quantity, price, params=params),
+            symbol=symbol, quantity=quantity
         )
 
     async def create_market_stop_loss_order(self, symbol, quantity, price, side, current_price, params=None) -> dict:
+        if self.client.has.get("createStopMarketOrder"):
+            try:
+                return self.adapter.adapt_order(
+                    await self.client.createStopMarketOrder(
+                        symbol,
+                        side=side,
+                        amount=quantity,
+                        stopPrice=price,
+                        params=params,
+                    )
+                )
+            except ccxt.OrderImmediatelyFillable:
+                # make sure stop always stops
+                created_order = await self.exchange_manager.exchange.create_order(
+                    order_type=(enums.TraderOrderType.BUY_MARKET
+                                if side == enums.TradeOrderSide.BUY.value
+                                else enums.TraderOrderType.SELL_MARKET),
+                    symbol=symbol,
+                    quantity=decimal.Decimal(str(quantity)),
+                    price=decimal.Decimal(str(price)),
+                    current_price=decimal.Decimal(str(current_price))
+                )
+                created_order[enums.ExchangeConstantsOrderColumns.TYPE.value] = (
+                    enums.TraderOrderType.STOP_LOSS.value
+                    )
+                return created_order
         raise NotImplementedError("create_market_stop_loss_order is not implemented")
 
-    async def create_limit_stop_loss_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
+    async def create_limit_stop_loss_order(self, symbol, quantity, price, stop_price, side, params=None) -> dict:
+        if self.client.has.get("createStopLimitOrder"):
+            return self.adapter.adapt_order(
+                await self.client.create_stop_limit_order(
+                    symbol,
+                    side=side,
+                    amount=quantity,
+                    price=price,
+                    stopPrice=stop_price,
+                    params=params,
+                )
+            )
         raise NotImplementedError("create_limit_stop_loss_order is not implemented")
 
     async def create_market_take_profit_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("create_market_take_profit_order is not implemented")
 
     async def create_limit_take_profit_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("create_limit_take_profit_order is not implemented")
@@ -379,25 +455,28 @@
         ccxt_order_type = self.get_ccxt_order_type(order_type)
         price_to_use = price
         if ccxt_order_type == enums.TradeOrderType.MARKET.value:
             # can't set price in market orders
             price_to_use = None
         # do not use keyword arguments here as default ccxt edit order is passing *args (and not **kwargs)
         return self.adapter.adapt_order(
-            await self.client.edit_order(order_id, symbol, ccxt_order_type, side, quantity, price_to_use, params)
+            await self.client.edit_order(order_id, symbol, ccxt_order_type, side, quantity, price_to_use, params),
+            symbol=symbol
         )
 
-    async def cancel_order(self, order_id: str, symbol: str = None, **kwargs: dict) -> enums.OrderStatus:
+    async def cancel_order(
+            self, order_id: str, symbol: str, order_type: enums.TraderOrderType, **kwargs: dict
+    ) -> enums.OrderStatus:
         try:
             with self.error_describer():
                 await self.client.cancel_order(order_id, symbol=symbol, params=kwargs)
                 # no exception, cancel worked
             try:
                 # make sure order is canceled
-                cancelled_order = await self.get_order(
+                cancelled_order = await self.exchange_manager.exchange.get_order(
                     order_id, symbol=symbol
                 )
                 if cancelled_order is None or personal_data.parse_is_cancelled(cancelled_order):
                     return enums.OrderStatus.CANCELED
                 elif personal_data.parse_is_open(cancelled_order):
                     return enums.OrderStatus.PENDING_CANCEL
                 # cancel command worked but order is still existing and is not open or canceled. unhandled case
@@ -406,62 +485,88 @@
                                   f"Considered as {enums.OrderStatus.PENDING_CANCEL.value}")
                 return enums.OrderStatus.PENDING_CANCEL
             except ccxt.OrderNotFound:
                 # Order is not found: it has successfully been cancelled (some exchanges don't allow to
                 # get a cancelled order).
                 return enums.OrderStatus.CANCELED
         except ccxt.OrderNotFound as e:
-            self.logger.error(f"Trying to cancel order with id {order_id} but order was not found")
+            self.logger.debug(f"Trying to cancel order with id {order_id} but order was not found")
             raise octobot_trading.errors.OrderCancelError from e
         except (ccxt.NotSupported, octobot_trading.errors.NotSupported) as e:
             raise octobot_trading.errors.NotSupported from e
         except Exception as e:
             self.logger.exception(e, True, f"Unexpected error when cancelling order with id: "
                                            f"{order_id} failed to cancel | {e} ({e.__class__.__name__})")
             raise e
 
     async def get_positions(self, symbols=None, **kwargs: dict) -> list:
-        return [
-            self.adapter.adapt_position(position)
-            for position in await self.client.fetch_positions(symbols=symbols, params=kwargs)
-        ]
+        try:
+            return [
+                self.adapter.adapt_position(position)
+                for position in await self.client.fetch_positions(symbols=symbols, params=kwargs)
+            ]
+        except ccxt.NotSupported as err:
+            raise NotImplementedError from err
 
     async def get_position(self, symbol: str, **kwargs: dict) -> dict:
+        try:
+            return self.adapter.adapt_position(
+                await self.client.fetch_position(symbol=symbol, params=kwargs)
+            )
+        except ccxt.NotSupported as err:
+            raise NotImplementedError from err
+
+    async def get_mocked_empty_position(self, symbol: str, **kwargs: dict) -> dict:
         return self.adapter.adapt_position(
-            await self.client.fetch_position(symbol=symbol, params=kwargs)
+            self.client.parse_position({}, market=self.client.market(symbol)),
+            force_empty=True
         )
 
     async def get_funding_rate(self, symbol: str, **kwargs: dict) -> dict:
         return self.adapter.adapt_funding_rate(
             await self.client.fetch_funding_rate(symbol=symbol, params=kwargs)
         )
 
     async def get_funding_rate_history(self, symbol: str, limit: int = 1, **kwargs: dict) -> list:
         return self.adapter.adapt_funding_rate(
             await self.client.fetch_funding_rate_history(symbol=symbol, limit=limit, params=kwargs)
         )
 
-    async def set_symbol_leverage(self, symbol: str, leverage: int, **kwargs: dict):
+    async def get_leverage_tiers(self, symbols: list = None, **kwargs: dict) -> dict:
+        if self.client.has.get("fetchLeverageTiers"):
+            return self.adapter.adapt_leverage_tiers(
+                await self.client.fetch_leverage_tiers(symbols=symbols, params=kwargs)
+            )
+        raise NotImplementedError("get_leverage_tiers is not supported")
+
+    def get_contract_size(self, symbol: str):
+        return decimal.Decimal(str(ccxt_client_util.get_contract_size(self.client, symbol)))
+
+    async def get_symbol_leverage(self, symbol: str, **kwargs: dict):
+        return self.adapter.adapt_leverage(
+            await self.client.fetch_leverage(symbol=symbol, params=kwargs)
+        )
+
+    async def set_symbol_leverage(self, symbol: str, leverage: float, **kwargs: dict):
         return await self.client.set_leverage(leverage=int(leverage), symbol=symbol, params=kwargs)
 
-    async def set_symbol_margin_type(self, symbol: str, isolated: bool):
-        return await self.client.set_margin_mode(symbol=symbol,
-                                                 marginType=self.CCXT_ISOLATED if isolated else self.CCXT_CROSSED)
+    async def set_symbol_margin_type(self, symbol: str, isolated: bool, **kwargs: dict):
+        return await self.client.set_margin_mode(
+            ccxt_enums.ExchangeMarginTypes.ISOLATED.value if isolated else ccxt_enums.ExchangeMarginTypes.CROSS.value,
+            symbol=symbol,
+            params=kwargs,
+        )
 
     async def set_symbol_position_mode(self, symbol: str, one_way: bool):
         return await self.client.set_position_mode(self, hedged=not one_way, symbol=symbol)
 
     async def set_symbol_partial_take_profit_stop_loss(self, symbol: str, inverse: bool,
                                                        tp_sl_mode: enums.TakeProfitStopLossMode):
         raise NotImplementedError("set_symbol_partial_take_profit_stop_loss is not implemented")
 
-    def get_bundled_order_parameters(self, stop_loss_price=None, take_profit_price=None) -> dict:
-        return self.connector.get_bundled_order_parameters(stop_loss_price=stop_loss_price,
-                                                           take_profit_price=take_profit_price)
-
     def get_ccxt_order_type(self, order_type: enums.TraderOrderType):
         if order_type in (enums.TraderOrderType.BUY_LIMIT, enums.TraderOrderType.SELL_LIMIT,
                           enums.TraderOrderType.STOP_LOSS_LIMIT, enums.TraderOrderType.TAKE_PROFIT_LIMIT,
                           enums.TraderOrderType.TRAILING_STOP_LIMIT):
             return enums.TradeOrderType.LIMIT.value
         if order_type in (enums.TraderOrderType.BUY_MARKET, enums.TraderOrderType.SELL_MARKET,
                           enums.TraderOrderType.STOP_LOSS, enums.TraderOrderType.TAKE_PROFIT,
@@ -472,14 +577,15 @@
     def get_trade_fee(self, symbol, order_type, quantity, price, taker_or_maker):
         fees = self.client.calculate_fee(symbol=symbol,
                                          type=order_type,
                                          side=exchanges.get_order_side(order_type),
                                          amount=float(quantity),
                                          price=float(price),
                                          takerOrMaker=taker_or_maker)
+        fees[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value] = False
         fees[enums.FeePropertyColumns.COST.value] = decimal.Decimal(str(fees[enums.FeePropertyColumns.COST.value]))
         if self.exchange_manager.is_future:
             # fees on futures are wrong
             rate = fees[enums.FeePropertyColumns.RATE.value]
             # avoid using ccxt computed fees as they are often wrong
             # see https://docs.ccxt.com/en/latest/manual.html#trading-fees
             parsed_symbol = commons_symbols.parse_symbol(symbol)
@@ -519,16 +625,17 @@
         return self.get_uniform_timestamp(self.client.milliseconds())
 
     def get_uniform_timestamp(self, timestamp):
         return self.adapter.get_uniformized_timestamp(timestamp)
 
     async def stop(self) -> None:
         self.logger.info(f"Closing connection.")
-        await self.client.close()
+        await ccxt_client_util.close_client(self.client)
         self.logger.info(f"Connection closed.")
+        self.client = None
         self.exchange_manager = None
 
     def get_pair_from_exchange(self, pair) -> typing.Optional[str]:
         try:
             return self.client.market(pair)["symbol"]
         except ccxt.BadSymbol:
             try:
@@ -569,28 +676,27 @@
         }
         return self.client.safe_string(
             self.client.market(symbol),
             trading_type_to_ccxt_property[trading_type],
             "False"
         ) == "True"
 
+    def is_expirable_symbol(self, symbol) -> bool:
+        return self.client.market(symbol).get("expiry") is not None
+
     def get_pair_market_type(self, pair, property_name, def_value=False):
         return self.client.safe_string(
             self.client.safe_value(self.client.markets, pair, {}), property_name, def_value
         )
 
-    def set_sandbox_mode(self, is_sandboxed):
-        try:
-            ccxt_client_util.set_sandbox_mode(self.client, is_sandboxed)
-        except ccxt.NotSupported as e:
-            default_type = self.client.options.get('defaultType', None)
-            additional_info = f" in type {default_type}" if default_type else ""
-            self.logger.warning(f"{self.name} does not support sandboxing {additional_info}: {e}")
-            # raise exception to stop this exchange and prevent dealing with a real funds exchange
-            raise e
+    def get_saved_data(self, key):
+        return self.saved_data[key]
+
+    def set_saved_data(self, key, value):
+        self.saved_data[key] = value
 
     """
     Parsers todo: remove all parsers
     """
 
     def parse_balance(self, balance):
         return self.client.parse_balance(balance)
@@ -622,17 +728,14 @@
 
     def parse_order_id(self, order):
         return order.get(ecoc.ID.value, None)
 
     def parse_order_symbol(self, order):
         return order.get(ecoc.SYMBOL.value, None)
 
-    def parse_status(self, status):
-        return enums.OrderStatus(self.client.parse_order_status(status))
-
     def parse_side(self, side):
         return enums.TradeOrderSide.BUY if side == self.BUY_STR else enums.TradeOrderSide.SELL
 
     def parse_account(self, account):
         return enums.AccountTypes[account]
 
     def parse_funding(self, funding_dict, from_ticker=False) -> dict:
@@ -645,22 +748,30 @@
         """
         Override when necessary
         :return: the maximum number of simultaneous pairs * time_frame that this exchange can handle.
         """
         # 15 pairs, each on 3 time frames
         return 45
 
+    def log_ddos_error(self, error):
+        self.logger.error(
+            f"DDoSProtection triggered [{error} ({error.__class__.__name__})]. "
+            f"Last response headers: {self.client.last_response_headers} "
+            f"Last json response: {self.client.last_json_response}"
+        )
+
     @contextlib.contextmanager
     def error_describer(self):
         try:
             yield
         except ccxt.DDoSProtection as e:
             # raised upon rate limit issues, last response data might have details on what is happening
             if self.exchange_manager.exchange.should_log_on_ddos_exception(e):
-                self.logger.error(
-                    f"DDoSProtection triggered [{e} ({e.__class__.__name__})]. "
-                    f"Last response headers: {self.client.last_response_headers} "
-                    f"Last json response: {self.client.last_json_response}"
-                )
+                self.log_ddos_error(e)
             raise
+        except ccxt.InvalidNonce as err:
+            # use 2 index to get the caller of the context manager
+            caller_function_name = inspect.stack()[2].function
+            exchanges.log_time_sync_error(self.logger, self.name, err, caller_function_name)
+            raise octobot_trading.errors.FailedRequest from err
         except ccxt.RequestTimeout as e:
             raise octobot_trading.errors.FailedRequest(f"Request timeout: {e}") from e
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py`

 * *Files 12% similar despite different names*

```diff
@@ -37,20 +37,25 @@
 from octobot_trading.enums import WebsocketFeeds as Feeds
 
 
 class CCXTWebsocketConnector(abstract_websocket_exchange.AbstractWebsocketExchange):
     INIT_REQUIRING_EXCHANGE_FEEDS = [Feeds.CANDLE]
     SUPPORTS_LIVE_PAIR_ADDITION = True
     FEED_INITIALIZATION_TIMEOUT = 15 * commons_constants.MINUTE_TO_SECONDS
+    MIN_CONNECTION_CLOSE_INTERVAL = 2 * commons_constants.MINUTE_TO_SECONDS
+    NO_MESSAGE_DISCONNECTED_TIMEOUT = 4 * commons_constants.MINUTE_TO_SECONDS
+    EXCHANGE_RECONNECT_INTERVAL = None
 
     IGNORED_FEED_PAIRS = {
         # When ticker or future index is available : no need to calculate mark price from recent trades
         Feeds.TRADES: [Feeds.TICKER, Feeds.FUTURES_INDEX],
         # When candles are available : use min timeframe kline to push ticker
-        Feeds.TICKER: [Feeds.KLINE]
+        Feeds.TICKER: [Feeds.KLINE],
+        # When funding can be found in websocket ticker
+        # Feeds.FUNDING: [Feeds.TICKER],
     }
 
     PAIR_INDEPENDENT_CHANNELS = [
         Feeds.PORTFOLIO,
         Feeds.ORDERS,
         Feeds.CREATE_ORDER,
         Feeds.CANCEL_ORDER,
@@ -59,18 +64,14 @@
         Feeds.PORTFOLIO,
     ]
     WATCHED_PAIR_CHANNELS = [
         Feeds.TRADES,
         Feeds.TICKER,
         Feeds.CANDLE,
     ]
-    TIME_FRAME_PAIR_CHANNELS = [
-        Feeds.CANDLE,
-        Feeds.KLINE,
-    ]
     CURRENT_TIME_FILTERED_CHANNELS = [
         Feeds.TRADES,
         Feeds.ORDERS,
         Feeds.TRADE,
     ]
     CANDLE_TIME_FILTERED_CHANNELS = [
         Feeds.CANDLE,
@@ -90,51 +91,56 @@
     AUTHENTICATED_CHANNELS = [
         trading_enums.WebsocketFeeds.ORDERS,
         trading_enums.WebsocketFeeds.PORTFOLIO,
         trading_enums.WebsocketFeeds.TRADE,
         trading_enums.WebsocketFeeds.POSITION,
     ]
     EXCHANGE_CONSTRUCTOR_KWARGS = {}
-    RECONNECT_DELAY = 5
+    SHORT_RECONNECT_DELAY = 0.5
+    LONG_RECONNECT_DELAY = 5
 
-    def __init__(self, config, exchange_manager, adapter_class=None, additional_config=None):
+    def __init__(self, config, exchange_manager, adapter_class=None, additional_config=None, websocket_name=None):
         super().__init__(config, exchange_manager)
         self.filtered_pairs = []
         self.watched_pairs = []
         self.min_timeframe = None
         self._previous_open_candles = {}
+        self._subsequent_unordered_candles_count = {}   # dict values: tuple(candle_count, candle_time)
+        self._errors_count = {}
         self._start_time_millis = None  # used for the "since" param in CURRENT/CANDLE_TIME_FILTERED_CHANNELS
+        self.websocket_name = websocket_name or self.get_name()
 
         self.local_loop = None
 
         self.should_stop = False
         self.is_authenticated = False
         self.adapter = self.get_adapter_class(adapter_class)(self)
         self.additional_config = additional_config
         self.headers = {}
         self.options = {
-            "newUpdates": True  # only get new updates from trades and ohlcv (don't return the full cached history)
+            "newUpdates": True,  # only get new updates from trades and ohlcv (don't return the full cached history)
         }
         # add default options
         self.add_options(
             ccxt_client_util.get_ccxt_client_login_options(self.exchange_manager)
         )
         self.client = None  # ccxt.pro exchange: a ccxt.async_support exchange with websocket capabilities
         self.feed_tasks = {}
+        self._last_close_time = 0
+        self._last_message_time = 0
         self.throttled_ws_updates = trading_constants.THROTTLED_WS_UPDATES
 
         self._create_client()
 
     """
     Methods
     """
 
-    @classmethod
-    def get_feed_name(cls):
-        return cls.get_name()
+    def get_feed_name(self):
+        return self.websocket_name
 
     def start(self):
         asyncio.run(self._inner_start())
 
     async def _inner_start(self):
         self._start_time_millis = self.client.milliseconds()
         self.stopped_event = asyncio.Event()
@@ -163,15 +169,16 @@
         self.options.update(options_dict)
         if self.client is not None:
             ccxt_client_util.add_options(self.client, options_dict)
 
     async def _inner_stop(self):
         self.should_stop = True
         try:
-            await self.client.close()
+            if self.client is not None:
+                await self.client.close()
             self.stopped_event.set()
         except Exception as e:
             self.logger.exception(e, False)
             self.logger.error(f"Failed to stop websocket feed : {e}")
 
     async def stop(self):
         """
@@ -208,14 +215,17 @@
     def update_followed_pairs(self):
         asyncio_tools.run_coroutine_in_asyncio_loop(self._inner_update_followed_pairs(), self.local_loop)
 
     @classmethod
     def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
         return cls.get_name() == exchange_candidate_name
 
+    def is_time_frame_supported(self, time_frame):
+        return time_frame.value in ccxt_client_util.get_time_frames(self.client)
+
     def get_pair_from_exchange(self, pair):
         """
         Convert a ccxt symbol format to uniformized symbol format
         :param pair: the pair to format
         :return: the formatted pair when success else an empty string
         """
         # octobot uses the ccxt format for pairs
@@ -240,14 +250,16 @@
         """
         client_class = getattr(ccxtpro, self.get_feed_name())
         self.client, self.is_authenticated = ccxt_client_util.create_client(
             client_class, self.name, self.exchange_manager, self.logger,
             self.options, self.headers, self.additional_config,
             self._should_authenticate()
         )
+        if self.exchange_manager.exchange.is_supporting_sandbox():
+            ccxt_client_util.set_sandbox_mode(self, self.exchange_manager.is_sandboxed)
 
     def _should_authenticate(self):
         return self._has_authenticated_channel() and super()._should_authenticate()
 
     def _has_authenticated_channel(self) -> bool:
         for feed in self.AUTHENTICATED_CHANNELS:
             if feed in self.EXCHANGE_FEEDS:
@@ -267,14 +279,24 @@
             self._filter_exchange_pairs_and_timeframes()
             self._subscribe_feeds()
         except Exception as e:
             self.logger.exception(e, True, f"Failed to subscribe when creating websocket feed : {e}")
         finally:
             self.initialized_event.set()
 
+    async def _close_exchange_to_force_reconnect(self):
+        if time.time() - self._last_close_time > self.MIN_CONNECTION_CLOSE_INTERVAL and not self.should_stop:
+            # Close client to force connections re-open. The next watch_xyz will recreate the connection
+            self.logger.debug(f"Closing exchange connection.")
+            await self.client.close()
+            self.logger.debug("Exchange connection closed. The next watch-xyz will re-open it.")
+            self._last_close_time = time.time()
+            return True
+        return False
+
     def _subscribe_feeds(self):
         """
         Prepares the subscription of unauthenticated and authenticated feeds and subscribe all
         """
         if self._should_run_candle_feed():
             if self.min_timeframe is None:
                 self.logger.error(
@@ -283,15 +305,15 @@
                     f"(valid_candle_intervals: {ccxt_client_util.get_time_frames(self.client)})")
             self._subscribe_candle_feed()
 
         # drop unsupported channels
         self.channels = [
             channel for channel in self.channels
             if self._is_supported_channel(channel)
-            and channel != self.EXCHANGE_FEEDS.get(Feeds.CANDLE)
+               and channel != self.EXCHANGE_FEEDS.get(Feeds.CANDLE)
         ]
 
         self._subscribe_channels_feeds(False)
 
     def _should_use_authenticated_feeds(self):
         """
         :return: True when authenticated feeds shouldn't be added
@@ -304,16 +326,16 @@
         :param channel: the channel name
         :return: True if the channel is not unsupported, not ignored
         and if it's an authenticated channel if the exchange is authenticated
         """
         if self._is_authenticated_feed(channel) and not self._should_use_authenticated_feeds():
             return False
         return not (
-            self.EXCHANGE_FEEDS.get(channel, Feeds.UNSUPPORTED.value) == Feeds.UNSUPPORTED.value
-            or self.should_ignore_feed(channel)
+                self.EXCHANGE_FEEDS.get(channel, Feeds.UNSUPPORTED.value) == Feeds.UNSUPPORTED.value
+                or self.should_ignore_feed(channel)
         )
 
     @classmethod
     def get_exchange_feed(cls, feed) -> str:
         feed_value = cls.EXCHANGE_FEEDS.get(feed, trading_enums.WebsocketFeeds.UNSUPPORTED.value)
         if cls.is_feed_supported(feed_value):
             return feed.value
@@ -435,15 +457,15 @@
         }
 
     def _get_since_filter_value(self, feed, time_frame):
         if feed in self.CURRENT_TIME_FILTERED_CHANNELS:
             return self._start_time_millis
         elif feed in self.CANDLE_TIME_FILTERED_CHANNELS:
             candles_ms = commons_enums.TimeFramesMinutes[commons_enums.TimeFrames(time_frame)] * \
-                commons_constants.MSECONDS_TO_MINUTE
+                         commons_constants.MSECONDS_TO_MINUTE
             time_delta = self._start_time_millis % candles_ms
             return self._start_time_millis - time_delta
         return None
 
     def _subscribe_feed(self, feed, symbols=None, time_frame=None, since=None, limit=None, params=None):
         """
         Subscribe a new feed
@@ -458,15 +480,17 @@
             feed_callback = self._get_callback_by_feed()[feed]
             feed_generator = self._get_feed_generator_by_feed()[feed]
             if Feeds.UNSUPPORTED in (feed_callback, feed_generator):
                 raise KeyError
         except KeyError:
             self.logger.error(f"Impossible to subscribe to {feed}: feed not supported")
             return
-        if feed in self.TIME_FRAME_PAIR_CHANNELS and time_frame is None:
+        added_subscriptions = []
+        has_added_feed = False
+        if feed in self.TIME_FRAME_RELATED_FEEDS and time_frame is None:
             time_frame = self.min_timeframe.value
         kwargs = copy.copy(self._get_feed_default_kwargs())
         if time_frame is not None:
             kwargs["timeframe"] = time_frame
         if since is not None:
             kwargs["since"] = since
         else:
@@ -481,65 +505,131 @@
             kwargs["limit"] = limit
         if params is not None:
             kwargs["params"] = params
         if symbols is not None:
             for symbol in symbols:
                 kwargs["symbol"] = symbol
                 # one task per symbol: ccxt_pro is not handling multi symbol generators
-                self._create_task_if_necessary(feed, feed_callback, feed_generator, **kwargs)
+                if self._create_task_if_necessary(feed, feed_callback, feed_generator, **kwargs):
+                    added_subscriptions.append(symbol)
+                    has_added_feed = True
         else:
             # no symbol param
-            self._create_task_if_necessary(feed, feed_callback, feed_generator, **kwargs)
+            if self._create_task_if_necessary(feed, feed_callback, feed_generator, **kwargs):
+                has_added_feed = True
 
-        symbols_str = f"for {', '.join(symbols)} " if symbols else ""
+        symbols_str = f"for {', '.join(added_subscriptions)} " if added_subscriptions else ""
         time_frame_str = f"on {time_frame}" if time_frame else ""
-        self.logger.debug(f"Subscribed to {feed.value} {symbols_str}{time_frame_str}")
+        if has_added_feed:
+            self.logger.debug(f"Subscribed to {feed.value} {symbols_str}{time_frame_str}")
+        else:
+            self.logger.debug(f"No new feed to subscribe to on {feed.value} (inputs: {symbols_str}{time_frame_str})")
 
-    async def _feed_task(self, feed, callback, generator_func, *g_args, **g_kwargs):
+    async def _feed_task(self, feed, callback, watch_func, *g_args, **g_kwargs):
         if not await self._wait_for_initialization(feed, *g_args, **g_kwargs):
             self.logger.error(f"Aborting {feed.value} feed connection with {g_kwargs}: "
                               f"missing required initialization data")
             return
         enable_throttling = feed in self.THROTTLED_CHANNELS and self.throttled_ws_updates != 0.0
+        ws_des = f"{watch_func.__name__} {g_kwargs}"
+        subsequent_disconnections = 0
+        already_got_feed_stopping_error = False
+        spamming_logs_warning_interval = 5000
+        spamming_logs_debug_interval = 1000
         while not self.should_stop:
             try:
-                update_data = await generator_func(*g_args, **g_kwargs)
+                update_data = await watch_func(*g_args, **g_kwargs)
+                self._last_message_time = time.time()
+                subsequent_disconnections = 0
                 if update_data:
-                    await callback(update_data, **g_kwargs)
+                    # Use a copy of the update data as it will be edited by adapters.
+                    # We should avoid editing the original object since it is also used in ccxt internally buffers
+                    await callback(copy.deepcopy(update_data), **g_kwargs)
                 if enable_throttling:
                     # ccxt keeps updating the internal structures while waiting
                     # https://docs.ccxt.com/en/latest/ccxt.pro.manual.html?rtd_search=fetchLedger#incremental-data-structures
                     await asyncio.sleep(self.throttled_ws_updates)
             except ccxt.NetworkError as err:
-                self.logger.debug(f"Can't connect to exchange websocket: {err}. "
-                                  f"Retrying in {self.RECONNECT_DELAY} seconds")
-                await asyncio.sleep(self.RECONNECT_DELAY)
-            except Exception as err:
+                # short reconnect on ping pong timeout or 1st reconnect
+                is_ping_pong_error = isinstance(err, ccxt.RequestTimeout)
+                if is_ping_pong_error and time.time() - self._last_message_time < self.NO_MESSAGE_DISCONNECTED_TIMEOUT:
+                    # last message not received long ago: the websocket is probably not disconnected, it's just a
+                    # pong timeout, which can happen: there is no issue, instantly reconnect feed
+                    self.logger.debug(f"Instantly reconnecting {ws_des} feed after ping-pong timeout.")
+                    continue
+                reconnect_delay = self.SHORT_RECONNECT_DELAY \
+                    if (subsequent_disconnections == 0 or is_ping_pong_error) \
+                    else self.LONG_RECONNECT_DELAY
+                self.logger.debug(f"Can't connect to exchange {ws_des} websocket: {err}. "
+                                  f"Retrying in {reconnect_delay} seconds")
+                if await self._close_exchange_to_force_reconnect():
+                    message = f"Closed exchange connection to force reconnect. Error: {err}"
+                    if subsequent_disconnections > 1 and subsequent_disconnections % 5 == 0:
+                        self.logger.error(
+                            f"Multiple disconnections if a row [{subsequent_disconnections}]for {ws_des}. {message}"
+                        )
+                    else:
+                        self.logger.debug(message)
+                await asyncio.sleep(reconnect_delay)
+                self.logger.debug(f"Reconnecting to {ws_des}")
+                subsequent_disconnections += 1  # wait for a longer time before the next reconnect
+            except ccxt.BadRequest as err:
+                message = f"Impossible to start {ws_des} feed due to exchange refusing the connection request: {err}."
                 self.logger.exception(
                     err,
                     True,
-                    f"Unexpected error when handling {generator_func.__name__} feed: {err}"
+                    f"{message} {'Will retry once' if not already_got_feed_stopping_error else 'Now stopping'}."
                 )
-                await asyncio.sleep(self.RECONNECT_DELAY)   # avoid spamming
+                if already_got_feed_stopping_error:
+                    # there is a real issue when connecting to the feed. Don't loop
+                    return
+                already_got_feed_stopping_error = True
+                await asyncio.sleep(self.LONG_RECONNECT_DELAY)  # avoid spamming
+            except ccxt.NotSupported as err:
+                self.logger.exception(
+                    err,
+                    True,
+                    f"Impossible to start {ws_des} feed: {err}. "
+                    f"Stopping it. Please report to the OctoBot team if you see this error"
+                )
+                return
+            except Exception as err:
+                error_count = self._increment_error_counter(g_kwargs.get("time_frame"), err)
+                error_message = f"Unexpected error when handling {ws_des} feed: {err} ({err.__class__.__name__}) " \
+                                f"({error_count} times)"
+                if error_count == 1:
+                    self.logger.exception(err, True, error_message)
+                elif error_count % spamming_logs_warning_interval == 0:
+                    self.logger.warning(error_message)
+                elif error_count % spamming_logs_debug_interval == 0:
+                    self.logger.debug(error_message)
+                await asyncio.sleep(self.LONG_RECONNECT_DELAY)  # avoid spamming
+                subsequent_disconnections += 1  # wait for a longer time before the next reconnect
 
     def _create_task_if_necessary(self, feed, feed_callback, feed_generator, **kwargs):
         identifier = self._get_feed_identifier(feed_generator, kwargs)
         if identifier not in self.feed_tasks:
             self.logger.debug(f"Subscribing to {feed.value} with {kwargs}")
             self.feed_tasks[identifier] = asyncio.create_task(
                 self._feed_task(feed, feed_callback, feed_generator, **kwargs)
             )
+            return True
+        return False
 
     async def _wait_for_initialization(self, feed, *g_args, **g_kwargs):
         if not self.is_feed_requiring_init(feed) or g_kwargs["symbol"] not in self.filtered_pairs:
             # no need to wait for pairs not in self.filtered_pairs
             return True
         is_initialized_func = None
         if feed is Feeds.CANDLE:
             def candle_is_initialized_func():
+                if self.exchange_manager is None:
+                    # Should only happen in tests / unusual environments. Or there is a real issue.
+                    self.logger.error(f"No exchange manager when starting websocket connector.")
+                    return False
                 try:
                     return self.exchange_manager.exchange_symbols_data.get_exchange_symbol_data(
                         g_kwargs["symbol"], allow_creation=False
                     ).symbol_candles[commons_enums.TimeFrames(g_kwargs["timeframe"])].candles_initialized
                 except KeyError:
                     return False
 
@@ -549,15 +639,15 @@
         if is_initialized_func():
             return True
         self.logger.debug(f"Waiting for initialization before starting {feed.value} feed with {g_kwargs}")
         t0 = time.time()
         while not self.should_stop and time.time() - t0 < self.FEED_INITIALIZATION_TIMEOUT:
             # add timeout
             if is_initialized_func():
-                self.logger.debug(f"Starting {feed} feed with {g_kwargs}: initialization complete")
+                self.logger.debug(f"Starting {feed.value} feed with {g_kwargs}: initialization complete")
                 return True
             # quickly update at first
             await asyncio.sleep(0.1 if time.time() - t0 < self.FEED_INITIALIZATION_TIMEOUT / 10 else 1)
         return is_initialized_func()
 
     def _get_feed_identifier(self, feed_generator, kwargs):
         return f"{feed_generator.__name__}{kwargs}"
@@ -616,15 +706,15 @@
             self.logger.error(f"{unsupported_pairs} pair is not supported by this exchange's websocket")
 
     def _add_time_frame(self, filtered_timeframes, time_frame, log_on_error):
         """
         Add a time frame to filtered_timeframes if supported
         :param time_frame: the time frame to add
         """
-        if self._is_supported_time_frame(time_frame) :
+        if self.is_time_frame_supported(time_frame):
             filtered_timeframes.append(time_frame)
         elif log_on_error:
             self.logger.error(f"{time_frame.value} time frame is not supported by this exchange's websocket")
 
     def _init_exchange_time_frames(self):
         """
         Populates self.min_timeframe from self.time_frames when time frame is supported by the ccxt exchange
@@ -640,17 +730,14 @@
 
     def _should_run_candle_feed(self):
         return self.EXCHANGE_FEEDS.get(Feeds.CANDLE, Feeds.UNSUPPORTED.value) != Feeds.UNSUPPORTED.value
 
     def _is_supported_pair(self, pair):
         return pair in ccxt_client_util.get_symbols(self.client)
 
-    def _is_supported_time_frame(self, time_frame):
-        return time_frame.value in ccxt_client_util.get_time_frames(self.client)
-
     def _is_pair_independent_feed(self, feed):
         return feed in self.PAIR_INDEPENDENT_CHANNELS
 
     def _convert_book_prices_to_orders(self, book_prices_and_volumes, book_side):
         """
         Convert a book_prices format : {PRICE_1: SIZE_1, PRICE_2: SIZE_2...}
         to OctoBot's order book format
@@ -722,14 +809,15 @@
         """
         :param candles: the ccxt ohlcv list
         :param symbol: the feed symbol
         :param timeframe: the feed timeframe
         :param kwargs: the feed kwargs
         """
         time_frame = commons_enums.TimeFrames(timeframe)
+        kline = self.adapter.adapt_kline([copy.deepcopy(candles[-1])])[0]
         adapted = self.adapter.adapt_ohlcv(candles, time_frame=time_frame)
         last_candle = adapted[-1]
         if symbol not in self.watched_pairs:
             for candle in adapted:
                 previous_candle = self._get_previous_open_candle(timeframe, symbol)
                 is_previous_candle_closed = False
                 if previous_candle is not None:
@@ -737,17 +825,31 @@
                     previous_candle_time = previous_candle[commons_enums.PriceIndexes.IND_PRICE_TIME.value]
                     if previous_candle_time < current_candle_time:
                         # new candle is after the previous one: the previous one is now closed
                         is_previous_candle_closed = True
                     elif previous_candle_time > current_candle_time:
                         # should not happen: exchange feed is providing past candles after newer ones
                         # candle feed should be marked as unsupported in this exchange (at least for now)
-                        self.logger.error(f"Ignored unexpected candle for {symbol} on {timeframe}: "
-                                          f"candle time {current_candle_time}, "
-                                          f"previous candle time: {previous_candle_time}")
+
+                        # update internal candle store to still keep track of the most up to date candle
+                        await self.exchange_manager.get_symbol_data(symbol) \
+                            .handle_candles_update(time_frame, candle, replace_all=False, partial=False, upsert=True)
+                        is_new_unordered_candle = self._register_subsequent_unordered_candle(
+                            timeframe, symbol, time_frame, current_candle_time
+                        )
+                        subsequent_unordered_candles = self._get_subsequent_unordered_candles_count(timeframe, symbol)
+                        error_message = f"Ignored unexpected candle for {symbol} on {timeframe}: " \
+                                        f"candle time {current_candle_time}, " \
+                                        f"previous candle time: {previous_candle_time} " \
+                                        f"({subsequent_unordered_candles} unordered candles in a row)."
+                        if is_new_unordered_candle:
+                            self.logger.warning(error_message)
+                        # prevent spamming
+                        elif subsequent_unordered_candles < 3 or (subsequent_unordered_candles % 1000 == 0):
+                            self.logger.debug(error_message)
                         if candle is last_candle:
                             # last candle in loop: don't go any further
                             return
                         else:
                             # go to next candle in loop
                             continue
                 if is_previous_candle_closed:
@@ -759,31 +861,31 @@
                         previous_candle
                     )
                 self._register_previous_open_candle(timeframe, symbol, candle)
             await self.push_to_channel(
                 trading_constants.KLINE_CHANNEL,
                 time_frame,
                 symbol,
-                last_candle
+                kline
             )
 
         # Push a new ticker if necessary : only push on the min timeframe
         if time_frame is self.min_timeframe:
             ticker = {
-                Ectc.HIGH.value: last_candle[commons_enums.PriceIndexes.IND_PRICE_HIGH.value],
-                Ectc.LOW.value: last_candle[commons_enums.PriceIndexes.IND_PRICE_LOW.value],
+                Ectc.HIGH.value: kline[commons_enums.PriceIndexes.IND_PRICE_HIGH.value],
+                Ectc.LOW.value: kline[commons_enums.PriceIndexes.IND_PRICE_LOW.value],
                 Ectc.BID.value: None,
                 Ectc.BID_VOLUME.value: None,
                 Ectc.ASK.value: None,
                 Ectc.ASK_VOLUME.value: None,
-                Ectc.OPEN.value: last_candle[commons_enums.PriceIndexes.IND_PRICE_OPEN.value],
-                Ectc.CLOSE.value: last_candle[commons_enums.PriceIndexes.IND_PRICE_CLOSE.value],
-                Ectc.LAST.value: last_candle[commons_enums.PriceIndexes.IND_PRICE_CLOSE.value],
+                Ectc.OPEN.value: kline[commons_enums.PriceIndexes.IND_PRICE_OPEN.value],
+                Ectc.CLOSE.value: kline[commons_enums.PriceIndexes.IND_PRICE_CLOSE.value],
+                Ectc.LAST.value: kline[commons_enums.PriceIndexes.IND_PRICE_CLOSE.value],
                 Ectc.PREVIOUS_CLOSE.value: None,
-                Ectc.BASE_VOLUME.value: last_candle[commons_enums.PriceIndexes.IND_PRICE_VOL.value],
+                Ectc.BASE_VOLUME.value: kline[commons_enums.PriceIndexes.IND_PRICE_VOL.value],
                 Ectc.TIMESTAMP.value: self.exchange.get_exchange_current_time(),
             }
             await self.push_to_channel(
                 trading_constants.TICKER_CHANNEL,
                 symbol,
                 ticker
             )
@@ -833,15 +935,16 @@
     async def orders(self, orders: list, **kwargs):
         """
         :param orders: the ccxt orders list
         :param kwargs: the feed kwargs
         """
         # TODO update this when supported (ccxt is supporting it)
         raise NotImplementedError("orders callback is not implemented")
-        adapted = [self.adapter.adapt_order(order) for order in orders]
+        symbol = None #todo
+        adapted = self.adapter.adapt_orders(orders, symbol=symbol)
         await self.push_to_channel(trading_constants.ORDERS_CHANNEL, adapted)
 
     async def trades(self, trades: list, **kwargs):
         """
         :param trades: the ccxt trades list
         :param kwargs: the feed kwargs
         """
@@ -877,7 +980,38 @@
             self._previous_open_candles[time_frame][symbol] = candle
 
     def _get_previous_open_candle(self, time_frame, symbol):
         try:
             return self._previous_open_candles[time_frame][symbol]
         except KeyError:
             return None
+
+    def _register_subsequent_unordered_candle(self, time_frame, symbol, parsed_timeframe, current_candle_time):
+        try:
+            count, last_candle_time = self._subsequent_unordered_candles_count[time_frame][symbol]
+            if current_candle_time - last_candle_time >= commons_enums.TimeFramesMinutes[parsed_timeframe] * \
+                    commons_constants.MINUTE_TO_SECONDS * 1.5:
+                # candle is not subsequent from the previous one: reset count
+                count = 0
+            self._subsequent_unordered_candles_count[time_frame][symbol] = (count + 1, current_candle_time)
+            return False
+        except KeyError:
+            if time_frame not in self._subsequent_unordered_candles_count:
+                self._subsequent_unordered_candles_count[time_frame] = {}
+            self._subsequent_unordered_candles_count[time_frame][symbol] = (1, current_candle_time)
+            return True
+
+    def _get_subsequent_unordered_candles_count(self, time_frame, symbol):
+        try:
+            return self._subsequent_unordered_candles_count[time_frame][symbol][0]
+        except KeyError:
+            return 0
+
+    def _increment_error_counter(self, time_frame, error):
+        error_key = error.__class__.__name__
+        try:
+            self._errors_count[time_frame][error_key] += 1
+        except KeyError:
+            if time_frame not in self._errors_count:
+                self._errors_count[time_frame] = {}
+            self._errors_count[time_frame][error_key] = 1
+        return self._errors_count[time_frame][error_key]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/constants.py` & `OctoBot-Trading-2.4.0/tests/api/test_trader.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,8 +10,11 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-CCXT_INFO = "info"
+import pytest
+
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/ccxt/enums.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/ccxt/enums.py`

 * *Files 20% similar despite different names*

```diff
@@ -17,14 +17,18 @@
 
 
 class ExchangeConstantsCCXTColumns(enum.Enum):
     TIMESTAMP = "timestamp"
     DATETIME = "datetime"
 
 
+class ExchangeConstantsMarketStatusCCXTColumns(enum.Enum):
+    CONTRACT_SIZE = "contractSize"
+
+
 class ExchangePositionCCXTColumns(enum.Enum):
     CONTRACTS = "contracts"
     CONTRACT_SIZE = "contractSize"
     MARGIN_TYPE = "marginType"
     MARGIN_MODE = "marginMode"
     LEVERAGE = "leverage"
     SYMBOL = "symbol"
@@ -40,23 +44,38 @@
     LIQUIDATION_PRICE = "liquidationPrice"
     MARK_PRICE = "markPrice"
     ENTRY_PRICE = "entryPrice"
     TIMESTAMP = "timestamp"
     DATETIME = "datetime"
     PERCENTAGE = "percentage"
     SIDE = "side"
+    HEDGED = "hedged"
     INFO = "info"
 
 
 class ExchangeFundingCCXTColumns(enum.Enum):
     SYMBOL = "symbol"
     LAST_FUNDING_TIME = "lastFundingTime"
     FUNDING_RATE = "fundingRate"
+    FUNDING_TIMESTAMP = "fundingTimestamp"
     NEXT_FUNDING_TIME = "nextFundingTime"
+    NEXT_FUNDING_TIMESTAMP = "nextFundingTimestamp"
     PREDICTED_FUNDING_RATE = "predictedFundingRate"
+    PREVIOUS_FUNDING_TIMESTAMP = "previousFundingTimestamp"
+    PREVIOUS_FUNDING_RATE = "previousFundingRate"
+
+
+class ExchangeLeverageTiersCCXTColumns(enum.Enum):
+    TIER = "tier"
+    CURRENCY = "currency"
+    MIN_NOTIONAL = "minNotional"
+    MAX_NOTIONAL = "maxNotional"
+    MAINTENANCE_MARGIN_RATE = "maintenanceMarginRate"
+    MAX_LEVERAGE = "maxLeverage"
+    INFO = "info"
 
 
 class ExchangeOrderCCXTColumns(enum.Enum):
     INFO = "info"
     ID = "id"
     TIMESTAMP = "timestamp"
     DATETIME = 'datetime'
@@ -76,14 +95,21 @@
     TRADES = "trades"
     MAKER = "maker"
     TAKER = "taker"
     ORDER = "order"
     TAKER_OR_MAKER = "takerOrMaker"
     REDUCE_ONLY = "reduceOnly"
     STOP_PRICE = "stopPrice"
+    TRIGGER_PRICE = "triggerPrice"
     TRIGGER_ABOVE = "triggerAbove"
     TAG = "tag"
+    MARGIN_MODE = "marginMode"
 
 
 class ExchangeWrapperLibs(enum.Enum):
     ASYNC_CCXT = "async_ccxt"
     CCXT = "ccxt"
+
+
+class ExchangeMarginTypes(enum.Enum):
+    ISOLATED = "isolated"
+    CROSS = "cross"
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/__init__.pxd` & `OctoBot-Trading-2.4.0/tests/api/test_trades.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,15 +10,11 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchanges.connectors.simulator cimport exchange_simulator_connector
-from octobot_trading.exchanges.connectors.simulator.exchange_simulator_connector cimport (
-    ExchangeSimulatorConnector,
-)
+import pytest
 
-__all__ = [
-    "ExchangeSimulatorConnector",
-]
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/trailing/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,20 +10,23 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchanges.connectors.simulator import exchange_simulator_adapter
-from octobot_trading.exchanges.connectors.simulator.exchange_simulator_adapter import (
-    ExchangeSimulatorAdapter,
+from octobot_trading.personal_data.orders.types.trailing import trailing_stop_order
+from octobot_trading.personal_data.orders.types.trailing import (
+    trailing_stop_limit_order,
 )
-from octobot_trading.exchanges.connectors.simulator import exchange_simulator_connector
-from octobot_trading.exchanges.connectors.simulator.exchange_simulator_connector import (
-    ExchangeSimulatorConnector,
+
+from octobot_trading.personal_data.orders.types.trailing.trailing_stop_order import (
+    TrailingStopOrder,
+)
+from octobot_trading.personal_data.orders.types.trailing.trailing_stop_limit_order import (
+    TrailingStopLimitOrder,
 )
 
 __all__ = [
-    "ExchangeSimulatorConnector",
-    "ExchangeSimulatorAdapter",
+    "TrailingStopOrder",
+    "TrailingStopLimitOrder",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py` & `OctoBot-Trading-2.4.0/tests/cli/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,13 +9,7 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-
-import octobot_trading.exchanges.adapters as adapters
-
-
-class ExchangeSimulatorAdapter(adapters.AbstractAdapter):
-    pass
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/util/initialization_util.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,42 +1,29 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_backtesting.backtesting as backtesting
-cimport octobot_trading.exchanges.abstract_exchange as abstract_exchange
+import octobot_commons.tree as commons_tree
 
-cdef class ExchangeSimulatorConnector(abstract_exchange.AbstractExchange):
-    cdef public backtesting.Backtesting backtesting
-    cdef public object adapter
 
-    cdef public list exchange_importers
-
-    cdef public dict current_future_candles
-
-    cdef public bint is_authenticated
-
-    cpdef object get_adapter_class(self, object adapter_class)
-    cpdef str get_pair_cryptocurrency(self, str pair)
-    cpdef list get_available_time_frames(self)
-    cpdef list get_backtesting_data_files(self)
-    cpdef list get_time_frames(self, object importer)
-
-    cdef void _read_fees_from_config(self, dict result_fees)
-
-# Should be cythonized with cython 3.0
-# cpdef set handles_real_data_for_updater(str channel_type, list available_data_types)
-
-# Should be cythonized with cython 3.0
-# cdef bint _are_required_data_available(str channel_type, list available_data_types)
+async def wait_for_topic_init(exchange_manager, timeout, topic, symbol=None, time_frame=None):
+    return await commons_tree.EventProvider.instance().wait_for_event(
+        exchange_manager.bot_id,
+        commons_tree.get_exchange_path(
+            exchange_manager.exchange_name,
+            topic,
+            symbol=symbol,
+            time_frame=time_frame
+        ),
+        timeout
+    )
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py`

 * *Files 4% similar despite different names*

```diff
@@ -61,15 +61,15 @@
         # set exchange manager attributes
         self.exchange_manager.client_symbols = list(self.symbols)
 
     def get_adapter_class(self, adapter_class):
         return adapter_class or exchange_simulator_adapter.ExchangeSimulatorAdapter
 
     @classmethod
-    def load_user_inputs(cls, tentacles_setup_config, tentacle_config):
+    def load_user_inputs_from_class(cls, tentacles_setup_config, tentacle_config):
         # no user input in connector
         pass
 
     @classmethod
     def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
         return True
 
@@ -185,14 +185,15 @@
                     commons_constants.CONFIG_SIMULATOR_FEES_WITHDRAW] / 100
 
     # returns {
     #     'type': takerOrMaker,
     #     'currency': 'BTC', // the unified fee currency code
     #     'rate': percentage, // the fee rate, 0.05% = 0.0005, 1% = 0.01, ...
     #     'cost': feePaid, // the fee cost (amount * fee rate)
+    #     'is_from_exchange': False, // simulated fees
     # }
     def get_trade_fee(self, symbol, order_type, quantity, price, taker_or_maker):
         if not taker_or_maker:
             taker_or_maker = enums.ExchangeConstantsMarketPropertyColumns.TAKER.value
         symbol_fees = self.get_fees(symbol)
         rate = symbol_fees[taker_or_maker]
         currency, market = symbol_util.parse_symbol(symbol).base_and_quote()
@@ -207,14 +208,15 @@
             fee_currency = market
 
         return {
             enums.FeePropertyColumns.TYPE.value: taker_or_maker,
             enums.FeePropertyColumns.CURRENCY.value: fee_currency,
             enums.FeePropertyColumns.RATE.value: rate,
             enums.FeePropertyColumns.COST.value: decimal.Decimal(str(cost)),
+            enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: False,
         }
 
     def get_time_frames(self, importer):
         return time_frame_manager.sort_time_frames(list(set(backtesting_api.get_available_time_frames(importer)) &
                                                         set(self.exchange_manager.exchange_config.traded_time_frames)),
                                                    reverse=True)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_builder.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_builder.py`

 * *Files 0% similar despite different names*

```diff
@@ -43,14 +43,17 @@
             await self._build_exchange_manager()
         except Exception as e:
             # stop exchange manager if an exception occurred when building it
             await self.exchange_manager.stop(warning_on_missing_elements=False)
             raise e
         return self.exchange_manager
 
+    def clear(self):
+        self.exchange_manager = None
+
     async def _build_exchange_manager(self):
         trading_mode_class = None
 
         try:
             if self._is_using_trading_modes:
                 trading_mode_class = modes.get_activated_trading_mode(self.exchange_manager.tentacles_setup_config)
                 # handle exchange related requirements if the activated trading mode has any
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_channels.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_channels.py`

 * *Files 3% similar despite different names*

```diff
@@ -99,26 +99,36 @@
 async def _create_producer(exchange_manager, producer) -> channel_producer.Producer:
     """
     Create a producer instance
     :param exchange_manager: the related exchange manager
     :param producer: the producer to create
     :return: the producer instance created
     """
+    should_start_producer = True
     producer_instance = producer(exchange_channel.get_chan(producer.CHANNEL_NAME, exchange_manager.id))
-    if exchanges.is_exchange_managed_by_websocket(exchange_manager, producer.CHANNEL_NAME):
+    if exchanges.is_channel_managed_by_websocket(exchange_manager, producer.CHANNEL_NAME):
         # websocket is handling this channel: initialize data if required
+        exchange_manager.logger.debug(
+            f"{exchange_manager.exchange_name} {producer.CHANNEL_NAME} channel is updated by websocket feed"
+        )
+        should_start_producer = \
+            not exchanges.is_channel_fully_managed_by_websocket(exchange_manager, producer.CHANNEL_NAME)
         if exchanges.is_websocket_feed_requiring_init(exchange_manager, producer.CHANNEL_NAME):
             try:
                 producer_instance.trigger_single_update()
             except Exception as e:
                 exchange_manager.logger.exception(e, True,
                                                   f"Error when initializing data for {producer.CHANNEL_NAME} "
                                                   f"channel required by websocket: {e}")
-    else:
-        # no websocket for this channel: start an producer
+    if should_start_producer:
+        # no websocket for this channel (or channel is not fully managed by ws): start a producer
+        exchange_manager.logger.debug(
+            f"{exchange_manager.exchange_name} {producer.CHANNEL_NAME} channel "
+            f"is updated by {producer_instance.__class__.__name__}"
+        )
         await producer_instance.run()
     return producer_instance
 
 
 async def create_authenticated_producer_from_parent(exchange_manager,
                                                     parent_producer_class,
                                                     force_register_producer=False):
@@ -154,8 +164,8 @@
     have been a few seconds ago)
     Return False if this channels updates by its exchange_manager
     and manual refresh trigger is not necessary (ex: websocket feed)
     :param exchange_manager: the related exchange manager
     :param channel: name of the channel
     :return: True if it should be refreshed via a manual trigger to be exactly up to date
     """
-    return not exchanges.is_exchange_managed_by_websocket(exchange_manager, channel)
+    return not exchanges.is_channel_managed_by_websocket(exchange_manager, channel)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_factory.py`

 * *Files 2% similar despite different names*

```diff
@@ -102,30 +102,30 @@
         exchange_manager.logger.exception(e, True, f"Error when creating exchange backend: {e}")
 
 
 async def _initialize_exchange_backend(exchange_manager):
     if exchange_manager.exchange_backend is not None and exchange_manager.exchange.authenticated() \
             and not exchange_manager.is_trader_simulated:
         exchange_manager.logger.debug(await exchange_manager.exchange_backend.initialize())
-        if not exchange_manager.is_future:
-            return
-        try:
+        return
+        # disabled
+        try:    # pylint: disable=W0101
             exchange_manager.is_valid_account = await _is_supporting_octobot()
             if exchange_manager.is_valid_account:
                 return True
             exchange_manager.is_valid_account, message = await exchange_manager.exchange_backend.is_valid_account()
             if not exchange_manager.is_valid_account:
                 exchange_manager.logger.error(
                     f"Incompatible {exchange_manager.exchange.name.capitalize()} account to use futures trading: "
                     f"{message}. OctoBot relies on exchanges profits sharing to remain 100% free, please create a "
                     f"new {exchange_manager.exchange.name.capitalize()} account or register a donation to support "
                     f"the project. {exchanges.get_partners_explanation_message()}")
         except trading_backend.TimeSyncError as err:
             exchanges.log_time_sync_error(exchange_manager.logger, exchange_manager.exchange.name,
-                                          err, "account details")
+                                          err, "exchange_backend.is_valid_account")
             exchange_manager.is_valid_account = False
             exchange_manager.init_error = err
         except Exception as err:
             exchange_manager.is_valid_account = False
             exchange_manager.init_error = err
             exchange_manager.logger.exception(err, True, f"Error when loading exchange account: {err}")
         finally:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_manager.py`

 * *Files 3% similar despite different names*

```diff
@@ -125,24 +125,28 @@
             await self.exchange.stop()
             exchanges.Exchanges.instance().del_exchange(self.exchange.name, self.id,
                                                         should_warn=warning_on_missing_elements)
             self.exchange.exchange_manager = None
             self.exchange = None
         if self.exchange_personal_data is not None:
             await self.exchange_personal_data.stop()
+        if self.exchange_symbols_data is not None:
+            await self.exchange_symbols_data.stop()
         if enable_logs:
             self.logger.debug(f"Stopped exchange channels for exchange_id: {self.id}")
 
         if enable_logs:
             self.logger.debug("Stopping storages ...")
         await self.storage_manager.stop()
 
         self.exchange_config = None
         self.exchange_personal_data = None
         self.exchange_symbols_data = None
+        if self.exchange_backend is not None:
+            self.exchange_backend.stop()
         if enable_logs:
             self.logger.debug("Stopping trader ...")
         if self.trader is not None:
             self.trader.clear()
             self.trader = None
         if enable_logs:
             self.logger.debug("Stopped trader")
@@ -257,28 +261,25 @@
     def get_is_overloaded(self):
         if self.has_websocket:
             return False
         max_handled = self.exchange.get_max_handled_pair_with_time_frame()
         return max_handled != constants.INFINITE_MAX_HANDLED_PAIRS_WITH_TIMEFRAME and max_handled < \
             self.get_currently_handled_pair_with_time_frame()
 
-    def should_decrypt_token(self, logger):
+    def should_decrypt_token(self):
         if configuration.has_invalid_default_config_value(
                 self.config[common_constants.CONFIG_EXCHANGES][self.get_exchange_name()].get(
                     common_constants.CONFIG_EXCHANGE_KEY, ''),
                 self.config[common_constants.CONFIG_EXCHANGES][self.get_exchange_name()].get(
                     common_constants.CONFIG_EXCHANGE_SECRET, '')):
-            logger.warning(f"Exchange configuration tokens for {self.get_exchange_name()} are not set yet, "
-                           f"to use OctoBot's real trader's features, "
-                           f"please enter your api tokens in exchange configuration")
             return False
         return True
 
-    def get_exchange_credentials(self, logger, exchange_name):
-        if self.ignore_config or not self.should_decrypt_token(logger) or self.without_auth:
+    def get_exchange_credentials(self, exchange_name):
+        if self.ignore_config or not self.should_decrypt_token() or self.without_auth:
             return "", "", ""
         config_exchange = self.config[common_constants.CONFIG_EXCHANGES][exchange_name]
         return (
             configuration.decrypt_element_if_possible(common_constants.CONFIG_EXCHANGE_KEY, config_exchange, None),
             configuration.decrypt_element_if_possible(common_constants.CONFIG_EXCHANGE_SECRET, config_exchange, None),
             configuration.decrypt_element_if_possible(common_constants.CONFIG_EXCHANGE_PASSWORD, config_exchange, None)
         )
@@ -292,15 +293,15 @@
 
     def update_debug_info(self):
         self.debug_info = {
             "str": str(self),
             "trading_modes": str([tm.get_name() for tm in self.trading_modes]),
             "traded_time_frames": str(self.exchange_config.traded_time_frames),
             "watched_pairs": str(self.exchange_config.watched_pairs),
-            "all_config_symbol_pairs": str(self.exchange_config.all_config_symbol_pairs),
+            "traded_symbol_pairs": str(self.exchange_config.traded_symbol_pairs),
         }
 
     def __str__(self):
         exchange_type = 'rest'
         exchange_type = 'spot only' if self.is_spot_only else exchange_type
         exchange_type = 'margin' if self.is_margin else exchange_type
         exchange_type = 'future' if self.is_future else exchange_type
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_websocket_factory.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.exchanges as exchanges
 
-cpdef bint is_exchange_managed_by_websocket(exchanges.ExchangeManager exchange_manager, str channel)
-cpdef bint is_websocket_feed_requiring_init(exchanges.ExchangeManager exchange_manager, str channel)
+
+def is_emitting_trading_signals(ctx):
+    return ctx.is_trading_signal_emitter()
+
+
+async def emit_trading_signals(ctx):
+    try:
+        return await ctx.emit_signal()
+    except Exception as e:
+        ctx.logger.exception(e, True, f"Error when emitting trading signal: {e}")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchange_websocket_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchange_websocket_factory.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,24 +13,39 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.constants
 import octobot_trading.exchanges as exchanges
 
 
-def is_exchange_managed_by_websocket(exchange_manager, channel):
-    """
-    # TODO improve checker
-    """
-    return not exchange_manager.rest_only \
-        and exchange_manager.has_websocket \
-        and not exchange_manager.is_backtesting \
-        and channel in octobot_trading.constants.WEBSOCKET_FEEDS_TO_TRADING_CHANNELS \
-        and any([exchange_manager.exchange_web_socket.is_feed_available(feed)
-                 for feed in octobot_trading.constants.WEBSOCKET_FEEDS_TO_TRADING_CHANNELS[channel]])
+def is_channel_managed_by_websocket(exchange_manager, channel):
+    return (
+        not exchange_manager.rest_only
+        and exchange_manager.has_websocket
+        and not exchange_manager.is_backtesting
+        and channel in octobot_trading.constants.WEBSOCKET_FEEDS_TO_TRADING_CHANNELS
+        and exchange_manager.exchange_web_socket is not None
+        and any([
+            exchange_manager.exchange_web_socket.is_feed_available(feed)
+            for feed in octobot_trading.constants.WEBSOCKET_FEEDS_TO_TRADING_CHANNELS[channel]
+        ])
+    )
+
+
+def is_channel_fully_managed_by_websocket(exchange_manager, channel):
+    return (
+        not any([
+            exchange_manager.exchange_web_socket.is_time_frame_related_feed(feed)
+            for feed in octobot_trading.constants.WEBSOCKET_FEEDS_TO_TRADING_CHANNELS[channel]
+        ])
+        or all([
+            exchange_manager.exchange_web_socket.is_time_frame_supported(time_frame)
+            for time_frame in exchange_manager.exchange_config.traded_time_frames
+        ])
+    )
 
 
 def is_websocket_feed_requiring_init(exchange_manager, channel):
     return any([exchange_manager.exchange_web_socket.is_feed_requiring_init(feed)
                 for feed in octobot_trading.constants.WEBSOCKET_FEEDS_TO_TRADING_CHANNELS[channel]])
 
 
@@ -40,15 +55,15 @@
         await _create_websocket(exchange_manager, exchanges.WebSocketExchange.__name__, ws_exchange_class)
 
 
 async def _create_websocket(exchange_manager, websocket_class_name, ws_exchange_class):
     try:
         exchange_manager.exchange_web_socket = ws_exchange_class(exchange_manager.config, exchange_manager)
         await _init_websocket(exchange_manager)
-        exchange_manager.logger.info(f"{ws_exchange_class.get_name()} connected to "
+        exchange_manager.logger.info(f"{ws_exchange_class.get_name()} connecting to "
                                      f"{exchange_manager.exchange.name.capitalize()}")
     except Exception as e:
         exchange_manager.logger.error(f"Fail to init websocket for {websocket_class_name} "
                                       f"({exchange_manager.exchange.name}): {e}")
         exchange_manager.exchange_web_socket = None
         exchange_manager.has_websocket = False
         raise e
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/exchanges.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/exchanges.py`

 * *Files 5% similar despite different names*

```diff
@@ -22,16 +22,14 @@
 class ExchangeConfiguration:
     def __init__(self, exchange_manager, matrix_id):
         self.exchange_manager = exchange_manager
         self.exchange_name = exchange_manager.exchange_name
         self.id = exchange_manager.id
         self.matrix_id = matrix_id
         # use only enabled currencies
-        # use exchange_manager.exchange_config.all_config_symbol_pairs to get all pairs regardless of whether they
-        # are activated in config
         self.symbols = exchange_manager.exchange_config.traded_symbol_pairs
         self.symbols_by_crypto_currencies = exchange_manager.exchange_config.traded_cryptocurrencies
         self.real_time_time_frames = exchange_manager.exchange_config.real_time_time_frames
         self.available_required_time_frames = exchange_manager.exchange_config.available_required_time_frames
 
 
 class Exchanges(singleton.Singleton):
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/default_rest_exchange.pxd` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import mock
 
-cimport octobot_trading.exchanges.types.rest_exchange as rest_exchange
 
-cdef class DefaultRestExchange(rest_exchange.RestExchange):
-    pass
+def order_mock(**kwargs):
+    order = mock.Mock(**kwargs)
+    order.is_open = mock.Mock(return_value=True)
+    order.is_cancelling = mock.Mock(return_value=False)
+    order.trader = mock.Mock()
+    order.trader.cancel_order = mock.AsyncMock()
+    order.trader.edit_order = mock.AsyncMock()
+    order.trader.exchange_manager = mock.Mock(trading_modes=[])
+    order.trader.exchange_manager.trader = order.trader
+    return order
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/default_websocket_exchange.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/transfer_transaction.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,21 +1,26 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-cimport octobot_trading.exchanges.types as exchanges_types
+import octobot_trading.enums as enums
+import octobot_trading.personal_data.transactions.transaction as transaction
 
-cdef class DefaultWebSocketExchange(exchanges_types.WebSocketExchange):
-    pass
+
+class TransferTransaction(transaction.Transaction):
+    def __init__(self, exchange_name, creation_time, currency, symbol):
+        super().__init__(exchange_name, creation_time,
+                         transaction_type=enums.TransactionType.TRANSFER,
+                         currency=currency,
+                         symbol=symbol)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/default_websocket_exchange.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/default_websocket_exchange.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,13 +28,14 @@
             name=exchange_manager.exchange_name,
             tentacles_setup_config=exchange_manager.tentacles_setup_config,
             parent_class=cls.DEFAULT_CONNECTOR_CLASS
         )
 
     def create_feeds(self):
         try:
-            connector = self.websocket_connector(config=self.config, exchange_manager=self.exchange_manager)
+            connector = self.websocket_connector(config=self.config, exchange_manager=self.exchange_manager,
+                                                 websocket_name=self.websocket_connector.get_name())
             connector.initialize(pairs=self.pairs, time_frames=self.time_frames, channels=self.channels)
             self.websocket_connectors.append(connector)
 
         except ValueError as e:
             self.logger.exception(e, True, f"Fail to create feed : {e}")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/implementations/exchange_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/implementations/exchange_simulator.py`

 * *Files 2% similar despite different names*

```diff
@@ -70,37 +70,38 @@
         """
         Create a new FutureContract for the pair
         :param pair: the pair
         """
         return self.create_pair_contract(
             pair=pair,
             current_leverage=constants.DEFAULT_SYMBOL_LEVERAGE,
+            contract_size=constants.DEFAULT_SYMBOL_CONTRACT_SIZE,
             margin_type=constants.DEFAULT_SYMBOL_MARGIN_TYPE,
             contract_type=self.exchange_manager.exchange_config.backtesting_exchange_config.future_contract_type,
             position_mode=constants.DEFAULT_SYMBOL_POSITION_MODE,
             maintenance_margin_rate=constants.DEFAULT_SYMBOL_MAINTENANCE_MARGIN_RATE,
             maximum_leverage=constants.DEFAULT_SYMBOL_MAX_LEVERAGE
         )
 
-    async def get_symbol_leverage(self, symbol: str):
+    async def get_symbol_leverage(self, symbol: str, **kwargs: dict):
         return constants.DEFAULT_SYMBOL_LEVERAGE
 
     async def get_margin_type(self, symbol: str):
         return constants.DEFAULT_SYMBOL_MARGIN_TYPE
 
     def get_contract_type(self, symbol: str):
         return self.exchange_manager.exchange_config.backtesting_exchange_config.future_contract_type
 
     async def get_funding_rate(self, symbol: str, **kwargs: dict):
         return self.exchange_manager.exchange_config.backtesting_exchange_config.funding_rate
 
     async def get_position_mode(self, symbol: str, **kwargs: dict):
         return constants.DEFAULT_SYMBOL_POSITION_MODE
 
-    async def set_symbol_leverage(self, symbol: str, leverage: int, **kwargs):
+    async def set_symbol_leverage(self, symbol: str, leverage: float, **kwargs):
         pass  # let trader update the contract
 
-    async def set_symbol_margin_type(self, symbol: str, isolated: bool):
+    async def set_symbol_margin_type(self, symbol: str, isolated: bool, **kwargs: dict):
         pass  # let trader update the contract
 
     async def set_symbol_position_mode(self, symbol: str, one_way: bool):
         pass  # let trader update the contract
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/trader.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/traders/trader.py`

 * *Files 3% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
 import decimal
+import typing
 
 import octobot_commons.logging as logging
 import octobot_commons.constants
 
 import octobot_trading.personal_data.orders.order_factory as order_factory
 import octobot_trading.personal_data.orders.order_util as order_util
 import octobot_trading.personal_data.orders.decimal_order_adapter as decimal_order_adapter
@@ -112,18 +113,19 @@
             self.logger.info(f"Creating order: {created_order}")
             created_order = await self._create_new_order(order, params, wait_for_creation=wait_for_creation,
                                                          creation_timeout=creation_timeout)
             if created_order is None:
                 self.logger.warning(f"Order not created order on {self.exchange_manager.exchange_name} "
                                     f"(failed attempt to create: {order}). This is likely due to "
                                     f"the order being refused by the exchange.")
+        except errors.MissingFunds:
+            # forward errors that require actions to fix the situation
+            raise
         except Exception as e:
-            import traceback
-            print(traceback.format_exc())
-            self.logger.exception(e, True, f"Unexpected error when creating order: {e}")
+            self.logger.exception(e, True, f"Unexpected error when creating order: {e}. Order: {order}")
             return None
 
         return created_order
 
     async def create_artificial_order(self, order_type, symbol, current_price, quantity, price,
                                       emit_trading_signals=False,
                                       wait_for_creation=True,
@@ -143,15 +145,15 @@
                 self.exchange_manager,
                 emit_trading_signals and signals.should_emit_trading_signal(self.exchange_manager),
                 order,
                 wait_for_creation=wait_for_creation,
                 creation_timeout=creation_timeout
             )
 
-    async def edit_order(self, order: object,
+    async def edit_order(self, order,
                          edited_quantity: decimal.Decimal = None,
                          edited_price: decimal.Decimal = None,
                          edited_stop_price: decimal.Decimal = None,
                          edited_current_price: decimal.Decimal = None,
                          params: dict = None) -> bool:
         """
         Edits an order, might be a simulated or a real order.
@@ -209,41 +211,49 @@
                         stop_price=edited_stop_price,
                         current_price=edited_current_price,
                     )
                     # consider order as new order to lock portfolio amounts
                     self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio.update_portfolio_available(
                         order, is_new_order=True
                     )
+                # push order edit into orders channel as edit update
+                await self.exchange_manager.exchange_personal_data.handle_order_update_notification(
+                    order, enums.OrderUpdateType.EDIT
+                )
                 self.logger.info(f"Edited order: {order}")
             return changed
         finally:
             if previous_order_id != order.order_id:
                 # order id changed: update orders_manager to keep consistency
                 self.exchange_manager.exchange_personal_data.orders_manager.replace_order(previous_order_id, order)
 
-    async def _create_new_order(self, new_order: object, params: dict,
+    async def _create_new_order(self, new_order, params: dict,
                                 wait_for_creation=True,
                                 creation_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT) -> object:
         """
         Creates an exchange managed order, it might be a simulated or a real order.
         Portfolio will be updated by the created order state after order will be initialized
         """
         updated_order = new_order
         is_pending_creation = False
         if not self.simulate and not new_order.is_self_managed():
             order_params = self.exchange_manager.exchange.get_order_additional_params(new_order)
+            order_params.update(new_order.exchange_creation_params)
             order_params.update(params)
-            created_order = await self.exchange_manager.exchange.create_order(new_order.order_type,
-                                                                              new_order.symbol,
-                                                                              new_order.origin_quantity,
-                                                                              new_order.origin_price,
-                                                                              new_order.origin_stop_price,
-                                                                              new_order.side,
-                                                                              new_order.created_last_price,
-                                                                              params=order_params)
+            created_order = await self.exchange_manager.exchange.create_order(
+                order_type=new_order.order_type,
+                symbol=new_order.symbol,
+                quantity=new_order.origin_quantity,
+                price=new_order.origin_price,
+                stop_price=new_order.origin_stop_price,
+                side=new_order.side,
+                current_price=new_order.created_last_price,
+                reduce_only=new_order.reduce_only,
+                params=order_params
+            )
             if created_order is None:
                 return None
             self.logger.debug(f"Successfully created order on {self.exchange_manager.exchange_name}: {created_order}")
 
             # get real order from exchange
             updated_order = order_factory.create_order_instance_from_raw(
                 self, created_order, force_open_or_pending_creation=True
@@ -258,54 +268,69 @@
             for chained_order in new_order.chained_orders:
                 chained_order.triggered_by = updated_order
             updated_order.triggered_by = new_order.triggered_by
             updated_order.has_been_bundled = new_order.has_been_bundled
             updated_order.exchange_creation_params = new_order.exchange_creation_params
             updated_order.is_waiting_for_chained_trigger = new_order.is_waiting_for_chained_trigger
             updated_order.set_shared_signal_order_id(new_order.shared_signal_order_id)
+            updated_order.associated_entry_ids = new_order.associated_entry_ids
+            updated_order.update_with_triggering_order_fees = new_order.update_with_triggering_order_fees
 
             if is_pending_creation:
                 # register order as pending order, it will then be added to live orders in order manager once open
                 self.exchange_manager.exchange_personal_data.orders_manager.register_pending_creation_order(updated_order)
 
         await updated_order.initialize()
         if is_pending_creation and wait_for_creation \
                 and updated_order.state is not None and updated_order.state.is_pending():
             await updated_order.state.wait_for_terminate(creation_timeout)
         return updated_order
 
-    async def bundle_chained_order_with_uncreated_order(self, order, chained_order, **kwargs):
+    async def bundle_chained_order_with_uncreated_order(
+        self, order, chained_order, update_with_triggering_order_fees, **kwargs
+    ):
         """
         Creates and bundles an order as a chained order to the given order.
         When supported and in real trading, return the stop loss parameters to be given when
         pushing the initial order on exchange
         :param order: the order to create a chained order from after fill
         :param chained_order: the chained order to create when the 1st order is filled
+        :param update_with_triggering_order_fees: if the chained order quantity should
+        be updated with triggering order fees
         :return: parameters with chained order details if supported
         """
         params = {}
         is_bundled = self.exchange_manager.exchange.supports_bundled_order_on_order_creation(
             order, chained_order.order_type
         )
         if is_bundled:
             if chained_order.order_type is enums.TraderOrderType.STOP_LOSS:
                 params.update(self.exchange_manager.exchange.get_bundled_order_parameters(
+                    order,
                     stop_loss_price=chained_order.origin_price
                 ))
             elif chained_order.order_type in (enums.TraderOrderType.TAKE_PROFIT,
                                               enums.TraderOrderType.BUY_MARKET, enums.TraderOrderType.SELL_MARKET,
                                               enums.TraderOrderType.BUY_LIMIT, enums.TraderOrderType.SELL_LIMIT):
                 params.update(self.exchange_manager.exchange.get_bundled_order_parameters(
+                    order,
+                    stop_loss_price=None,   # required for cython
                     take_profit_price=chained_order.origin_price
                 ))
-        await chained_order.set_as_chained_order(order, is_bundled, {}, **kwargs)
+            if params:
+                self.logger.debug(
+                    f"Including {chained_order.order_type} chained order into order "
+                    f"parameters to handle it directly on exchange."
+                )
+        await chained_order.set_as_chained_order(order, is_bundled, {}, update_with_triggering_order_fees, **kwargs)
         order.add_chained_order(chained_order)
+        self.logger.debug(f"Added chained order [{chained_order}] to [{order}] order.")
         return params
 
-    async def cancel_order(self, order: object, ignored_order: object = None,
+    async def cancel_order(self, order, ignored_order=None,
                            wait_for_cancelling=True,
                            cancelling_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT) -> bool:
         """
         Cancels the given order and updates the portfolio, publish in order channel
         if order is from a real exchange.
         :param order: Order to cancel
         :param ignored_order: Order not to cancel if found in groupped orders recursive cancels (ex: avoid cancelling
@@ -319,52 +344,108 @@
         if order and order.is_open():
             self.logger.info(f"Cancelling order: {order}")
             # always cancel this order first to avoid infinite loop followed by deadlock
             return await self._handle_order_cancellation(order, ignored_order,
                                                          wait_for_cancelling, cancelling_timeout)
         return False
 
-    async def _handle_order_cancellation(self, order: object, ignored_order: object,
+    async def _handle_order_cancellation(self, order, ignored_order,
                                          wait_for_cancelling: bool, cancelling_timeout: float) -> bool:
         success = True
-        async with order.lock:
-            if order.is_waiting_for_chained_trigger:
-                # order will just never get created
-                order.is_waiting_for_chained_trigger = False
-                return success
-            # if real order: cancel on exchange
-            if not self.simulate and not order.is_self_managed():
-                try:
+        if order.is_waiting_for_chained_trigger:
+            # order will just never get created
+            order.is_waiting_for_chained_trigger = False
+            return success
+        # if real order: cancel on exchange
+        if not self.simulate and not order.is_self_managed():
+            try:
+                async with order.lock:
                     try:
-                        order_status = await self.exchange_manager.exchange.cancel_order(order.order_id, order.symbol)
+                        order_status = await self.exchange_manager.exchange.cancel_order(
+                            order.order_id, order.symbol, order.order_type
+                        )
                     except errors.NotSupported:
                         raise
                     except (errors.OrderCancelError, Exception) as err:
                         # retry to cancel order
-                        self.logger.debug(f"Failed to cancel order ({err}), retrying")
-                        order_status = await self.exchange_manager.exchange.cancel_order(order.order_id, order.symbol)
-                except Exception as e:
-                    self.logger.exception(e, True, f"Failed to cancel order {order}")
-                    return False
-                if order_status is enums.OrderStatus.CANCELED:
-                    order.status = octobot_trading.enums.OrderStatus.CANCELED
-                    self.logger.debug(f"Successfully cancelled order {order}")
-                elif order_status is enums.OrderStatus.PENDING_CANCEL:
-                    order.status = octobot_trading.enums.OrderStatus.PENDING_CANCEL
-                    self.logger.debug(f"Order cancel in progress for {order}")
-            else:
+                        self.logger.debug(f"Failed to cancel order ({err} {err.__class__.__name__}), retrying")
+                        order_status = await self.exchange_manager.exchange.cancel_order(
+                            order.order_id, order.symbol, order.order_type
+                        )
+            except errors.OrderCancelError as err:
+                if await self._handle_order_cancel_error(order, err, wait_for_cancelling, cancelling_timeout):
+                    return True
+            except Exception as e:
+                self.logger.exception(e, True, f"Failed to cancel order {order}")
+                return False
+            if order_status is enums.OrderStatus.CANCELED:
                 order.status = octobot_trading.enums.OrderStatus.CANCELED
+                self.logger.debug(f"Successfully cancelled order {order}")
+            elif order_status is enums.OrderStatus.PENDING_CANCEL:
+                order.status = octobot_trading.enums.OrderStatus.PENDING_CANCEL
+                self.logger.debug(f"Order cancel in progress for {order}")
+        else:
+            order.status = octobot_trading.enums.OrderStatus.CANCELED
 
         await order.on_cancel(force_cancel=order.status is octobot_trading.enums.OrderStatus.CANCELED,
                               is_from_exchange_data=False,
                               ignored_order=ignored_order)
         if wait_for_cancelling and order.state is not None and order.state.is_pending():
-            await order.state.wait_for_terminate(cancelling_timeout)
+            await self._wait_for_order_cancel(order, cancelling_timeout)
         return True
 
+    async def _handle_order_cancel_error(self, order, err, wait_for_cancelling, cancelling_timeout):
+        """
+        Use when an order can't be cancelled: it usually means that the order is not open on exchange anymore.
+        Will synch the given order on exchange to figure out the cancel issue if any.
+        Returns True when the order cancel ends up successful even though an error initially occurred
+        Raises OrderCancelError on unrecoverable cases
+        Raises a subclass of UnexpectedExchangeSideOrderStateError when the order is in a unexpected state
+        on exchange but is still manageable.
+        """
+        if order.state is None:
+            raise errors.OrderCancelError(
+                f"Error when cancelling order. This order state is unset, which makes "
+                f"it impossible to handle this the issue. Please report it if you see it."
+            ) from err
+        # trigger forced refresh to get an update of the order
+        if order.state.is_refreshing():
+            await order.state.wait_for_next_state(cancelling_timeout)
+        else:
+            previous_status = order.status
+            await order.state.synchronize(force_synchronization=True)
+            if previous_status != order.status:
+                # status changed: wait for state change
+                await order.state.wait_for_next_state(cancelling_timeout)
+        if order.is_cancelled():
+            self.logger.debug(f"Tried to cancel an already cancelled order.")
+            return True
+        if order.is_cancelling():
+            if wait_for_cancelling:
+                await self._wait_for_order_cancel(order, cancelling_timeout)
+            return True
+        elif order.is_open():
+            raise errors.OpenOrderError(
+                "Order is open, but can't be cancelled. This is unexpected"
+            ) from err
+        elif order.is_filled():
+            raise errors.FilledOrderError("Order is filled, it can't be cancelled") from err
+        elif order.is_closed():
+            raise errors.ClosedOrderError("Order is closed, it can't be cancelled") from err
+        else:
+            # should not happen
+            raise errors.OrderCancelError(
+                f"Can't cancel order and unknown post sync order state for order: {order}."
+            ) from err
+
+    async def _wait_for_order_cancel(self, order, cancelling_timeout):
+        self.logger.debug(f"Waiting for order cancelling, order: {order}")
+        await order.state.wait_for_terminate(cancelling_timeout)
+        self.logger.debug(f"Completed order cancelling, order: {order}")
+
     async def cancel_order_with_id(self, order_id, emit_trading_signals=False,
                                    wait_for_cancelling=True,
                                    cancelling_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT):
         """
         Gets order matching order_id from the OrderManager and calls self.cancel_order() on it
         :param order_id: Id of the order to cancel
         :param emit_trading_signals: when true, trading signals will be emitted
@@ -384,44 +465,49 @@
                 )
         except KeyError:
             return False
 
     async def cancel_open_orders(self, symbol, cancel_loaded_orders=True, side=None,
                                  emit_trading_signals=False,
                                  wait_for_cancelling=True,
-                                 cancelling_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT
+                                 cancelling_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT, 
+                                 since: typing.Union[int, float] = octobot_trading.constants.NO_DATA_LIMIT, 
+                                 until: typing.Union[int, float] = octobot_trading.constants.NO_DATA_LIMIT
                                  ) -> (bool, list):
         """
         Should be called only if the goal is to cancel all open orders for a given symbol
         :param symbol: The symbol to cancel all orders on
         :param cancel_loaded_orders: When True, also cancels loaded orders (order that are not from this bot instance)
         :param side: When set, only cancels orders from this side
         :param emit_trading_signals: when true, trading signals will be emitted
         :param wait_for_cancelling: when True, always make sure the order is completely cancelled before returning.
         :param cancelling_timeout: time before raising a timeout error when waiting for an order cancel
         :return: (True, orders): True if all orders got cancelled, False if an error occurred and the list of
         cancelled orders
         """
         all_cancelled = True
         cancelled_orders = []
-        for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders():
+        for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders(since=since, until=until):
             if order.symbol == symbol and \
                     (side is None or order.side is side) and \
-                    not order.is_cancelled() and \
+                    not (order.is_cancelled() or order.is_closed()) and \
                     (cancel_loaded_orders or order.is_from_this_octobot):
-                async with signals.remote_signal_publisher(self.exchange_manager, order.symbol, emit_trading_signals):
-                    cancelled = await signals.cancel_order(
-                        self.exchange_manager,
-                        emit_trading_signals and signals.should_emit_trading_signal(self.exchange_manager),
-                        order,
-                        wait_for_cancelling=wait_for_cancelling,
-                        cancelling_timeout=cancelling_timeout, )
-                if cancelled:
-                    cancelled_orders.append(order)
-                all_cancelled = cancelled and all_cancelled
+                try:
+                    async with signals.remote_signal_publisher(self.exchange_manager, order.symbol, emit_trading_signals):
+                        cancelled = await signals.cancel_order(
+                            self.exchange_manager,
+                            emit_trading_signals and signals.should_emit_trading_signal(self.exchange_manager),
+                            order,
+                            wait_for_cancelling=wait_for_cancelling,
+                            cancelling_timeout=cancelling_timeout, )
+                    if cancelled:
+                        cancelled_orders.append(order)
+                    all_cancelled = cancelled and all_cancelled
+                except (errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError) as err:
+                    self.logger.warning(f"Skipping order cancel: {err}")
         return all_cancelled, cancelled_orders
 
     async def cancel_all_open_orders_with_currency(
             self, currency, emit_trading_signals=False,
             wait_for_cancelling=True,
             cancelling_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT
     ) -> bool:
@@ -455,21 +541,27 @@
         :param wait_for_cancelling: when True, always make sure the order is completely cancelled before returning.
         :param cancelling_timeout: time before raising a timeout error when waiting for an order cancel
         :return: True if all orders got cancelled, False if an error occurred
         """
         all_cancelled = True
         for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders():
             if not order.is_cancelled():
-                async with signals.remote_signal_publisher(self.exchange_manager, order.symbol, emit_trading_signals):
-                    all_cancelled = await signals.cancel_order(
-                        self.exchange_manager,
-                        emit_trading_signals and signals.should_emit_trading_signal(self.exchange_manager),
-                        order,
-                        wait_for_cancelling=wait_for_cancelling,
-                        cancelling_timeout=cancelling_timeout, ) and all_cancelled
+                try:
+                    async with signals.remote_signal_publisher(
+                            self.exchange_manager, order.symbol, emit_trading_signals
+                    ):
+                        all_cancelled = await signals.cancel_order(
+                            self.exchange_manager,
+                            emit_trading_signals and signals.should_emit_trading_signal(self.exchange_manager),
+                            order,
+                            wait_for_cancelling=wait_for_cancelling,
+                            cancelling_timeout=cancelling_timeout, ) and all_cancelled
+                except (errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError) as err:
+                    self.logger.warning(f"Skipping order cancel: {err}")
+                    all_cancelled = False
         return all_cancelled
 
     async def _sell_everything(self, symbol, inverted, timeout=None):
         created_orders = []
         order_type = octobot_trading.enums.TraderOrderType.BUY_MARKET \
             if inverted else octobot_trading.enums.TraderOrderType.SELL_MARKET
         async with self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio.lock:
@@ -606,48 +698,54 @@
                                               f"but maximal value is {contract.maximum_leverage}")
         if contract.current_leverage != leverage:
             if not self.simulate:
                 await self.exchange_manager.exchange.set_symbol_leverage(
                     symbol=symbol,
                     leverage=leverage
                 )
+            self.logger.info(f"Switching {symbol} leverage from {contract.current_leverage} to {leverage}")
             contract.set_current_leverage(leverage)
 
     async def set_symbol_take_profit_stop_loss_mode(self, symbol, new_mode: enums.TakeProfitStopLossMode):
         """
         Updates the take profit and stop loss mode for the given symbol
         Raises NotImplementedError if the endpoint is not implemented on exchange
         :param symbol: the symbol to update
         :param new_mode: the take_profit_stop_loss_mode value
         """
         contract = self.exchange_manager.exchange.get_pair_future_contract(symbol)
         if contract.take_profit_stop_loss_mode != new_mode:
             if not self.simulate:
                 await self.exchange_manager.exchange.set_symbol_partial_take_profit_stop_loss(
                     symbol, contract.is_inverse_contract(), new_mode)
+            self.logger.info(
+                f"Switching {symbol} profit_stop_loss_mode from {contract.take_profit_stop_loss_mode} to {new_mode}"
+            )
             contract.set_take_profit_stop_loss_mode(new_mode)
 
     async def set_margin_type(self, symbol, side, margin_type):
         """
         Updates the symbol contract margin type
         TODO: recreate position instances if any
         :param symbol: the symbol to update
         :param side: the side to update (TODO)
         :param margin_type: the new margin type (enums.MarginType)
         """
         contract = self.exchange_manager.exchange.get_pair_future_contract(symbol)
-        if not self.simulate:
-            await self.exchange_manager.exchange.set_symbol_margin_type(
-                symbol=symbol,
-                isolated=margin_type is enums.MarginType.ISOLATED
+        if contract.margin_type != margin_type:
+            if not self.simulate:
+                await self.exchange_manager.exchange.set_symbol_margin_type(
+                    symbol=symbol,
+                    isolated=margin_type is enums.MarginType.ISOLATED
+                )
+            self.logger.info(f"Switching {symbol} margin_type from {contract.margin_type} to {margin_type}")
+            contract.set_margin_type(
+                is_isolated=margin_type is enums.MarginType.ISOLATED,
+                is_cross=margin_type is enums.MarginType.CROSS
             )
-        contract.set_margin_type(
-            is_isolated=margin_type is enums.MarginType.ISOLATED,
-            is_cross=margin_type is enums.MarginType.CROSS
-        )
 
     async def set_position_mode(self, symbol, position_mode):
         """
         Updates the symbol contract position mode
         :param symbol: the symbol to update
         :param position_mode: the new position mode (enums.PositionMode)
         """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/traders/trader_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/traders/trader_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/__init__.pxd` & `OctoBot-Trading-2.4.0/tests/exchange_data/contracts/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,19 +9,7 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-
-from octobot_trading.exchanges.types.rest_exchange cimport (
-    RestExchange,
-)
-from octobot_trading.exchanges.types.websocket_exchange cimport (
-    WebSocketExchange,
-)
-
-__all__ = [
-    "RestExchange",
-    "WebSocketExchange",
-]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,20 +10,26 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchanges.types import websocket_exchange
-from octobot_trading.exchanges.types.websocket_exchange import (
-    WebSocketExchange,
+from octobot_trading.personal_data.portfolios.types import future_portfolio
+from octobot_trading.personal_data.portfolios.types import margin_portfolio
+from octobot_trading.personal_data.portfolios.types import spot_portfolio
+
+from octobot_trading.personal_data.portfolios.types.future_portfolio import (
+    FuturePortfolio,
+)
+from octobot_trading.personal_data.portfolios.types.margin_portfolio import (
+    MarginPortfolio,
 )
-from octobot_trading.exchanges.types import rest_exchange
-from octobot_trading.exchanges.types.rest_exchange import (
-    RestExchange,
+from octobot_trading.personal_data.portfolios.types.spot_portfolio import (
+    SpotPortfolio,
 )
 
 __all__ = [
-    "WebSocketExchange",
-    "RestExchange",
+    "FuturePortfolio",
+    "MarginPortfolio",
+    "SpotPortfolio",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/rest_exchange.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/types/rest_exchange.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,36 +14,53 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import contextlib
 import decimal
 import typing
 import copy
 import asyncio
+import traceback
+import sys
 
 import ccxt.async_support as ccxt
 import octobot_commons.enums as commons_enums
 import octobot_commons.tree as commons_tree
 
 from octobot_commons import number_util
 
 import octobot_trading.enums as enums
+import octobot_trading.constants as constants
 import octobot_trading.errors as errors
 import octobot_trading.exchanges.util as exchanges_util
 import octobot_trading.exchanges.connectors.ccxt.ccxt_connector as ccxt_connector
 from octobot_trading.enums import ExchangeConstantsOrderColumns as ecoc
 import octobot_trading.exchanges.abstract_exchange as abstract_exchange
 import octobot_trading.exchange_data.contracts as contracts
 import octobot_trading.personal_data.orders as orders
 
 
-
 class RestExchange(abstract_exchange.AbstractExchange):
     ORDER_NON_EMPTY_FIELDS = [ecoc.ID.value, ecoc.TIMESTAMP.value, ecoc.SYMBOL.value, ecoc.TYPE.value,
                               ecoc.SIDE.value, ecoc.PRICE.value, ecoc.AMOUNT.value, ecoc.STATUS.value]
     ORDER_REQUIRED_FIELDS = ORDER_NON_EMPTY_FIELDS + [ecoc.REMAINING.value]
+    PRINT_DEBUG_LOGS = False
+    REQUIRE_ORDER_FEES_FROM_TRADES = False  # set True when get_order is not giving fees on closed orders and fees
+    # should be fetched using recent trades.
+    REQUIRE_CLOSED_ORDERS_FROM_RECENT_TRADES = False  # set True when get_closed_orders is not supported
+    ALLOW_TRADES_FROM_CLOSED_ORDERS = False  # set True when get_my_recent_trades should use get_closed_orders
+    DUMP_INCOMPLETE_LAST_CANDLE = False  # set True in tentacle when the exchange can return incomplete last candles
+    # Set True when exchange is not returning empty position details when fetching a position with a specified symbol
+    # Exchange will then fallback to self.get_mocked_empty_position when having get_position returning None
+    REQUIRES_MOCKED_EMPTY_POSITION = False
+    # set True when get_positions() is not returning empty positions and should use get_position() instead
+    REQUIRES_SYMBOL_FOR_EMPTY_POSITION = False
+    SUPPORTS_SET_MARGIN_TYPE = True  # set False when there is no API to switch between cross and isolated margin types
+    EXPECT_POSSIBLE_ORDER_NOT_FOUND_DURING_ORDER_CREATION = False  # set True when get_order() can return None
+    # (order not found) when orders are being created on exchange and are not fully processed on the exchange side.
+    REQUIRES_AUTHENTICATION = False  # set True when even normally public apis require authentication
     """
     RestExchange is using its exchange connector to interact with the exchange.
     It should be used regardless of the exchange or the exchange library (ccxt or other)
     Always take and returns octobot formatted data and errors
     Is used request regardless of the trading type (spot / future / other)
 
     Is extended in exchange tentacles to define custom behaviors or exchange adapter (override of get_adapter_class)
@@ -53,27 +70,33 @@
     MARK_PRICE_IN_POSITION = False
     MARK_PRICE_IN_TICKER = False
 
     # Funding rate params
     FUNDING_WITH_MARK_PRICE = False
     FUNDING_IN_TICKER = False
 
+    # Set when order cost is not (yet) accurately computed for a given exchange
+    MAX_INCREASED_POSITION_QUANTITY_MULTIPLIER = constants.ONE
+
     DEFAULT_CONNECTOR_CLASS = ccxt_connector.CCXTConnector
 
     def __init__(self, config, exchange_manager, connector_class=None):
         super().__init__(config, exchange_manager)
         self.connector = self._create_connector(config, exchange_manager, connector_class)
         self.pair_contracts = {}
+        self.update_supported_elements(exchange_manager)
 
     def _create_connector(self, config, exchange_manager, connector_class):
         return (connector_class or self.DEFAULT_CONNECTOR_CLASS)(
             config,
             exchange_manager,
             adapter_class=self.get_adapter_class(),
-            additional_config=self.get_additional_connector_config()
+            additional_config=self.get_additional_connector_config(),
+            rest_name=self.get_rest_name(),
+            force_auth=self.REQUIRES_AUTHENTICATION,
         )
 
     async def initialize_impl(self):
         await self.connector.initialize()
         self.symbols = self.connector.symbols
         self.time_frames = self.connector.time_frames
 
@@ -82,35 +105,44 @@
         self.exchange_manager = None
 
     @classmethod
     def get_name(cls):
         return cls.__name__
 
     @classmethod
+    def update_supported_elements(cls, exchange_manager):
+        pass
+
+    @classmethod
     def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
         return cls.get_name() == exchange_candidate_name
 
     @classmethod
     def get_supported_exchange_types(cls) -> list:
         """
         :return: The list of supported exchange types. Override if necessary
         """
         return [enums.ExchangeTypes.SPOT]
 
+    def get_rest_name(self):
+        return self.exchange_manager.exchange_class_string
+
     def get_adapter_class(self):
         # Override in tentacles when using a custom adapter
         return None
 
     async def create_order(self, order_type: enums.TraderOrderType, symbol: str, quantity: decimal.Decimal,
                            price: decimal.Decimal = None, stop_price: decimal.Decimal = None,
                            side: enums.TradeOrderSide = None, current_price: decimal.Decimal = None,
-                           params: dict = None) -> typing.Optional[dict]:
+                           reduce_only: bool = False, params: dict = None) -> typing.Optional[dict]:
         async with self._order_operation(order_type, symbol, quantity, price, stop_price):
-            created_order = await self._create_order_with_retry(order_type, symbol, quantity,
-                                                                price, side, current_price, params)
+            created_order = await self._create_order_with_retry(
+                order_type=order_type, symbol=symbol, quantity=quantity, price=price,
+                stop_price=stop_price, side=side, current_price=current_price,
+                reduce_only=reduce_only, params=params)
             self.logger.debug(f"Created order: {created_order}")
             return await self._verify_order(created_order, order_type, symbol, price, side)
         return None
 
     async def edit_order(self, order_id: str, order_type: enums.TraderOrderType, symbol: str,
                          quantity: decimal.Decimal, price: decimal.Decimal,
                          stop_price: decimal.Decimal = None, side: enums.TradeOrderSide = None,
@@ -142,29 +174,40 @@
 
     @contextlib.asynccontextmanager
     async def _order_operation(self, order_type, symbol, quantity, price, stop_price):
         try:
             yield
         except ccxt.InsufficientFunds as e:
             self.log_order_creation_error(e, order_type, symbol, quantity, price, stop_price)
-            self.logger.warning(str(e))
+            if self.__class__.PRINT_DEBUG_LOGS:
+                self.logger.warning(str(e))
             raise errors.MissingFunds(e)
         except ccxt.NotSupported:
             raise errors.NotSupported
+        except ccxt.DDoSProtection as e:
+            # raised upon rate limit issues, last response data might have details on what is happening
+            if self.should_log_on_ddos_exception(e):
+                self.connector.log_ddos_error(e)
+            raise errors.FailedRequest(f"Failed to order operation: {e.__class__.__name__} {e}") from e
         except Exception as e:
             self.log_order_creation_error(e, order_type, symbol, quantity, price, stop_price)
+            print(traceback.format_exc(), file=sys.stderr)
             self.logger.exception(e, False, f"Unexpected error during order operation: {e}")
 
-    async def _verify_order(self, created_order, order_type, symbol, price, side, params=None):
+    async def _verify_order(self, created_order, order_type, symbol, price, side, get_order_params=None):
         # some exchanges are not returning the full order details on creation: fetch it if necessary
         if created_order and not self._ensure_order_details_completeness(created_order):
             if ecoc.ID.value in created_order:
-                params = params or {}
+                order_id = created_order[ecoc.ID.value]
+                if order_id is None:
+                    self.logger.error(f"No order id on created order: {created_order}")
+                    return None
+                params = get_order_params or {}
                 fetched_order = await self.get_order(
-                    created_order[ecoc.ID.value], symbol=symbol, params=params
+                    created_order[ecoc.ID.value], symbol=symbol, **params
                 )
                 if fetched_order is None:
                     created_order[ecoc.STATUS.value] = enums.OrderStatus.PENDING_CREATION.value
                     # Order is created but not live on exchange. Consider it as pending.
                     # It will be updated later on via order updater
                     created_order[ecoc.SYMBOL.value] = symbol
                     created_order[ecoc.TYPE.value] = orders.get_trade_order_type(order_type).value
@@ -175,141 +218,170 @@
         # on some exchange, market order are not including price, add it manually to ensure uniformity
         if created_order is not None and created_order[ecoc.PRICE.value] is None and price is not None:
             created_order[ecoc.PRICE.value] = float(price)
 
         return created_order
 
     async def _create_order_with_retry(self, order_type, symbol, quantity: decimal.Decimal,
-                                       price: decimal.Decimal, side: enums.TradeOrderSide,
-                                       current_price: decimal.Decimal, params) -> dict:
+                                       price: decimal.Decimal, stop_price: decimal.Decimal, 
+                                       side: enums.TradeOrderSide,
+                                       current_price: decimal.Decimal, 
+                                       reduce_only: bool, params) -> dict:
         try:
-            return await self._create_specific_order(order_type, symbol, quantity, price=price, side=side,
-                                                     current_price=current_price, params=params)
+            return await self._create_specific_order(order_type, symbol, quantity, price=price,
+                                                     stop_price=stop_price, side=side,
+                                                     current_price=current_price, 
+                                                     reduce_only=reduce_only, params=params)
         except (ccxt.InvalidOrder, ccxt.BadRequest) as e:
             # can be raised when exchange precision/limits rules change
             self.logger.debug(f"Failed to create order ({e}) : order_type: {order_type}, symbol: {symbol}. "
                               f"This might be due to an update on {self.name} market rules. Fetching updated rules.")
             await self.connector.load_symbol_markets(reload=True)
             # retry order creation with updated markets (ccxt will use the updated market values)
-            return await self._create_specific_order(order_type, symbol, quantity, price=price, side=side,
-                                                     current_price=current_price, params=params)
+            return await self._create_specific_order(order_type, symbol, quantity, price=price, 
+                                                     stop_price=stop_price, side=side,
+                                                     current_price=current_price, reduce_only=reduce_only, 
+                                                     params=params)
 
     def _ensure_order_details_completeness(self, order, order_required_fields=None, order_non_empty_fields=None):
         if order_required_fields is None:
             order_required_fields = self.ORDER_REQUIRED_FIELDS
         if order_non_empty_fields is None:
             order_non_empty_fields = self.ORDER_NON_EMPTY_FIELDS
         # ensure all order_required_fields are present and all order_non_empty_fields are not empty
         return all(key in order for key in order_required_fields) and \
             all(order[key] for key in order_non_empty_fields)
 
     async def _create_specific_order(self, order_type, symbol, quantity: decimal.Decimal, price: decimal.Decimal = None,
-                                     side: enums.TradeOrderSide = None, current_price: decimal.Decimal = None,
-                                     params=None) -> dict:
+                                     side: enums.TradeOrderSide = None, current_price: decimal.Decimal = None, 
+                                     stop_price: decimal.Decimal = None, reduce_only: bool = False, params=None) -> dict:
         created_order = None
         float_quantity = float(quantity)
-        float_price = float(price)
-        float_current_price = float(current_price)
+        float_price = price if price is None else float(price)
+        float_stop_price = stop_price if stop_price is None else float(stop_price)
+        float_current_price = current_price if current_price is None else float(current_price)
         side = None if side is None else side.value
         params = {} if params is None else params
         params.update(self.exchange_manager.exchange_backend.get_orders_parameters(None))
         if order_type == enums.TraderOrderType.BUY_MARKET:
             created_order = await self._create_market_buy_order(symbol, float_quantity, price=float_price,
-                                                                params=params)
+                                                                reduce_only=reduce_only, params=params)
         elif order_type == enums.TraderOrderType.BUY_LIMIT:
             created_order = await self._create_limit_buy_order(symbol, float_quantity, price=float_price,
-                                                               params=params)
+                                                               reduce_only=reduce_only, params=params)
         elif order_type == enums.TraderOrderType.SELL_MARKET:
             created_order = await self._create_market_sell_order(symbol, float_quantity, price=float_price,
-                                                                 params=params)
+                                                                 reduce_only=reduce_only, params=params)
         elif order_type == enums.TraderOrderType.SELL_LIMIT:
             created_order = await self._create_limit_sell_order(symbol, float_quantity, price=float_price,
-                                                                params=params)
+                                                                reduce_only=reduce_only, params=params)
         elif order_type == enums.TraderOrderType.STOP_LOSS:
             created_order = await self._create_market_stop_loss_order(symbol, float_quantity, price=float_price,
                                                                       side=side, current_price=float_current_price,
                                                                       params=params)
         elif order_type == enums.TraderOrderType.STOP_LOSS_LIMIT:
             created_order = await self._create_limit_stop_loss_order(symbol, float_quantity, price=float_price,
-                                                                     side=side, params=params)
+                                                                     side=side, stop_price=float_stop_price, params=params)
         elif order_type == enums.TraderOrderType.TAKE_PROFIT:
             created_order = await self._create_market_take_profit_order(symbol, float_quantity, price=float_price,
                                                                         side=side, params=params)
         elif order_type == enums.TraderOrderType.TAKE_PROFIT_LIMIT:
             created_order = await self._create_limit_take_profit_order(symbol, float_quantity, price=float_price,
                                                                        side=side, params=params)
         elif order_type == enums.TraderOrderType.TRAILING_STOP:
             created_order = await self._create_market_trailing_stop_order(symbol, float_quantity, price=float_price,
-                                                                          side=side, params=params)
+                                                                          side=side, reduce_only=reduce_only, params=params)
         elif order_type == enums.TraderOrderType.TRAILING_STOP_LIMIT:
             created_order = await self._create_limit_trailing_stop_order(symbol, float_quantity, price=float_price,
-                                                                         side=side, params=params)
+                                                                         side=side, reduce_only=reduce_only, params=params)
         return created_order
 
-    async def _create_market_buy_order(self, symbol, quantity, price=None, params=None) -> dict:
-        return await self.connector.create_market_buy_order(symbol, quantity, params=params)
-
-    async def _create_limit_buy_order(self, symbol, quantity, price=None, params=None) -> dict:
-        return await self.connector.create_limit_buy_order(symbol, quantity, price, params=params)
-
-    async def _create_market_sell_order(self, symbol, quantity, price=None, params=None) -> dict:
-        return await self.connector.create_market_sell_order(symbol, quantity, params=params)
+    async def _create_market_buy_order(
+        self, symbol, quantity, price=None, reduce_only: bool = False, params=None
+        ) -> dict:
+        return await self.connector.create_market_buy_order(symbol, quantity, price=price, params=params)
+
+    async def _create_limit_buy_order(
+        self, symbol, quantity, price=None, reduce_only: bool = False, params=None
+        ) -> dict:
+        return await self.connector.create_limit_buy_order(
+            symbol, quantity, price, params=params
+            )
 
-    async def _create_limit_sell_order(self, symbol, quantity, price=None, params=None) -> dict:
-        return await self.connector.create_limit_sell_order(symbol, quantity, price, params=params)
+    async def _create_market_sell_order(
+        self, symbol, quantity, price=None, reduce_only: bool = False, params=None
+        ) -> dict:
+        return await self.connector.create_market_sell_order(symbol, quantity, price=price, params=params)
+
+    async def _create_limit_sell_order(
+        self, symbol, quantity, price=None, reduce_only: bool = False, params=None
+        ) -> dict:
+        return await self.connector.create_limit_sell_order(
+            symbol, quantity, price, params=params)
 
     async def _create_market_stop_loss_order(self, symbol, quantity, price, side, current_price, params=None) -> dict:
-        raise NotImplementedError("_create_market_stop_loss_order is not implemented")
-
-    async def _create_limit_stop_loss_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
-        raise NotImplementedError("_create_limit_stop_loss_order is not implemented")
+        return await self.connector.create_market_stop_loss_order(
+            symbol=symbol, quantity=quantity, price=price,
+            side=side, current_price=current_price, params=params)
+
+    async def _create_limit_stop_loss_order(self, symbol, quantity, price, stop_price, side, params=None) -> dict:
+        return await self.connector.create_limit_stop_loss_order(
+            symbol=symbol, quantity=quantity, price=price, stop_price=stop_price, side=side, params=params)
 
     async def _create_market_take_profit_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("_create_market_take_profit_order is not implemented")
 
     async def _create_limit_take_profit_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("_create_limit_take_profit_order is not implemented")
 
-    async def _create_market_trailing_stop_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
+    async def _create_market_trailing_stop_order(
+        self, symbol, quantity, price=None, side=None,
+        reduce_only: bool = False, params=None) -> dict:
         raise NotImplementedError("_create_market_trailing_stop_order is not implemented")
 
-    async def _create_limit_trailing_stop_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
+    async def _create_limit_trailing_stop_order(
+        
+        self, symbol, quantity, price=None, side=None,
+        reduce_only: bool = False, params=None) -> dict:
         raise NotImplementedError("_create_limit_trailing_stop_order is not implemented")
 
     def get_exchange_current_time(self):
         return self.connector.get_exchange_current_time()
 
     def get_uniform_timestamp(self, timestamp):
         return self.connector.get_uniform_timestamp(timestamp)
 
     def get_market_status(self, symbol, price_example=None, with_fixer=True):
         """
         Override using get_fixed_market_status in exchange tentacle if the default market status is not as expected
         """
         return self.connector.get_market_status(symbol, price_example=price_example, with_fixer=with_fixer)
 
-    def get_fixed_market_status(self, symbol, price_example=None, with_fixer=True, remove_price_limits=False):
+    def get_fixed_market_status(self, symbol, price_example=None, with_fixer=True, remove_price_limits=False,
+                                adapt_for_contract_size=False):
         """
         Use this method in local get_market_status overrides when market status has to be fixed by
         calling _fix_market_status.
         Changes PRECISION_AMOUNT and PRECISION_PRICE from decimals to integers
         (use number of digits instead of price example) by default.
         Override _fix_market_status to change other elements
         """
         market_status = self._fix_market_status(
             copy.deepcopy(
                 self.connector.get_market_status(symbol, with_fixer=False)
             ),
             remove_price_limits=remove_price_limits
         )
+        if adapt_for_contract_size and self.exchange_manager.is_future:
+            self._adapt_market_status_for_contract_size(market_status, self.get_contract_size(symbol))
         if with_fixer:
             return exchanges_util.ExchangeMarketStatusFixer(market_status, price_example).market_status
         return market_status
 
-    def _fix_market_status(self, market_status, remove_price_limits=False): # todo move to adapter
+    def _fix_market_status(self, market_status, remove_price_limits=False):  # todo move to adapter
         """
         Overrite if necessary
         """
         market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
             enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value] = number_util.get_digits_count(
             market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
                 enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value]
@@ -325,22 +397,45 @@
                 enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MIN.value] = None
             market_status[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][
                 enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE.value][
                 enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MAX.value] = None
 
         return market_status
 
+    def _apply_contract_size(self, value, contract_size):
+        if value is None:
+            return value
+        return value * contract_size
+
+    def _adapt_market_status_for_contract_size(self, market_status, contract_size):
+        float_size = float(contract_size)
+        for limit_type in (enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT.value, ):
+            for limit_val in (enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT_MIN.value,
+                              enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT_MAX.value):
+
+                market_status[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][limit_type][limit_val] = \
+                    self._apply_contract_size(
+                        market_status[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][limit_type][limit_val],
+                        float_size
+                    )
+        market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
+            enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value] = \
+            number_util.get_digits_count(float_size)
+
     async def get_balance(self, **kwargs: dict):
         return await self.connector.get_balance(**kwargs)
 
     async def get_symbol_prices(self, symbol: str, time_frame: commons_enums.TimeFrames, limit: int = None,
                                 **kwargs: dict) -> typing.Optional[list]:
         return await self.connector.get_symbol_prices(symbol=symbol, time_frame=time_frame, limit=limit, **kwargs)
 
-    async def get_kline_price(self, symbol: str, time_frame: commons_enums.TimeFrames, **kwargs: dict) -> typing.Optional[list]:
+    async def get_kline_price(self, symbol: str, time_frame: commons_enums.TimeFrames,
+                              **kwargs: dict) -> typing.Optional[list]:
+        if self.DUMP_INCOMPLETE_LAST_CANDLE:
+            raise errors.NotSupported(f"Can't fetch kline when the last candle from exchange can't be fetched")
         return await self.connector.get_kline_price(symbol=symbol, time_frame=time_frame, **kwargs)
 
     async def get_order_book(self, symbol: str, limit: int = 5, **kwargs: dict) -> typing.Optional[dict]:
         return await self.connector.get_order_book(symbol=symbol, limit=limit, **kwargs)
 
     async def get_recent_trades(self, symbol: str, limit: int = 50, **kwargs: dict) -> typing.Optional[list]:
         return await self.connector.get_recent_trades(symbol=symbol, limit=limit, **kwargs)
@@ -348,15 +443,18 @@
     async def get_price_ticker(self, symbol: str, **kwargs: dict) -> typing.Optional[dict]:
         return await self.connector.get_price_ticker(symbol=symbol, **kwargs)
 
     async def get_all_currencies_price_ticker(self, **kwargs: dict) -> typing.Optional[list]:
         return await self.connector.get_all_currencies_price_ticker(**kwargs)
 
     async def get_order(self, order_id: str, symbol: str = None, **kwargs: dict) -> dict:
-        return await self.connector.get_order(symbol=symbol, order_id=order_id, **kwargs)
+        return await self._ensure_order_completeness(
+            await self.connector.get_order(order_id, symbol=symbol, **kwargs),
+            symbol, **kwargs
+        )
 
     async def get_order_from_open_and_closed_orders(self, order_id: str, symbol: str = None, **kwargs: dict) -> dict:
         for order in await self.get_open_orders(symbol, **kwargs):
             if order[enums.ExchangeConstantsOrderColumns.ID.value] == order_id:
                 return order
         for order in await self.get_closed_orders(symbol, **kwargs):
             if order[enums.ExchangeConstantsOrderColumns.ID.value] == order_id:
@@ -365,47 +463,93 @@
 
     async def get_order_from_trades(self, symbol, order_id, order_to_update=None):
         order_to_update = order_to_update or {}
         trades = await self.get_my_recent_trades(symbol)
         # usually the right trade is within the last ones
         for trade in trades[::-1]:
             if trade[ecoc.ORDER.value] == order_id:
-                order_to_update[ecoc.INFO.value] = trade[ecoc.INFO.value]
-                order_to_update[ecoc.ID.value] = order_id
-                order_to_update[ecoc.SYMBOL.value] = symbol
-                order_to_update[ecoc.TYPE.value] = trade[ecoc.TYPE.value]
-                order_to_update[ecoc.AMOUNT.value] = trade[ecoc.AMOUNT.value]
-                order_to_update[ecoc.DATETIME.value] = trade[ecoc.DATETIME.value]
-                order_to_update[ecoc.SIDE.value] = trade[ecoc.SIDE.value]
-                order_to_update[ecoc.TAKER_OR_MAKER.value] = trade[ecoc.TAKER_OR_MAKER.value]
-                order_to_update[ecoc.PRICE.value] = trade[ecoc.PRICE.value]
-                order_to_update[ecoc.TIMESTAMP.value] = order_to_update.get(ecoc.TIMESTAMP.value,
-                                                                            trade[ecoc.TIMESTAMP.value])
-                order_to_update[ecoc.STATUS.value] = enums.OrderStatus.FILLED.value
-                order_to_update[ecoc.FILLED.value] = trade[ecoc.AMOUNT.value]
-                order_to_update[ecoc.COST.value] = trade[ecoc.COST.value]
-                order_to_update[ecoc.REMAINING.value] = 0
-                order_to_update[ecoc.FEE.value] = trade[ecoc.FEE.value]
-                return order_to_update
+                return exchanges_util.update_raw_order_from_raw_trade(order_to_update, trade)
         return None  #OrderNotFound
 
     async def get_all_orders(self, symbol: str = None, since: int = None, limit: int = None, **kwargs: dict) -> list:
-        return await self.connector.get_all_orders(symbol=symbol, since=since, limit=limit, **kwargs)
+        return await self._ensure_orders_completeness(
+            await self.connector.get_all_orders(symbol=symbol, since=since, limit=limit, **kwargs),
+            symbol, since=since, limit=limit, **kwargs
+        )
 
     async def get_open_orders(self, symbol: str = None, since: int = None, limit: int = None, **kwargs: dict) -> list:
-        return await self.connector.get_open_orders(symbol=symbol, since=since, limit=limit, **kwargs)
+        return await self._ensure_orders_completeness(
+            await self.connector.get_open_orders(symbol=symbol, since=since, limit=limit, **kwargs),
+            symbol, since=since, limit=limit, **kwargs
+        )
 
     async def get_closed_orders(self, symbol: str = None, since: int = None, limit: int = None, **kwargs: dict) -> list:
-        return await self.connector.get_closed_orders(symbol=symbol, since=since, limit=limit, **kwargs)
+        try:
+            return await self._ensure_orders_completeness(
+                await self.connector.get_closed_orders(symbol=symbol, since=since, limit=limit, **kwargs),
+                symbol, since=since, limit=limit, **kwargs
+            )
+        except errors.NotSupported:
+            if self.REQUIRE_CLOSED_ORDERS_FROM_RECENT_TRADES:
+                return await self._get_closed_orders_from_my_recent_trades(
+                    symbol=symbol, since=since, limit=limit, **kwargs
+                )
+            raise
+
+    async def _get_closed_orders_from_my_recent_trades(
+        self, symbol: str = None, since: int = None, limit: int = None, **kwargs: dict
+    ) -> list:
+        trades = await self.get_my_recent_trades(symbol, since=since, limit=limit, **kwargs)
+        return [
+            exchanges_util.update_raw_order_from_raw_trade({}, trade)
+            for trade in trades
+        ]
+
+    async def _ensure_orders_completeness(
+        self, raw_orders, symbol, since=None, limit=None, trades_by_order_id=None, **kwargs
+    ):
+        if not self.REQUIRE_ORDER_FEES_FROM_TRADES \
+                or not any(exchanges_util.is_missing_trading_fees(order) for order in raw_orders):
+            return raw_orders
+        trades_by_order_id = trades_by_order_id or await self._get_trades_by_order_id(
+            symbol=symbol, since=since, limit=limit, **kwargs
+        )
+        return [
+            await self._ensure_order_completeness(order, symbol, trades_by_order_id=trades_by_order_id, **kwargs)
+            for order in raw_orders
+        ]
+
+    async def _ensure_order_completeness(
+        self, raw_order, symbol, since=None, limit=None, trades_by_order_id=None, **kwargs
+    ):
+        if not self.REQUIRE_ORDER_FEES_FROM_TRADES or not exchanges_util.is_missing_trading_fees(raw_order):
+            return raw_order
+        trades_by_order_id = trades_by_order_id or await self._get_trades_by_order_id(
+            symbol=symbol, since=since, limit=limit, **kwargs
+        )
+        exchanges_util.apply_trades_fees(raw_order, trades_by_order_id)
+        return raw_order
+
+    async def _get_trades_by_order_id(self, symbol=None, since=None, limit=None, **kwargs):
+        trades_by_order_id = {}
+        for trade in await self.get_my_recent_trades(symbol=symbol, since=since, limit=limit, **kwargs):
+            order_id = trade[enums.ExchangeConstantsOrderColumns.ORDER.value]
+            if order_id in trades_by_order_id:
+                trades_by_order_id[order_id].append(trade)
+            else:
+                trades_by_order_id[order_id] = [trade]
+        return trades_by_order_id
 
     async def get_my_recent_trades(self, symbol: str = None, since: int = None, limit: int = None, **kwargs: dict) -> list:
         return await self.connector.get_my_recent_trades(symbol=symbol, since=since, limit=limit, **kwargs)
 
-    async def cancel_order(self, order_id: str, symbol: str = None, **kwargs: dict) -> enums.OrderStatus:
-        return await self.connector.cancel_order(symbol=symbol, order_id=order_id, **kwargs)
+    async def cancel_order(
+            self, order_id: str, symbol: str, order_type: enums.TraderOrderType, **kwargs: dict
+    ) -> enums.OrderStatus:
+        return await self.connector.cancel_order(order_id, symbol, order_type, **kwargs)
 
     def get_trade_fee(self, symbol, order_type, quantity, price, taker_or_maker):
         return self.connector.get_trade_fee(symbol, order_type, quantity, price, taker_or_maker)
 
     def get_fees(self, symbol):
         return self.connector.get_fees(symbol)
 
@@ -436,51 +580,60 @@
         Load and create a new FutureContract for the pair
         :param pair: the contract pair
         """
         try:
             return self.create_pair_contract(
                 pair=pair,
                 current_leverage=await self.get_symbol_leverage(pair),
+                contract_size=self.get_contract_size(pair),
                 margin_type=await self.get_margin_type(pair),
                 contract_type=self.get_contract_type(pair),
                 position_mode=await self.get_position_mode(pair),
                 maintenance_margin_rate=await self.get_maintenance_margin_rate(pair),
             )
         except NotImplementedError:
             try:
                 positions = [await self.get_position(pair)]
             except NotImplementedError:
                 positions = await self.get_positions(symbols=[pair])
             contracts.update_contracts_from_positions(self.exchange_manager, positions)
 
-    def create_pair_contract(self, pair, current_leverage, margin_type,
+    def create_pair_contract(self, pair, current_leverage, contract_size, margin_type,
                              contract_type, position_mode, maintenance_margin_rate, maximum_leverage=None):
         """
         Create a new FutureContract for the pair
         # TODO: support 1 contract by side when using hedge position mode --> think about another way to store contracts
         :param pair: the contract pair
         :param current_leverage: the contract current leverage
         :param margin_type: the contract margin type
+        :param contract_size: the size of a contract
         :param contract_type: the contract type
         :param position_mode: the contract position mode
         :param maintenance_margin_rate: the contract maintenance margin rate
         :param maximum_leverage: the contract maximum leverage
         """
         self.logger.debug(f"Creating {pair} contract...")
         contract = contracts.FutureContract(pair=pair,
+                                            contract_size=contract_size,
                                             margin_type=margin_type,
                                             contract_type=contract_type,
                                             maximum_leverage=maximum_leverage,
                                             current_leverage=current_leverage,
                                             position_mode=position_mode,
                                             maintenance_margin_rate=maintenance_margin_rate)
         self.pair_contracts[pair] = contract
-        self._set_contract_initialized_event(pair)
         return contract
 
+    def has_pair_future_contract(self, pair):
+        """
+        :param pair: the pair
+        :return: True if the given pair is in local contracts
+        """
+        return pair in self.pair_contracts
+
     def get_pair_future_contract(self, pair):
         """
         Return the FutureContract instance associated to the pair
         :param pair: the pair
         :return: the FutureContract instance
         """
         try:
@@ -493,41 +646,61 @@
         """
         Set the future contract
         :param pair: the pair
         :param future_contract: the future contract
         """
         self.pair_contracts[pair] = future_contract
 
-    def _set_contract_initialized_event(self, symbol):
+    def set_contract_initialized_event(self, symbol):
         commons_tree.EventProvider.instance().trigger_event(
             self.exchange_manager.bot_id, commons_tree.get_exchange_path(
                 self.exchange_manager.exchange_name,
                 commons_enums.InitializationEventExchangeTopics.CONTRACTS.value,
                 symbol=symbol
             )
         )
 
     """
     Positions
     """
 
     async def get_position(self, symbol: str, **kwargs: dict) -> dict:
         """
-        Get the current user symbol position list
+        Get the current user symbol position
         :param symbol: the position symbol
-        :return: the user symbol position list
+        :return: the user symbol position
         """
-        return await self.connector.get_position(symbol=symbol, **kwargs)
+        position = await self.connector.get_position(symbol=symbol, **kwargs)
+        if position is None and self.REQUIRES_MOCKED_EMPTY_POSITION:
+            # this exchange does not support empty position fetching, create an empty position from available data
+            return await self.get_mocked_empty_position(symbol, **kwargs)
+        return position
 
     async def get_positions(self, symbols=None, **kwargs: dict) -> list:
         """
         Get the current user position list
         :return: the user position list
         """
-        return await self.connector.get_positions(symbols=symbols, **kwargs)
+        if not self.REQUIRES_SYMBOL_FOR_EMPTY_POSITION:
+            return await self.connector.get_positions(symbols=symbols, **kwargs)
+        if symbols is None:
+            raise NotImplementedError(f"The symbols param is required to get multiple positions at once")
+        # force get_position when symbols is set as ccxt get_positions is only returning open positions
+        return [
+            await self.get_position(symbol, **kwargs)
+            for symbol in symbols
+        ]
+
+    async def get_mocked_empty_position(self, symbol: str, **kwargs: dict) -> dict:
+        """
+        Override when necessary
+        Called when self.REQUIRES_MOCKED_EMPTY_POSITION is True and a fetched position is None
+        :param symbol: the position symbol
+        """
+        return await self.connector.get_mocked_empty_position(symbol=symbol, **kwargs)
 
     async def get_funding_rate(self, symbol: str, **kwargs: dict) -> dict:
         """
         :param symbol: the symbol
         :return: the current symbol funding rate
         """
         return await self.connector.get_funding_rate(symbol=symbol, **kwargs)
@@ -540,21 +713,28 @@
         """
         return await self.connector.get_funding_rate_history(symbol=symbol, limit=limit, **kwargs)
 
     """
     Margin and leverage
     """
 
-    async def get_symbol_leverage(self, symbol: str):
+    async def get_symbol_leverage(self, symbol: str, **kwargs: dict):
         """
         :param symbol: the symbol
         :return: the current symbol leverage multiplier
         """
         raise NotImplementedError("get_symbol_leverage is not implemented")
 
+    async def get_leverage_tiers(self, symbols: list = None, **kwargs: dict)-> dict:
+        """
+        :param symbols: the symbols or None
+        :return: the current leverage tiers by symbols
+        """
+        return await self.connector.get_leverage_tiers(symbols=symbols, **kwargs)
+
     async def get_margin_type(self, symbol: str):
         """
         :param symbol: the symbol
         :return: the margin type for the requested symbol. Can be MarginType.ISOLATED or MarginType.CROSS
         """
         raise NotImplementedError("get_margin_type is not implemented")
 
@@ -566,45 +746,54 @@
         Requires is_inverse_symbol and is_linear_symbol to be implemented
         """
         if self.is_linear_symbol(symbol):
             return enums.FutureContractType.LINEAR_PERPETUAL
         if self.is_inverse_symbol(symbol):
             return enums.FutureContractType.INVERSE_PERPETUAL
 
+    def get_contract_size(self, symbol: str):
+        """
+        :param symbol: the symbol
+        :return: the contract size for the requested symbol.
+        """
+        return self.connector.get_contract_size(symbol)
+
     async def get_position_mode(self, symbol: str):
         """
         :param symbol: the symbol
         :return: the position mode for the requested symbol. Can be PositionMode HEDGE or ONE_WAY
         """
         raise NotImplementedError("get_position_mode is not implemented")
 
     async def get_maintenance_margin_rate(self, symbol: str):
         """
         :param symbol: the symbol
         :return: the symbol maintenance margin rate
         """
         raise NotImplementedError("get_maintenance_margin_rate is not implemented")
 
-    async def set_symbol_leverage(self, symbol: str, leverage: int, **kwargs):
+    async def set_symbol_leverage(self, symbol: str, leverage: float, **kwargs):
         """
         Set the symbol leverage
         :param symbol: the symbol
         :param leverage: the leverage
         :return: the update result
         """
         return await self.connector.set_symbol_leverage(leverage=leverage, symbol=symbol, **kwargs)
 
-    async def set_symbol_margin_type(self, symbol: str, isolated: bool):
+    async def set_symbol_margin_type(self, symbol: str, isolated: bool, **kwargs: dict):
         """
         Set the symbol margin type
         :param symbol: the symbol
         :param isolated: when False, margin type is cross, else it's isolated
         :return: the update result
         """
-        return await self.connector.set_symbol_margin_type(symbol=symbol, isolated=isolated)
+        if self.SUPPORTS_SET_MARGIN_TYPE:
+            return await self.connector.set_symbol_margin_type(symbol=symbol, isolated=isolated, **kwargs)
+        raise errors.NotSupported(f"set_symbol_margin_type is not supported on {self.get_name()}")
 
     async def set_symbol_position_mode(self, symbol: str, one_way: bool):
         """
         Set the symbol margin type
         :param symbol: the symbol
         :param one_way: when False, position mode is hedge, else it's one_way
         :return: the update result
@@ -629,30 +818,34 @@
     def is_inverse_symbol(self, symbol):
         """
         :param symbol: the symbol
         :return: True if the symbol is related to an inverse contract
         """
         return self.supports_trading_type(symbol, enums.FutureContractType.INVERSE_PERPETUAL)
 
+    def is_expirable_symbol(self, symbol):
+        """
+        :param symbol: the symbol
+        :return: True if the symbol is related to a contract having an expiration date
+        """
+        return self.connector.is_expirable_symbol(symbol)
+
     """
     Parsers todo remove ?
     """
 
     def parse_order_book_ticker(self, order_book_ticker):
         return self.connector.parse_order_book_ticker(order_book_ticker)
 
     def parse_order_id(self, order):
         return self.connector.parse_order_id(order)
 
     def parse_order_symbol(self, order):
         return self.connector.parse_order_symbol(order)
 
-    def parse_status(self, status):
-        return self.connector.parse_status(status)
-
     def parse_funding(self, funding_dict, from_ticker=False) -> dict:
         """
         :param from_ticker: when True, the funding dict is extracted from ticker data
         :param funding_dict: the funding dict
         :return: the uniformized funding dict
         """
         return self.connector.parse_funding(funding_dict, from_ticker=from_ticker)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/types/websocket_exchange.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/types/websocket_exchange.py`

 * *Files 3% similar despite different names*

```diff
@@ -49,14 +49,15 @@
         raise NotImplementedError("get_exchange_connector_class is not implemented")
 
     def create_feeds(self):
         raise NotImplementedError("create_feeds is not implemented")
 
     async def init_websocket(self, time_frames, trader_pairs, tentacles_setup_config):
         self.websocket_connector = self.get_exchange_connector_class(self.exchange_manager)
+        self.websocket_connector.update_exchange_feeds(self.exchange_manager)
         self.pairs = trader_pairs
         self.time_frames = time_frames
 
         if self.pairs:
             # unauthenticated
             await self.add_feed(octobot_trading.enums.WebsocketFeeds.TRADES)
             await self.add_feed(octobot_trading.enums.WebsocketFeeds.L1_BOOK)
@@ -115,14 +116,23 @@
     def get_name(cls):
         return cls.__name__
 
     @classmethod
     def has_name(cls, exchange_manager: object) -> bool:  # pylint: disable=arguments-renamed
         return cls.get_exchange_connector_class(exchange_manager) is not None
 
+    def is_time_frame_related_feed(self, feed):
+        return self.websocket_connectors[0].is_time_frame_related_feed(feed)
+
+    def is_time_frame_supported(self, time_frame):
+        return all([
+            connector.is_time_frame_supported(time_frame)
+            for connector in self.websocket_connectors
+        ])
+
     async def start_sockets(self):
         if any(self.handled_feeds.values() and self.websocket_connectors):
             try:
                 self.websocket_connectors_executors = futures.ThreadPoolExecutor(
                     max_workers=len(self.websocket_connectors),
                     thread_name_prefix=f"{self.get_name()}-{self.exchange_name}-pool-executor"
                 )
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -10,41 +10,59 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.exchanges.util cimport exchange_market_status_fixer
-from octobot_trading.exchanges.util.exchange_market_status_fixer cimport (
+from octobot_trading.exchanges.util import exchange_market_status_fixer
+from octobot_trading.exchanges.util.exchange_market_status_fixer import (
     ExchangeMarketStatusFixer,
     is_ms_valid,
 )
-from octobot_trading.exchanges.util cimport exchange_util
-from octobot_trading.exchanges.util.exchange_util cimport (
+from octobot_trading.exchanges.util import exchange_util
+from octobot_trading.exchanges.util.exchange_util import (
     get_rest_exchange_class,
     get_order_side,
+    log_time_sync_error,
+    get_partners_explanation_message,
+    get_enabled_exchanges,
+    is_compatible_account,
+    get_historical_ohlcv,
     get_exchange_type,
     get_default_exchange_type,
     get_supported_exchange_types,
+    update_raw_order_from_raw_trade,
+    is_missing_trading_fees,
+    apply_trades_fees,
     get_exchange_class_from_name,
 )
-from octobot_trading.exchanges.util cimport websockets_util
-from octobot_trading.exchanges.util.websockets_util cimport (
+from octobot_trading.exchanges.util import websockets_util
+from octobot_trading.exchanges.util.websockets_util import (
     force_disable_web_socket,
     check_web_socket_config,
     search_websocket_class,
+    supports_websocket,
 )
 
 __all__ = [
     "ExchangeMarketStatusFixer",
     "is_ms_valid",
     "get_rest_exchange_class",
     "get_order_side",
-    "force_disable_web_socket",
-    "check_web_socket_config",
-    "search_websocket_class",
+    "log_time_sync_error",
+    "get_partners_explanation_message",
+    "get_enabled_exchanges",
+    "is_compatible_account",
+    "get_historical_ohlcv",
     "get_exchange_type",
     "get_default_exchange_type",
     "get_supported_exchange_types",
+    "update_raw_order_from_raw_trade",
+    "is_missing_trading_fees",
+    "apply_trades_fees",
     "get_exchange_class_from_name",
+    "force_disable_web_socket",
+    "check_web_socket_config",
+    "search_websocket_class",
+    "supports_websocket",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchanges/implementations/test_default_rest_exchange.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=E0611
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -9,52 +10,59 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import octobot_trading.exchanges as exchanges
+import octobot_commons.enums as commons_enums
+import pytest
 
-from octobot_trading.exchanges.util import exchange_market_status_fixer
-from octobot_trading.exchanges.util.exchange_market_status_fixer import (
-    ExchangeMarketStatusFixer,
-    is_ms_valid,
-)
-from octobot_trading.exchanges.util import exchange_util
-from octobot_trading.exchanges.util.exchange_util import (
-    get_rest_exchange_class,
-    get_order_side,
-    log_time_sync_error,
-    get_partners_explanation_message,
-    is_compatible_account,
-    get_historical_ohlcv,
-    get_exchange_type,
-    get_default_exchange_type,
-    get_supported_exchange_types,
-    get_exchange_class_from_name,
-)
-from octobot_trading.exchanges.util import websockets_util
-from octobot_trading.exchanges.util.websockets_util import (
-    force_disable_web_socket,
-    check_web_socket_config,
-    search_websocket_class,
-    supports_websocket,
-)
-
-__all__ = [
-    "ExchangeMarketStatusFixer",
-    "is_ms_valid",
-    "get_rest_exchange_class",
-    "get_order_side",
-    "log_time_sync_error",
-    "get_partners_explanation_message",
-    "is_compatible_account",
-    "get_historical_ohlcv",
-    "get_exchange_type",
-    "get_default_exchange_type",
-    "get_supported_exchange_types",
-    "get_exchange_class_from_name",
-    "force_disable_web_socket",
-    "check_web_socket_config",
-    "search_websocket_class",
-    "supports_websocket",
-]
+from tests.exchanges import exchange_manager, DEFAULT_EXCHANGE_NAME
+
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
+
+
+class MockedCCXTConnector(exchanges.CCXTConnector):
+    @classmethod
+    def get_name(cls):
+        return DEFAULT_EXCHANGE_NAME
+
+
+class MockedRestExchange(exchanges.DefaultRestExchange):
+    DEFAULT_CONNECTOR_CLASS = MockedCCXTConnector
+
+    @classmethod
+    def get_exchange_connector_class(cls, exchange_manager):
+        return cls.DEFAULT_CONNECTOR_CLASS
+
+
+@pytest.fixture
+def default_rest_exchange(exchange_manager):
+    return MockedRestExchange(exchange_manager.config, exchange_manager)
+
+
+async def test_start_request_data_and_stop(default_rest_exchange):
+    await default_rest_exchange.initialize()
+    symbol = "BTC/USDT"
+    try:
+        assert len(default_rest_exchange.symbols) > 10
+        assert len(default_rest_exchange.time_frames) > 5
+        market_status = default_rest_exchange.get_market_status(symbol)
+        assert isinstance(market_status, dict)
+        assert market_status
+        ohlcv = await default_rest_exchange.get_symbol_prices(symbol, commons_enums.TimeFrames.ONE_HOUR)
+        assert isinstance(ohlcv, list)
+        assert len(ohlcv) > 50
+        trades = await default_rest_exchange.get_recent_trades(symbol)
+        assert isinstance(trades, list)
+        assert len(trades) > 5
+        ticker = await default_rest_exchange.get_price_ticker(symbol)
+        assert isinstance(ticker, dict)
+        assert ticker
+        book = await default_rest_exchange.get_order_book(symbol)
+        assert isinstance(book, dict)
+        assert book
+    finally:
+        await default_rest_exchange.stop()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/exchange_market_status_fixer.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/exchange_market_status_fixer.py`

 * *Files 2% similar despite different names*

```diff
@@ -79,60 +79,50 @@
         Ecmsc.LIMITS_AMOUNT_MIN.value in limit_amount and Ecmsc.LIMITS_PRICE_MIN.value in limit_price:
         if is_ms_valid(limit_amount[Ecmsc.LIMITS_AMOUNT_MIN.value]) \
                 and is_ms_valid(limit_price[Ecmsc.LIMITS_PRICE_MIN.value]):
             limit_cost[Ecmsc.LIMITS_COST_MIN.value] = limit_amount[Ecmsc.LIMITS_AMOUNT_MIN.value] * \
                                                       limit_price[Ecmsc.LIMITS_PRICE_MIN.value]
 
 
-def calculate_prices(market_limit):
-    limit_cost, limit_price, limit_amount = get_markets_limit(market_limit)
+def update_prices(market_limit):
+    _, limit_price, _ = get_markets_limit(market_limit)
 
-    if not is_ms_valid(limit_price[Ecmsc.LIMITS_PRICE_MAX.value]) and \
-        Ecmsc.LIMITS_COST_MAX.value in limit_cost and Ecmsc.LIMITS_AMOUNT_MAX.value in limit_amount:
-        if is_ms_valid(limit_cost[Ecmsc.LIMITS_COST_MAX.value]) \
-                and is_ms_valid(limit_amount[Ecmsc.LIMITS_AMOUNT_MAX.value]) \
-                and limit_amount[Ecmsc.LIMITS_AMOUNT_MAX.value] > 0:
-            limit_price[Ecmsc.LIMITS_PRICE_MAX.value] = limit_cost[Ecmsc.LIMITS_COST_MAX.value] / \
-                                                        limit_amount[Ecmsc.LIMITS_AMOUNT_MAX.value]
-
-    if not is_ms_valid(limit_price[Ecmsc.LIMITS_PRICE_MIN.value]) and \
-            Ecmsc.LIMITS_COST_MIN.value in limit_cost and Ecmsc.LIMITS_AMOUNT_MIN.value in limit_amount:
-        if is_ms_valid(limit_cost[Ecmsc.LIMITS_COST_MIN.value]) \
-                and is_ms_valid(limit_amount[Ecmsc.LIMITS_AMOUNT_MIN.value]) \
-                and limit_amount[Ecmsc.LIMITS_AMOUNT_MIN.value] > 0:
-            limit_price[Ecmsc.LIMITS_PRICE_MIN.value] = limit_cost[Ecmsc.LIMITS_COST_MIN.value] / \
-                                                        limit_amount[Ecmsc.LIMITS_AMOUNT_MIN.value]
+    if not is_ms_valid(limit_price[Ecmsc.LIMITS_PRICE_MAX.value]):
+        limit_price[Ecmsc.LIMITS_PRICE_MAX.value] = None
+
+    if not is_ms_valid(limit_price[Ecmsc.LIMITS_PRICE_MIN.value]):
+        limit_price[Ecmsc.LIMITS_PRICE_MIN.value] = None
 
 
 def fix_market_status_limits_from_current_data(market_limit):
     # calculate cost
     if not (check_market_status_values(market_limit[Ecmsc.LIMITS_COST.value].values())):
         calculate_costs(market_limit)
 
     # calculate amounts
     if not (check_market_status_values(market_limit[Ecmsc.LIMITS_AMOUNT.value].values())):
         calculate_amounts(market_limit)
 
-    # calculate prices
+    # set price to None if missing
     if not (check_market_status_values(market_limit[Ecmsc.LIMITS_PRICE.value].values())):
-        calculate_prices(market_limit)
+        update_prices(market_limit)
 
     if not is_ms_valid(
             market_limit[Ecmsc.LIMITS_COST.value][Ecmsc.LIMITS_COST_MIN.value]):
         market_limit[Ecmsc.LIMITS_COST.value][Ecmsc.LIMITS_COST_MIN.value] = 0
 
 
 class ExchangeMarketStatusFixer:
     # todo move to connector/ccxt
     LIMIT_PRICE_MULTIPLIER = 1000
     LIMIT_COST_MULTIPLIER = 1
 
     # calculated from popular exchanges
-    LIMIT_AMOUNT_MAX_SUP_ATTENUATION = 6  # when log(price, 10) >= 0
-    LIMIT_AMOUNT_MAX_MINUS_3_ATTENUATION = 1  # when log(price, 10) > -3
+    LIMIT_AMOUNT_MAX_SUP_ATTENUATION = 8  # when log(price, 10) >= 0
+    LIMIT_AMOUNT_MAX_MINUS_3_ATTENUATION = 8  # when log(price, 10) < 0
     LIMIT_AMOUNT_MIN_ATTENUATION = 3  # when log(price, 10) < 0
     LIMIT_AMOUNT_MIN_SUP_ATTENUATION = 1  # when log(price, 10) >= 0
 
     """
     Utility class that performs exchange_self.market_status fixes
     """
 
@@ -247,19 +237,30 @@
         else:
             amount_min = 10 ** -(amount_log_price + self.LIMIT_AMOUNT_MIN_ATTENUATION)
             amount_max = 10 ** (-amount_log_price + self.LIMIT_AMOUNT_MAX_MINUS_3_ATTENUATION)
 
         return amount_min, amount_max
 
     def _fix_market_status_limits_with_price(self):
-        # self.LIMIT_AMOUNT_MULTIPLIER
-        amount_min, amount_max = self._calculate_amount()
-        price_max = self.price_example * self.LIMIT_PRICE_MULTIPLIER
-        price_min = self.price_example / self.LIMIT_PRICE_MULTIPLIER
-
+        candidate_amount_min, candidate_amount_max = self._calculate_amount()
+        limits_amount = self.market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_AMOUNT.value]
+        amount_min = limits_amount.get(Ecmsc.LIMITS_PRICE_MIN.value)
+        if not is_ms_valid(amount_min, zero_valid=True):
+            amount_min = candidate_amount_min
+        amount_max = limits_amount.get(Ecmsc.LIMITS_AMOUNT_MAX.value)
+        if not is_ms_valid(amount_max, zero_valid=False):
+            amount_max = candidate_amount_max
+
+        limits_price = self.market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_PRICE.value]
+        price_min = limits_price.get(Ecmsc.LIMITS_PRICE_MIN.value)
+        if not is_ms_valid(price_min, zero_valid=True):
+            price_min = self.price_example / self.LIMIT_PRICE_MULTIPLIER
+        price_max = limits_price.get(Ecmsc.LIMITS_PRICE_MAX.value)
+        if not is_ms_valid(price_max, zero_valid=False):
+            price_max = self.price_example * self.LIMIT_PRICE_MULTIPLIER
         self.market_status[Ecmsc.LIMITS.value] = {
             Ecmsc.LIMITS_AMOUNT.value: {
                 Ecmsc.LIMITS_AMOUNT_MIN.value: amount_min,
                 Ecmsc.LIMITS_AMOUNT_MAX.value: amount_max,
             },
             Ecmsc.LIMITS_PRICE.value: {
                 Ecmsc.LIMITS_PRICE_MIN.value: price_min,
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/exchanges/util/websockets_util.py` & `OctoBot-Trading-2.4.0/octobot_trading/exchanges/util/websockets_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/abstract_trading_mode.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/abstract_trading_mode.py`

 * *Files 5% similar despite different names*

```diff
@@ -39,14 +39,15 @@
 import octobot_trading.signals as signals
 
 
 class AbstractTradingMode(abstract_tentacle.AbstractTentacle):
     __metaclass__ = abc.ABCMeta
     USER_INPUT_TENTACLE_TYPE = common_enums.UserInputTentacleTypes.TRADING_MODE
     ALLOW_CUSTOM_TRIGGER_SOURCE = False
+    HISTORIZE_USER_INPUT_CONFIG = True
 
     MODE_PRODUCER_CLASSES = []
     MODE_CONSUMER_CLASSES = []
     # maximum seconds before sending a trading signal if orders are slow to create on exchange
     TRADING_SIGNAL_TIMEOUT = 10
 
     def __init__(self, config, exchange_manager):
@@ -243,22 +244,32 @@
             self.logger.debug(f"{services_channels.UserCommandsChannel.get_name()} unavailable")
         except ImportError:
             self.logger.warning("Can't connect to services channels")
         return None
 
     async def user_commands_callback(self, bot_id, subject, action, data) -> None:
         self.logger.debug(f"Received {action} command")
+        if action == common_enums.UserCommands.MANUAL_TRIGGER.value:
+            self.logger.debug(f"Triggering trading mode from {action} command with data: {data}")
+            await self._manual_trigger(data)
         if action == common_enums.UserCommands.RELOAD_CONFIG.value:
             await self.reload_config(bot_id)
             self.logger.debug("Reloaded configuration")
         elif action == common_enums.UserCommands.CLEAR_PLOTTING_CACHE.value:
             await modes_util.clear_plotting_cache(self)
         elif action == common_enums.UserCommands.CLEAR_SIMULATED_ORDERS_CACHE.value:
             await modes_util.clear_simulated_orders_cache(self)
 
+    async def _manual_trigger(self, data):
+        kwargs = {
+            "trigger_source": common_enums.TriggerSource.MANUAL.value
+        }
+        kwargs.update(data.get("kwargs", {}))
+        for producer in self.producers:
+            await producer.trigger(**kwargs)
 
     async def _create_mode_consumer(self, mode_consumer_class):
         """
         Creates a new :mode_consumer_class: instance and subscribe this new consumer to the trading mode channel
         :param mode_consumer_class: the trading mode consumer class to create
         :return: the consumer class created
         """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/modes/channel/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,29 +10,33 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.modes.channel cimport mode
-from octobot_trading.modes.channel.mode cimport (
+from octobot_trading.modes.channel import mode
+from octobot_trading.modes.channel.mode import (
     ModeChannelConsumer,
     ModeChannelProducer,
     ModeChannel,
 )
-from octobot_trading.modes.channel cimport abstract_mode_producer
-from octobot_trading.modes.channel.abstract_mode_producer cimport (
-    AbstractTradingModeProducer,
-)
-from octobot_trading.modes.channel cimport abstract_mode_consumer
-from octobot_trading.modes.channel.abstract_mode_consumer cimport (
+
+from octobot_trading.modes.channel import abstract_mode_producer
+from octobot_trading.modes.channel import abstract_mode_consumer
+
+from octobot_trading.modes.channel.abstract_mode_consumer import (
     AbstractTradingModeConsumer,
+    check_factor,
+)
+from octobot_trading.modes.channel.abstract_mode_producer import (
+    AbstractTradingModeProducer,
 )
 
 __all__ = [
     "ModeChannelConsumer",
     "ModeChannelProducer",
     "ModeChannel",
     "AbstractTradingModeProducer",
     "AbstractTradingModeConsumer",
+    "check_factor",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/channel/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/scripted_trading_mode/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -10,33 +10,18 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.modes.channel import mode
-from octobot_trading.modes.channel.mode import (
-    ModeChannelConsumer,
-    ModeChannelProducer,
-    ModeChannel,
-)
-
-from octobot_trading.modes.channel import abstract_mode_producer
-from octobot_trading.modes.channel import abstract_mode_consumer
 
-from octobot_trading.modes.channel.abstract_mode_consumer import (
-    AbstractTradingModeConsumer,
-    check_factor,
-)
-from octobot_trading.modes.channel.abstract_mode_producer import (
-    AbstractTradingModeProducer,
+from octobot_trading.modes.scripted_trading_mode import abstract_scripted_trading_mode
+from octobot_trading.modes.scripted_trading_mode.abstract_scripted_trading_mode import (
+    AbstractScriptedTradingMode,
+    AbstractScriptedTradingModeProducer,
 )
 
 __all__ = [
-    "ModeChannelConsumer",
-    "ModeChannelProducer",
-    "ModeChannel",
-    "AbstractTradingModeProducer",
-    "AbstractTradingModeConsumer",
-    "check_factor",
+    "AbstractScriptedTradingMode",
+    "AbstractScriptedTradingModeProducer",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/channel/abstract_mode_consumer.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/channel/abstract_mode_consumer.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,14 +10,16 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import asyncio
+
 import octobot_commons.symbols as symbol_util
 import octobot_commons.constants as commons_constants
 
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.modes.channel as modes_channel
 import octobot_trading.enums as enums
 import octobot_trading.errors as errors
@@ -44,18 +46,27 @@
         self.exchange_manager = None
 
     async def internal_callback(self, trading_mode_name, cryptocurrency, symbol, time_frame, final_note, state, data):
         # creates a new order (or multiple split orders), always check self.can_create_order() first.
         try:
             await self.create_order_if_possible(symbol, final_note, state, data=data)
         except errors.MissingMinimalExchangeTradeVolume:
-            self.logger.info(f"Not enough funds to create a new order: {self.exchange_manager.exchange_name} "
-                             f"exchange minimal order volume has not been reached.")
+            market_status = self.exchange_manager.exchange.get_market_status(symbol, price_example=None, with_fixer=False)
+            self.logger.info(f"Not enough funds to create a new {symbol} order after {final_note} evaluation: "
+                             f"{self.exchange_manager.exchange_name} exchange minimal order "
+                             f"volume has not been reached. "
+                             f"Exchanges requirements are: {market_status.get(Ecmsc.LIMITS.value)}")
+        except errors.UnhandledContractError as err:
+            self.logger.error(f"Unhandled contract error on {self.exchange_manager.exchange_name}: {err}. "
+                              f"Please make sure that {symbol} is the full futures contract symbol. "
+                              f"Future contract symbols contain the settlement currency after ':'. "
+                              f"Example: use BTC/USDT:USDT for linear BTC/USDT contracts and "
+                              f"BTC/USD:BTC for inverse BTC/USD contracts.")
         except errors.OrderCreationError:
-            self.logger.info(f"Failed order creation on: {self.exchange_manager.exchange_name} "
+            self.logger.info(f"Failed {symbol} order creation on: {self.exchange_manager.exchange_name} "
                              f"an unexpected error happened when creating order. This is likely due to "
                              f"the order being refused by the exchange.")
 
     async def init_user_inputs(self, should_clear_inputs):
         pass
 
     async def create_new_orders(self, symbol, final_note, state, **kwargs):
@@ -109,15 +120,15 @@
 
         if self.exchange_manager.is_future:
             # future: need settlement asset and to take the open positions into account
             current_symbol_holding, _, market_quantity, current_price, _ = \
                 await personal_data.get_pre_order_data(self.exchange_manager,
                                                        symbol=symbol,
                                                        timeout=constants.ORDER_DATA_FETCHING_TIMEOUT,
-                                                       portfolio_type=commons_constants.PORTFOLIO_TOTAL)
+                                                       portfolio_type=commons_constants.PORTFOLIO_AVAILABLE)
             side = enums.TradeOrderSide.SELL \
                 if state == enums.EvaluatorStates.VERY_SHORT.value or state == enums.EvaluatorStates.SHORT.value \
                 else enums.TradeOrderSide.BUY
             max_order_size, _ = personal_data.get_futures_max_order_size(
                 self.exchange_manager, symbol, side, current_price, False, current_symbol_holding, market_quantity
             )
             return max_order_size > symbol_min_amount
@@ -138,14 +149,45 @@
         return self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder \
             .get_currency_holding_ratio(currency)
 
     def get_number_of_traded_assets(self):
         return len(self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder
                    .origin_crypto_currencies_values)
 
+    async def wait_for_active_position(self, symbol, timeout, side=None) -> bool:
+        """
+        Instantly return when the position is already active.
+        Wait for the given timeout if the position is not active.
+        :return: Return True when the position is active
+        """
+        if self.exchange_manager.is_backtesting:
+            # never wait in backtesting
+            return True
+        if not self.exchange_manager.exchange.has_pair_future_contract(symbol):
+            self.logger.error(f"Missing required contract for {symbol}")
+            return False
+        if not self.exchange_manager.exchange.get_pair_future_contract(symbol).is_one_way_position_mode() \
+                and side is None:
+            raise errors.NotSupported("The side parameter is required when dealing with non one-way contracts")
+        position = self.exchange_manager.exchange_personal_data.positions_manager.get_symbol_position(
+            symbol,
+            side or enums.PositionSide.BOTH
+        )
+        if position.state is None:
+            self.logger.error(f"Can't wait for active position: position state is unset for position: {position}")
+            return False
+        else:
+            if not position.state.is_active():
+                try:
+                    self.logger.debug(f"Waiting for position idle to be active, position: {position}")
+                    await position.state.wait_for_next_state(timeout)
+                except asyncio.TimeoutError:
+                    self.logger.debug(f"Timeout while waiting for idle position to be active, position: {position}")
+        return position.state.is_active()
+
 
 def check_factor(min_val, max_val, factor):
     """
     Checks if factor is min_val < factor < max_val
     :param min_val:
     :param max_val:
     :param factor:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/channel/abstract_mode_producer.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/channel/abstract_mode_producer.py`

 * *Files 15% similar despite different names*

```diff
@@ -29,26 +29,28 @@
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
 import octobot_trading.util as util
 import octobot_trading.exchanges.exchanges as exchanges
 import octobot_trading.exchange_channel as exchanges_channel
 import octobot_trading.modes.channel as modes_channel
 import octobot_trading.modes.script_keywords as script_keywords
+import octobot_trading.storage.util as storage_util
 
 
 class AbstractTradingModeProducer(modes_channel.ModeChannelProducer):
     TOPIC_TO_CHANNEL_NAME = {
         common_enums.ActivationTopics.FULL_CANDLES.value:
             channels_name.OctoBotTradingChannelsName.OHLCV_CHANNEL.value,
         common_enums.ActivationTopics.IN_CONSTRUCTION_CANDLES.value:
             channels_name.OctoBotTradingChannelsName.KLINE_CHANNEL.value,
         common_enums.ActivationTopics.EVALUATION_CYCLE.value:
             channels_name.OctoBotEvaluatorsChannelsName.MATRIX_CHANNEL.value,
     }
-    CONFIG_INIT_TIMEOUT = 30
+    CONFIG_INIT_TIMEOUT = 1 * common_constants.MINUTE_TO_SECONDS    # let time for orders to be fetched before
+    # declaring timeout at first trigger
 
     def __init__(self, channel, config, trading_mode, exchange_manager):
         super().__init__(channel)
         # the trading mode instance logger
         self.logger = logging.get_logger(self.__class__.__name__)
 
         # the trading mode instance
@@ -78,14 +80,16 @@
 
         self.time_frame_filter = None
 
         # Define trading modes default consumer priority level
         self.priority_level: int = channel_enums.ChannelConsumerPriorityLevels.MEDIUM.value
 
         self.symbol = None
+
+        self._is_ready_to_trade = None
         self.on_reload_config()
 
     def on_reload_config(self):
         """
         Called at constructor and after the associated trading mode's reload_config.
         Implement if necessary
         """
@@ -112,14 +116,22 @@
         But can overwritten (with return False) to disable wildcard trigger when get_is_time_frame_wildcard() is True
         :return: True if the mode producer should be triggered by all timeframes
         """
         return self.trading_mode.get_is_time_frame_wildcard()
 
     # noinspection PyArgumentList
     async def start(self) -> None:
+        self._is_ready_to_trade = asyncio.Event()
+        try:
+            await self.inner_start()
+        finally:
+            self.logger.debug("Ready to trade")
+            self._is_ready_to_trade.set()
+
+    async def inner_start(self) -> None:
         """
         Start trading mode channels subscriptions
         """
         registration_topics = self.get_channels_registration()
         trigger_time_frames = self.get_trigger_time_frames()
         currency_filter = self.trading_mode.cryptocurrency \
             if self.trading_mode.cryptocurrency is not None and not self.is_cryptocurrency_wildcard() \
@@ -138,14 +150,15 @@
             missing_time_frames = [tf for tf in trigger_time_frames if tf not in self.time_frame_filter]
             self.logger.error(f"Missing timeframe to satisfy {trigger_time_frames} required time frames. "
                               f"Please activate those timeframes {missing_time_frames}")
         self.matrix_id = exchanges.Exchanges.instance().get_exchange(self.exchange_manager.exchange_name,
                                                                      self.exchange_manager.id).matrix_id
         await self._subscribe_to_registration_topic(registration_topics, currency_filter, symbol_filter)
         await self.init_user_inputs(False)
+        await self._wait_for_bot_init(self.CONFIG_INIT_TIMEOUT)
 
     async def _subscribe_to_registration_topic(self, registration_topics, currency_filter, symbol_filter):
         for registration_topic in registration_topics:
             if registration_topic == channels_name.OctoBotEvaluatorsChannelsName.MATRIX_CHANNEL.value:
                 # register to matrix channel if necessary
                 try:
                     import octobot_evaluators.evaluators.channel as evaluators_channel
@@ -258,53 +271,83 @@
         :param exchange_name: the exchange name
         :param cryptocurrency: the cryptocurrency
         :param symbol: the symbol
         :param time_frame: the time frame
         """
         if time_frame is None or time_frame in self.time_frame_filter:
             await self.finalize(exchange_name=exchange_name, matrix_id=matrix_id, cryptocurrency=cryptocurrency,
-                                symbol=symbol, time_frame=time_frame)
+                                symbol=symbol, time_frame=time_frame,
+                                trigger_source=common_enums.TriggerSource.EVALUATION_MATRIX.value)
 
     async def finalize(self, exchange_name: str,
                        matrix_id: str,
                        cryptocurrency: str = None,
                        symbol: str = None,
-                       time_frame=None) -> None:
+                       time_frame=None,
+                       trigger_source: str = common_enums.TriggerSource.UNDEFINED.value
+                       ) -> None:
         """
         Finalize evaluation
         """
         if exchange_name != self.exchange_name or not self.exchange_manager.trader.is_enabled:
             # Do nothing if not its exchange
             return
+        await self.trigger(matrix_id, cryptocurrency, symbol, time_frame, trigger_source)
 
-        async with self.trading_mode_trigger(), self.trading_mode.remote_signal_publisher(symbol):
-            await self.set_final_eval(matrix_id=matrix_id,
-                                      cryptocurrency=cryptocurrency,
-                                      symbol=symbol,
-                                      time_frame=time_frame)
+    async def trigger(self, matrix_id: str = None, cryptocurrency: str = None, symbol: str = None, time_frame = None,
+                      trigger_source: str = common_enums.TriggerSource.UNDEFINED.value) -> None:
+        """
+        Called by finalize and MANUAL_TRIGGER user command. Override if necessary
+        """
+        try:
+            async with self.trading_mode_trigger(), self.trading_mode.remote_signal_publisher(symbol):
+                await self.set_final_eval(matrix_id=matrix_id,
+                                          cryptocurrency=cryptocurrency,
+                                          symbol=symbol,
+                                          time_frame=time_frame,
+                                          trigger_source=trigger_source)
+        except errors.InitializingError as e:
+            self.logger.exception(
+                e,
+                True,
+                f"Ignored signal: "
+                f"Trading mode is not yet ready to trade, OctoBot is still initializing and fetching required data."
+            )
 
     @contextlib.asynccontextmanager
     async def trading_mode_trigger(self):
         try:
+            if not self._is_ready_to_trade.is_set():
+                if self.exchange_manager.is_backtesting:
+                    raise asyncio.TimeoutError(f"Trading mode producer has to be started in backtesting")
+                self.logger.debug("Waiting for orders initialization to proceed")
+                try:
+                    await asyncio.wait_for(self._is_ready_to_trade.wait(), self.CONFIG_INIT_TIMEOUT)
+                except asyncio.TimeoutError as e:
+                    raise errors.InitializingError() from e
+                self.logger.debug("Order initialized")
             yield
+        except errors.InitializingError:
+            raise
         except errors.UnreachableExchange as e:
             self.logger.warning(f"Error when calling trading mode: {e}")
+        except AttributeError:
+            if self._is_ready_to_trade is None:
+                raise AttributeError(f"{self.__class__.__name__} has to be started. self._is_ready_to_trade is None")
+            raise
         except Exception as e:
             self.logger.exception(e, True, f"Error when calling trading mode: {e}")
         finally:
             await self.post_trigger()
 
     async def post_trigger(self):
-        if not self.exchange_manager.is_backtesting:
-            # update db after each run only in live mode
-            for database in self.all_databases().values():
-                if database:
-                    await database.flush()
+        pass
 
-    async def set_final_eval(self, matrix_id: str, cryptocurrency: str, symbol: str, time_frame) -> None:
+    async def set_final_eval(self, matrix_id: str, cryptocurrency: str, symbol: str, time_frame,
+                             trigger_source: str) -> None:
         """
         Called to calculate the final note or state => when any notification appears
         """
         raise NotImplementedError("set_final_eval not implemented")
 
     async def submit_trading_evaluation(self, cryptocurrency, symbol, time_frame,
                                         final_note=constants.ZERO,
@@ -335,22 +378,23 @@
         if self.exchange_manager.trader.is_enabled:
             return (await self.exchange_manager.trader.cancel_open_orders(
                 symbol, cancel_loaded_orders, emit_trading_signals=self.trading_mode.should_emit_trading_signal()))[0]
         return True
 
     def all_databases(self):
         provider = databases.RunDatabasesProvider.instance()
+        account_type = storage_util.get_account_type_suffix_from_exchange_manager(self.exchange_manager)
         return {
             common_enums.RunDatabases.RUN_DATA_DB.value: provider.get_run_db(self.trading_mode.bot_id),
             common_enums.RunDatabases.ORDERS_DB.value:
-                provider.get_orders_db(self.trading_mode.bot_id, self.exchange_name),
+                provider.get_orders_db(self.trading_mode.bot_id, account_type, self.exchange_name),
             common_enums.RunDatabases.TRADES_DB.value:
-                provider.get_trades_db(self.trading_mode.bot_id, self.exchange_name),
+                provider.get_trades_db(self.trading_mode.bot_id, account_type, self.exchange_name),
             common_enums.RunDatabases.TRANSACTIONS_DB.value:
-                provider.get_transactions_db(self.trading_mode.bot_id, self.exchange_name),
+                provider.get_transactions_db(self.trading_mode.bot_id, account_type, self.exchange_name),
             self.trading_mode.symbol:
                 provider.get_symbol_db(self.trading_mode.bot_id, self.exchange_name, self.trading_mode.symbol)
                 if self.trading_mode.symbol else None,
         }
 
     async def _wait_for_symbol_init(self, symbol, time_frame, timeout) -> bool:
         try:
@@ -360,14 +404,25 @@
                 await util.wait_for_topic_init(self.exchange_manager, timeout,
                                                common_enums.InitializationEventExchangeTopics.CONTRACTS.value, symbol)
             return True
         except (asyncio.TimeoutError, concurrent.futures.TimeoutError):
             self.logger.error(f"Initialization took more than {timeout} seconds")
         return False
 
+    async def _wait_for_bot_init(self, timeout) -> bool:
+        try:
+            self.logger.debug("Trading mode start complete. Now waiting for orders full initialisation.")
+            await util.wait_for_topic_init(self.exchange_manager, timeout,
+                                           common_enums.InitializationEventExchangeTopics.ORDERS.value)
+            self.logger.debug("Trading mode start complete. Orders initialisation completed.")
+            return True
+        except (asyncio.TimeoutError, concurrent.futures.TimeoutError):
+            self.logger.error(f"Initialization took more than {timeout} seconds")
+        return False
+
     async def init_user_inputs(self, should_clear_inputs):
         if should_clear_inputs:
             await commons_configuration.clear_user_inputs(
                 databases.RunDatabasesProvider.instance().get_run_db(self.trading_mode.bot_id)
             )
         await self._register_and_apply_required_user_inputs(
             script_keywords.get_base_context(self.trading_mode, init_call=True)
@@ -387,10 +442,11 @@
                 activation_topic_values
             )
         await self._apply_exchange_side_config(context)
 
     async def _apply_exchange_side_config(self, context):
         # can be slow, call in a task if necessary
         if context.exchange_manager.is_future:
-            await util.wait_for_topic_init(self.exchange_manager, self.CONFIG_INIT_TIMEOUT,
-                                           common_enums.InitializationEventExchangeTopics.CONTRACTS.value)
+            if not self._is_ready_to_trade.is_set():
+                await util.wait_for_topic_init(self.exchange_manager, self.CONFIG_INIT_TIMEOUT,
+                                               common_enums.InitializationEventExchangeTopics.CONTRACTS.value)
             await script_keywords.set_leverage(context, await script_keywords.user_select_leverage(context))
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/channel/mode.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/channel/mode.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/mode_config.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/mode_config.py`

 * *Files 8% similar despite different names*

```diff
@@ -62,15 +62,15 @@
         order=commons_configuration.UserInput.MAX_ORDER - 2
     ):
         trading_mode.UI.user_input(
             common_constants.CONFIG_TRADING_SIGNALS_STRATEGY, common_enums.UserInputTypes.TEXT, trading_mode.get_name(),
             inputs,
             title="Name of the strategy to send signals on.",
             order=commons_configuration.UserInput.MAX_ORDER - 1,
-            other_schema_values={"minLength": 0}
+            other_schema_values={"minLength": 0},
         )
 
 
 def is_trading_signal_emitter(trading_mode) -> bool:
     """
     :return: True if the mode should be emitting trading signals according to configuration
     """
@@ -85,24 +85,29 @@
         f"use the following syntax: " \
         f"0.1 to trade 0.1 BTC on BTC/USD, " \
         f"2{dsl.QuantityType.PERCENT.value} to trade 2% of the total portfolio value, " \
         f"12{dsl.QuantityType.AVAILABLE_PERCENT.value} to trade 12% of the available holdings, " \
         f"Leave empty to auto-compute the amount."
 
 
-def user_select_order_amount(trading_mode, inputs: dict, include_buy=True, include_sell=True):
+def user_select_order_amount(trading_mode, inputs: dict, include_buy=True, include_sell=True,
+                             buy_dependencies=None, sell_dependencies=None):
     if include_buy:
         trading_mode.UI.user_input(
-                constants.CONFIG_BUY_ORDER_AMOUNT, common_enums.UserInputTypes.TEXT, "", inputs,
-                title=_get_order_amount_title("buy"), other_schema_values={"minLength": 0}
+            constants.CONFIG_BUY_ORDER_AMOUNT, common_enums.UserInputTypes.TEXT, "", inputs,
+            title=_get_order_amount_title("buy"),
+            other_schema_values={"minLength": 0},
+            editor_options={"dependencies": buy_dependencies} if buy_dependencies else None,
         )
     if include_sell:
         trading_mode.UI.user_input(
-                constants.CONFIG_SELL_ORDER_AMOUNT, common_enums.UserInputTypes.TEXT, "", inputs,
-                title=_get_order_amount_title("sell"), other_schema_values={"minLength": 0}
+            constants.CONFIG_SELL_ORDER_AMOUNT, common_enums.UserInputTypes.TEXT, "", inputs,
+            title=_get_order_amount_title("sell"),
+            other_schema_values={"minLength": 0},
+            editor_options={"dependencies": sell_dependencies} if sell_dependencies else None,
         )
 
 
 def get_user_selected_order_amount(trading_mode, side) -> str:
     try:
         if side is enums.TradeOrderSide.SELL:
             return trading_mode.trading_config[constants.CONFIG_SELL_ORDER_AMOUNT]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/modes_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/modes_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/modes_util.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/modes_util.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,34 +10,38 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_commons.databases as databases
+import octobot_commons.constants as common_constants
 import octobot_tentacles_manager.api as tentacles_manager_api
 import octobot_trading.constants as constants
-import octobot_commons.constants as common_constants
+import octobot_trading.storage as storage
 import octobot_trading.modes.script_keywords.basic_keywords as basic_keywords
 
 
 def get_required_candles_count(trading_mode_class, tentacles_setup_config):
     return tentacles_manager_api.get_tentacle_config(tentacles_setup_config, trading_mode_class).get(
         constants.CONFIG_CANDLES_HISTORY_SIZE_KEY,
         common_constants.DEFAULT_IGNORED_VALUE
     )
 
 
 async def clear_simulated_orders_cache(trading_mode):
     await basic_keywords.clear_orders_cache(
         databases.RunDatabasesProvider.instance().get_orders_db(
-            trading_mode.bot_id, trading_mode.exchange_manager.exchange_name
+            trading_mode.bot_id,
+            storage.get_account_type_suffix_from_exchange_manager(trading_mode.exchange_manager),
+            trading_mode.exchange_manager.exchange_name
         )
     )
 
 
 async def clear_plotting_cache(trading_mode):
     await basic_keywords.clear_symbol_plot_cache(
         databases.RunDatabasesProvider.instance().get_symbol_db(
-            trading_mode.bot_id, trading_mode.exchange_manager.exchange_name, trading_mode.symbol
+            trading_mode.bot_id,
+            trading_mode.exchange_manager.exchange_name, trading_mode.symbol
         )
     )
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -37,15 +37,14 @@
     get_amount_from_input_amount,
     total_account_balance,
     available_account_balance,
     adapt_amount_to_holdings,
     account_holdings,
     get_order_size_portfolio_percent,
     set_plot_orders,
-    store_orders,
 )
 
 from octobot_trading.modes.script_keywords import context_management
 from octobot_trading.modes.script_keywords.context_management import (
     get_base_context,
     get_full_context,
     Context,
@@ -70,12 +69,11 @@
     "get_amount_from_input_amount",
     "total_account_balance",
     "available_account_balance",
     "adapt_amount_to_holdings",
     "account_holdings",
     "get_order_size_portfolio_percent",
     "set_plot_orders",
-    "store_orders",
     "get_base_context",
     "get_full_context",
     "Context",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -49,15 +49,14 @@
     emit_trading_signals,
 )
 
 
 from octobot_trading.modes.script_keywords.basic_keywords.run_persistence import (
     disable_candles_plot,
     set_plot_orders,
-    store_orders,
     clear_orders_cache,
     clear_symbol_plot_cache,
 )
 
 
 __all__ = [
     "user_input",
@@ -75,11 +74,10 @@
     "total_account_balance",
     "available_account_balance",
     "adapt_amount_to_holdings",
     "account_holdings",
     "get_order_size_portfolio_percent",
     "disable_candles_plot",
     "set_plot_orders",
-    "store_orders",
     "clear_orders_cache",
     "clear_symbol_plot_cache",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/amount.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/amount.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/configuration.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/configuration.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,18 +9,18 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import decimal
 
 
-def is_emitting_trading_signals(ctx):
-    return ctx.is_trading_signal_emitter()
-
-
-async def emit_trading_signals(ctx):
-    try:
-        return await ctx.emit_signal()
-    except Exception as e:
-        ctx.logger.exception(e, True, f"Error when emitting trading signal: {e}")
+def create_historical_asset_value_from_dict_like_object(historical_asset_class, asset_values):
+    return historical_asset_class(
+        asset_values[historical_asset_class.TIMESTAMP_KEY],
+        {
+            currency: decimal.Decimal(f"{value}")
+            for currency, value in asset_values[historical_asset_class.VALUES_KEY].items()
+        }
+    )
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/context_management.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/context_management.py`

 * *Files 5% similar despite different names*

```diff
@@ -25,14 +25,15 @@
 import octobot_commons.display as commons_display
 import octobot_commons.optimization_campaign as optimization_campaign
 import octobot_commons.tree.base_tree as event_tree
 import octobot_commons.signals as signals
 import octobot_backtesting.api as backtesting_api
 import octobot_trading.modes as modes
 import octobot_trading.signals as trading_signals
+import octobot_trading.storage.util as storage_util
 import octobot_tentacles_manager.api as tentacles_manager_api
 import octobot_tentacles_manager.models as tentacles_manager_models
 
 
 def get_base_context(trading_mode, symbol=None, init_call=False):
     return get_full_context(trading_mode, None, None, symbol, None, None, None, None, None, init_call=init_call)
 
@@ -101,26 +102,36 @@
         self.logger = logger
         bot_id = exchange_manager.bot_id if \
             (exchange_manager is not None) \
             and (exchange_manager.bot_id is not None) \
             and databases.RunDatabasesProvider.instance().is_storage_enabled(
                 exchange_manager.bot_id
             ) else None
-        self.run_data_writer = databases.RunDatabasesProvider.instance().get_run_db(bot_id) \
-            if bot_id else None
-        self.orders_writer = databases.RunDatabasesProvider.instance().get_orders_db(bot_id, self.exchange_name) \
-            if bot_id else None
-        self.trades_writer = databases.RunDatabasesProvider.instance().get_trades_db(bot_id, self.exchange_name) \
-            if bot_id else None
-        self.transaction_writer = databases.RunDatabasesProvider.instance().get_transactions_db(bot_id,
-                                                                                                self.exchange_name) \
-            if bot_id else None
-        self.symbol_writer = databases.RunDatabasesProvider.instance().get_symbol_db(bot_id, self.exchange_name,
-                                                                                     self.symbol) \
-            if bot_id else None
+        self.run_data_writer = self.orders_writer = self.trades_writer = self.transaction_writer = self.symbol_writer \
+            = None
+        if bot_id:
+            self.run_data_writer = databases.RunDatabasesProvider.instance().get_run_db(bot_id)
+            account_type = None
+            if self.exchange_manager is not None:
+                account_type = storage_util.get_account_type_suffix_from_exchange_manager(self.exchange_manager)
+            elif self.run_data_writer is not None:
+                account_type = storage_util.get_account_type_suffix_from_run_metadata(self.run_data_writer)
+            self.symbol_writer = databases.RunDatabasesProvider.instance().get_symbol_db(
+                bot_id, self.exchange_name, self.symbol
+            ) if self.symbol else None
+            if account_type is not None:
+                self.orders_writer = databases.RunDatabasesProvider.instance().get_orders_db(
+                    bot_id, account_type, self.exchange_name
+                )
+                self.trades_writer = databases.RunDatabasesProvider.instance().get_trades_db(
+                    bot_id, account_type, self.exchange_name
+                )
+                self.transaction_writer = databases.RunDatabasesProvider.instance().get_transactions_db(
+                    bot_id, account_type, self.exchange_name
+                )
         self.trading_mode_class = trading_mode_class
         self.trigger_cache_timestamp = trigger_cache_timestamp
         self.trigger_source = trigger_source
         self.trigger_value = trigger_value
         self._sanitized_traded_pair = symbol_util.merge_symbol(self.symbol) \
             if self.symbol else self.symbol
         self.backtesting_id = backtesting_id
@@ -169,15 +180,15 @@
         self.signal_builder.reset()
 
     @contextlib.contextmanager
     def adapted_trigger_timestamp(self, tentacle_class, config_name):
         previous_trigger_cache_timestamp = self.trigger_cache_timestamp
         try:
             if isinstance(self.tentacle, modes.AbstractTradingMode) and \
-                    self.trigger_source == common_enums.ActivationTopics.EVALUATION_CYCLE.value:
+                    self.trigger_source == common_enums.TriggerSource.EVALUATION_MATRIX.value:
                 # only trading modes can have a delayed trigger timestamp when they are waken up from evaluators
                 self.trigger_cache_timestamp = self._get_adapted_trigger_timestamp(tentacle_class,
                                                                                    previous_trigger_cache_timestamp,
                                                                                    config_name)
             yield self
         finally:
             self.trigger_cache_timestamp = previous_trigger_cache_timestamp
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/dsl/__init__.py` & `OctoBot-Trading-2.4.0/tests/test_utils/order_util.py`

 * *Files 27% similar despite different names*

```diff
@@ -9,19 +9,18 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+from octobot_commons.asyncio_tools import wait_asyncio_next_cycle
 
-from octobot_trading.modes.script_keywords.dsl.quantity import (
-    parse_quantity,
-)
-from octobot_trading.modes.script_keywords.dsl.values import (
-    QuantityType,
-)
 
-__all__ = [
-    "parse_quantity",
-    "QuantityType",
-]
+async def fill_limit_or_stop_order(limit_or_stop_order):
+    await limit_or_stop_order.on_fill()
+    await wait_asyncio_next_cycle()
+
+
+async def fill_market_order(market_order):
+    await market_order.on_fill()
+    await wait_asyncio_next_cycle()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/script_keywords/dsl/quantity.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/script_keywords/dsl/quantity.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py` & `OctoBot-Trading-2.4.0/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py`

 * *Files 2% similar despite different names*

```diff
@@ -174,15 +174,15 @@
         if self.exchange_manager.is_backtesting:
             # not necessary in backtesting
             return
 
         # fake a full candle call
         cryptocurrency, symbol, time_frame = self._get_initialization_call_args()
         # wait for symbol data to be initialized
-        candle = await self._wait_for_symbol_init(symbol, time_frame, 30)
+        candle = await self._wait_for_symbol_init(symbol, time_frame, self.CONFIG_INIT_TIMEOUT)
         if candle is None:
             self.logger.error(f"Can't initialize trading script: {symbol} {time_frame} candles are not fetched")
         await self.ohlcv_callback(self.exchange_name, self.exchange_manager.id, cryptocurrency, symbol, time_frame,
                                   candle, init_call=True)
 
     async def _wait_for_symbol_init(self, symbol, time_frame, timeout):
         if not await super()._wait_for_symbol_init(symbol, time_frame, timeout):
@@ -215,30 +215,29 @@
                              time_frame: str, candle: dict, init_call: bool = False):
         async with self.trading_mode_trigger(), self.trading_mode.remote_signal_publisher(symbol):
             # add a full candle to time to get the real time
             trigger_time = candle[commons_enums.PriceIndexes.IND_PRICE_TIME.value] + \
                            commons_enums.TimeFramesMinutes[commons_enums.TimeFrames(time_frame)] * \
                            commons_constants.MINUTE_TO_SECONDS
             await self.call_script(self.matrix_id, cryptocurrency, symbol, time_frame,
-                                   commons_enums.ActivationTopics.FULL_CANDLES.value,
+                                   commons_enums.TriggerSource.OHLCV.value,
                                    trigger_time,
                                    candle=candle,
                                    init_call=init_call)
 
     async def kline_callback(self, exchange: str, exchange_id: str, cryptocurrency: str, symbol: str,
                              time_frame, kline: dict):
         async with self.trading_mode_trigger(), self.trading_mode.remote_signal_publisher(symbol):
             await self.call_script(self.matrix_id, cryptocurrency, symbol, time_frame,
-                                   commons_enums.ActivationTopics.IN_CONSTRUCTION_CANDLES.value,
+                                   commons_enums.TriggerSource.KLINE.value,
                                    kline[commons_enums.PriceIndexes.IND_PRICE_TIME.value],
                                    kline=kline)
 
-    async def set_final_eval(self, matrix_id: str, cryptocurrency: str, symbol: str, time_frame):
-        await self.call_script(matrix_id, cryptocurrency, symbol, time_frame,
-                               commons_enums.ActivationTopics.EVALUATION_CYCLE.value,
+    async def set_final_eval(self, matrix_id: str, cryptocurrency: str, symbol: str, time_frame, trigger_source: str):
+        await self.call_script(matrix_id, cryptocurrency, symbol, time_frame, trigger_source,
                                self._get_latest_eval_time(matrix_id, cryptocurrency, symbol, time_frame))
 
     def _get_latest_eval_time(self, matrix_id: str, cryptocurrency: str, symbol: str, time_frame):
         try:
             import octobot_evaluators.matrix as matrix
             import octobot_evaluators.enums as evaluators_enums
             return matrix.get_latest_eval_time(matrix_id,
@@ -289,7 +288,17 @@
             run_data_writer.set_initialized_flags(initialized)
             databases.RunDatabasesProvider.instance().get_symbol_db(self.exchange_manager.bot_id,
                                                                   self.exchange_name, symbol)\
                 .set_initialized_flags(initialized, (time_frame,))
 
     async def _pre_script_call(self, context):
         await basic_keywords.set_leverage(context, await basic_keywords.user_select_leverage(context))
+
+    async def post_trigger(self):
+        if not self.exchange_manager.is_backtesting:
+            # update db after each run only in live mode
+            for database in self.all_databases().values():
+                if database:
+                    try:
+                        await database.flush()
+                    except Exception as err:
+                        self.logger.exception(err, True, f"Error when flushing database: {err}")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/octobot_channel_consumer.py` & `OctoBot-Trading-2.4.0/octobot_trading/octobot_channel_consumer.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -33,28 +33,34 @@
     get_fees_for_currency,
     parse_raw_fees,
     parse_order_status,
     parse_is_cancelled,
     parse_is_open,
     get_pnl_transaction_source_from_order,
     is_stop_order,
+    is_take_profit_order,
     get_trade_order_type,
     create_as_chained_order,
     ensure_orders_relevancy,
     get_order_quantity_currency,
     get_order_size_portfolio_percent,
     generate_order_id,
+    apply_order_storage_details_if_any,
+    create_orders_storage_related_elements,
+    create_missing_self_managed_orders_from_storage_order_groups,
     is_associated_pending_order,
     apply_pending_order_from_created_order,
     get_up_to_date_price,
     get_pre_order_data,
     OrderState,
     OrderGroup,
     BalancedTakeProfitAndStopOrderGroup,
     OneCancelsTheOtherOrderGroup,
+    get_group_class,
+    get_or_create_order_group_from_storage_order_details,
     OrdersUpdater,
     adapt_price,
     get_minimal_order_amount,
     decimal_adapt_price,
     adapt_quantity,
     decimal_adapt_quantity,
     trunc_with_n_decimal_digits,
@@ -69,25 +75,28 @@
     decimal_check_and_adapt_order_details_if_necessary,
     add_dusts_to_quantity_if_necessary,
     decimal_add_dusts_to_quantity_if_necessary,
     create_order_from_raw,
     create_order_instance_from_raw,
     create_order_from_type,
     create_order_instance,
+    create_order_from_dict,
+    create_order_from_order_storage_details,
     OrdersProducer,
     OrdersChannel,
     OrdersManager,
     OrdersUpdaterSimulator,
     CloseOrderState,
     CancelOrderState,
     OpenOrderState,
     create_order_state,
     FillOrderState,
     PendingCreationOrderState,
     PendingCreationChainedOrderState,
+    UnsupportedOrder,
     UnknownOrder,
     MarketOrder,
     SellMarketOrder,
     BuyMarketOrder,
     BuyLimitOrder,
     SellLimitOrder,
     LimitOrder,
@@ -109,24 +118,26 @@
     Portfolio,
     BalanceProducer,
     BalanceChannel,
     BalanceProfitabilityProducer,
     BalanceProfitabilityChannel,
     SubPortfolio,
     PortfolioManager,
+    ValueConverter,
     PortfolioValueHolder,
     FuturePortfolio,
     MarginPortfolio,
     SpotPortfolio,
     Asset,
     FutureAsset,
     MarginAsset,
     SpotAsset,
     parse_decimal_portfolio,
     parse_decimal_config_portfolio,
+    filter_empty_values,
     portfolio_to_float,
     create_historical_asset_value_from_dict_like_object,
     get_draw_down,
     get_coefficient_of_determination,
     HistoricalAssetValue,
     HistoricalPortfolioValueManager,
 )
@@ -142,27 +153,30 @@
     PositionsUpdater,
     PositionsManager,
     create_position_instance_from_raw,
     create_position_from_type,
     create_symbol_position,
     parse_position_status,
     LiquidatePositionState,
-    OpenPositionState,
+    IdlePositionState,
+    ActivePositionState,
     create_position_state,
 )
 from octobot_trading.personal_data import trades
 from octobot_trading.personal_data.trades import (
     TradesManager,
     TradesProducer,
     TradesChannel,
     create_trade_instance_from_raw,
     create_trade_from_order,
     create_trade_instance,
+    create_trade_from_dict,
     TradesUpdater,
     Trade,
+    TradePnl,
     compute_win_rate,
 )
 from octobot_trading.personal_data import transactions
 from octobot_trading.personal_data.transactions import (
     TransactionsManager,
     Transaction,
     BlockchainTransaction,
@@ -200,14 +214,15 @@
     octobot_trading.enums.TraderOrderType.TRAILING_STOP: TrailingStopOrder,
     octobot_trading.enums.TraderOrderType.TRAILING_STOP_LIMIT: TrailingStopLimitOrder,
     octobot_trading.enums.TraderOrderType.STOP_LOSS: StopLossOrder,
     octobot_trading.enums.TraderOrderType.STOP_LOSS_LIMIT: StopLossLimitOrder,
     octobot_trading.enums.TraderOrderType.SELL_MARKET: SellMarketOrder,
     octobot_trading.enums.TraderOrderType.SELL_LIMIT: SellLimitOrder,
     octobot_trading.enums.TraderOrderType.UNKNOWN: UnknownOrder,
+    octobot_trading.enums.TraderOrderType.UNSUPPORTED: UnsupportedOrder,
 }
 
 TraderPositionTypeClasses = {
     octobot_trading.enums.FutureContractType.LINEAR_PERPETUAL: LinearPosition,
     octobot_trading.enums.FutureContractType.INVERSE_PERPETUAL: InversePosition,
     octobot_trading.enums.FutureContractType.LINEAR_EXPIRABLE: LinearPosition,
     octobot_trading.enums.FutureContractType.INVERSE_EXPIRABLE: InversePosition,
@@ -226,28 +241,34 @@
     "get_fees_for_currency",
     "parse_raw_fees",
     "parse_order_status",
     "parse_is_cancelled",
     "parse_is_open",
     "get_pnl_transaction_source_from_order",
     "is_stop_order",
+    "is_take_profit_order",
     "get_trade_order_type",
     "create_as_chained_order",
     "ensure_orders_relevancy",
     "get_order_quantity_currency",
     "get_order_size_portfolio_percent",
     "generate_order_id",
+    "apply_order_storage_details_if_any",
+    "create_orders_storage_related_elements",
+    "create_missing_self_managed_orders_from_storage_order_groups",
     "is_associated_pending_order",
     "apply_pending_order_from_created_order",
     "get_up_to_date_price",
     "get_pre_order_data",
     "OrderState",
     "OrderGroup",
     "BalancedTakeProfitAndStopOrderGroup",
     "OneCancelsTheOtherOrderGroup",
+    "get_group_class",
+    "get_or_create_order_group_from_storage_order_details",
     "OrdersUpdater",
     "adapt_price",
     "get_minimal_order_amount",
     "decimal_adapt_price",
     "adapt_quantity",
     "decimal_adapt_quantity",
     "trunc_with_n_decimal_digits",
@@ -262,25 +283,28 @@
     "decimal_check_and_adapt_order_details_if_necessary",
     "add_dusts_to_quantity_if_necessary",
     "decimal_add_dusts_to_quantity_if_necessary",
     "create_order_from_raw",
     "create_order_instance_from_raw",
     "create_order_from_type",
     "create_order_instance",
+    "create_order_from_dict",
+    "create_order_from_order_storage_details",
     "OrdersProducer",
     "OrdersChannel",
     "OrdersManager",
     "OrdersUpdaterSimulator",
     "CloseOrderState",
     "CancelOrderState",
     "OpenOrderState",
     "create_order_state",
     "FillOrderState",
     "PendingCreationOrderState",
     "PendingCreationChainedOrderState",
+    "UnsupportedOrder",
     "UnknownOrder",
     "MarketOrder",
     "SellMarketOrder",
     "BuyMarketOrder",
     "BuyLimitOrder",
     "SellLimitOrder",
     "LimitOrder",
@@ -301,52 +325,57 @@
     "Portfolio",
     "BalanceProducer",
     "BalanceChannel",
     "BalanceProfitabilityProducer",
     "BalanceProfitabilityChannel",
     "SubPortfolio",
     "PortfolioManager",
+    "ValueConverter",
     "PortfolioValueHolder",
     "FuturePortfolio",
     "MarginPortfolio",
     "SpotPortfolio",
     "Asset",
     "FutureAsset",
     "MarginAsset",
     "SpotAsset",
     "parse_decimal_portfolio",
     "parse_decimal_config_portfolio",
+    "filter_empty_values",
     "portfolio_to_float",
     "create_historical_asset_value_from_dict_like_object",
     "get_draw_down",
     "create_historical_asset_value_from_dict_like_object",
     "HistoricalAssetValue",
     "HistoricalPortfolioValueManager",
     "PositionsUpdaterSimulator",
     "Position",
     "LinearPosition",
     "InversePosition",
     "PositionState",
     "LiquidatePositionState",
-    "OpenPositionState",
+    "IdlePositionState",
+    "ActivePositionState",
     "create_position_state",
     "PositionsUpdater",
     "PositionsManager",
     "create_position_instance_from_raw",
     "create_position_from_type",
     "create_symbol_position",
     "parse_position_status",
     "TradesManager",
     "TradesProducer",
     "TradesChannel",
     "create_trade_instance_from_raw",
     "create_trade_from_order",
     "create_trade_instance",
+    "create_trade_from_dict",
     "TradesUpdater",
     "Trade",
+    "TradePnl",
     "compute_win_rate",
     "ExchangePersonalData",
     "AUTHENTICATED_UPDATER_PRODUCERS",
     "AUTHENTICATED_UPDATER_SIMULATOR_PRODUCERS",
     "TraderOrderTypeClasses",
     "TraderPositionTypeClasses",
     "TransactionsManager",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/exchange_personal_data.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/exchange_personal_data.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,14 +21,15 @@
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.portfolios.portfolio_manager as portfolio_manager
 import octobot_trading.personal_data.positions.positions_manager as positions_manager
 import octobot_trading.personal_data.orders.orders_manager as orders_manager
+import octobot_trading.personal_data.orders.orders_storage_operations as orders_storage_operations
 import octobot_trading.personal_data.trades.trades_manager as trades_manager
 import octobot_trading.personal_data.transactions.transactions_manager as transactions_manager
 import octobot_trading.personal_data.transactions.transaction_factory as transaction_factory
 import octobot_trading.util as util
 
 
 class ExchangePersonalData(util.Initializable):
@@ -89,15 +90,16 @@
             if should_notify:
                 await self.handle_portfolio_update_notification(self.portfolio_manager.portfolio.portfolio)
 
                 if self.exchange_manager.is_future:
                     # should this be done only "if should_notify" ?
                     await self.handle_position_instance_update(
                         order.exchange_manager.exchange_personal_data.positions_manager.get_order_position(order),
-                        should_notify=True)
+                        should_notify=True
+                    )
                 elif self.exchange_manager.is_margin:
                     pass  # TODO : nothing for now
             return changed
         except AttributeError as e:
             self.logger.exception(e, True, f"Failed to update balance : {e}")
             return False
 
@@ -178,74 +180,91 @@
             self.logger.debug(f"Ignored update for order with {order_id}: this order has already been closed "
                               f"(received raw order: {raw_order})")
         else:
             try:
                 changed: bool = await self.orders_manager.upsert_order_from_raw(order_id, raw_order, is_from_exchange)
                 if changed:
                     updated_order = self.orders_manager.get_order(order_id)
-                    asyncio.create_task(updated_order.state.on_refresh_successful())
-
-                    if should_notify:
-                        await self.handle_order_update_notification(updated_order, is_new_order)
-
+                    await self.on_order_refresh_success(updated_order, should_notify, is_new_order)
                 return changed
+            except errors.PortfolioNegativeValueError as e:
+                if is_new_order:
+                    self.logger.debug(f"Impossible to count new order in portfolio: a synch is necessary "
+                                      f"(order: {raw_order}).")
+                    # forward to caller: this is a new order: portfolio might not be synchronized
+                    raise
+                self.logger.exception(e, True, f"Failed to update order : {e}")
             except KeyError as ke:
                 self.logger.debug(f"Failed to update order : Order was not found ({ke})")
             except Exception as e:
                 self.logger.exception(e, True, f"Failed to update order : {e}")
         return False
 
+    async def update_order_from_stored_data(self, order_id, pending_groups):
+        order = self.orders_manager.get_order(order_id)
+        await orders_storage_operations.apply_order_storage_details_if_any(order, self.exchange_manager, pending_groups)
+
+    async def on_order_refresh_success(self, order, should_notify, is_new_order):
+        if order.state is not None:
+            asyncio.create_task(order.state.on_refresh_successful())
+
+        if should_notify:
+            update_type = enums.OrderUpdateType.NEW if is_new_order else enums.OrderUpdateType.STATE_CHANGE
+            await self.handle_order_update_notification(order, update_type)
+        return order.state is not None
+
     def _is_out_of_sync_order(self, order_id) -> bool:
         return self.trades_manager.has_closing_trade_with_order_id(order_id)
 
     async def handle_order_instance_update(self, order, is_new_order: bool = False, should_notify: bool = True):
         try:
             changed: bool = await self.orders_manager.upsert_order_instance(order)
 
             if changed:
-                asyncio.create_task(order.state.on_refresh_successful())
-
-                if should_notify:
-                    await self.handle_order_update_notification(order, is_new_order)
+                await self.on_order_refresh_success(order, should_notify, is_new_order)
             return changed
         except Exception as e:
             self.logger.exception(e, True, f"Failed to update order instance : {e}")
             return False
 
-    async def handle_order_update_notification(self, order, is_new_order):
+    async def handle_order_update_notification(self, order, update_type: enums.OrderUpdateType):
         """
         Notify Orders channel for Order update
         :param order: the updated order
-        :param is_new_order: True if the order was created during update
+        :param update_type: the type of update as enums.OrderUpdateType
         """
         try:
             orders_chan = exchange_channel.get_chan(constants.ORDERS_CHANNEL, self.exchange_manager.id)
             if not orders_chan.get_consumers():
                 # avoid other computations if no consumer
                 return
             await orders_chan.get_internal_producer().send(
-                cryptocurrency=self.exchange_manager.exchange.get_pair_cryptocurrency(order.symbol),
-                symbol=order.symbol,
-                order=order.to_dict(),
+                self.exchange_manager.exchange.get_pair_cryptocurrency(order.symbol),
+                order.symbol,
+                order.to_dict(),
                 is_from_bot=order.is_from_this_octobot,
-                is_new=is_new_order,
+                update_type=update_type,
                 is_closed=order.is_closed()
             )
         except ValueError as e:
             self.logger.error(f"Failed to send order update notification : {e}")
 
     async def handle_closed_order_update(self, order_id, raw_order) -> bool:
         """
         Handle closed order creation or update
         :param order_id: the closed order id
         :param raw_order: the closed order dict
         :return: True if the closed order has been created or updated
         """
         try:
-            return await self.orders_manager.upsert_order_close_from_raw(order_id, raw_order) is not None
+            found_order = await self.orders_manager.upsert_order_close_from_raw(order_id, raw_order)
+            if found_order is None:
+                return False
+            await self.on_order_refresh_success(found_order, False, False)
+            return True
         except Exception as e:
             self.logger.exception(e, True, f"Failed to update order : {e}")
             return False
 
     async def handle_trade_update(self, symbol, trade_id, trade,
                                   is_old_trade: bool = False, should_notify: bool = True):
         try:
@@ -283,17 +302,19 @@
                       old_trade=is_old_trade)
         except ValueError as e:
             self.logger.error(f"Failed to send trade update notification : {e}")
 
     async def handle_position_update(self, symbol, side, position, should_notify: bool = True):
         try:
             changed: bool = await self.positions_manager.upsert_position(symbol, side, position)
+            position_instance = self.positions_manager.get_symbol_position(symbol=symbol, side=side)
+            # Position has been fetched from exchange, make sure it is initialized.
+            # Position might have been previously created without exchange data and therefore not be initialized
+            await position_instance.ensure_position_initialized(is_from_exchange_data=True)
             if should_notify:
-                position_instance = self.positions_manager.get_symbol_position(
-                    symbol=symbol, side=None if position.symbol_contract.is_one_way_position_mode() else side)
                 await self.handle_position_update_notification(position_instance, is_updated=changed)
             return changed
         except errors.UnhandledContractError as e:
             self.logger.debug(f"Failed to update {symbol} position : {e}")
             return False
         except Exception as e:
             self.logger.exception(e, True, f"Failed to update {symbol} position : {e}")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -22,22 +22,25 @@
 from octobot_trading.personal_data.orders.order_group import (
     OrderGroup,
 )
 from octobot_trading.personal_data.orders import groups
 from octobot_trading.personal_data.orders.groups import (
     BalancedTakeProfitAndStopOrderGroup,
     OneCancelsTheOtherOrderGroup,
+    get_group_class,
+    get_or_create_order_group_from_storage_order_details,
 )
 from octobot_trading.personal_data.orders import order
 from octobot_trading.personal_data.orders.order import (
     Order,
     parse_order_type,
 )
 from octobot_trading.personal_data.orders import types
 from octobot_trading.personal_data.orders.types import (
+    UnsupportedOrder,
     UnknownOrder,
     MarketOrder,
     SellMarketOrder,
     BuyMarketOrder,
     BuyLimitOrder,
     SellLimitOrder,
     LimitOrder,
@@ -82,23 +85,30 @@
     parse_order_status,
     parse_is_cancelled,
     parse_is_open,
     get_up_to_date_price,
     get_pre_order_data,
     get_pnl_transaction_source_from_order,
     is_stop_order,
+    is_take_profit_order,
     get_trade_order_type,
     create_as_chained_order,
     is_associated_pending_order,
     apply_pending_order_from_created_order,
     ensure_orders_relevancy,
     get_order_quantity_currency,
     get_order_size_portfolio_percent,
     generate_order_id,
 )
+from octobot_trading.personal_data.orders import orders_storage_operations
+from octobot_trading.personal_data.orders.orders_storage_operations import (
+    apply_order_storage_details_if_any,
+    create_orders_storage_related_elements,
+    create_missing_self_managed_orders_from_storage_order_groups,
+)
 from octobot_trading.personal_data.orders import order_adapter
 from octobot_trading.personal_data.orders.order_adapter import (
     adapt_price,
     adapt_quantity,
     trunc_with_n_decimal_digits,
     adapt_order_quantity_because_quantity,
     adapt_order_quantity_because_price,
@@ -119,14 +129,16 @@
 )
 from octobot_trading.personal_data.orders import order_factory
 from octobot_trading.personal_data.orders.order_factory import (
     create_order_from_raw,
     create_order_instance_from_raw,
     create_order_from_type,
     create_order_instance,
+    create_order_from_dict,
+    create_order_from_order_storage_details,
 )
 
 __all__ = [
     "Order",
     "parse_order_type",
     "is_valid",
     "get_min_max_amounts",
@@ -143,20 +155,24 @@
     "get_pre_order_data",
     "get_pnl_transaction_source_from_order",
     "create_as_chained_order",
     "ensure_orders_relevancy",
     "get_order_quantity_currency",
     "get_order_size_portfolio_percent",
     "generate_order_id",
+    "apply_order_storage_details_if_any",
+    "create_missing_self_managed_orders_from_storage_order_groups",
     "is_associated_pending_order",
     "apply_pending_order_from_created_order",
     "OrderState",
     "OrderGroup",
     "BalancedTakeProfitAndStopOrderGroup",
     "OneCancelsTheOtherOrderGroup",
+    "get_group_class",
+    "get_or_create_order_group_from_storage_order_details",
     "OrdersUpdater",
     "adapt_price",
     "get_minimal_order_amount",
     "decimal_adapt_price",
     "adapt_quantity",
     "decimal_adapt_quantity",
     "trunc_with_n_decimal_digits",
@@ -171,25 +187,28 @@
     "decimal_check_and_adapt_order_details_if_necessary",
     "add_dusts_to_quantity_if_necessary",
     "decimal_add_dusts_to_quantity_if_necessary",
     "create_order_from_raw",
     "create_order_instance_from_raw",
     "create_order_from_type",
     "create_order_instance",
+    "create_order_from_dict",
+    "create_order_from_order_storage_details",
     "OrdersProducer",
     "OrdersChannel",
     "OrdersManager",
     "OrdersUpdaterSimulator",
     "CloseOrderState",
     "CancelOrderState",
     "OpenOrderState",
     "create_order_state",
     "FillOrderState",
     "PendingCreationOrderState",
     "PendingCreationChainedOrderState",
+    "UnsupportedOrder",
     "UnknownOrder",
     "MarketOrder",
     "SellMarketOrder",
     "BuyMarketOrder",
     "BuyLimitOrder",
     "SellLimitOrder",
     "LimitOrder",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -10,22 +10,26 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.channel.orders cimport (
+from octobot_trading.personal_data.orders.channel import orders
+from octobot_trading.personal_data.orders.channel.orders import (
     OrdersProducer,
     OrdersChannel,
 )
-from octobot_trading.personal_data.orders.channel.orders_updater cimport (
+
+from octobot_trading.personal_data.orders.channel import orders_updater
+from octobot_trading.personal_data.orders.channel.orders_updater import (
     OrdersUpdater,
 )
-from octobot_trading.personal_data.orders.channel.orders_updater_simulator cimport (
+from octobot_trading.personal_data.orders.channel import orders_updater_simulator
+from octobot_trading.personal_data.orders.channel.orders_updater_simulator import (
     OrdersUpdaterSimulator,
 )
 
 __all__ = [
     "OrdersUpdater",
     "OrdersProducer",
     "OrdersChannel",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,28 +10,30 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.channel import orders
-from octobot_trading.personal_data.orders.channel.orders import (
-    OrdersProducer,
-    OrdersChannel,
+from octobot_trading.personal_data.orders.groups import balanced_take_profit_and_stop_order_group
+from octobot_trading.personal_data.orders.groups.balanced_take_profit_and_stop_order_group import (
+    BalancedTakeProfitAndStopOrderGroup,
 )
 
-from octobot_trading.personal_data.orders.channel import orders_updater
-from octobot_trading.personal_data.orders.channel.orders_updater import (
-    OrdersUpdater,
+from octobot_trading.personal_data.orders.groups import one_cancels_the_other_order_group
+from octobot_trading.personal_data.orders.groups.one_cancels_the_other_order_group import (
+    OneCancelsTheOtherOrderGroup,
 )
-from octobot_trading.personal_data.orders.channel import orders_updater_simulator
-from octobot_trading.personal_data.orders.channel.orders_updater_simulator import (
-    OrdersUpdaterSimulator,
+
+
+from octobot_trading.personal_data.orders.groups import group_util
+from octobot_trading.personal_data.orders.groups.group_util import (
+    get_group_class,
+    get_or_create_order_group_from_storage_order_details,
 )
 
 __all__ = [
-    "OrdersUpdater",
-    "OrdersProducer",
-    "OrdersChannel",
-    "OrdersUpdaterSimulator",
+    "BalancedTakeProfitAndStopOrderGroup",
+    "OneCancelsTheOtherOrderGroup",
+    "get_group_class",
+    "get_or_create_order_group_from_storage_order_details",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/channel/orders_updater.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=E0611
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -11,180 +12,205 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import asyncio
 
-import async_channel.constants as channel_constants
+import octobot_commons.async_job as async_job
+import octobot_commons.tree as commons_tree
+import octobot_commons.enums as commons_enums
+import octobot_commons.constants as commons_constants
 
-import octobot_trading.exchange_channel as exchanges_channel
-import octobot_trading.exchanges as exchanges
+import octobot_trading.errors as errors
+import octobot_trading.personal_data.orders.channel.orders as orders_channel
 import octobot_trading.constants as constants
 
 
-class OrdersProducer(exchanges_channel.ExchangeChannelProducer):
-    async def push(self, orders, is_from_bot=False, are_closed=False):
-        await self.perform(orders, is_from_bot=is_from_bot, are_closed=are_closed)
+class OrdersUpdater(orders_channel.OrdersProducer):
+    """
+    Update open and close orders from exchange
+    Can also be used to update a specific order from exchange
+    """
+
+    CHANNEL_NAME = constants.ORDERS_CHANNEL
+    ORDERS_UPDATE_LIMIT = None
+    ORDERS_STARTING_REFRESH_TIME = 10
+    OPEN_ORDER_REFRESH_TIME = 7
+    CLOSE_ORDER_REFRESH_TIME = 81
+    TIME_BETWEEN_ORDERS_REFRESH = 2
+    DEPENDENCIES_TIMEOUT = 30
+    OPEN_ORDER_INITIAL_FETCH_GIVE_UP_TIMEOUT = 3 * commons_constants.MINUTE_TO_SECONDS
+
+    def __init__(self, channel):
+        super().__init__(channel)
+
+        self._is_initialized_event_set = False
+        # create async jobs
+        self.open_orders_job = async_job.AsyncJob(self._open_orders_fetch_and_push,
+                                                  execution_interval_delay=self.OPEN_ORDER_REFRESH_TIME,
+                                                  min_execution_delay=self.TIME_BETWEEN_ORDERS_REFRESH)
+        self.closed_orders_job = async_job.AsyncJob(self._closed_orders_fetch_and_push,
+                                                    execution_interval_delay=self.CLOSE_ORDER_REFRESH_TIME,
+                                                    min_execution_delay=self.TIME_BETWEEN_ORDERS_REFRESH)
+        self.order_update_job = async_job.AsyncJob(self._order_fetch_and_push,
+                                                   is_periodic=False,
+                                                   enable_multiple_runs=True)
+        self.order_update_job.add_job_dependency(self.open_orders_job)
+        self.open_orders_job.add_job_dependency(self.order_update_job)
 
-    async def perform(self, orders, is_from_bot=False, are_closed=False):
+    async def initialize(self) -> None:
+        """
+        Initialize data before starting jobs
+        """
         try:
-            self.logger.debug(f"Received order update for {len(orders)} orders.")
-            symbol = None
-            has_new_order = False
-            for order in orders:
-                symbol = self.channel.exchange_manager.get_exchange_symbol(
-                    self.channel.exchange_manager.exchange.parse_order_symbol(order))
-                if self.channel.get_filtered_consumers(symbol=channel_constants.CHANNEL_WILDCARD) or \
-                        self.channel.get_filtered_consumers(symbol=symbol):
-                    order_id: str = self.channel.exchange_manager.exchange.parse_order_id(order)
-
-                    # if this order was not managed by order_manager before
-                    is_new_order = not self.channel.exchange_manager.exchange_personal_data.orders_manager. \
-                        has_order(order_id)
-                    has_new_order |= is_new_order
-
-                    # update this order
-                    if are_closed:
-                        await self._handle_close_order_update(order_id, order)
-                    else:
-                        await self._handle_open_order_update(symbol, order, order_id, is_from_bot, is_new_order)
+            await self.wait_for_dependencies(
+                [
+                    commons_tree.get_exchange_path(
+                        self.channel.exchange_manager.exchange_name,
+                        commons_enums.InitializationEventExchangeTopics.CONTRACTS.value
+                    ),
+                    commons_tree.get_exchange_path(
+                        self.channel.exchange_manager.exchange_name,
+                        commons_enums.InitializationEventExchangeTopics.POSITIONS.value
+                    ),
+                ],
+                self.DEPENDENCIES_TIMEOUT
+            )
+            await self.fetch_and_push(is_from_bot=False, retry_till_success=True)
+        except errors.NotSupported:
+            self.logger.error(f"{self.channel.exchange_manager.exchange_name} is not supporting open orders updates")
+            await self.pause()
+        except Exception as e:
+            self.logger.exception(e, True, f"Fail to initialize orders : {e}")
 
-            if not are_closed:
-                await self.handle_post_open_order_update(symbol, orders, has_new_order)
+    async def start(self) -> None:
+        """
+        Start updater jobs
+        """
+        await self.initialize()
+        await asyncio.sleep(self.ORDERS_STARTING_REFRESH_TIME)
+        await self.open_orders_job.run()
+        # await self.closed_orders_job.run()
 
-        except asyncio.CancelledError:
-            self.logger.info("Update tasks cancelled.")
-        except Exception as e:
-            self.logger.exception(e, True, f"Exception when triggering update: {e}")
+    async def fetch_and_push(self, is_from_bot=True, limit=ORDERS_UPDATE_LIMIT, retry_till_success=False):
+        """
+        Update open and closed orders from exchange
+        :param is_from_bot: True if the order was created by OctoBot
+        :param limit: the exchange request orders count limit
+        :param retry_till_success: retry request till it works. Should be rarely used as it might take some time
+        """
+        # should not raise: open orders are necessary
+        try:
+            await self._open_orders_fetch_and_push(is_from_bot=is_from_bot, limit=limit,
+                                                   retry_till_success=retry_till_success)
+        finally:
+            if self.channel is not None:
+                self.channel.exchange_manager.exchange_personal_data.orders_manager.are_exchange_orders_initialized = True
+        await asyncio.sleep(self.TIME_BETWEEN_ORDERS_REFRESH)
+        try:
+            # can raise, closed orders are not critical data
+            await self._closed_orders_fetch_and_push(limit=limit)
+        except errors.NotSupported:
+            self.logger.debug(f"{self.channel.exchange_manager.exchange_name} is not supporting closed orders updates")
+
+    async def _open_orders_fetch_and_push(self, is_from_bot=True, limit=ORDERS_UPDATE_LIMIT, retry_till_success=False):
+        """
+        Update open orders from exchange
+        :param is_from_bot: True if the order was created by OctoBot
+        :param limit: the exchange request orders count limit
+        :param retry_till_success: retry request till it works. Should be rarely used as it might take some time
+        """
+        for symbol in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
+            if retry_till_success:
+                open_orders: list = await self.channel.exchange_manager.exchange.retry_till_success(
+                    self.OPEN_ORDER_INITIAL_FETCH_GIVE_UP_TIMEOUT,
+                    self.channel.exchange_manager.exchange.get_open_orders, symbol=symbol, limit=limit
+                )
+            else:
+                open_orders: list = await self.channel.exchange_manager.exchange.get_open_orders(
+                    symbol=symbol, limit=limit
+                )
+            if open_orders:
+                await self.push(open_orders, is_from_bot=is_from_bot)
+            else:
+                await self.handle_post_open_orders_update((symbol, ), open_orders, [], False, True)
+            if not self._is_initialized_event_set:
+                self._set_initialized_event(symbol)
+        self._is_initialized_event_set = True
+
+    def _set_initialized_event(self, symbol):
+        # set init in updater as it's the only place we know if we fetched orders or not regardless of orders existence
+        commons_tree.EventProvider.instance().trigger_event(
+            self.channel.exchange_manager.bot_id, commons_tree.get_exchange_path(
+                self.channel.exchange_manager.exchange_name,
+                commons_enums.InitializationEventExchangeTopics.ORDERS.value,
+                symbol=symbol
+            )
+        )
 
-    async def _handle_open_order_update(self, symbol, order, order_id, is_from_bot, is_new_order):
+    async def _closed_orders_fetch_and_push(self, limit=ORDERS_UPDATE_LIMIT) -> None:
+        """
+        Update closed orders from exchange
+        :param limit: the exchange request orders count limit
         """
-        Create or update an open Order from exchange data
-        :param symbol: the order symbol
-        :param order: the order dict
-        :param order_id: the order id
-        :param is_from_bot: If the order was created by OctoBot
-        :param is_new_order: True if this open order has been created
-        """
-        if (await self.channel.exchange_manager.exchange_personal_data.handle_order_update_from_raw(
-                order_id, order, is_new_order=is_new_order, should_notify=False)):
-            await self.send(cryptocurrency=self.channel.exchange_manager.exchange.
-                            get_pair_cryptocurrency(symbol),
-                            symbol=symbol, order=order,
-                            is_from_bot=is_from_bot,
-                            is_new=is_new_order,
-                            is_closed=False)
-
-    async def _handle_close_order_update(self, order_id, order):
-        """
-        Create or update a close Order from exchange data
-        :param order: the order dict
-        :param order_id: the order id
-        """
-        await self.channel.exchange_manager.exchange_personal_data.handle_closed_order_update(order_id, order)
-
-    async def handle_post_open_order_update(self, symbol, orders, has_new_order):
-        """
-        Perform post open Order update actions :
-        - Check if some previously known open order has not been found during update
-        - Force portfolio refresh if a new order has been loaded
-        :param symbol: the update symbol
-        :param orders: the update order dicts
-        :param has_new_order: if a new order has been loaded
-        :return:
-        """
-        if symbol is not None:
-            await self._check_missing_open_orders(symbol, orders)
-
-            # if a new order have been loaded : refresh portfolio to ensure available funds are up to date
-            if has_new_order:
-                await exchanges_channel.get_chan(constants.BALANCE_CHANNEL,
-                                                 self.channel.exchange_manager.id).get_internal_producer(). \
-                    refresh_real_trader_portfolio()
+        for symbol in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
+            close_orders: list = await self.channel.exchange_manager.exchange.get_closed_orders(
+                symbol=symbol, limit=limit)
+
+            if close_orders:
+                await self.push(close_orders, are_closed=True)
 
     async def update_order_from_exchange(self, order,
                                          should_notify=False,
                                          wait_for_refresh=False,
                                          force_job_execution=False,
                                          create_order_producer_if_missing=True):
         """
-        Update order from exchange
+        Trigger order job refresh from exchange
         :param order: the order to update
         :param wait_for_refresh: if True, wait until the order refresh task to finish
         :param should_notify: if Orders channel consumers should be notified
         :param force_job_execution: When True, order_update_job will bypass its dependencies check
         :param create_order_producer_if_missing: Should be set to False when called by self to prevent spamming
         :return: True if the order was updated
         """
-        try:
-            await (exchanges_channel.get_chan(constants.ORDERS_CHANNEL, self.channel.exchange_manager.id).producers[-1].
-                   update_order_from_exchange(order=order,
-                                              should_notify=should_notify,
-                                              force_job_execution=force_job_execution,
-                                              wait_for_refresh=wait_for_refresh))
-        except IndexError:
-            if not self.channel.exchange_manager.is_simulated and create_order_producer_if_missing:
-                self.logger.debug("Missing orders producer, starting one...")
-                await exchanges.create_authenticated_producer_from_parent(self.channel.exchange_manager,
-                                                                          self.__class__,
-                                                                          force_register_producer=True)
-                await self.update_order_from_exchange(order=order,
-                                                      should_notify=should_notify,
-                                                      wait_for_refresh=wait_for_refresh,
-                                                      force_job_execution=force_job_execution,
-                                                      create_order_producer_if_missing=False)
-
-    async def _check_missing_open_orders(self, symbol, orders):
-        """
-        Check if there is no missing open orders in order_manager compared to exchange open orders
-        :param symbol: the order symbol
-        :param orders: open orders from exchange
-        """
-        missing_order_ids = list(
-            set(
-                order.order_id for order in
-                self.channel.exchange_manager.exchange_personal_data.orders_manager.get_open_orders(
-                    symbol
-                ) + self.channel.exchange_manager.exchange_personal_data.orders_manager.get_pending_cancel_orders(
-                    symbol
-                )
-                if not order.is_self_managed()) -
-            set(
-                self.channel.exchange_manager.exchange.parse_order_id(order)
-                for order in orders)
-        )
-        if missing_order_ids:
-            self.logger.debug(f"{len(missing_order_ids)} open orders are missing on exchange, "
-                              f"synchronizing with exchange...")
-            synchronize_tasks = []
-            for missing_order_id in missing_order_ids:
-                try:
-                    order_to_update = self.channel.exchange_manager.exchange_personal_data.orders_manager. \
-                        get_order(missing_order_id)
-                    if order_to_update.state is not None:
-                        # catch exception not to prevent multiple synchronize to be cancelled in asyncio.gather
-                        synchronize_tasks.append(order_to_update.state.synchronize(force_synchronization=True,
-                                                                                   catch_exception=True))
-                except KeyError:
-                    self.logger.error(f"Order with id {missing_order_id} could not be synchronized")
-            await asyncio.gather(*synchronize_tasks)
-
-    async def send(self, cryptocurrency, symbol, order, is_from_bot=True, is_new=False, is_closed=False):
-        if is_closed:
-            # do not push closed orders
-            return
-        for consumer in self.channel.get_filtered_consumers(symbol=symbol):
-            await consumer.queue.put({
-                "exchange": self.channel.exchange_manager.exchange_name,
-                "exchange_id": self.channel.exchange_manager.id,
-                "cryptocurrency": cryptocurrency,
-                "symbol": symbol,
-                "order": order,
-                "is_new": is_new,
-                "is_from_bot": is_from_bot
-            })
-
-
-class OrdersChannel(exchanges_channel.ExchangeChannel):
-    PRODUCER_CLASS = OrdersProducer
-    CONSUMER_CLASS = exchanges_channel.ExchangeChannelConsumer
+        await self.order_update_job.run(force=True, wait_for_task_execution=wait_for_refresh,
+                                        ignore_dependencies_check=force_job_execution,
+                                        order=order, should_notify=should_notify)
+
+    async def _order_fetch_and_push(self, order, should_notify=False):
+        """
+        Update Order from exchange
+        :param order: the order to update
+        :param should_notify: if Orders channel consumers should be notified
+        :return: True if the order was updated
+        """
+        exchange_name = order.exchange_manager.exchange_name if order.exchange_manager else "cleared order's exchange"
+        self.logger.debug(f"Requested update for {order} on {exchange_name}")
+        raw_order = await self.channel.exchange_manager.exchange.get_order(order.order_id, order.symbol)
+
+        if raw_order is not None:
+            self.logger.debug(f"Received update for {order} on {exchange_name}: {raw_order}")
+
+            await self.channel.exchange_manager.exchange_personal_data.handle_order_update_from_raw(
+                order.order_id, raw_order, should_notify=should_notify
+            )
+        else:
+            self.logger.debug(f"Can't received update for {order} on {exchange_name}: received order is None")
+
+    async def stop(self) -> None:
+        """
+        Stop producer by stopping its jobs
+        """
+        await super().stop()
+        self.open_orders_job.stop()
+        self.closed_orders_job.stop()
+        self.order_update_job.stop()
+
+    async def resume(self) -> None:
+        """
+        Resume producer by restarting its jobs
+        """
+        await super().resume()
+        if not self.is_running:
+            await self.run()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/channel/orders_updater_simulator.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,11 +9,27 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.personal_data.orders.channel.orders_updater as orders_updater
 
-cdef class OrdersUpdaterSimulator(orders_updater.OrdersUpdater):
-    pass
+from octobot_trading.personal_data.portfolios.assets import future_asset
+from octobot_trading.personal_data.portfolios.assets import margin_asset
+from octobot_trading.personal_data.portfolios.assets import spot_asset
+
+from octobot_trading.personal_data.portfolios.assets.future_asset import (
+    FutureAsset,
+)
+from octobot_trading.personal_data.portfolios.assets.margin_asset import (
+    MarginAsset,
+)
+from octobot_trading.personal_data.portfolios.assets.spot_asset import (
+    SpotAsset,
+)
+
+__all__ = [
+    "FutureAsset",
+    "MarginAsset",
+    "SpotAsset",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/decimal_order_adapter.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/decimal_order_adapter.py`

 * *Files 2% similar despite different names*

```diff
@@ -156,26 +156,26 @@
 
     symbol_market_limits = symbol_market[Ecmsc.LIMITS.value]
 
     limit_amount = symbol_market_limits[Ecmsc.LIMITS_AMOUNT.value]
     limit_cost = symbol_market_limits[Ecmsc.LIMITS_COST.value]
     limit_price = symbol_market_limits[Ecmsc.LIMITS_PRICE.value]
 
+    # adapt digits if necessary
+    valid_quantity = decimal_adapt_quantity(symbol_market, quantity, truncate)
+    valid_price = decimal_adapt_price(symbol_market, price, truncate)
+
     # case 1: try with data directly from exchange
     if personal_data.is_valid(limit_amount, Ecmsc.LIMITS_AMOUNT_MIN.value):
         min_quantity = decimal.Decimal(str(limit_amount.get(Ecmsc.LIMITS_AMOUNT_MIN.value, math.nan)))
         max_quantity = None
         # not all symbol data have a max quantity
         if personal_data.is_valid(limit_amount, Ecmsc.LIMITS_AMOUNT_MAX.value):
             max_quantity = decimal.Decimal(str(limit_amount.get(Ecmsc.LIMITS_AMOUNT_MAX.value, math.nan)))
 
-        # adapt digits if necessary
-        valid_quantity = decimal_adapt_quantity(symbol_market, quantity, truncate)
-        valid_price = decimal_adapt_price(symbol_market, price, truncate)
-
         total_order_price = valid_quantity * valid_price
 
         if valid_quantity < min_quantity:
             # invalid order
             return []
 
         # case 1.1: use only quantity and cost
@@ -197,43 +197,44 @@
                 return decimal_split_orders(total_order_price, max_cost, valid_quantity,
                                             max_quantity, valid_price, quantity, symbol_market)
 
             else:
                 # valid order that can be handled by the exchange
                 return [(valid_quantity, valid_price)]
 
-        # case 1.2: use only quantity and price
-        elif personal_data.is_valid(limit_price, Ecmsc.LIMITS_PRICE_MIN.value):
-            min_price = decimal.Decimal(str(limit_price.get(Ecmsc.LIMITS_PRICE_MIN.value, math.nan)))
-            max_price = None
-            # not all symbol data have a max price
-            if personal_data.is_valid(limit_price, Ecmsc.LIMITS_PRICE_MAX.value):
-                max_price = decimal.Decimal(str(limit_price.get(Ecmsc.LIMITS_PRICE_MAX.value, math.nan)))
-
-            if (max_price is not None and (max_price <= valid_price)) or valid_price <= min_price:
-                # invalid order
-                return []
+        # case 1.2: use only quantity and price (if available)
+        else:
+            if personal_data.is_valid(limit_price, Ecmsc.LIMITS_PRICE_MIN.value):
+                min_price = decimal.Decimal(str(limit_price.get(Ecmsc.LIMITS_PRICE_MIN.value, math.nan)))
+                max_price = None
+                # not all symbol data have a max price
+                if personal_data.is_valid(limit_price, Ecmsc.LIMITS_PRICE_MAX.value):
+                    max_price = decimal.Decimal(str(limit_price.get(Ecmsc.LIMITS_PRICE_MAX.value, math.nan)))
+
+                if (max_price is not None and (valid_price > max_price)) or valid_price < min_price:
+                    # invalid order
+                    return []
 
             # check total_order_price not > max_cost and valid_quantity not > max_quantity
-            elif max_quantity is not None and valid_quantity > max_quantity:
+            if max_quantity is not None and valid_quantity > max_quantity:
                 # split quantity into smaller orders
                 return decimal_adapt_order_quantity_because_quantity(valid_quantity, max_quantity,
                                                                      quantity, valid_price, symbol_market)
             else:
                 # valid order that can be handled wy the exchange
                 return [(valid_quantity, valid_price)]
 
     if not fixed_symbol_data:
         # case 2: try fixing data from exchanges
         fixed_data = exchanges.ExchangeMarketStatusFixer(symbol_market, float(price)).market_status
         return decimal_check_and_adapt_order_details_if_necessary(quantity, price, fixed_data,
                                                                   fixed_symbol_data=True, truncate=truncate)
     else:
-        # impossible to check if order is valid: refuse it
-        return []
+        # impossible to check if order is valid: try anyway, the exchange will tell
+        return [(valid_quantity, valid_price)]
 
 
 def decimal_add_dusts_to_quantity_if_necessary(quantity, price, symbol_market, current_symbol_holding):
     """
     Adds remaining quantity to the order if the remaining quantity is too small
     :param quantity:
     :param price:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,23 +10,26 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.groups cimport balanced_take_profit_and_stop_order_group
-from octobot_trading.personal_data.orders.groups.balanced_take_profit_and_stop_order_group cimport (
-    BalancedTakeProfitAndStopOrderGroup
-)
-
+from octobot_trading.personal_data.orders.types.market import market_order
+from octobot_trading.personal_data.orders.types.market import sell_market_order
+from octobot_trading.personal_data.orders.types.market import buy_market_order
 
-from octobot_trading.personal_data.orders.groups cimport one_cancels_the_other_order_group
-from octobot_trading.personal_data.orders.groups.one_cancels_the_other_order_group cimport (
-    OneCancelsTheOtherOrderGroup
+from octobot_trading.personal_data.orders.types.market.market_order import (
+    MarketOrder,
+)
+from octobot_trading.personal_data.orders.types.market.sell_market_order import (
+    SellMarketOrder,
+)
+from octobot_trading.personal_data.orders.types.market.buy_market_order import (
+    BuyMarketOrder,
 )
-
 
 __all__ = [
-    "BalancedTakeProfitAndStopOrderGroup",
-    "OneCancelsTheOtherOrderGroup",
+    "MarketOrder",
+    "SellMarketOrder",
+    "BuyMarketOrder",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.personal_data.orders.order_group as order_group
 import octobot_trading.personal_data.orders.order_util as order_util
 import octobot_trading.constants as constants
 import octobot_trading.signals as signals
+import octobot_trading.errors as errors
 
 
 class BalancedTakeProfitAndStopOrderGroup(order_group.OrderGroup):
     """
     BalancedTakeProfitAndStopOrderGroup is linking orders together in the way that if any order of the group is filled
     order cancelled, orders that are on the other extreme of the setup (extremes being take profits and stop losses)
     are reduced or cancelled symmetrically.
@@ -100,20 +101,23 @@
             updated_orders = False
             balance = self._get_balance(closed_order, ignored_orders)
             locally_balancing_orders = balance[self.TAKE_PROFIT].orders + balance[self.STOP].orders
             self.balancing_orders += locally_balancing_orders
             take_profit_actions = balance[self.TAKE_PROFIT].get_actions_to_balance(balance[self.STOP].get_balance())
             stop_actions = balance[self.STOP].get_actions_to_balance(balance[self.TAKE_PROFIT].get_balance())
             for order in take_profit_actions[self.CANCEL] + stop_actions[self.CANCEL]:
-                self.logger.debug(f"Cancelling order to keep balance, order: {order} as {closed_order} is closed")
-                async with signals.remote_signal_publisher(order.trader.exchange_manager, order.symbol, True):
-                    await signals.cancel_order(order.trader.exchange_manager,
-                                               signals.should_emit_trading_signal(order.trader.exchange_manager),
-                                               order,
-                                               ignored_order=closed_order)
+                try:
+                    self.logger.debug(f"Cancelling order to keep balance, order: {order} as {closed_order} is closed")
+                    async with signals.remote_signal_publisher(order.trader.exchange_manager, order.symbol, True):
+                        await signals.cancel_order(order.trader.exchange_manager,
+                                                   signals.should_emit_trading_signal(order.trader.exchange_manager),
+                                                   order,
+                                                   ignored_order=closed_order)
+                except (errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError) as err:
+                    self.logger.error(f"Skipping order cancel: {err}")
                 updated_orders = True
             for update_data in take_profit_actions[self.UPDATE] + stop_actions[self.UPDATE]:
                 self.logger.info(f"Updating order side to {update_data[self.UPDATED_QUANTITY]} to keep balance, "
                                  f"order: {update_data[self.ORDER]}")
                 order = update_data[self.ORDER]
                 async with signals.remote_signal_publisher(order.trader.exchange_manager, order.symbol, True):
                     await signals.edit_order(order.trader.exchange_manager,
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py`

 * *Files 10% similar despite different names*

```diff
@@ -31,24 +31,15 @@
         This is called right before updating portfolio for this filled order and the
         order fill publication
         :param filled_order: the filled order
         :param ignored_orders: orders that should be ignored
         """
         if not self.enabled:
             return
-        for order in self.get_group_open_orders():
-            if order is not filled_order and order.is_open():
-                self.logger.info(f"Cancelling order [{order}] from order group as {filled_order} is filled")
-                async with signals.remote_signal_publisher(order.trader.exchange_manager, order.symbol, True):
-                    await signals.cancel_order(
-                        order.trader.exchange_manager,
-                        signals.should_emit_trading_signal(order.trader.exchange_manager),
-                        order,
-                        ignored_order=filled_order
-                    )
+        await self._cancel_orders(filled_order, "filled", filled_order)
 
     async def on_cancel(self, cancelled_order, ignored_orders=None):
         """
         Called when an order referencing this group is cancelled
         This is called before updating portfolio for this cancelled order and the
         order cancel publication
         :param cancelled_order: the cancelled order
@@ -56,15 +47,23 @@
         """
         if not self.enabled:
             return
         if ignored_orders and len(ignored_orders) > 1:
             raise errors.OrderGroupTriggerArgumentError(f"ignored_orders supports at most 1 argument "
                                                         f"for {self.__class__.__name__}")
         ignored_order = ignored_orders[0] if ignored_orders else None
+        await self._cancel_orders(cancelled_order, "cancelled", ignored_order)
+
+    async def _cancel_orders(self, triggering_order, trigger, ignored_order):
         for order in self.get_group_open_orders():
-            if order is not cancelled_order and order.is_open():
-                self.logger.info(f"Cancelling order [{order}] from order group as {cancelled_order} is cancelled")
-                async with signals.remote_signal_publisher(order.trader.exchange_manager, order.symbol, True):
-                    await signals.cancel_order(order.trader.exchange_manager,
-                                               signals.should_emit_trading_signal(order.trader.exchange_manager),
-                                               order,
-                                               ignored_order=ignored_order)
+            if order is not triggering_order and order.is_open():
+                try:
+                    self.logger.info(f"Cancelling order [{order}] from order group as {triggering_order} is {trigger}")
+                    async with signals.remote_signal_publisher(order.trader.exchange_manager, order.symbol, True):
+                        await signals.cancel_order(
+                            order.trader.exchange_manager,
+                            signals.should_emit_trading_signal(order.trader.exchange_manager),
+                            order,
+                            ignored_order=ignored_order
+                        )
+                except (errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError) as err:
+                    self.logger.error(f"Skipping order cancel: {err}")
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order.py`

 * *Files 3% similar despite different names*

```diff
@@ -23,14 +23,15 @@
 
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 import octobot_trading.errors as errors
 import octobot_trading.personal_data.orders.states as orders_states
 import octobot_trading.personal_data.orders.order_util as order_util
 import octobot_trading.util as util
+import octobot_trading.storage.orders_storage as orders_storage
 
 
 class Order(util.Initializable):
     """
     Order class will represent an open order in the specified exchange
     In simulation it will also define rules to be filled / canceled
     It is also use to store creation & fill values of the order
@@ -54,14 +55,15 @@
         self.currency = None
         self.market = None
         self.quantity_currency = None
         self.taker_or_maker = None
         self.timestamp = 0
         self.side = side
         self.tag = None
+        self.associated_entry_ids = None
 
         # original order attributes
         self.creation_time = self.exchange_manager.exchange.get_exchange_current_time()
         self.origin_price = constants.ZERO
         self.created_last_price = constants.ZERO
         self.origin_quantity = constants.ZERO
         self.origin_stop_price = constants.ZERO
@@ -99,20 +101,24 @@
         self.position_side = None
 
         # Chained orders attributes
         # other orders (as any Order) that should be created when this order is filled
         self.chained_orders = []
         # order that triggered this order creation (when created as a chained order)
         self.triggered_by = None
+        # if True this orders quantity will be reduced according to the triggering order's paid fees
+        self.update_with_triggering_order_fees = False
         # True when this order has been created directly by the exchange (usually as stop loss / take profit
         # when passed as parameter alongside another order)
         self.has_been_bundled = False
         # True when this order is to be opened as a chained order and has not been open yet
         self.is_waiting_for_chained_trigger = False
-        # params give to the exchange request when this order is created
+
+        # Params given to the exchange request when this order is created. Include any exchange specific param here.
+        # All params and values in those will be ignored in simulated orders
         self.exchange_creation_params = {}
         # kwargs given to trader.create_order() when this order should be created later on
         self.trader_creation_kwargs = {}
 
     @classmethod
     def get_name(cls):
         return cls.__name__
@@ -123,18 +129,21 @@
         return self.logger_name
 
     def update(self, symbol, order_id="", status=enums.OrderStatus.OPEN,
                current_price=constants.ZERO, quantity=constants.ZERO, price=constants.ZERO, stop_price=constants.ZERO,
                quantity_filled=constants.ZERO, filled_price=constants.ZERO, average_price=constants.ZERO,
                fee=None, total_cost=constants.ZERO, timestamp=None,
                order_type=None, reduce_only=None, close_position=None, position_side=None, fees_currency_side=None,
-               group=None, tag=None, quantity_currency=None) -> bool:
+               group=None, tag=None, quantity_currency=None, exchange_creation_params=None,
+               associated_entry_id=None) -> bool:
         changed: bool = False
         should_update_total_cost = False
 
+        price = current_price if self.use_current_price_as_origin_price() else price
+
         if order_id and self.order_id != order_id:
             self.order_id = order_id
 
         if symbol and self.symbol != symbol:
             self.currency, self.market = self.exchange_manager.get_exchange_quote_and_base(symbol)
             self.symbol = symbol
 
@@ -249,14 +258,20 @@
 
         if group is not None:
             self.add_to_order_group(group)
 
         if tag is not None:
             self.tag = tag
 
+        if exchange_creation_params is not None:
+            self.exchange_creation_params = exchange_creation_params
+
+        if associated_entry_id is not None:
+            self.associate_to_entry(associated_entry_id)
+
         if should_update_total_cost and not total_cost:
             self._update_total_cost()
 
         return changed
 
     async def initialize_impl(self, **kwargs):
         """
@@ -291,44 +306,54 @@
     async def update_order_status(self, force_refresh=False):
         """
         Update_order_status will define the rules for a simulated order to be filled / canceled
         """
         raise NotImplementedError("Update_order_status not implemented")
 
     def add_to_order_group(self, order_group):
-        if not self.is_open():
+        if not self.is_open() and not self.is_waiting_for_chained_trigger:
             logging.get_logger(self.get_logger_name()).warning(f"Adding order to group however order is not open.")
         self.order_group = order_group
 
     def get_total_fees(self, currency):
         return order_util.get_fees_for_currency(self.fee, currency)
 
     def is_created(self):
         return self.state is None or self.state.is_created()
 
+    def is_pending_creation(self):
+        return isinstance(self.state, orders_states.PendingCreationOrderState)
+
     def is_open(self):
         # also check is_initialized to avoid considering uncreated orders as open
         return self.state is None or self.state.is_open()
 
     def is_filled(self):
         return self.state.is_filled() or (self.state.is_closed() and self.status is enums.OrderStatus.FILLED)
 
     def is_cancelled(self):
         return self.state.is_canceled() or (self.state.is_closed() and self.status is enums.OrderStatus.CANCELED)
 
+    def is_cancelling(self):
+        return self.state.state is enums.OrderStates.CANCELING or self.status is enums.OrderStatus.PENDING_CANCEL
+
     def is_closed(self):
         return self.state.is_closed() if self.state is not None else self.status is enums.OrderStatus.CLOSED
 
     def is_refreshing(self):
         return self.state is not None and self.state.is_refreshing()
 
     def can_be_edited(self):
         # orders that are not yet open or already open can be edited
         return self.state is None or (self.state.is_open() and not self.is_refreshing())
 
+    def use_current_price_as_origin_price(self):
+        # Override to return True when the current order price can't be set by the user (ex: market orders)
+        return False
+
     def get_position_side(self, future_contract):
         """
         :param future_contract: the associated future contract
         :return: the position side if it can be determined, else raise an InvalidPositionSide
         """
         if self.position_side is not None:
             return self.position_side
@@ -361,15 +386,15 @@
                 # state has already been created and initialized
                 return
             self.state = orders_states.OpenOrderState(self, is_from_exchange_data=is_from_exchange_data)
             await self.state.initialize(forced=force_open)
 
     async def on_fill(self, force_fill=False, is_from_exchange_data=False):
         logging.get_logger(self.get_logger_name()).debug(f"on_fill triggered for {self}")
-        if self.is_open() and not self.is_refreshing():
+        if (self.is_open() and not self.is_refreshing()) or self.is_pending_creation():
             with self.order_state_creation():
                 self.state = orders_states.FillOrderState(self, is_from_exchange_data=is_from_exchange_data)
                 await self.state.initialize(forced=force_fill)
         else:
             logging.get_logger(self.get_logger_name()).debug(f"Trying to fill a refreshing or previously filled "
                                                              f"or canceled order: "
                                                              f"ignored fill call for {self}")
@@ -392,28 +417,54 @@
 
     async def on_filled(self):
         """
         Filling complete callback
         """
         await self._trigger_chained_orders()
 
+    def associate_to_entry(self, entry_order_id):
+        if self.associated_entry_ids is None:
+            self.associated_entry_ids = []
+        if entry_order_id not in self.associated_entry_ids:
+            self.associated_entry_ids.append(entry_order_id)
+            return True
+        return False
+
+    def update_quantity_with_order_fees(self, other_order):
+        relevant_fees_amount = order_util.get_fees_for_currency(other_order.fee, self.quantity_currency)
+        if relevant_fees_amount:
+            logger = logging.get_logger(self.get_logger_name())
+            fees_str = f"Paid {self.quantity_currency} fees: {relevant_fees_amount}, " \
+                       f"initial order size: {self.origin_quantity}"
+            if relevant_fees_amount > self.origin_quantity:
+                logger.error(f"Impossible to update chained order amount according to triggering order fees: "
+                             f"fees are larger than then chained order size. {fees_str}")
+                return False
+            self.origin_quantity -= relevant_fees_amount
+            logger.debug(f"Updating chained order quantity with triggering order fees. {fees_str}")
+        return True
+
     async def _trigger_chained_orders(self):
         logger = logging.get_logger(self.get_logger_name())
         for index, order in enumerate(self.chained_orders):
-            if order.should_be_created():
+            can_be_created = True
+            if order.update_with_triggering_order_fees:
+                can_be_created = order.update_quantity_with_order_fees(self)
+            if can_be_created and order.should_be_created():
                 logger.debug(f"Creating chained order {index + 1}/{len(self.chained_orders)}")
                 await order_util.create_as_chained_order(order)
             else:
                 logger.debug(f"Skipping cancelled chained order {index + 1}/{len(self.chained_orders)}")
 
     async def set_as_chained_order(self, triggered_by, has_been_bundled, exchange_creation_params,
-                                   **trader_creation_kwargs):
+                                   update_with_triggering_order_fees, **trader_creation_kwargs):
         if triggered_by is self:
             raise errors.ConflictingOrdersError("Impossible to chain an order to itself")
         self.triggered_by = triggered_by
+        self.update_with_triggering_order_fees = update_with_triggering_order_fees
         self.has_been_bundled = has_been_bundled
         self.exchange_creation_params = exchange_creation_params
         self.trader_creation_kwargs = trader_creation_kwargs
         self.is_waiting_for_chained_trigger = True
         self.status = enums.OrderStatus.PENDING_CREATION
         await self.initialize()
 
@@ -428,33 +479,45 @@
             if other_order is self:
                 return False
             if self.order_group is not None and self.order_group is other_order.order_group \
                     and other_order.is_closed():
                 return True
         return False
 
+    def has_exchange_fetched_fees(self):
+        if not self.fee:
+            return False
+        try:
+            # requires fees to be from exchange and having a not None exchange original cost
+            return self.fee[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value] \
+                   and self.fee[enums.FeePropertyColumns.EXCHANGE_ORIGINAL_COST.value] is not None
+        except KeyError:
+            return False
+
     def get_computed_fee(self, forced_value=None):
+        is_from_exchange = False
         if self.fees_currency_side is enums.FeesCurrencySide.UNDEFINED:
             computed_fee = self.exchange_manager.exchange.get_trade_fee(self.symbol, self.order_type,
                                                                         self.filled_quantity, self.filled_price,
                                                                         self.taker_or_maker)
             value = computed_fee[enums.FeePropertyColumns.COST.value]
             currency = computed_fee[enums.FeePropertyColumns.CURRENCY.value]
+            is_from_exchange = computed_fee[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value]
         else:
             symbol_fees = self.exchange_manager.exchange.get_fees(self.symbol)
             fees = decimal.Decimal(f"{symbol_fees[self.taker_or_maker]}")
             if self.fees_currency_side is enums.FeesCurrencySide.CURRENCY:
                 value = self.filled_quantity / self.filled_price * fees
                 currency = self.currency
             else:
                 value = self.filled_quantity * self.filled_price * fees
                 currency = self.market
         return {
-            enums.FeePropertyColumns.COST.value:
-                forced_value if forced_value is not None else value,
+            enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: is_from_exchange,
+            enums.FeePropertyColumns.COST.value: forced_value if forced_value is not None else value,
             enums.FeePropertyColumns.CURRENCY.value: currency,
         }
 
     def get_profitability(self):
         if self.filled_price != 0 and self.created_last_price != 0:
             if self.filled_price >= self.created_last_price:
                 self.order_profitability = 1 - self.filled_price / self.created_last_price
@@ -463,29 +526,31 @@
             else:
                 self.order_profitability = 1 - self.created_last_price / self.filled_price
                 if self.side is enums.TradeOrderSide.BUY:
                     self.order_profitability *= -1
         return self.order_profitability
 
     async def default_exchange_update_order_status(self):
-        result = await self.exchange_manager.exchange.get_order(self.order_id, self.symbol)
-        new_status = self.exchange_manager.exchange.connector.parse_status(result)
+        raw_order = await self.exchange_manager.exchange.get_order(self.order_id, self.symbol)
+        new_status = order_util.parse_order_status(raw_order)
         self.is_synchronized_with_exchange = True
         if new_status in {enums.OrderStatus.FILLED, enums.OrderStatus.CLOSED}:
             await self.on_fill()
         elif new_status is enums.OrderStatus.CANCELED:
             await self.trader.cancel_order(self)
 
     def generate_executed_time(self):
         return self.exchange_manager.exchange.get_exchange_current_time()
 
     def is_counted_in_available_funds(self):
         return not self.is_self_managed()
 
     def is_self_managed(self):
+        if self.is_cleared():
+            return order_util.is_stop_order(self.order_type) or order_util.is_take_profit_order(self.order_type)
         return self.trader.allow_artificial_orders and \
             not self.is_synchronized_with_exchange and \
             not self.exchange_manager.exchange.is_supported_order_type(self.order_type)
 
     def is_long(self):
         return self.side is enums.TradeOrderSide.BUY
 
@@ -497,20 +562,22 @@
             try:
                 self._update_type_from_raw(raw_order)
                 if self.taker_or_maker is None:
                     self._update_taker_maker()
             except KeyError:
                 logging.get_logger(self.__class__.__name__).warning("Failed to parse order side and type")
 
-        price = raw_order.get(enums.ExchangeConstantsOrderColumns.PRICE.value, 0.0) or 0.0
-        # TODO replace with := when cython will be supporting it
-        stop_price = raw_order.get(enums.ExchangeConstantsOrderColumns.STOP_PRICE.value, None)
-        if stop_price is not None and (price is None or price == 0):
-            # parse stop price when available
-            price = stop_price
+        # use stop price when available
+        price = (
+            raw_order.get(enums.ExchangeConstantsOrderColumns.PRICE.value, None)
+            or raw_order.get(enums.ExchangeConstantsOrderColumns.STOP_PRICE.value, None)
+            or raw_order.get(enums.ExchangeConstantsOrderColumns.STOP_LOSS_PRICE.value, None)
+            or raw_order.get(enums.ExchangeConstantsOrderColumns.TAKE_PROFIT_PRICE.value, None)
+            or 0.0
+        )
         filled_price = decimal.Decimal(str(price))
         # set average price with real average price if available, use filled_price otherwise
         average_price = decimal.Decimal(str(raw_order.get(enums.ExchangeConstantsOrderColumns.AVERAGE.value, 0.0)
                                             or filled_price))
 
         return self.update(
             symbol=str(raw_order.get(enums.ExchangeConstantsOrderColumns.SYMBOL.value, None)),
@@ -561,14 +628,32 @@
         self.position_side = other_order.position_side
 
         self.is_waiting_for_chained_trigger = other_order.is_waiting_for_chained_trigger
 
         if other_order.state is not None:
             await other_order.state.replace_order(self)
 
+    def update_from_storage_order_details(self, order_details):
+        # rebind order attributes that are not stored on exchange
+        order_dict = order_details.get(orders_storage.OrdersStorage.ORIGIN_VALUE_KEY, {})
+        self.tag = order_dict.get(enums.ExchangeConstantsOrderColumns.TAG.value, self.tag)
+        self.trader_creation_kwargs = order_details.get(enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value,
+                                                        self.trader_creation_kwargs)
+        self.exchange_creation_params = order_details.get(enums.StoredOrdersAttr.EXCHANGE_CREATION_PARAMS.value,
+                                                          self.exchange_creation_params)
+        self.set_shared_signal_order_id(order_details.get(enums.StoredOrdersAttr.SHARED_SIGNAL_ORDER_ID.value,
+                                                          self.shared_signal_order_id))
+        self.has_been_bundled = order_details.get(enums.StoredOrdersAttr.HAS_BEEN_BUNDLED.value,
+                                                  self.has_been_bundled)
+        self.associated_entry_ids = order_details.get(enums.StoredOrdersAttr.ENTRIES.value,
+                                                      self.associated_entry_ids)
+        self.update_with_triggering_order_fees = order_details.get(
+            enums.StoredOrdersAttr.UPDATE_WITH_TRIGGERING_ORDER_FEES.value, False
+        )
+
     def consider_as_filled(self):
         self.status = enums.OrderStatus.FILLED
         if self.executed_time == 0:
             self.executed_time = self.timestamp
         if self.filled_quantity == constants.ZERO:
             self.filled_quantity = self.origin_quantity
         if self.filled_price == constants.ZERO:
@@ -642,15 +727,16 @@
             enums.ExchangeConstantsOrderColumns.SIDE.value: self.side.value,
             enums.ExchangeConstantsOrderColumns.AMOUNT.value: self.origin_quantity,
             enums.ExchangeConstantsOrderColumns.COST.value: self.total_cost,
             enums.ExchangeConstantsOrderColumns.QUANTITY_CURRENCY.value: self.quantity_currency,
             enums.ExchangeConstantsOrderColumns.FILLED.value: self.filled_quantity,
             enums.ExchangeConstantsOrderColumns.FEE.value: self.fee,
             enums.ExchangeConstantsOrderColumns.REDUCE_ONLY.value: self.reduce_only,
-            enums.ExchangeConstantsOrderColumns.TAG.value: self.tag
+            enums.ExchangeConstantsOrderColumns.TAG.value: self.tag,
+            enums.ExchangeConstantsOrderColumns.SELF_MANAGED.value: self.is_self_managed(),
         }
 
     def clear(self):
         if self.state is not None:
             self.state.clear()
         self.trader = None
         self.exchange_manager = None
@@ -694,14 +780,16 @@
                 return side, enums.TraderOrderType.UNKNOWN
             else:
                 # Incompatible order type info: raise error
                 raise e
 
         if order_type is enums.TradeOrderType.UNKNOWN:
             parsed_order_type = enums.TraderOrderType.UNKNOWN
+        elif order_type is enums.TradeOrderType.UNSUPPORTED:
+            parsed_order_type = enums.TraderOrderType.UNSUPPORTED
         elif side is enums.TradeOrderSide.BUY:
             if order_type is enums.TradeOrderType.LIMIT or order_type == enums.TradeOrderType.LIMIT_MAKER:
                 parsed_order_type = enums.TraderOrderType.BUY_LIMIT
             elif order_type is enums.TradeOrderType.MARKET:
                 parsed_order_type = enums.TraderOrderType.BUY_MARKET
             else:
                 parsed_order_type = _get_sell_and_buy_types(order_type)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_adapter.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_group.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_group.py`

 * *Files 12% similar despite different names*

```diff
@@ -41,15 +41,19 @@
         :param ignored_orders: orders that should be ignored
         """
 
     async def enable(self, enabled):
         self.enabled = enabled
 
     def get_group_open_orders(self):
-        return self.orders_manager.get_order_from_group(self.name)
+        return [
+            order
+            for order in self.orders_manager.get_order_from_group(self.name)
+            if order.is_open() and not order.is_cancelling()
+        ]
 
     def clear(self):
         self.orders_manager = None
 
     def __str__(self):
         return f"{self.__class__.__name__} #{self.name}"
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -111,14 +111,18 @@
                 order=self.order,
                 wait_for_refresh=True,
                 force_job_execution=force_synchronization,
             )
         except octobot_trading.errors.InvalidOrderState:
             self.get_logger().debug(f"Skipping exchange synchronisation as order has already been closed.")
 
+    async def wait_for_next_state(self, timeout) -> None:
+        # terminate is called at the end of the state for most order states
+        await self.wait_for_terminate(timeout)
+
     @staticmethod
     def ensure_not_cleared(order):
         if order.is_cleared():
             raise octobot_trading.errors.InvalidOrderState(f"Order has already been cleared. Order: {order}")
 
     def clear(self):
         """
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/order_util.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/order_util.py`

 * *Files 4% similar despite different names*

```diff
@@ -101,15 +101,15 @@
             logging.get_logger(LOGGER_NAME).error("Invalid min_cost from exchange")
         return False
     return True
 
 
 async def get_up_to_date_price(exchange_manager, symbol: str, timeout: int = None, base_error: str = None):
     exchange_time = exchange_manager.exchange.get_exchange_current_time()
-    base_error = base_error or f"Can't get the necessary price data to create a new order on the " \
+    base_error = base_error or f"Can't get the necessary price data to create a new {symbol} order on the " \
                                f"{timestamp_util.convert_timestamp_to_datetime(exchange_time)} " \
                                f"(timestamp: {exchange_time}):"
     try:
         mark_price = await exchange_manager.exchange_symbols_data.get_exchange_symbol_data(symbol) \
             .prices_manager.get_mark_price(timeout=timeout)
     except asyncio.TimeoutError:
         raise asyncio.TimeoutError(f"{base_error} mark price is not available")
@@ -178,14 +178,20 @@
                 side is enums.TradeOrderSide.SELL):
         quantity = market_quantity if current_position.symbol_contract.is_inverse_contract() \
             else market_quantity * current_price
         unleveraged_quantity = quantity / current_position.symbol_contract.current_leverage
         max_position_increased_order_quantity = get_max_order_quantity_for_price(
             current_position, unleveraged_quantity, current_price, new_position_side, symbol
         )
+        # apply MAX_INCREASED_POSITION_QUANTITY_MULTIPLIER in case the total order cost computation
+        # is not (yet) accurate on this exchange (default is 1, meaning the calculation is accurate)
+        if exchange_manager.exchange.MAX_INCREASED_POSITION_QUANTITY_MULTIPLIER != constants.ONE \
+           and not exchange_manager.is_backtesting:
+            max_position_increased_order_quantity *= \
+                exchange_manager.exchange.MAX_INCREASED_POSITION_QUANTITY_MULTIPLIER
         # increasing position: always use the same currency
         return max_position_increased_order_quantity, True
     return contract_market_quantity if side is enums.TradeOrderSide.BUY else contract_current_symbol_holding, False
 
 
 def get_max_order_quantity_for_price(position, available_quantity, price, side, symbol):
     """
@@ -220,17 +226,26 @@
     if fee and fee[enums.FeePropertyColumns.CURRENCY.value] == currency:
         return decimal.Decimal(str(fee[enums.FeePropertyColumns.COST.value]))
     return constants.ZERO
 
 
 def parse_raw_fees(raw_fees):
     fees = raw_fees
-    if fees and enums.ExchangeConstantsOrderColumns.COST.value in fees:
-        raw_fees[enums.ExchangeConstantsOrderColumns.COST.value] = \
-            decimal.Decimal(str(raw_fees[enums.ExchangeConstantsOrderColumns.COST.value]))
+    if fees:
+        # parsed fees should be from exchange by default
+        fees[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value] = \
+            fees.get(enums.FeePropertyColumns.IS_FROM_EXCHANGE.value, True)
+        if enums.FeePropertyColumns.COST.value in fees:
+            try:
+                raw_fees[enums.FeePropertyColumns.COST.value] = \
+                    decimal.Decimal(str(raw_fees[enums.FeePropertyColumns.COST.value]))
+            except decimal.InvalidOperation:
+                # Ensure fee cost can be used in computations. The original value is kept
+                # under the EXCHANGE_ORIGINAL_COST key if relevant
+                raw_fees[enums.FeePropertyColumns.COST.value] = constants.ZERO
     return fees
 
 
 def parse_order_status(raw_order):
     try:
         return enums.OrderStatus(raw_order[enums.ExchangeConstantsOrderColumns.STATUS.value])
     except KeyError:
@@ -260,16 +275,24 @@
         return enums.PNLTransactionSource.LIMIT_ORDER
     if is_stop_order(order.order_type):
         return enums.PNLTransactionSource.STOP_ORDER
     return enums.PNLTransactionSource.UNKNOWN
 
 
 def is_stop_order(order_type):
-    return order_type in [enums.TraderOrderType.STOP_LOSS, enums.TraderOrderType.STOP_LOSS_LIMIT,
-                          enums.TraderOrderType.TRAILING_STOP, enums.TraderOrderType.TRAILING_STOP_LIMIT]
+    return order_type in [
+        enums.TraderOrderType.STOP_LOSS, enums.TraderOrderType.STOP_LOSS_LIMIT,
+        enums.TraderOrderType.TRAILING_STOP, enums.TraderOrderType.TRAILING_STOP_LIMIT,
+    ]
+
+
+def is_take_profit_order(order_type):
+    return order_type in [
+        enums.TraderOrderType.TAKE_PROFIT, enums.TraderOrderType.TAKE_PROFIT_LIMIT,
+    ]
 
 
 def get_trade_order_type(order_type: enums.TraderOrderType):
     if order_type in (enums.TraderOrderType.BUY_MARKET, enums.TraderOrderType.SELL_MARKET):
         return enums.TradeOrderType.MARKET
     if order_type in (enums.TraderOrderType.BUY_LIMIT, enums.TraderOrderType.SELL_LIMIT):
         return enums.TradeOrderType.LIMIT
@@ -360,17 +383,23 @@
 
 
 async def _cancel_reduce_only_orders_on_position_reset(exchange_manager, symbol):
     for order in list(exchange_manager.exchange_personal_data.orders_manager.get_open_orders(symbol)):
         # reduce only order are automatically cancelled on exchanges, only cancel simulated orders
         if (exchange_manager.is_trader_simulated or order.is_self_managed()) \
                 and order.is_open() and order.reduce_only:
-            await order.trader.cancel_order(order)
-            if order.order_group:
-                await order.order_group.on_cancel(order)
+            try:
+                await order.trader.cancel_order(order)
+                if order.order_group:
+                    await order.order_group.on_cancel(order)
+            except (    # pylint: disable=try-except-raise
+                errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError
+            ):
+                # should never happen as those should be simulated orders
+                raise
 
 
 def get_order_quantity_currency(exchange_manager, symbol):
     try:
         parsed_symbol = symbol_util.parse_symbol(symbol)
         base, quote = parsed_symbol.base_and_quote()
     except ValueError:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/orders_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/orders_manager.py`

 * *Files 7% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 import collections
 import uuid
 import typing
 
 import octobot_commons.logging as logging
 
 import octobot_trading.enums as enums
+import octobot_trading.constants as constants
 import octobot_trading.util as util
 import octobot_trading.errors as errors
 import octobot_trading.personal_data.orders.order as order_class
 import octobot_trading.personal_data.orders.order_factory as order_factory
 import octobot_trading.personal_data.orders.order_util as order_util
 
 
@@ -41,25 +42,45 @@
         self.pending_creation_orders = []
         # if this the orders manager completed the initial exchange orders sync phase (only on real trader)
         self.are_exchange_orders_initialized = self.trader.simulate
 
     async def initialize_impl(self):
         self._reset_orders()
 
-    def get_all_orders(self, symbol=None, since=-1, limit=-1, tag=None):
-        return self._select_orders(None, symbol=symbol, since=since, limit=limit, tag=tag)
-
-    def get_open_orders(self, symbol=None, since=-1, limit=-1, tag=None):
-        return self._select_orders(enums.OrderStatus.OPEN, symbol, since, limit, tag=tag)
-
-    def get_pending_cancel_orders(self, symbol=None, since=-1, limit=-1, tag=None):
-        return self._select_orders(enums.OrderStatus.PENDING_CANCEL, symbol, since, limit, tag=tag)
-
-    def get_closed_orders(self, symbol=None, since=-1, limit=-1, tag=None):
-        return self._select_orders(enums.OrderStatus.CLOSED, symbol, since, limit, tag=tag)
+    def get_all_orders(
+        self, symbol=None, since=constants.NO_DATA_LIMIT, 
+        until=constants.NO_DATA_LIMIT, limit=constants.NO_DATA_LIMIT, tag=None):
+        return self._select_orders(
+            None, symbol=symbol, since=since,
+            until=until, limit=limit, tag=tag
+        )
+
+    def get_open_orders(
+        self, symbol=None, since=constants.NO_DATA_LIMIT, until=constants.NO_DATA_LIMIT,
+        limit=constants.NO_DATA_LIMIT, tag=None):
+        return self._select_orders(
+            enums.OrderStatus.OPEN, symbol, since=since,
+            until=until, limit=limit, tag=tag
+        )
+
+    def get_pending_cancel_orders(
+        self, symbol=None, since=constants.NO_DATA_LIMIT, until=constants.NO_DATA_LIMIT,
+        limit=constants.NO_DATA_LIMIT, tag=None):
+        return self._select_orders(
+            enums.OrderStatus.PENDING_CANCEL, symbol, since=since, 
+            until=until, limit=limit, tag=tag
+        )
+
+    def get_closed_orders(
+        self, symbol=None, since=constants.NO_DATA_LIMIT, until=constants.NO_DATA_LIMIT,
+        limit=constants.NO_DATA_LIMIT, tag=None):
+        return self._select_orders(
+            enums.OrderStatus.CLOSED, symbol, since=since,
+            until=until, limit=limit, tag=tag
+        )
 
     def get_order(self, order_id):
         return self.orders[order_id]
 
     def get_order_from_group(self, group_name):
         return [
             order
@@ -104,16 +125,16 @@
             self.logger.info(f"Including new order fetched from exchange: {raw_order}")
             new_order = order_factory.create_order_instance_from_raw(self.trader, raw_order)
             # replace new_order by previously created pending_order if any relevant pending_order
             new_order = await self.get_and_update_pending_order(new_order) or new_order
             if is_from_exchange:
                 new_order.is_synchronized_with_exchange = True
             self._add_order(order_id, new_order)
-            await new_order.initialize(is_from_exchange_data=True)
             self._check_orders_size()
+            await new_order.initialize(is_from_exchange_data=True)
             return True
         return await _update_order_from_raw(self.orders[order_id], raw_order)
 
     def register_pending_creation_order(self, pending_order):
         if self.trader.simulate:
             self.logger.error(f"Called register_pending_creation_order on an simulated trader, "
                               f"this should not happen. Order: {pending_order}")
@@ -188,26 +209,29 @@
             group.clear()
         self.order_groups = {}
 
     def _check_orders_size(self):
         if self.MAX_ORDERS_COUNT and len(self.orders) > self.MAX_ORDERS_COUNT:
             self._remove_oldest_orders(int(self.MAX_ORDERS_COUNT / 2))
 
-    def _select_orders(self, state=None, symbol=None, since=-1, limit=-1, tag=None):
+    def _select_orders(
+        self, state=None, symbol=None, since=constants.NO_DATA_LIMIT, 
+        until=constants.NO_DATA_LIMIT, limit=constants.NO_DATA_LIMIT, tag=None):
         orders = [
             order
             for order in self.orders.values()
             if (
                     (state is None or order.status == state) and
                     (symbol is None or (symbol and order.symbol == symbol)) and
-                    (since == -1 or (since and order.timestamp < since)) and
+                    (since == constants.NO_DATA_LIMIT or (since and order.timestamp >= since)) and
+                    (until == constants.NO_DATA_LIMIT or (until and order.timestamp <= until)) and
                     (tag is None or order.tag == tag)
             )
         ]
-        return orders if limit == -1 else orders[0:limit]
+        return orders if limit == constants.NO_DATA_LIMIT else orders[0:limit]
 
     def _remove_oldest_orders(self, nb_to_remove):
         for _ in range(nb_to_remove):
             self.orders.popitem(last=False)
 
     def clear(self):
         for order in self.orders.values():
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -10,46 +10,46 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.states cimport close_order_state
-from octobot_trading.personal_data.orders.states.close_order_state cimport (
-    CloseOrderState
+from octobot_trading.personal_data.orders.states import order_state_factory
+from octobot_trading.personal_data.orders.states.order_state_factory import (
+    create_order_state,
 )
 
-from octobot_trading.personal_data.orders.states cimport cancel_order_state
-from octobot_trading.personal_data.orders.states.cancel_order_state cimport (
-    CancelOrderState
-)
+from octobot_trading.personal_data.orders.states import close_order_state
+from octobot_trading.personal_data.orders.states import cancel_order_state
+from octobot_trading.personal_data.orders.states import open_order_state
+from octobot_trading.personal_data.orders.states import fill_order_state
+from octobot_trading.personal_data.orders.states import pending_creation_order_state
 
-from octobot_trading.personal_data.orders.states cimport open_order_state
-from octobot_trading.personal_data.orders.states.open_order_state cimport (
-    OpenOrderState
+from octobot_trading.personal_data.orders.states.close_order_state import (
+    CloseOrderState,
 )
-
-from octobot_trading.personal_data.orders.states cimport pending_creation_order_state
-from octobot_trading.personal_data.orders.states.pending_creation_order_state cimport (
-    PendingCreationOrderState
+from octobot_trading.personal_data.orders.states.cancel_order_state import (
+    CancelOrderState,
 )
-
-from octobot_trading.personal_data.orders.states cimport pending_creation_chained_order_state
-from octobot_trading.personal_data.orders.states.pending_creation_chained_order_state cimport (
-    PendingCreationChainedOrderState
+from octobot_trading.personal_data.orders.states.open_order_state import (
+    OpenOrderState,
 )
-
-from octobot_trading.personal_data.orders.states cimport fill_order_state
-from octobot_trading.personal_data.orders.states.fill_order_state cimport (
-    FillOrderState
+from octobot_trading.personal_data.orders.states.fill_order_state import (
+    FillOrderState,
+)
+from octobot_trading.personal_data.orders.states.pending_creation_order_state import (
+    PendingCreationOrderState,
+)
+from octobot_trading.personal_data.orders.states.pending_creation_chained_order_state import (
+    PendingCreationChainedOrderState,
 )
-
 
 __all__ = [
     "CloseOrderState",
     "CancelOrderState",
     "OpenOrderState",
+    "create_order_state",
+    "FillOrderState",
     "PendingCreationOrderState",
     "PendingCreationChainedOrderState",
-    "FillOrderState",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/cancel_order_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/cancel_order_state.py`

 * *Files 8% similar despite different names*

```diff
@@ -41,15 +41,15 @@
     def is_pending(self) -> bool:
         return self.state is enums.OrderStates.CANCELING
 
     def is_canceled(self) -> bool:
         return self.state is enums.OrderStates.CANCELED
 
     def is_status_pending(self) -> bool:
-        return self.order.status is enums.OrderStatus.PENDING_CANCEL
+        return self.order.status is enums.OrderStatus.PENDING_CANCEL and not self.order.simulated
 
     def is_status_cancelled(self) -> bool:
         return not self.is_status_pending() and self.order.status in constants.CANCEL_ORDER_STATUS_SCOPE
 
     def allows_new_status(self, status) -> bool:
         """
         Don't allow going from canceling to open
@@ -98,16 +98,17 @@
 
             # update portfolio after close
             async with self.order.exchange_manager.exchange_personal_data.portfolio_manager.portfolio.lock:
                 self.ensure_not_cleared(self.order)
                 await self.order.exchange_manager.exchange_personal_data.handle_portfolio_update_from_order(self.order,
                                                                                                             False)
 
-            # notify order filled
-            await self.order.exchange_manager.exchange_personal_data.handle_order_update_notification(self.order,
-                                                                                                      False)
+            # notify order cancelled
+            await self.order.exchange_manager.exchange_personal_data.handle_order_update_notification(
+                self.order, enums.OrderUpdateType.STATE_CHANGE
+            )
 
             # set close state
             await self.order.on_close(force_close=True)  # TODO force ?
         except Exception as e:
             self.get_logger().exception(e, True, f"Fail to execute cancel state termination : {e}.")
             raise
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/close_order_state.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/types/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,11 +9,23 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.personal_data.orders.order_state as order_state
 
-cdef class CloseOrderState(order_state.OrderState):
-    pass
+from octobot_trading.personal_data.positions.types import linear_position
+from octobot_trading.personal_data.positions.types import inverse_position
+
+from octobot_trading.personal_data.positions.types.linear_position import (
+    LinearPosition,
+)
+
+from octobot_trading.personal_data.positions.types.inverse_position import (
+    InversePosition,
+)
+
+__all__ = [
+    "LinearPosition",
+    "InversePosition",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/close_order_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/close_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/fill_order_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/fill_order_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -85,15 +85,15 @@
             self.order.on_fill_actions()
 
             # set executed time
             self.order.executed_time = self.order.generate_executed_time()
 
             # compute trading fees
             try:
-                if self.order.exchange_manager is not None:
+                if self.order.exchange_manager is not None and not self.order.has_exchange_fetched_fees():
                     self.order.fee = self.order.get_computed_fee()
             except KeyError:
                 self.get_logger().error(f"Fail to compute trading fees for {self.order}.")
 
             self.ensure_not_cleared(self.order)
             async with order_util.ensure_orders_relevancy(order=self.order):
                 # Trigger order group
@@ -106,15 +106,16 @@
                 async with self.order.exchange_manager.exchange_personal_data.portfolio_manager.portfolio.lock:
                     self.ensure_not_cleared(self.order)
                     await self.order.exchange_manager.exchange_personal_data.handle_portfolio_update_from_order(
                         self.order)
 
                 # notify order filled
                 await self.order.exchange_manager.exchange_personal_data.handle_order_update_notification(
-                    self.order, False)
+                    self.order, enums.OrderUpdateType.STATE_CHANGE
+                )
 
                 # call order on_filled callback
                 await self.order.on_filled()
 
             # set close state
             await self.order.on_close(force_close=True)  # TODO force ?
         except Exception as e:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/open_order_state.pxd` & `OctoBot-Trading-2.4.0/tests/personal_data/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,11 +9,22 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.personal_data.orders.order_state as order_state
 
-cdef class OpenOrderState(order_state.OrderState):
-    cdef bint has_terminated
+DEFAULT_ORDER_SYMBOL = "BTC/USDT"
+DEFAULT_SYMBOL_QUANTITY = 10
+DEFAULT_MARKET_QUANTITY = 1000
+
+
+def check_created_transaction(exchange_manager, closed_quantity, cumulated_closed_quantity):
+    transaction = get_latest_transaction(exchange_manager)
+    assert transaction.closed_quantity == closed_quantity
+    assert transaction.cumulated_closed_quantity == cumulated_closed_quantity
+
+
+def get_latest_transaction(exchange_manager):
+    transactions = exchange_manager.exchange_personal_data.transactions_manager.transactions
+    return list(transactions.values())[-1] if transactions else None
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/open_order_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/open_order_state.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,45 +9,54 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import asyncio
+
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.order_state as order_state
 import octobot_trading.personal_data.orders.states.order_state_factory as order_state_factory
 
 
 class OpenOrderState(order_state.OrderState):
     def __init__(self, order, is_from_exchange_data):
         super().__init__(order, is_from_exchange_data)
-        self.state = enums.States.OPEN if is_from_exchange_data \
-                                          or self.order.simulated \
-                                          or self.order.is_self_managed() \
-                                          or self.order.status is enums.OrderStatus.OPEN \
+        self.state = enums.States.OPEN if \
+            is_from_exchange_data \
+            or self.order.simulated \
+            or self.order.is_self_managed() \
+            or self.order.status is enums.OrderStatus.OPEN \
             else enums.States.OPENING
 
         self.has_terminated = False
+        self._is_not_open_anymore = asyncio.Event()
 
     def is_open(self) -> bool:
         """
         :return: True if the Order is considered as open
         """
         return not (self.is_pending() or self.is_refreshing())
 
     async def initialize_impl(self, forced=False) -> None:
         if forced:
             self.state = enums.States.OPEN
 
         if self.order.exchange_manager.exchange_personal_data.orders_manager.are_exchange_orders_initialized:
             # update the availability of the currency in the portfolio if order is not
             # from exchange initialization (otherwise it's already taken into account in portfolio)
-            self.order.exchange_manager.exchange_personal_data.portfolio_manager.portfolio. \
-                update_portfolio_available(self.order, is_new_order=True)
+            portfolio = self.order.exchange_manager.exchange_personal_data.portfolio_manager.portfolio
+            before_order_details = str(portfolio)
+            portfolio.update_portfolio_available(self.order, is_new_order=True)
+            self.get_logger().debug(
+                f"Updated portfolio available after new open order. "
+                f"Before order: {before_order_details}. After order: {portfolio}"
+            )
 
         return await super().initialize_impl()
 
     async def on_refresh_successful(self):
         """
         Verify the order is properly created and still OrderStatus.OPEN
         """
@@ -59,19 +68,32 @@
             if self.order.status is enums.OrderStatus.OPEN:
                 self.state = enums.States.OPEN
                 await self.update()
             else:
                 if self.order.status is enums.OrderStatus.CLOSED:
                     self.order.status = enums.OrderStatus.FILLED
                     self.order.state = None
+                self.set_is_not_open_anymore()
                 await order_state_factory.create_order_state(self.order, is_from_exchange_data=True)
         else:
             self.get_logger().debug(f"on_refresh_successful triggered from previous state "
                                     f"after state change on {self.order}")
 
+    def set_is_not_open_anymore(self):
+        if not self._is_not_open_anymore.is_set():
+            self._is_not_open_anymore.set()
+
+    def __del__(self):
+        super(OpenOrderState, self).__del__()
+        self.set_is_not_open_anymore()
+
+    async def wait_for_next_state(self, timeout) -> None:
+        # terminate can't be used to follow state transition in open orders
+        await asyncio.wait_for(self._is_not_open_anymore.wait(), timeout=timeout)
+
     async def terminate(self):
         """
         Should wait for being replaced by a FillOrderState or a CancelOrderState
         """
         if not self.has_terminated:
             self.log_event_message(enums.StatesMessages.OPEN)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/order_state_factory.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,16 +1,15 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
-#  License along with this library.
+#  License along with this library
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/states/order_state_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/states/order_state_factory.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 async def create_order_state(order, is_from_exchange_data=False, ignore_states=None):
     if ignore_states is None:
         ignore_states = []
 
     if order.status is enums.OrderStatus.PENDING_CREATION \
        and enums.States.PENDING_CREATION not in ignore_states:
         await order.on_pending_creation()
-    if order.status is enums.OrderStatus.OPEN and enums.States.OPEN not in ignore_states:
+    elif order.status is enums.OrderStatus.OPEN and enums.States.OPEN not in ignore_states:
         await order.on_open(force_open=False, is_from_exchange_data=is_from_exchange_data)
     elif order.status in constants.FILL_ORDER_STATUS_SCOPE \
             and enums.OrderStates.FILLED not in ignore_states \
             and enums.States.CLOSED not in ignore_states:
         await order.on_fill(force_fill=False, is_from_exchange_data=is_from_exchange_data)
     elif order.status in constants.CANCEL_ORDER_STATUS_SCOPE and enums.OrderStates.CANCELED not in ignore_states:
         await order.on_cancel(force_cancel=False, is_from_exchange_data=is_from_exchange_data)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -10,49 +10,58 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.types cimport limit
-from octobot_trading.personal_data.orders.types.limit cimport (
+from octobot_trading.personal_data.orders.types import limit
+from octobot_trading.personal_data.orders.types import trailing
+from octobot_trading.personal_data.orders.types import market
+from octobot_trading.personal_data.orders.types import unsupported_order
+from octobot_trading.personal_data.orders.types import unknown_order
+
+from octobot_trading.personal_data.orders.types.limit import (
     BuyLimitOrder,
     SellLimitOrder,
     LimitOrder,
     TakeProfitOrder,
     StopLossOrder,
     StopLossLimitOrder,
     TakeProfitLimitOrder,
 )
-from octobot_trading.personal_data.orders.types cimport trailing
-from octobot_trading.personal_data.orders.types.trailing cimport (
+
+from octobot_trading.personal_data.orders.types.trailing import (
     TrailingStopOrder,
     TrailingStopLimitOrder,
 )
-from octobot_trading.personal_data.orders.types cimport market
-from octobot_trading.personal_data.orders.types.market cimport (
+
+from octobot_trading.personal_data.orders.types.market import (
     MarketOrder,
     SellMarketOrder,
     BuyMarketOrder,
 )
-from octobot_trading.personal_data.orders.types cimport unknown_order
-from octobot_trading.personal_data.orders.types.unknown_order cimport (
+
+from octobot_trading.personal_data.orders.types.unsupported_order import (
+    UnsupportedOrder,
+)
+
+from octobot_trading.personal_data.orders.types.unknown_order import (
     UnknownOrder,
 )
 
 __all__ = [
+    "UnsupportedOrder",
     "UnknownOrder",
     "MarketOrder",
     "SellMarketOrder",
     "BuyMarketOrder",
     "BuyLimitOrder",
     "SellLimitOrder",
     "LimitOrder",
     "TakeProfitOrder",
     "StopLossOrder",
     "StopLossLimitOrder",
     "TakeProfitLimitOrder",
     "TrailingStopOrder",
     "TrailingStopLimitOrder",
 ]
-
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,52 +10,31 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.types import limit
-from octobot_trading.personal_data.orders.types import trailing
-from octobot_trading.personal_data.orders.types import market
-from octobot_trading.personal_data.orders.types import unknown_order
+from octobot_trading.personal_data.transactions.types import blockchain_transaction
+from octobot_trading.personal_data.transactions.types import fee_transaction
+from octobot_trading.personal_data.transactions.types import realised_pnl_transaction
+from octobot_trading.personal_data.transactions.types import transfer_transaction
 
-from octobot_trading.personal_data.orders.types.limit import (
-    BuyLimitOrder,
-    SellLimitOrder,
-    LimitOrder,
-    TakeProfitOrder,
-    StopLossOrder,
-    StopLossLimitOrder,
-    TakeProfitLimitOrder,
+from octobot_trading.personal_data.transactions.types.blockchain_transaction import (
+    BlockchainTransaction,
 )
-
-from octobot_trading.personal_data.orders.types.trailing import (
-    TrailingStopOrder,
-    TrailingStopLimitOrder,
+from octobot_trading.personal_data.transactions.types.fee_transaction import (
+    FeeTransaction,
 )
-
-from octobot_trading.personal_data.orders.types.market import (
-    MarketOrder,
-    SellMarketOrder,
-    BuyMarketOrder,
+from octobot_trading.personal_data.transactions.types.realised_pnl_transaction import (
+    RealisedPnlTransaction,
 )
-
-from octobot_trading.personal_data.orders.types.unknown_order import (
-    UnknownOrder,
+from octobot_trading.personal_data.transactions.types.transfer_transaction import (
+    TransferTransaction,
 )
 
 __all__ = [
-    "UnknownOrder",
-    "MarketOrder",
-    "SellMarketOrder",
-    "BuyMarketOrder",
-    "BuyLimitOrder",
-    "SellLimitOrder",
-    "LimitOrder",
-    "TakeProfitOrder",
-    "StopLossOrder",
-    "StopLossLimitOrder",
-    "TakeProfitLimitOrder",
-    "TrailingStopOrder",
-    "TrailingStopLimitOrder",
+    "BlockchainTransaction",
+    "FeeTransaction",
+    "RealisedPnlTransaction",
+    "TransferTransaction",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -10,47 +10,49 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.types.limit cimport buy_limit_order
-from octobot_trading.personal_data.orders.types.limit cimport sell_limit_order
-from octobot_trading.personal_data.orders.types.limit cimport limit_order
-from octobot_trading.personal_data.orders.types.limit cimport take_profit_order
-from octobot_trading.personal_data.orders.types.limit cimport stop_loss_order
-from octobot_trading.personal_data.orders.types.limit cimport stop_loss_limit_order
-from octobot_trading.personal_data.orders.types.limit cimport take_profit_limit_order
-
-from octobot_trading.personal_data.orders.types.limit.buy_limit_order cimport (
-    BuyLimitOrder,
-)
-from octobot_trading.personal_data.orders.types.limit.sell_limit_order cimport (
-    SellLimitOrder,
-)
-from octobot_trading.personal_data.orders.types.limit.limit_order cimport (
+from octobot_trading.personal_data.orders.types.limit import limit_order
+from octobot_trading.personal_data.orders.types.limit.limit_order import (
     LimitOrder,
 )
-from octobot_trading.personal_data.orders.types.limit.take_profit_order cimport (
+
+from octobot_trading.personal_data.orders.types.limit import stop_loss_order
+from octobot_trading.personal_data.orders.types.limit.stop_loss_order import (
+    StopLossOrder,
+)
+
+from octobot_trading.personal_data.orders.types.limit import take_profit_order
+from octobot_trading.personal_data.orders.types.limit.take_profit_order import (
     TakeProfitOrder,
 )
-from octobot_trading.personal_data.orders.types.limit.stop_loss_order cimport (
-    StopLossOrder,
+
+from octobot_trading.personal_data.orders.types.limit import buy_limit_order
+from octobot_trading.personal_data.orders.types.limit import sell_limit_order
+from octobot_trading.personal_data.orders.types.limit import stop_loss_limit_order
+from octobot_trading.personal_data.orders.types.limit import take_profit_limit_order
+
+from octobot_trading.personal_data.orders.types.limit.buy_limit_order import (
+    BuyLimitOrder,
+)
+from octobot_trading.personal_data.orders.types.limit.sell_limit_order import (
+    SellLimitOrder,
 )
-from octobot_trading.personal_data.orders.types.limit.stop_loss_limit_order cimport (
+from octobot_trading.personal_data.orders.types.limit.stop_loss_limit_order import (
     StopLossLimitOrder,
 )
-from octobot_trading.personal_data.orders.types.limit.take_profit_limit_order cimport (
+from octobot_trading.personal_data.orders.types.limit.take_profit_limit_order import (
     TakeProfitLimitOrder,
 )
 
 __all__ = [
     "BuyLimitOrder",
     "SellLimitOrder",
     "LimitOrder",
     "TakeProfitOrder",
     "StopLossOrder",
     "StopLossLimitOrder",
     "TakeProfitLimitOrder",
 ]
-
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/limit_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/limit/take_profit_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/limit/take_profit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,26 +10,49 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.orders.types.market import market_order
-from octobot_trading.personal_data.orders.types.market import sell_market_order
-from octobot_trading.personal_data.orders.types.market import buy_market_order
+from octobot_trading.personal_data.trades import trades_manager
+from octobot_trading.personal_data.trades import trade_factory
+from octobot_trading.personal_data.trades import channel
+from octobot_trading.personal_data.trades import trade
 
-from octobot_trading.personal_data.orders.types.market.market_order import (
-    MarketOrder,
+from octobot_trading.personal_data.trades.trades_manager import (
+    TradesManager,
 )
-from octobot_trading.personal_data.orders.types.market.sell_market_order import (
-    SellMarketOrder,
+from octobot_trading.personal_data.trades.trade_factory import (
+    create_trade_instance_from_raw,
+    create_trade_from_order,
+    create_trade_instance,
+    create_trade_from_dict,
 )
-from octobot_trading.personal_data.orders.types.market.buy_market_order import (
-    BuyMarketOrder,
+from octobot_trading.personal_data.trades.channel import (
+    TradesProducer,
+    TradesChannel,
+    TradesUpdater,
+)
+from octobot_trading.personal_data.trades.trade import (
+    Trade,
+)
+from octobot_trading.personal_data.trades.trade_pnl import (
+    TradePnl,
+)
+from octobot_trading.personal_data.trades.trades_util import (
+    compute_win_rate,
 )
 
 __all__ = [
-    "MarketOrder",
-    "SellMarketOrder",
-    "BuyMarketOrder",
+    "TradesManager",
+    "TradesProducer",
+    "TradesChannel",
+    "create_trade_instance_from_raw",
+    "create_trade_from_order",
+    "create_trade_instance",
+    "create_trade_from_dict",
+    "TradesUpdater",
+    "Trade",
+    "TradePnl",
+    "compute_win_rate",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/buy_market_order.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/margin_portfolio.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,11 +9,24 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.personal_data.orders.types.market.market_order as market_order
+import octobot_trading.constants as constants
+import octobot_trading.personal_data.portfolios.assets.margin_asset as margin_asset
+import octobot_trading.personal_data.portfolios.portfolio as portfolio_class
 
-cdef class BuyMarketOrder(market_order.MarketOrder):
-    pass
+
+class MarginPortfolio(portfolio_class.Portfolio):
+    def create_currency_asset(self, currency, available=constants.ZERO, total=constants.ZERO):
+        return margin_asset.MarginAsset(name=currency, available=available, total=total)
+
+    def update_portfolio_data_from_order(self, order):
+        pass  # TODO
+
+    def update_portfolio_data_from_withdrawal(self, amount, currency):
+        pass  # TODO
+
+    def update_portfolio_available_from_order(self, order, is_new_order=True):
+        pass  # TODO
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/market_order.pxd` & `OctoBot-Trading-2.4.0/tests/personal_data/trades/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,11 +9,27 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.personal_data.orders.order as order_class
+import octobot_trading.personal_data as personal_data
 
-cdef class MarketOrder(order_class.Order):
-    pass
+
+def create_trade(trader, trade_id, is_closing_order, origin_order_id):
+    trade = personal_data.Trade(trader)
+    trade.trade_id = trade_id
+    trade.is_closing_order = is_closing_order
+    trade.origin_order_id = origin_order_id
+    return trade
+
+
+def create_executed_trade(trader, side, executed_time, executed_quantity, executed_price, symbol, fee):
+    trade = personal_data.Trade(trader)
+    trade.executed_time = executed_time
+    trade.executed_quantity = executed_quantity
+    trade.executed_price = executed_price
+    trade.symbol = symbol
+    trade.fee = fee
+    trade.side = side
+    return trade
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/market/market_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/market/market_order.py`

 * *Files 16% similar despite different names*

```diff
@@ -34,7 +34,12 @@
         self.filled_quantity = self.origin_quantity
         self._update_total_cost()
         order_class.Order.on_fill_actions(self)
 
     def can_be_edited(self):
         # instantly filled orders can't be edited
         return False
+
+    def use_current_price_as_origin_price(self):
+        # Override to return True when the current order price can't be set by the user (ex: market orders)
+        return True
+
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,87 +9,115 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-from octobot_trading.personal_data.portfolios cimport portfolio
-from octobot_trading.personal_data.portfolios.portfolio cimport (
-    Portfolio,
-)
-from octobot_trading.personal_data.portfolios cimport asset
-from octobot_trading.personal_data.portfolios.asset cimport (
-    Asset,
-)
-from octobot_trading.personal_data.portfolios cimport channel
-from octobot_trading.personal_data.portfolios.channel cimport (
+
+from octobot_trading.personal_data.portfolios import channel
+from octobot_trading.personal_data.portfolios.channel import (
     BalanceUpdater,
     BalanceProfitabilityUpdater,
     BalanceUpdaterSimulator,
     BalanceProfitabilityUpdaterSimulator,
     BalanceProducer,
     BalanceChannel,
     BalanceProfitabilityProducer,
     BalanceProfitabilityChannel,
 )
-from octobot_trading.personal_data.portfolios cimport portfolio_factory
-from octobot_trading.personal_data.portfolios.portfolio_factory cimport (
+
+from octobot_trading.personal_data.portfolios import portfolio
+from octobot_trading.personal_data.portfolios.portfolio import (
+    Portfolio,
+)
+from octobot_trading.personal_data.portfolios import asset
+from octobot_trading.personal_data.portfolios.asset import (
+    Asset,
+)
+from octobot_trading.personal_data.portfolios import portfolio_factory
+from octobot_trading.personal_data.portfolios import portfolio_profitability
+from octobot_trading.personal_data.portfolios import sub_portfolio
+from octobot_trading.personal_data.portfolios import portfolio_manager
+from octobot_trading.personal_data.portfolios import value_converter
+from octobot_trading.personal_data.portfolios import portfolio_value_holder
+from octobot_trading.personal_data.portfolios import types
+from octobot_trading.personal_data.portfolios import portfolio_util
+from octobot_trading.personal_data.portfolios import history
+
+
+from octobot_trading.personal_data.portfolios.portfolio_factory import (
     create_portfolio_from_exchange_manager,
 )
-from octobot_trading.personal_data.portfolios cimport sub_portfolio
-from octobot_trading.personal_data.portfolios.sub_portfolio cimport (
+from octobot_trading.personal_data.portfolios.portfolio_profitability import (
+    PortfolioProfitability,
+)
+from octobot_trading.personal_data.portfolios.sub_portfolio import (
     SubPortfolio,
 )
-from octobot_trading.personal_data.portfolios cimport portfolio_manager
-from octobot_trading.personal_data.portfolios.portfolio_manager cimport (
+from octobot_trading.personal_data.portfolios.portfolio_manager import (
     PortfolioManager,
 )
-from octobot_trading.personal_data.portfolios cimport types
-from octobot_trading.personal_data.portfolios.types cimport (
+from octobot_trading.personal_data.portfolios.value_converter import (
+    ValueConverter,
+)
+from octobot_trading.personal_data.portfolios.portfolio_value_holder import (
+    PortfolioValueHolder,
+)
+from octobot_trading.personal_data.portfolios.types import (
     FuturePortfolio,
     MarginPortfolio,
     SpotPortfolio,
 )
-from octobot_trading.personal_data.portfolios.assets cimport (
+from octobot_trading.personal_data.portfolios.assets import (
     FutureAsset,
     MarginAsset,
     SpotAsset,
 )
-from octobot_trading.personal_data.portfolios cimport portfolio_util
-from octobot_trading.personal_data.portfolios.portfolio_util cimport (
+from octobot_trading.personal_data.portfolios.portfolio_util import (
     parse_decimal_portfolio,
+    parse_decimal_config_portfolio,
+    filter_empty_values,
     portfolio_to_float,
+    get_draw_down,
+    get_coefficient_of_determination,
 )
-from octobot_trading.personal_data.portfolios cimport history
-from octobot_trading.personal_data.portfolios.history cimport (
+from octobot_trading.personal_data.portfolios.history import (
     create_historical_asset_value_from_dict_like_object,
     HistoricalAssetValue,
     HistoricalPortfolioValueManager,
 )
 
 __all__ = [
     "BalanceUpdaterSimulator",
     "BalanceProfitabilityUpdaterSimulator",
     "create_portfolio_from_exchange_manager",
     "BalanceUpdater",
     "BalanceProfitabilityUpdater",
+    "PortfolioProfitability",
     "Portfolio",
     "Asset",
     "BalanceProducer",
     "BalanceChannel",
     "BalanceProfitabilityProducer",
     "BalanceProfitabilityChannel",
     "SubPortfolio",
     "PortfolioManager",
+    "ValueConverter",
+    "PortfolioValueHolder",
     "FuturePortfolio",
     "MarginPortfolio",
     "SpotPortfolio",
     "FutureAsset",
     "MarginAsset",
     "SpotAsset",
     "parse_decimal_portfolio",
+    "parse_decimal_config_portfolio",
+    "filter_empty_values",
     "portfolio_to_float",
+    "get_draw_down",
+    "get_coefficient_of_determination",
     "create_historical_asset_value_from_dict_like_object",
+    "get_draw_down",
     "HistoricalAssetValue",
     "HistoricalPortfolioValueManager",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/asset.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/asset.py`

 * *Files 11% similar despite different names*

```diff
@@ -58,14 +58,25 @@
 
     def restore_available(self):
         """
         Balance available value with total
         """
         self.available = self.total
 
+    def restore_unavailable_from_other(self, other_asset):
+        with self.update_or_restore():
+            if other_asset.available < other_asset.total:
+                self.available = self.available - (other_asset.total - other_asset.available)
+            self._specific_restore_unavailable_from_other(other_asset)
+
+    def _specific_restore_unavailable_from_other(self, other_asset):
+        """
+        Implement if necessary
+        """
+
     def reset(self):
         """
         Reset asset portfolio to zero
         """
         raise NotImplementedError("reset is not implemented")
 
     def restore(self, old_asset):
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,26 +10,27 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.portfolios.assets import future_asset
-from octobot_trading.personal_data.portfolios.assets import margin_asset
-from octobot_trading.personal_data.portfolios.assets import spot_asset
-
-from octobot_trading.personal_data.portfolios.assets.future_asset import (
-    FutureAsset,
+from octobot_trading.personal_data.portfolios.history import historical_asset_value_factory
+from octobot_trading.personal_data.portfolios.history.historical_asset_value_factory import (
+    create_historical_asset_value_from_dict_like_object,
 )
-from octobot_trading.personal_data.portfolios.assets.margin_asset import (
-    MarginAsset,
+
+from octobot_trading.personal_data.portfolios.history import historical_asset_value
+from octobot_trading.personal_data.portfolios.history.historical_asset_value import (
+    HistoricalAssetValue,
 )
-from octobot_trading.personal_data.portfolios.assets.spot_asset import (
-    SpotAsset,
+
+from octobot_trading.personal_data.portfolios.history import historical_portfolio_value_manager
+from octobot_trading.personal_data.portfolios.history.historical_portfolio_value_manager import (
+    HistoricalPortfolioValueManager,
 )
 
 __all__ = [
-    "FutureAsset",
-    "MarginAsset",
-    "SpotAsset",
+    "create_historical_asset_value_from_dict_like_object",
+    "HistoricalAssetValue",
+    "HistoricalPortfolioValueManager",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/future_asset.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/future_asset.py`

 * *Files 3% similar despite different names*

```diff
@@ -63,14 +63,24 @@
     def __eq__(self, other):
         if isinstance(other, FutureAsset):
             return self.available == other.available and self.total == other.total and \
                    self.initial_margin == other.initial_margin and self.wallet_balance == other.wallet_balance and \
                    self.position_margin == other.position_margin and self.order_margin == other.order_margin
         return False
 
+    def _specific_restore_unavailable_from_other(self, other_asset):
+        if other_asset.initial_margin != constants.ZERO:
+            self.initial_margin = self.initial_margin + other_asset.initial_margin
+        # update wallet_balance when handling cross positions
+        if other_asset.position_margin != constants.ZERO:
+            self.position_margin = self.position_margin + other_asset.position_margin
+        if other_asset.order_margin != constants.ZERO:
+            self.order_margin = self.order_margin + other_asset.order_margin
+
+
     def restore(self, old_asset):
         """
         Restore asset from previous state
         :param old_asset: previous asset state
         """
         super().restore(old_asset)
         self.unrealized_pnl = old_asset.unrealized_pnl
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/margin_asset.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/margin_asset.py`

 * *Files 6% similar despite different names*

```diff
@@ -35,14 +35,22 @@
 
     def __eq__(self, other):
         if isinstance(other, MarginAsset):
             return self.available == other.available and self.total == other.total and \
                    self.borrowed == other.borrowed and self.interest == other.interest and self.locked == other.locked
         return False
 
+    def _specific_restore_unavailable_from_other(self, other_asset):
+        if other_asset.borrowed != constants.ZERO:
+            self.borrowed = self.borrowed + other_asset.borrowed
+        if other_asset.interest != constants.ZERO:
+            self.interest = self.interest + other_asset.interest
+        if other_asset.locked != constants.ZERO:
+            self.locked = self.locked + other_asset.locked
+
     def update(self, available=constants.ZERO, total=constants.ZERO, borrowed=constants.ZERO,
                interest=constants.ZERO, locked=constants.ZERO):
         """
         Update asset portfolio
         :param available: the available delta
         :param total: the total delta
         :param borrowed: the borrowed delta
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/assets/spot_asset.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/assets/spot_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -10,28 +10,28 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.portfolios.channel cimport balance
-from octobot_trading.personal_data.portfolios.channel.balance cimport (
+from octobot_trading.personal_data.portfolios.channel import balance
+from octobot_trading.personal_data.portfolios.channel.balance import (
     BalanceProducer,
     BalanceChannel,
     BalanceProfitabilityProducer,
     BalanceProfitabilityChannel,
 )
-from octobot_trading.personal_data.portfolios.channel cimport balance_updater
-from octobot_trading.personal_data.portfolios.channel.balance_updater cimport (
+from octobot_trading.personal_data.portfolios.channel import balance_updater
+from octobot_trading.personal_data.portfolios.channel.balance_updater import (
     BalanceUpdater,
     BalanceProfitabilityUpdater,
 )
-from octobot_trading.personal_data.portfolios.channel cimport balance_updater_simulator
-from octobot_trading.personal_data.portfolios.channel.balance_updater_simulator cimport (
+from octobot_trading.personal_data.portfolios.channel import balance_updater_simulator
+from octobot_trading.personal_data.portfolios.channel.balance_updater_simulator import (
     BalanceUpdaterSimulator,
     BalanceProfitabilityUpdaterSimulator,
 )
 
 __all__ = [
     "BalanceUpdaterSimulator",
     "BalanceProfitabilityUpdaterSimulator",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/balance.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=W0237
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/channel/balance_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/channel/balance_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_asset_value.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/historical_asset_value.py`

 * *Files 13% similar despite different names*

```diff
@@ -18,22 +18,27 @@
 
 class HistoricalAssetValue:
     """
     HistoricalAssetValue stores the portfolio value at a given time in multiple currencies
     """
     TIMESTAMP_KEY = "t"
     VALUES_KEY = "v"
+    SIGNIFICANT_VALUE_CHANGE_THRESHOLD = 0.1    # 10%
 
     def __init__(self, timestamp, value_by_currency):
         self._timestamp = timestamp
         self._value_by_currency = copy.copy(value_by_currency)
 
     def __contains__(self, item):
         return item in self._value_by_currency
 
+    def __repr__(self):
+        return f"{self.__class__.__name__} " \
+               f"[timestamp: {HistoricalAssetValue}, _value_by_currency{self._value_by_currency}]"
+
     def get(self, currency):
         return self._value_by_currency[currency]
 
     def set(self, currency, value):
         self._value_by_currency[currency] = value
 
     def update(self, value_by_currency):
@@ -45,12 +50,18 @@
 
     def get_currencies(self):
         return self._value_by_currency.keys()
 
     def get_timestamp(self):
         return self._timestamp
 
+    def is_significant_change(self, currency, value):
+        stored_value = self.get(currency)
+        if not stored_value:
+            return bool(value)
+        return abs(stored_value - value) / stored_value >= self.SIGNIFICANT_VALUE_CHANGE_THRESHOLD
+
     def to_dict(self):
         return {
             self.TIMESTAMP_KEY: self._timestamp,
             self.VALUES_KEY: {currency: float(value) for currency, value in self._value_by_currency.items()}
         }
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import time
+
 import sortedcontainers
 import copy
 
 import octobot_commons.logging as logging
 import octobot_commons.constants as commons_constants
 import octobot_commons.enums as commons_enums
 import octobot_commons.symbols as symbol_util
@@ -58,25 +60,45 @@
             constants.DEFAULT_SAVED_HISTORICAL_TIMEFRAMES
         )
         self.data_source = data_source or self.__class__.DEFAULT_DATA_SOURCE
         self.version = version or self.__class__.DEFAULT_DATA_VERSION
         self.starting_time = self.portfolio_manager.exchange_manager.exchange.get_exchange_current_time()
         self.last_update_time = self.starting_time
         self.starting_portfolio = None
+        self.historical_ending_portfolio = None
+        self.historical_starting_portfolio_values = {}
         self.ending_portfolio = None
 
         self.max_history_size = self.__class__.MAX_HISTORY_SIZE
         self.historical_portfolio_value = sortedcontainers.SortedDict()
 
     async def initialize_impl(self):
         """
         Reset the portfolio instance
         """
         await self._reload_historical_portfolio_value()
 
+    async def reset_history(self):
+        self.starting_time = self.portfolio_manager.exchange_manager.exchange.get_exchange_current_time()
+        self.last_update_time = self.starting_time
+        self.starting_portfolio = None
+        self.ending_portfolio = None
+        self.historical_portfolio_value = sortedcontainers.SortedDict()
+        # reset uploaded portfolio history
+        await self.save_historical_portfolio_value(reset=True)
+
+    def has_previous_session_portfolio(self):
+        return self.historical_ending_portfolio is not None
+
+    def has_historical_starting_portfolio_value(self, unit):
+        return unit in self.historical_starting_portfolio_values
+
+    def get_historical_starting_starting_portfolio_value(self, unit):
+        return self.historical_starting_portfolio_values[unit]
+
     async def on_portfolio_update(self):
         """
         Updates the historical portfolio if changed
         """
         if self.portfolio_manager.portfolio is not None \
            and self.portfolio_manager.portfolio.portfolio is not None \
            and self.ending_portfolio != portfolio_util.portfolio_to_float(
@@ -93,16 +115,17 @@
         :param force_update: when True, even if timestamp is already associated to a value, the value is still updated
         :param save_changes: when True, updates the database via save_historical_portfolio_value()
         :param include_past_data: when True, also save data from past time periods using their closest relevant
         timestamp
         :return: True if something changed
         """
         # TODO replace by := when cython will support it
-        relevant_timestamps = self._get_relevant_timestamps(timestamp, value_by_currency.keys(),
-                                                            self.saved_time_frames, force_update, include_past_data)
+        relevant_timestamps = self._get_relevant_timestamps(
+            timestamp, value_by_currency, self.saved_time_frames, force_update, include_past_data
+        )
         if relevant_timestamps:
             return await self._upsert_value(relevant_timestamps, value_by_currency, save_changes)
         return False
 
     async def on_new_values(self, value_by_currency_by_timestamp, force_update=False, save_changes=True):
         changed = False
         for timestamp, value_by_currency in value_by_currency_by_timestamp.items():
@@ -138,23 +161,19 @@
                 # do not add missing historical values
                 self.logger.debug(f"Missing price data when computing historical portfolio value: {e}")
         return historical_values
 
     def get_historical_value(self, timestamp):
         return self.historical_portfolio_value[timestamp]
 
-    async def reset_history(self):
-        self.historical_portfolio_value = sortedcontainers.SortedDict()
-        await self.save_historical_portfolio_value()
-
     async def _upsert_value(self, timestamps, value_by_currency, save_changes):
         changed = False
         for timestamp in timestamps:
             try:
-                changed |= self.get_historical_value(timestamp).update(value_by_currency)
+                changed = self.get_historical_value(timestamp).update(value_by_currency) or changed
             except KeyError:
                 self._add_historical_portfolio_value(timestamp, value_by_currency)
                 changed = True
         if changed and save_changes:
             await self.save_historical_portfolio_value()
         return changed
 
@@ -165,97 +184,110 @@
         self.historical_portfolio_value[timestamp] = \
             historical_asset_value.HistoricalAssetValue(timestamp, value_by_currency)
 
     def _update_portfolios(self):
         if self.portfolio_manager.portfolio is None or self.portfolio_manager.portfolio.portfolio is None:
             self.logger.debug("Ignoring portfolio values in history: portfolio_manager.portfolio is not initialized")
             return
-        self.ending_portfolio = portfolio_util.portfolio_to_float(
+        self.ending_portfolio = portfolio_util.filter_empty_values(portfolio_util.portfolio_to_float(
             self.portfolio_manager.portfolio.portfolio
-        )
+        ))
         if self.starting_portfolio is None:
             if self.portfolio_manager.portfolio_value_holder.origin_portfolio is None \
                     or not self.portfolio_manager.portfolio_value_holder.origin_portfolio.portfolio:
                 # origin portfolio might not be initialized, use ending_portfolio
                 self.starting_portfolio = copy.deepcopy(self.ending_portfolio)
             else:
-                self.starting_portfolio = portfolio_util.portfolio_to_float(
+                self.starting_portfolio = portfolio_util.filter_empty_values(portfolio_util.portfolio_to_float(
                     self.portfolio_manager.portfolio_value_holder.origin_portfolio.portfolio
-                )
+                ))
 
-    async def save_historical_portfolio_value(self, update_data=True):
+    async def save_historical_portfolio_value(self, update_data=True, reset=False):
         if update_data:
             self.last_update_time = self.portfolio_manager.exchange_manager.exchange.get_exchange_current_time()
             self._update_portfolios()
         if not self.portfolio_manager.exchange_manager.is_backtesting:
             # in backtesting, history is stored at the end
-            await self.portfolio_manager.exchange_manager.storage_manager.store_history()
+            await self.portfolio_manager.exchange_manager.storage_manager.portfolio_storage.store_history(reset=reset)
 
     async def _reload_historical_portfolio_value(self):
         db = self.portfolio_manager.exchange_manager.storage_manager.portfolio_storage.get_db()
-        self._load_historical_values(await db.all(self.TABLE_NAME))
-        self._load_metadata(await db.all(commons_enums.RunDatabases.METADATA.value))
+        try:
+            self._load_historical_values(await db.all(self.TABLE_NAME))
+            self._load_metadata(await db.all(commons_enums.RunDatabases.METADATA.value))
+        except Exception as err:
+            self.logger.exception(err, True, f"Error when ready portfolio history: {err}")
 
     def _load_historical_values(self, dict_values):
         self.historical_portfolio_value = sortedcontainers.SortedDict({
             element[historical_asset_value.HistoricalAssetValue.TIMESTAMP_KEY]:
                 historical_asset_value_factory.create_historical_asset_value_from_dict_like_object(
                     historical_asset_value.HistoricalAssetValue, element
                 )
             for element in dict_values
         })
+        self._load_historical_starting_portfolio_values()
 
     def _load_metadata(self, metadata_list):
         if metadata_list:
             # metadata are always stored as the 1st element of the table
             metadata = metadata_list[0]
-            # on real trader, use historical values
-            if not self.portfolio_manager.exchange_manager.is_trader_simulated:
-                self.starting_time = metadata.get(self.STARTING_TIME, self.starting_time)
-                self.starting_portfolio = metadata.get(self.STARTING_PORTFOLIO, None)
+            self.starting_time = metadata.get(self.STARTING_TIME, self.starting_time)
+            self.starting_portfolio = metadata.get(self.STARTING_PORTFOLIO, None)
+            self.historical_ending_portfolio = metadata.get(self.ENDING_PORTFOLIO, None)
+
+    def _load_historical_starting_portfolio_values(self):
+        self.historical_starting_portfolio_values = {}
+        for value in self.historical_portfolio_value.values():
+            for currency in value.get_currencies():
+                if currency not in self.historical_starting_portfolio_values:
+                    self.historical_starting_portfolio_values[currency] = value.get(currency)
 
     def _is_historical_timestamp_relevant(self, timestamp, time_frame_seconds, from_timestamp, to_timestamp):
+        from_timestamp = from_timestamp or 0
+        to_timestamp = to_timestamp or time.time()
         return self._is_timestamp_relevant(timestamp, time_frame_seconds) and \
-               from_timestamp <= timestamp <= to_timestamp
+           from_timestamp <= timestamp <= to_timestamp
 
     @staticmethod
     def _is_timestamp_relevant(timestamp, time_frame_seconds):
         return timestamp % time_frame_seconds == 0
 
     @staticmethod
     def convert_to_historical_timestamp(timestamp, time_frame):
         return timestamp - (timestamp % (
                 commons_enums.TimeFramesMinutes[time_frame] * commons_constants.MINUTE_TO_SECONDS
         ))
 
-    def _get_relevant_timestamps(self, timestamp, currencies, time_frames, force_update, include_past_data):
+    def _get_relevant_timestamps(self, timestamp, value_by_currency, time_frames, force_update, include_past_data):
         relevant_timestamps = set()
         current_time = self.portfolio_manager.exchange_manager.exchange.get_exchange_current_time()
         for time_frame in time_frames:
             # allowed times are [local time frame t0: local time frame t0 + allowed lag]
             time_frame_allowed_window_start = self.convert_to_historical_timestamp(
                 timestamp if include_past_data else current_time,
                 time_frame)
-            if self._should_update_timestamp(currencies, time_frame_allowed_window_start, force_update):
+            if self._should_update_timestamp(value_by_currency, time_frame_allowed_window_start, force_update):
                 # allow time window if time_frame_allowed_window_start not in self.historical_portfolio_value
-                # or when force_update
+                # or when value changes are significant or when force_update
                 time_frame_seconds = commons_enums.TimeFramesMinutes[time_frame] * commons_constants.MINUTE_TO_SECONDS
                 time_frame_allowed_window_end = time_frame_allowed_window_start + \
                     max(time_frame_seconds * self.TIME_FRAME_RELEVANCY_TIME_RATIO,
                         self.MIN_TIME_FRAME_RELEVANCY_SECONDS)
                 if time_frame_allowed_window_start <= timestamp <= time_frame_allowed_window_end:
                     relevant_timestamps.add(time_frame_allowed_window_start)
         return relevant_timestamps
 
-    def _should_update_timestamp(self, currencies, time_frame_allowed_window_start, force_update):
+    def _should_update_timestamp(self, value_by_currency, time_frame_allowed_window_start, force_update):
         if force_update:
             return True
         try:
-            for currency in currencies:
-                self.get_historical_value(time_frame_allowed_window_start).get(currency)
+            for currency, value in value_by_currency.items():
+                if self.get_historical_value(time_frame_allowed_window_start).is_significant_change(currency, value):
+                    return True
         except KeyError:
             return True
         return False
 
     def _get_value_in_currency(self, historical_value, currency):
         try:
             return historical_value.get(currency)
@@ -263,20 +295,33 @@
             return self._convert_historical_value(historical_value, currency)
 
     def _convert_historical_value(self, historical_value, target_currency):
         # TODO try to get a more accurate historical value into target_currency currency using price history
         # last chance: try to get any usable value from portfolio value holder (not accurate since used the intermediary
         # asset might also have changed in price since the time it was recorded)
         for currency in historical_value.get_currencies():
-            for pair in self.portfolio_manager.portfolio_value_holder.last_prices_by_trading_pair:
+            quantity = historical_value.get(currency)
+            # 1. try from pairs with price
+            for pair in self.portfolio_manager.portfolio_value_holder.value_converter.last_prices_by_trading_pair:
                 base_and_quote = symbol_util.parse_symbol(pair).base_and_quote()
                 if currency in base_and_quote and target_currency in base_and_quote:
-                    return self.portfolio_manager.portfolio_value_holder.convert_currency_value_using_last_prices(
-                        historical_value.get(currency), currency, target_currency
+                    return self.portfolio_manager.portfolio_value_holder.value_converter\
+                        .convert_currency_value_using_last_prices(
+                            historical_value.get(currency), currency, target_currency
+                        )
+            # 2. try from existing indirect pairs
+            try:
+                value = self.portfolio_manager.portfolio_value_holder.value_converter.\
+                    try_convert_currency_value_using_multiple_pairs(
+                        currency, target_currency, quantity, []
                     )
+                if value is not None:
+                    return value
+            except (errors.MissingPriceDataError, errors.PendingPriceDataError):
+                pass
         raise errors.MissingPriceDataError(f"no price data to evaluate {historical_value} on {target_currency}")
 
     def get_dict_historical_values(self):
         return [historical_asset.to_dict() for historical_asset in self.historical_portfolio_value.values()]
 
     def get_metadata(self):
         return {
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio.py`

 * *Files 6% similar despite different names*

```diff
@@ -143,16 +143,16 @@
     def update_portfolio_from_filled_order(self, order):
         """
         update_portfolio performs the update of the total / available quantity of a currency
         It is called only when an order is filled to update the real quantity of the currency to be set in "total" field
         :param order: the order to be taken into account
         """
         # stop losses and take profits aren't using available portfolio
-        # restoring available portfolio when order type is stop loss or take profit
-        if not _should_update_available(order):
+        # sync available portfolio funds when order type is stop loss or take profit
+        if _should_reduce_available_assets_on_fill(order):
             self.update_portfolio_available_from_order(order)
 
         self.update_portfolio_data_from_order(order)
         self.log_portfolio_update_from_order(order)
 
     def update_portfolio_from_withdrawal(self, amount, currency):
         """
@@ -281,14 +281,29 @@
         :param amount: withdraw quantity
         :param currency: withdraw currency
         """
         self.logger.debug(f"Portfolio updated from withdraw | {currency} -{amount}"
                           f" | {constants.CURRENT_PORTFOLIO_STRING} {self.portfolio}")
 
 
+def _should_reduce_available_assets_on_fill(order):
+    """
+    Check if the order fill should trigger an update on the portfolio available funds.
+    It's the case for orders that are not counted in available funds (stop losses). As they
+    are filled, the available funds have to be reduced to keep sync with total funds.
+
+    This is required to keep uniformity with regular order that are already reducing
+    part of available funds. As we are here on the fill context of a stop-like order,
+    available funds now have to be updated.
+    :param order: The order to check
+    :return: True if the order should update available portfolio
+    """
+    return not order.is_counted_in_available_funds()
+
+
 def _should_update_available(order):
     """
     Check if the order has impact on availability
     :param order: The order to check
     :return: True if the order should update available portfolio
     """
     return order.is_counted_in_available_funds()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_factory.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/supervisors/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,20 +1,31 @@
-# cython: language_level=3
+# pylint: disable=E0611, E0401
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.personal_data.portfolios.portfolio as portfolio_class
-cimport octobot_trading.exchanges as exchanges
 
-cpdef portfolio_class.Portfolio create_portfolio_from_exchange_manager(exchanges.ExchangeManager exchange_manager)
+from octobot_trading.supervisors import abstract_supervisor
+from octobot_trading.supervisors.abstract_supervisor import (
+    AbstractSupervisor,
+)
+
+from octobot_trading.supervisors import abstract_portfolio_supervisor
+from octobot_trading.supervisors.abstract_portfolio_supervisor import (
+    AbstractPortfolioSupervisor,
+)
+
+__all__ = [
+    "AbstractSupervisor",
+    "AbstractPortfolioSupervisor",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_manager.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,25 +10,27 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import contextlib
+import copy
 
 import octobot_commons.logging as logging
 import octobot_commons.constants as commons_constants
 import octobot_commons.tree as commons_tree
 import octobot_commons.enums as commons_enums
 
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
 import octobot_trading.personal_data as personal_data
 import octobot_trading.util as util
+import octobot_trading.enums as enums
 
 
 class PortfolioManager(util.Initializable):
     """
     Manage the portfolio and portfolio profitability instances
     """
 
@@ -39,22 +41,28 @@
 
         self.portfolio = None
         self.portfolio_profitability = None
         self.portfolio_value_holder = None
         self.historical_portfolio_value_manager = None
         self.reference_market = None
         self._is_initialized_event_set = False
+        self._simulated_portfolio_initial_config = None
 
     async def initialize_impl(self):
         """
         Reset the portfolio instance
         """
-        self._reset_portfolio()
-        if self.historical_portfolio_value_manager is not None:
+
+        if self.exchange_manager.is_storage_enabled() and self.historical_portfolio_value_manager is None:
+            self.historical_portfolio_value_manager = personal_data.HistoricalPortfolioValueManager(self)
             await self.historical_portfolio_value_manager.initialize()
+        self.set_simulated_portfolio_initial_config(
+            self.config[commons_constants.CONFIG_SIMULATOR][commons_constants.CONFIG_STARTING_PORTFOLIO]
+        )
+        self._reset_portfolio()
 
     def handle_balance_update(self, balance, is_diff_update=False):
         """
         Handle a balance update request
         :param balance: the new balance
         :param is_diff_update: True when the update is a partial portfolio
         :return: True if the portfolio was updated
@@ -131,20 +139,26 @@
             currency, time_frame, from_timestamp, to_timestamp
         )
         # add/update current portfolio value
         current_historical_time = self.historical_portfolio_value_manager.convert_to_historical_timestamp(
             self.exchange_manager.exchange.get_exchange_current_time(), time_frame
         )
         historical_values[current_historical_time] = self.portfolio_value_holder.portfolio_current_value
-        return historical_values
+        return [
+            {
+                enums.HistoricalPortfolioValue.TIME.value: key,
+                enums.HistoricalPortfolioValue.VALUE.value: val,
+            }
+            for key, val in historical_values.items()
+        ]
 
     async def update_historical_portfolio_values(self):
         if self.historical_portfolio_value_manager is None or \
            not self.portfolio_value_holder.current_crypto_currencies_values or \
-           self.portfolio_value_holder.initializing_symbol_prices:
+           self.portfolio_value_holder.value_converter.initializing_symbol_prices:
             # initializing symbol prices, impossible to get an accurate portfolio value for now
             return
         try:
             # in backtesting, save at the end of the backtesting when calling stop
             await self.historical_portfolio_value_manager.on_new_value(
                 self.exchange_manager.exchange.get_exchange_current_time(),
                 {
@@ -190,25 +204,43 @@
         Call BALANCE_CHANNEL producer to refresh real trader portfolio
         :return: True if the portfolio was updated
         """
         return await exchange_channel.get_chan(constants.BALANCE_CHANNEL,
                                                self.exchange_manager.id).get_internal_producer().\
             refresh_real_trader_portfolio()
 
+    async def reset_history(self):
+        if self.trader.simulate:
+            # reset simulated portfolio
+            # save not_available assets to reapply them
+            previous_assets = self.portfolio.portfolio
+            self._load_portfolio(True)
+            self._apply_locked_assets(previous_assets)
+        # nothing specific to do for real trader
+        # reset values
+        self.portfolio_value_holder.reset_portfolio_values()
+        self.portfolio_profitability.reset_profitability()
+        # reset historical values using now as a starting point
+        if self.exchange_manager.is_storage_enabled():
+            await self.historical_portfolio_value_manager.reset_history()
+
+    def _apply_locked_assets(self, previous_assets):
+        for key, asset in self.portfolio.portfolio.items():
+            if key in previous_assets:
+                asset.restore_unavailable_from_other(previous_assets[key])
+
     def _reset_portfolio(self):
         """
         Reset the portfolio and portfolio profitability instances
         """
         self.portfolio = personal_data.create_portfolio_from_exchange_manager(self.exchange_manager)
-        self._load_portfolio()
+        self._load_portfolio(False)
 
         self.reference_market = util.get_reference_market(self.config)
         self.portfolio_value_holder = personal_data.PortfolioValueHolder(self)
-        if self.exchange_manager.is_storage_enabled():
-            self.historical_portfolio_value_manager = personal_data.HistoricalPortfolioValueManager(self)
         self.portfolio_profitability = personal_data.PortfolioProfitability(self)
         self._is_initialized_event_set = False
 
     def _refresh_simulated_trader_portfolio_from_order(self, order):
         """
         Handle a balance update from an order request when simulating
         Catch a PortfolioNegativeValueError when calling portfolio update method and returns False if raised
@@ -223,30 +255,46 @@
             return True
         except errors.PortfolioNegativeValueError as portfolio_negative_value_error:
             self.logger.exception(portfolio_negative_value_error, True,
                                   f"Failed to update portfolio : {portfolio_negative_value_error} "
                                   f"for order {order.to_dict()}")
         return False
 
-    def _load_portfolio(self):
+    def _load_portfolio(self, reset_from_config):
         """
         Load simulated portfolio from config if required
         """
         if self.trader.is_enabled:
             if self.trader.simulate:
-                self._set_starting_simulated_portfolio()
+                if reset_from_config \
+                        or self.historical_portfolio_value_manager is None \
+                        or not self.historical_portfolio_value_manager.has_previous_session_portfolio():
+                    self._apply_starting_simulated_portfolio()
+                else:
+                    self._load_simulated_portfolio_from_history()
             self.logger.info(f"{constants.CURRENT_PORTFOLIO_STRING} {self.portfolio.portfolio}")
 
-    def _set_starting_simulated_portfolio(self):
+    def _load_simulated_portfolio_from_history(self):
+        #  todo also load available amounts when loading simulated orders
+        portfolio_amount_dict = personal_data.parse_decimal_config_portfolio(
+            {
+                symbol: value[commons_constants.PORTFOLIO_TOTAL]
+                for symbol, value in self.historical_portfolio_value_manager.historical_ending_portfolio.items()
+            }
+        )
+        self.handle_balance_update(self.portfolio.get_portfolio_from_amount_dict(portfolio_amount_dict))
+
+    def set_simulated_portfolio_initial_config(self, portfolio_config):
+        self._simulated_portfolio_initial_config = copy.deepcopy(portfolio_config)
+
+    def _apply_starting_simulated_portfolio(self):
         """
         Load new portfolio from config settings
         """
-        portfolio_amount_dict = personal_data.parse_decimal_config_portfolio(
-            self.config[commons_constants.CONFIG_SIMULATOR][commons_constants.CONFIG_STARTING_PORTFOLIO]
-        )
+        portfolio_amount_dict = personal_data.parse_decimal_config_portfolio(self._simulated_portfolio_initial_config)
         self.handle_balance_update(self.portfolio.get_portfolio_from_amount_dict(portfolio_amount_dict))
 
     def _set_initialized_event(self):
         commons_tree.EventProvider.instance().trigger_event(
             self.exchange_manager.bot_id, commons_tree.get_exchange_path(
                 self.exchange_manager.exchange_name,
                 commons_enums.InitializationEventExchangeTopics.BALANCE.value
@@ -258,9 +306,10 @@
             await self.historical_portfolio_value_manager.stop()
 
     def clear(self):
         """
         Clear portfolio manager objects
         """
         self.portfolio_profitability = None
+        self.portfolio_value_holder.clear()
         self.portfolio_value_holder = None
         self.historical_portfolio_value_manager = None
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_profitability.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_profitability.py`

 * *Files 5% similar despite different names*

```diff
@@ -43,14 +43,17 @@
         # is market only => not used to compute market average profitability
         self.traded_currencies_without_market_specific = set()
 
         # set of currencies that should be valuated because either present in config or as a reference market
         self.valuated_currencies = util.get_all_currencies(self.portfolio_manager.config, enabled_only=False)
         self.valuated_currencies.add(self.portfolio_manager.reference_market)
 
+    def reset_profitability(self):
+        self._reset_before_profitability_calculation()
+
     def get_average_market_profitability(self):
         """
         Returns the % move average of all the watched cryptocurrencies between bot's start time and now
         :return: the average market profitability
         """
         self.portfolio_manager.portfolio_value_holder.get_current_crypto_currencies_values()
         return self._calculate_average_market_profitability()
@@ -63,15 +66,14 @@
         """
         self._reset_before_profitability_calculation()
         try:
             self.portfolio_manager.handle_profitability_recalculation(force_recompute_origin_portfolio)
             self._update_profitability_calculation()
             return self.profitability_diff != constants.ZERO
         except KeyError as missing_data_exception:
-            self.logger.warning(f"Missing ticker data to calculate profitability")
             self.logger.warning(f"Missing {missing_data_exception} ticker data to calculate profitability")
         except Exception as missing_data_exception:
             self.logger.exception(missing_data_exception, True, str(missing_data_exception))
 
     def _reset_before_profitability_calculation(self):
         """
         Prepare profitability calculation
@@ -107,36 +109,40 @@
         self.market_profitability_percent = self.get_average_market_profitability()
 
     def _calculate_average_market_profitability(self):
         """
         Calculate the average of all the watched cryptocurrencies between bot's start time and now
         :return: the calculation result
         """
-        origin_values = [value / self.value_manager.origin_crypto_currencies_values[currency]
-                         for currency, value
-                         in self._only_symbol_currency_filter(self.value_manager.
-                                                              current_crypto_currencies_values).items()
-                         if self.value_manager.origin_crypto_currencies_values[currency] > constants.ZERO]
-
+        origin_values = [
+            value / self.value_manager.origin_crypto_currencies_values[currency]
+            for currency, value in self._get_trading_currencies_values(
+                self.value_manager.current_crypto_currencies_values
+            ).items()
+            if self.value_manager.origin_crypto_currencies_values[currency] > constants.ZERO
+        ]
         return sum(origin_values) / len(origin_values) * constants.ONE_HUNDRED - constants.ONE_HUNDRED \
             if origin_values else constants.ZERO
 
-    def _only_symbol_currency_filter(self, currency_dict):
+    def _get_trading_currencies_values(self, currency_dict):
         """
-        Return the dict of traded currencies with their portfolio value
-        :param currency_dict: the currency dictionary to be filtered
+        Return the dict of traded currencies with their portfolio value.
+        :param currency_dict: the value by currency dictionary
         :return: the currency portfolio value filtered
         """
         if not self.traded_currencies_without_market_specific:
             self._init_traded_currencies_without_market_specific()
-        return {currency: v for currency, v in currency_dict.items()
-                if currency in self.traded_currencies_without_market_specific}
+        return {
+            currency: v
+            for currency, v in currency_dict.items()
+            if currency in self.traded_currencies_without_market_specific
+        }
 
     def _init_traded_currencies_without_market_specific(self):
         """
         Initialize traded currencies without market specific set
-        Use exchange_config.all_config_symbol_pairs to take every config pair into account including disabled ones
+        Use exchange_config.traded_symbols to take every config pair into account except disabled ones
         """
         self.traded_currencies_without_market_specific = set(
             symbol_util.parse_symbol(pair).base
-            for pair in self.portfolio_manager.exchange_manager.exchange_config.all_config_symbol_pairs
+            for pair in self.portfolio_manager.exchange_manager.exchange_config.traded_symbol_pairs
         )
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/portfolio_util.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/portfolio_util.py`

 * *Files 4% similar despite different names*

```diff
@@ -38,14 +38,22 @@
 def parse_decimal_config_portfolio(portfolio):
     return {
         symbol: decimal.Decimal(str(symbol_balance))
         for symbol, symbol_balance in portfolio.items()
     }
 
 
+def filter_empty_values(portfolio):
+    return {
+        symbol: value
+        for symbol, value in portfolio.items()
+        if value[commons_constants.PORTFOLIO_TOTAL] > 0
+    }
+
+
 def portfolio_to_float(portfolio):
     float_portfolio = {}
     for symbol, symbol_balance in portfolio.items():
         if isinstance(symbol_balance, asset.Asset):
             float_portfolio[symbol] = {
                 commons_constants.PORTFOLIO_AVAILABLE: float(symbol_balance.available),
                 commons_constants.PORTFOLIO_TOTAL: float(symbol_balance.total)
@@ -79,15 +87,15 @@
                 portfolio_history.append(portfolio_history[-1] + current_pnl)
 
                 current_draw_down = constants.ONE_HUNDRED - \
                     (portfolio_history[-1] / (max(portfolio_history) / constants.ONE_HUNDRED))
 
                 draw_down = current_draw_down if current_draw_down > draw_down else draw_down
         except Exception as e:
-            commons_logging.get_logger(__name__).exception(e, True, f"Error when computing draw down: {e}")
+            commons_logging.get_logger(__name__).warning(f"Error when computing draw down: {e}")
     return draw_down
 
 
 async def get_coefficient_of_determination_data(transactions, start_balance,
                                                 use_high_instead_of_end_balance=True,
                                                 x_as_trade_count=True):
     if transactions:
@@ -160,14 +168,17 @@
     """
     Calculates proximity to the best case growth for the current run (best growth being associated to an exponential
     curve). The closer the actual result, the higher the coefficient_of_determination (R squared) will be.
     Return 0 if we end up with less money that we had to begin with
     :param use_high_instead_of_end_balance: best case exponential growth based on end balance or highest balance
     """
     coefficient_of_determination = 0
+    if exchange_manager.exchange_personal_data.portfolio_manager is None or \
+            exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.origin_portfolio is None:
+        return 0
     # get data the data necessary to compute the coefficient_of_determination
     origin_portfolio = portfolio_to_float(
         exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.origin_portfolio.portfolio
     )
     start_balance = origin_portfolio[
         exchange_manager.exchange_personal_data.portfolio_manager.reference_market][commons_constants.PORTFOLIO_TOTAL]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/sub_portfolio.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/sub_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/future_portfolio.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/future_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/portfolios/types/spot_portfolio.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/portfolios/types/spot_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,56 +10,58 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.positions cimport position_state
-from octobot_trading.personal_data.positions.position_state cimport (
+from octobot_trading.personal_data.positions import position_state
+from octobot_trading.personal_data.positions.position_state import (
     PositionState,
 )
 
-from octobot_trading.personal_data.positions cimport position
-from octobot_trading.personal_data.positions.position cimport (
+from octobot_trading.personal_data.positions import position
+from octobot_trading.personal_data.positions.position import (
     Position,
 )
 
-from octobot_trading.personal_data.positions cimport types
-from octobot_trading.personal_data.positions.types cimport (
+from octobot_trading.personal_data.positions import types
+from octobot_trading.personal_data.positions.types import (
     LinearPosition,
     InversePosition,
 )
 
-from octobot_trading.personal_data.positions cimport states
-from octobot_trading.personal_data.positions.states cimport (
+from octobot_trading.personal_data.positions import states
+from octobot_trading.personal_data.positions.states import (
     LiquidatePositionState,
-    OpenPositionState,
+    IdlePositionState,
+    ActivePositionState,
+    create_position_state,
 )
 
-from octobot_trading.personal_data.positions cimport channel
-from octobot_trading.personal_data.positions.channel cimport (
+from octobot_trading.personal_data.positions import channel
+from octobot_trading.personal_data.positions.channel import (
     PositionsProducer,
     PositionsChannel,
     PositionsUpdater,
     PositionsUpdaterSimulator,
 )
 
-from octobot_trading.personal_data.positions cimport positions_manager
-from octobot_trading.personal_data.positions.positions_manager cimport (
+from octobot_trading.personal_data.positions import positions_manager
+from octobot_trading.personal_data.positions.positions_manager import (
     PositionsManager,
 )
 
-from octobot_trading.personal_data.positions cimport position_util
-from octobot_trading.personal_data.positions.position_util cimport (
+from octobot_trading.personal_data.positions import position_util
+from octobot_trading.personal_data.positions.position_util import (
     parse_position_status,
 )
 
-from octobot_trading.personal_data.positions cimport position_factory
-from octobot_trading.personal_data.positions.position_factory cimport (
+from octobot_trading.personal_data.positions import position_factory
+from octobot_trading.personal_data.positions.position_factory import (
     create_position_instance_from_raw,
     create_position_from_type,
     create_symbol_position,
 )
 
 __all__ = [
     "PositionState",
@@ -72,9 +74,11 @@
     "PositionsUpdater",
     "PositionsManager",
     "create_position_instance_from_raw",
     "create_position_from_type",
     "create_symbol_position",
     "parse_position_status",
     "LiquidatePositionState",
-    "OpenPositionState",
+    "IdlePositionState",
+    "ActivePositionState",
+    "create_position_state",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,73 +10,27 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.positions import position_state
-from octobot_trading.personal_data.positions.position_state import (
-    PositionState,
-)
-
-from octobot_trading.personal_data.positions import position
-from octobot_trading.personal_data.positions.position import (
-    Position,
-)
-
-from octobot_trading.personal_data.positions import types
-from octobot_trading.personal_data.positions.types import (
-    LinearPosition,
-    InversePosition,
-)
-
-from octobot_trading.personal_data.positions import states
-from octobot_trading.personal_data.positions.states import (
-    LiquidatePositionState,
-    OpenPositionState,
-    create_position_state,
-)
-
-from octobot_trading.personal_data.positions import channel
-from octobot_trading.personal_data.positions.channel import (
+from octobot_trading.personal_data.positions.channel.positions import (
     PositionsProducer,
     PositionsChannel,
-    PositionsUpdater,
-    PositionsUpdaterSimulator,
-)
-
-from octobot_trading.personal_data.positions import positions_manager
-from octobot_trading.personal_data.positions.positions_manager import (
-    PositionsManager,
 )
 
-from octobot_trading.personal_data.positions import position_util
-from octobot_trading.personal_data.positions.position_util import (
-    parse_position_status,
+from octobot_trading.personal_data.positions.channel import positions_updater
+from octobot_trading.personal_data.positions.channel.positions_updater import (
+    PositionsUpdater,
 )
-
-from octobot_trading.personal_data.positions import position_factory
-from octobot_trading.personal_data.positions.position_factory import (
-    create_position_instance_from_raw,
-    create_position_from_type,
-    create_symbol_position,
+from octobot_trading.personal_data.positions.channel import positions_updater_simulator
+from octobot_trading.personal_data.positions.channel.positions_updater_simulator import (
+    PositionsUpdaterSimulator,
 )
 
 __all__ = [
-    "PositionState",
     "PositionsProducer",
     "PositionsChannel",
     "PositionsUpdaterSimulator",
-    "Position",
-    "LinearPosition",
-    "InversePosition",
     "PositionsUpdater",
-    "PositionsManager",
-    "create_position_instance_from_raw",
-    "create_position_from_type",
-    "create_symbol_position",
-    "parse_position_status",
-    "LiquidatePositionState",
-    "OpenPositionState",
-    "create_position_state",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/positions.py`

 * *Files 3% similar despite different names*

```diff
@@ -11,45 +11,40 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import asyncio
 
-import async_channel.constants as channel_constants
-
 import octobot_trading.exchange_channel as exchanges_channel
 import octobot_trading.enums as enums
 
 
 class PositionsProducer(exchanges_channel.ExchangeChannelProducer):
     async def push(self, positions):
         await self.perform(positions)
 
     async def perform(self, positions):
         try:
             for position in positions:
                 if not position:
                     continue
                 symbol: str = position[enums.ExchangeConstantsPositionColumns.SYMBOL.value]
-                if self.channel.get_filtered_consumers(symbol=channel_constants.CHANNEL_WILDCARD) or \
-                        self.channel.get_filtered_consumers(symbol=symbol):
-                    side: object = position[enums.ExchangeConstantsPositionColumns.SIDE.value]
-                    changed = await self.channel.exchange_manager.exchange_personal_data. \
-                        handle_position_update(symbol=symbol,
-                                               side=side,
-                                               position=position,
-                                               should_notify=False)
-
-                    if changed:
-                        await self.send(cryptocurrency=self.channel.exchange_manager.exchange.
-                                        get_pair_cryptocurrency(symbol),
-                                        symbol=symbol,
-                                        position=position,
-                                        is_updated=changed)
+                changed = await self.channel.exchange_manager.exchange_personal_data. \
+                    handle_position_update(symbol=symbol,
+                                           side=position[enums.ExchangeConstantsPositionColumns.SIDE.value],
+                                           position=position,
+                                           should_notify=False)
+
+                if changed:
+                    await self.send(cryptocurrency=self.channel.exchange_manager.exchange.
+                                    get_pair_cryptocurrency(symbol),
+                                    symbol=symbol,
+                                    position=position,
+                                    is_updated=changed)
         except asyncio.CancelledError:
             self.logger.info("Update tasks cancelled.")
         except Exception as e:
             self.logger.exception(e, True, f"Exception when triggering update: {e}")
 
     async def send(self, cryptocurrency, symbol, position, is_updated=False):
         for consumer in self.channel.get_filtered_consumers(symbol=symbol):
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/positions_updater.py`

 * *Files 6% similar despite different names*

```diff
@@ -35,21 +35,16 @@
     CHANNEL_NAME = constants.POSITIONS_CHANNEL
     POSITIONS_STARTING_REFRESH_TIME = 12
     POSITION_REFRESH_TIME = 9
     TIME_BETWEEN_POSITIONS_REFRESH = 3
 
     def __init__(self, channel):
         super().__init__(channel)
-        # Warning, when True, might result in missing contract details after bot startup as not every available
-        # contract will be loaded (only the ones related to configured symbols will be loaded alongside
-        # their position)
-        self.should_use_position_per_symbol = False
-
         # create async jobs
-        self.position_update_job = async_job.AsyncJob(self._positions_fetch_and_push,
+        self.position_update_job = async_job.AsyncJob(self.fetch_and_push_positions,
                                                       execution_interval_delay=self.POSITION_REFRESH_TIME,
                                                       min_execution_delay=self.TIME_BETWEEN_POSITIONS_REFRESH)
 
     async def initialize(self) -> None:
         """
         Initialize positions and future contracts
         """
@@ -70,39 +65,36 @@
     async def initialize_contracts(self) -> None:
         """
         Initialize exchange FutureContracts required to manage positions
         """
         for pair in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
             try:
                 await self.channel.exchange_manager.exchange.load_pair_future_contract(pair)
+                await self._update_contract_settings(pair)
             except NotImplementedError as e:
                 self.logger.debug(f"Can't to load {pair} contract info from exchange: {e}. "
                                   f"This contract will be created from fetched positions.")
             except Exception as e:
                 self.logger.exception(e, False)
                 self.logger.warning(f"Failed to load {pair} contract info : {e}")
 
     async def initialize_positions(self) -> None:
         """
         Initialize data before starting jobs
         """
         try:
             await self.fetch_and_push()
         except NotImplementedError:
-            self.should_use_position_per_symbol = True
-            try:
-                await self.fetch_and_push()
-            except NotImplementedError:
-                self.logger.warning("Position updater cannot fetch positions : required methods are not implemented")
-                await self.stop()
+            self.logger.warning("Position updater cannot fetch positions : required methods are not implemented")
+            await self.stop()
         except errors.NotSupported:
             self.logger.warning(f"{self.channel.exchange_manager.exchange_name} is not supporting updates")
             await self.stop()
         except Exception as e:
-            self.logger.error(f"Fail to initialize positions : {e}")
+            self.logger.exception(e, True, f"Fail to initialize positions : {e}")
 
     async def start(self):
         """
         Start updater jobs
         """
         if not self._should_run():
             return
@@ -111,71 +103,68 @@
         await asyncio.sleep(self.POSITIONS_STARTING_REFRESH_TIME)
         await self.position_update_job.run()
 
     async def fetch_and_push(self):
         """
         Update positions from exchange
         """
-        await self._positions_fetch_and_push()
+        await self.fetch_and_push_positions()
         await asyncio.sleep(self.TIME_BETWEEN_POSITIONS_REFRESH)
 
-    async def _positions_fetch_and_push(self):
-        """
-        Update positions from exchange
-        """
-        if self.should_use_position_per_symbol:
-            await self.fetch_position_per_symbol()
-        else:
-            await self.fetch_positions()
-
     def _should_run(self):
         return self.channel.exchange_manager.is_future
 
-    async def fetch_position_per_symbol(self):
-        positions = []
-        for symbol in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
-            fetched_positions = await self.channel.exchange_manager.exchange.get_position(symbol=symbol)
-            if positions:
-                positions += fetched_positions
-
-        if positions:
-            exchange_data.update_contracts_from_positions(self.channel.exchange_manager, positions)
-            await self._push_positions(positions)
-
     def _is_relevant_position(self, position_dict):
         return position_dict and position_dict.get(enums.ExchangeConstantsPositionColumns.SYMBOL.value, None) \
                in self.channel.exchange_manager.exchange_config.traded_symbol_pairs
 
-    async def fetch_positions(self):
-        positions = [
-            position
-            for position in await self.channel.exchange_manager.exchange.get_positions()
-        ]
-
+    async def fetch_and_push_positions(self):
+        """
+        Update positions from exchange
+        """
+        symbols = self.channel.exchange_manager.exchange_config.traded_symbol_pairs \
+            if self.channel.exchange_manager.exchange.REQUIRES_SYMBOL_FOR_EMPTY_POSITION else None
+        positions = await self.channel.exchange_manager.exchange.get_positions(symbols=symbols)
         if positions:
             relevant_positions = [
                 position
                 for position in positions
                 if self._is_relevant_position(position)
             ]
             # initialize relevant contracts first as they might be waited for
-            exchange_data.update_contracts_from_positions(self.channel.exchange_manager,
-                                                          relevant_positions)
-            exchange_data.update_contracts_from_positions(self.channel.exchange_manager,
-                                                          positions)
+            updated = exchange_data.update_contracts_from_positions(self.channel.exchange_manager, relevant_positions)
+            if exchange_data.update_contracts_from_positions(self.channel.exchange_manager, positions) or updated:
+                await self._update_positions_contract_settings(positions)
             # only consider positions that are relevant to the current setup
             await self._push_positions(relevant_positions)
 
     async def _push_positions(self, positions):
         await self.push(positions)
 
         if self._should_push_mark_price():
             for position in positions:
                 await self.extract_mark_price(position)
 
+    async def _update_positions_contract_settings(self, positions):
+        for position in positions:
+            symbol = position.get(enums.ExchangeConstantsPositionColumns.SYMBOL.value, None)
+            if symbol is not None:
+                await self._update_contract_settings(symbol)
+
+    async def _update_contract_settings(self, symbol):
+        try:
+            if constants.FORCED_MARGIN_TYPE:
+                await self.channel.exchange_manager.trader.set_margin_type(
+                    symbol, enums.PositionSide.BOTH, constants.FORCED_MARGIN_TYPE
+                )
+        except Exception as e:
+            self.logger.exception(e, True, f"Fail to update contracts settings : {e}")
+        finally:
+            self.channel.exchange_manager.exchange.set_contract_initialized_event(symbol)
+
     async def extract_mark_price(self, position_dict: dict):
         try:
             await exchanges_channel.get_chan(constants.MARK_PRICE_CHANNEL,
                                              self.channel.exchange_manager.id).get_internal_producer(). \
                 push(position_dict[enums.ExchangeConstantsPositionColumns.SYMBOL.value],
                      position_dict[enums.ExchangeConstantsPositionColumns.MARK_PRICE.value])
         except Exception as e:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py`

 * *Files 2% similar despite different names*

```diff
@@ -43,23 +43,25 @@
         """
         Initialize exchange FutureContracts required to manage positions
         """
         for pair in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
             contract = self.channel.exchange_manager.exchange.create_pair_contract(
                 pair=pair,
                 current_leverage=constants.DEFAULT_SYMBOL_LEVERAGE,
+                contract_size=constants.DEFAULT_SYMBOL_CONTRACT_SIZE,
                 margin_type=constants.DEFAULT_SYMBOL_MARGIN_TYPE,
                 contract_type=
                 self.channel.exchange_manager.exchange_config.backtesting_exchange_config.future_contract_type
                 if self.channel.exchange_manager.is_backtesting else self._get_contract_type_or_default(pair),
                 position_mode=constants.DEFAULT_SYMBOL_POSITION_MODE,
                 maintenance_margin_rate=constants.DEFAULT_SYMBOL_MAINTENANCE_MARGIN_RATE,
                 maximum_leverage=constants.DEFAULT_SYMBOL_MAX_LEVERAGE)
             if not contract.is_handled_contract():
                 self.logger.error(f"Unhandled contract {contract}. This contract can't be traded")
+            self.channel.exchange_manager.exchange.set_contract_initialized_event(pair)
 
     def _get_contract_type_or_default(self, pair):
         try:
             return self.channel.exchange_manager.exchange.get_contract_type(pair)
         except NotImplementedError as e:
             self.logger.error(f"Unimplemented required method: {e}")
         self.logger.error(f"Unknown contract type for {pair} on {self.channel.exchange_manager.exchange_name}. Using "
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position.py`

 * *Files 1% similar despite different names*

```diff
@@ -90,33 +90,43 @@
             self.logger_name = f"{self.get_name()} | {self.position_id}"
         return self.logger_name
 
     async def initialize_impl(self, **kwargs):
         """
         Initialize position status update tasks
         """
-        await positions_states.create_position_state(self, **kwargs)
+        positions_states.create_position_state(self, **kwargs)
+        if self.state.has_to_be_async_synchronized():
+            await self.state.initialize()
 
-    async def on_open(self, force_open=False, is_from_exchange_data=False):
+    def on_idle(self, force_open=False, is_from_exchange_data=False):
         """
-        Triggers a new position open state
+        Triggers a new position idle state
         :param force_open: if the new state should be forced
         :param is_from_exchange_data: if it's call from exchange data
         """
-        self.state = positions_states.OpenPositionState(self, is_from_exchange_data=is_from_exchange_data)
-        await self.state.initialize(forced=force_open)
+        self.state = positions_states.IdlePositionState(self, is_from_exchange_data=is_from_exchange_data)
+        self.state.sync_initialize(forced=force_open)
 
-    async def on_liquidate(self, force_liquidate=False, is_from_exchange_data=False):
+    def on_active(self, force_open=False, is_from_exchange_data=False):
+        """
+        Triggers a new position active state
+        :param force_open: if the new state should be forced
+        :param is_from_exchange_data: if it's call from exchange data
+        """
+        self.state = positions_states.ActivePositionState(self, is_from_exchange_data=is_from_exchange_data)
+        self.state.sync_initialize(forced=force_open)
+
+    def on_liquidate(self, force_liquidate=False, is_from_exchange_data=False):
         """
         Triggers a new position liquidation state
         :param force_liquidate: if the new state should be forced
         :param is_from_exchange_data: if it's call from exchange data
         """
         self.state = positions_states.LiquidatePositionState(self, is_from_exchange_data=is_from_exchange_data)
-        await self.state.initialize(forced=force_liquidate)
 
     def _should_change(self, original_value, new_value):
         if new_value is not None and original_value != new_value:
             return True
 
     def _update(self, position_id, symbol, currency, market, timestamp,
                 entry_price, mark_price, liquidation_price,
@@ -188,30 +198,30 @@
 
         self._update_quantity_or_size_if_necessary()
         # update side after quantity as it relies on self.quantity
         self._update_side(not entry_price)
         self._update_prices_if_necessary(mark_price)
         return changed
 
-    async def _ensure_position_initialized(self):
+    async def ensure_position_initialized(self, **kwargs):
         """
         Checks if the position has already been initialized
         When it's not initialize it
         """
         if self.state is None:
-            await self.initialize()
+            await self.initialize(**kwargs)
 
     async def update(self, update_size=None, mark_price=None, update_margin=None):
         """
         Updates position size and / or mark price
         :param update_size: the size update value
         :param mark_price: the mark price update value
         :param update_margin: the margin update value
         """
-        await self._ensure_position_initialized()
+        await self.ensure_position_initialized()
 
         try:
             with self.update_or_restore():
                 if mark_price is not None:
                     self._update_mark_price(mark_price)
                 if update_margin is not None:
                     self._update_size_from_margin(update_margin)
@@ -675,14 +685,16 @@
         Resets the side related data when a position side changes
         """
         if reset_entry_price:
             self._reset_entry_price()
         self.exit_price = constants.ZERO
         self.creation_time = self.exchange_manager.exchange.get_exchange_current_time()
         logging.get_logger(self.get_logger_name()).info(f"Changed position side: now {self.side.name}")
+        # update position state if necessary
+        positions_states.create_position_state(self)
 
     def _on_size_update(self,
                         size_update,
                         realised_pnl_update,
                         margin_update,
                         is_update_increasing_position_size):
         """
@@ -690,14 +702,16 @@
         """
         self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio. \
             update_portfolio_data_from_position_size_update(self,
                                                             realised_pnl_update,
                                                             size_update,
                                                             margin_update,
                                                             is_update_increasing_position_size)
+        # update position state if necessary
+        positions_states.create_position_state(self)
 
     async def recreate(self):
         """
         Recreate itself using its PositionManager instance
         """
         self.exchange_manager.exchange_personal_data.positions_manager.recreate_position(self)
 
@@ -714,15 +728,15 @@
             liquidation_price=raw_position.get(enums.ExchangeConstantsPositionColumns.LIQUIDATION_PRICE.value,
                                                constants.ZERO),
             quantity=raw_position.get(enums.ExchangeConstantsPositionColumns.QUANTITY.value, constants.ZERO),
             size=raw_position.get(enums.ExchangeConstantsPositionColumns.SIZE.value, constants.ZERO),
             value=raw_position.get(enums.ExchangeConstantsPositionColumns.NOTIONAL.value, constants.ZERO),
             initial_margin=raw_position.get(enums.ExchangeConstantsPositionColumns.INITIAL_MARGIN.value,
                                             constants.ZERO),
-            position_id=str(raw_position.get(enums.ExchangeConstantsPositionColumns.ID.value, symbol)),
+            position_id=str(raw_position.get(enums.ExchangeConstantsPositionColumns.ID.value, None) or symbol),
             timestamp=raw_position.get(enums.ExchangeConstantsPositionColumns.TIMESTAMP.value, 0),
             unrealized_pnl=raw_position.get(enums.ExchangeConstantsPositionColumns.UNREALIZED_PNL.value,
                                             constants.ZERO),
             realised_pnl=raw_position.get(enums.ExchangeConstantsPositionColumns.REALISED_PNL.value, constants.ZERO),
             fee_to_close=raw_position.get(enums.ExchangeConstantsPositionColumns.CLOSING_FEE.value, constants.ZERO),
             status=position_util.parse_position_status(raw_position)
         )
@@ -746,27 +760,30 @@
             enums.ExchangeConstantsPositionColumns.REALISED_PNL.value: self.realised_pnl,
         }
 
     def _check_for_liquidation(self):
         """
         _check_for_liquidation defines rules for a position to be liquidated
         """
+        if self.liquidation_price.is_nan():
+            return
         if (self.is_short()
             and self.mark_price >= self.liquidation_price > constants.ZERO) or (
             self.is_long()
             and self.mark_price <= self.liquidation_price > constants.ZERO
         ):
             raise errors.LiquidationPriceReached
 
     async def _create_liquidation_state(self):
         """
         create liquidation state
         """
         self.status = enums.PositionStatus.LIQUIDATING
-        await positions_states.create_position_state(self)
+        positions_states.create_position_state(self)
+        await self.state.initialize()
 
     def _reset_entry_price(self):
         """
         Reset the entry price to ZERO and force entry price update
         """
         self.entry_price = constants.ZERO
         self._update_prices_if_necessary(self.mark_price)
@@ -832,16 +849,15 @@
         self.fee_to_close = constants.ZERO
         self.status = enums.PositionStatus.OPEN
         self.side = enums.PositionSide.UNKNOWN
         self.unrealized_pnl = constants.ZERO
         self.realised_pnl = constants.ZERO
         self.creation_time = 0
         self.on_pnl_update()  # notify portfolio to reset unrealized PNL
-        if not self.is_open():
-            await self.on_open()
+        positions_states.create_position_state(self)
 
     def clear(self):
         """
         Clear position references
         """
         if self.state:
             self.state.clear()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_state.pxd` & `OctoBot-Trading-2.4.0/tests/exchange_data/funding/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,13 +9,7 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.personal_data.state as state_class
-
-cdef class PositionState(state_class.State):
-    cdef public object position  # instance of Position
-
-    cpdef bint is_liquidated(self)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/position_state.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import asyncio
 
 import octobot_trading.constants
 import octobot_trading.enums as enums
 import octobot_trading.errors
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.personal_data.state as state_class
 
@@ -24,14 +25,25 @@
 class PositionState(state_class.State):
     def __init__(self, position, is_from_exchange_data):
         super().__init__(is_from_exchange_data)
 
         # related position
         self.position = position
 
+        self._has_state_changed = asyncio.Event()
+
+    def has_to_be_async_synchronized(self):
+        return False
+
+    def is_active(self) -> bool:
+        """
+        :return: True if the Position has a non-zero size
+        """
+        return False
+
     def is_liquidated(self) -> bool:
         """
         :return: True if the instance is considered as liquidated
         """
         return False
 
     def log_event_message(self, state_message, error=None):
@@ -54,12 +66,28 @@
         """
         return (await exchange_channel.get_chan(octobot_trading.constants.POSITIONS_CHANNEL,
                                                 self.position.exchange_manager.id).get_internal_producer().
                 update_position_from_exchange(position=self.position,
                                               wait_for_refresh=True,
                                               force_job_execution=force_synchronization))
 
+    def set_is_changing_state(self):
+        if not self._has_state_changed.is_set():
+            self._has_state_changed.set()
+
+    def __del__(self):
+        """
+        Call set_is_changing_state in case this state has not been updated
+        """
+        self.set_is_changing_state()
+        super().__del__()
+
+    async def wait_for_next_state(self, timeout) -> None:
+        if self._has_state_changed.is_set():
+            return
+        await asyncio.wait_for(self._has_state_changed.wait(), timeout=timeout)
+
     def clear(self):
         """
         Clear references
         """
         self.position = None
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/position_util.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/kline/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,15 +9,7 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import octobot_trading.enums as enums
-
-
-def parse_position_status(raw_position):
-    try:
-        return enums.PositionStatus(raw_position[enums.ExchangeConstantsPositionColumns.STATUS.value])
-    except KeyError:
-        return None
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/positions_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/positions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -15,22 +15,27 @@
 #  License along with this library.
 
 from octobot_trading.personal_data.positions.states import position_state_factory
 from octobot_trading.personal_data.positions.states.position_state_factory import (
     create_position_state,
 )
 
-from octobot_trading.personal_data.positions.states import open_position_state
+from octobot_trading.personal_data.positions.states import idle_position_state
+from octobot_trading.personal_data.positions.states import active_position_state
 from octobot_trading.personal_data.positions.states import liquidate_position_state
 
 from octobot_trading.personal_data.positions.states.liquidate_position_state import (
     LiquidatePositionState,
 )
-from octobot_trading.personal_data.positions.states.open_position_state import (
-    OpenPositionState,
+from octobot_trading.personal_data.positions.states.idle_position_state import (
+    IdlePositionState,
+)
+from octobot_trading.personal_data.positions.states.active_position_state import (
+    ActivePositionState,
 )
 
 __all__ = [
     "LiquidatePositionState",
-    "OpenPositionState",
+    "IdlePositionState",
+    "ActivePositionState",
     "create_position_state",
 ]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/liquidate_position_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/liquidate_position_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -27,14 +27,17 @@
             if is_from_exchange_data or force_liquidate or self.position.simulated else enums.PositionStates.LIQUIDATING
 
     async def initialize_impl(self, forced=False) -> None:
         if forced:
             self.state = enums.PositionStates.LIQUIDATED
         return await super().initialize_impl()
 
+    def has_to_be_async_synchronized(self):
+        return True
+
     def is_pending(self) -> bool:
         return self.state is enums.PositionStates.LIQUIDATING
 
     def is_closed(self) -> bool:
         return self.state is enums.PositionStates.LIQUIDATED
 
     def is_liquidated(self) -> bool:
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/open_position_state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/idle_position_state.py`

 * *Files 20% similar despite different names*

```diff
@@ -16,15 +16,18 @@
 import decimal
 
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.positions.position_state as position_state
 import octobot_trading.personal_data.positions.states.position_state_factory as position_state_factory
 
 
-class OpenPositionState(position_state.PositionState):
+class IdlePositionState(position_state.PositionState):
+    """
+    ActivePositionState is the state of a position that has size of zero
+    """
     def __init__(self, position, is_from_exchange_data):
         super().__init__(position, is_from_exchange_data)
         self.state = enums.States.OPEN if is_from_exchange_data \
                                           or self.position.simulated \
                                           or self.position.status is enums.PositionStatus.OPEN \
             else enums.States.OPENING
 
@@ -37,45 +40,55 @@
         return not (self.is_pending() or self.is_refreshing())
 
     async def initialize_impl(self, forced=False) -> None:
         if forced:
             self.state = enums.States.OPEN
         return await super().initialize_impl()
 
+    def _is_compatible_size(self):
+        return self.position.is_idle()
+
     async def on_refresh_successful(self):
         """
         Verify the position is properly created and still PositionStatus.OPEN
         """
         # skip refresh process if the current position state is not the same as the one triggering this
         # on_refresh_successful to avoid synchronization issues (state already got refreshed by another mean)
         if self.position is None:
             self.get_logger().warning(f"on_refresh_successful triggered on cleared position: ignoring update.")
         elif self.state is self.position.state.state:
-            if self.position.status is enums.PositionStatus.OPEN:
+            if self.position.status is enums.PositionStatus.OPEN and self._is_compatible_size():
                 self.state = enums.States.OPEN
                 await self.update()
             else:
-                await position_state_factory.create_position_state(self.position, is_from_exchange_data=True)
+                position_state_factory.create_position_state(self.position, is_from_exchange_data=True)
+                if self.position.state.has_to_be_async_synchronized():
+                    await self.position.state.initialize()
         else:
             self.get_logger().debug(f"on_refresh_successful triggered from previous state "
                                     f"after state change on {self.position}")
 
     async def _synchronize_with_exchange(self, force_synchronization: bool = False) -> None:
         # Disable open position synchronization for now, let position updater refresh positions
         pass
 
-    async def terminate(self):
+    def sync_terminate(self):
         """
-        Should wait for being replaced by a LiquidatePositionState
+        Should wait for being replaced by an ActivePositionState or LiquidatePositionState
         """
         if not self.has_terminated:
             self.log_event_message(enums.StatesMessages.OPEN)
 
-            # set position mark price
-            self.position.mark_price = decimal.Decimal(
-                self.position.exchange_manager.exchange_symbols_data.
-                    get_exchange_symbol_data(self.position.symbol).prices_manager.mark_price)
+            if not self.position.mark_price:
+                # set position mark price
+                self.position.mark_price = decimal.Decimal(
+                    self.position.exchange_manager.exchange_symbols_data.
+                        get_exchange_symbol_data(self.position.symbol).prices_manager.mark_price
+                )
 
             self.has_terminated = True
 
+    async def terminate(self):
+        self.sync_terminate()
+
     def is_pending(self) -> bool:
         return self.state is enums.States.OPENING
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/position_state_factory.pxd` & `OctoBot-Trading-2.4.0/tests/exchange_data/ohlcv/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/states/position_state_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/states/position_state_factory.py`

 * *Files 11% similar despite different names*

```diff
@@ -12,15 +12,25 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.enums as enums
 
 
-async def create_position_state(position, is_from_exchange_data=False, ignore_states=None):
+def create_position_state(position, is_from_exchange_data=False, ignore_states=None):
     if ignore_states is None:
         ignore_states = []
-
     if position.status is enums.PositionStatus.OPEN and enums.States.OPEN not in ignore_states:
-        await position.on_open(force_open=False, is_from_exchange_data=is_from_exchange_data)
+        if position.is_idle() and (position.state is None or position.state.is_active()):
+            _pre_change_state(position)
+            position.on_idle(force_open=False, is_from_exchange_data=is_from_exchange_data)
+        elif not position.is_idle() and (position.state is None or not position.state.is_active()):
+            _pre_change_state(position)
+            position.on_active(force_open=False, is_from_exchange_data=is_from_exchange_data)
     elif position.status is enums.PositionStatus.LIQUIDATING and enums.PositionStates.LIQUIDATED not in ignore_states:
-        await position.on_liquidate(force_liquidate=False, is_from_exchange_data=is_from_exchange_data)
+        _pre_change_state(position)
+        position.on_liquidate(force_liquidate=False, is_from_exchange_data=is_from_exchange_data)
+
+
+def _pre_change_state(position):
+    if position.state is not None:
+        position.state.set_is_changing_state()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/inverse_position.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/types/inverse_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/positions/types/linear_position.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/positions/types/linear_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/state.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/state.py`

 * *Files 8% similar despite different names*

```diff
@@ -77,30 +77,49 @@
         """
         Log a state event
         """
         self.get_logger().info(state_message.value)
 
     async def initialize_impl(self) -> None:
         """
-        Default State initialization process
+        Default async State initialization process
         """
         await self.update()
 
+    def sync_initialize(self, forced=False):
+        """
+        Default sync initialization process
+        """
+        if not self.is_initialized or forced:
+            self.sync_update()
+            self.is_initialized = True
+            return True
+        return False
+
+    def sync_update(self):
+        if not self.is_refreshing():
+            if self.is_pending():
+                raise NotImplementedError("can't use sync_update on a pending state")
+            else:
+                self.trigger_sync_terminate()
+        else:
+            self.log_event_message(enums.StatesMessages.ALREADY_SYNCHRONIZING)
+
     async def should_be_updated(self) -> bool:
         """
         Defines if the instance should be updated
         :return: True if the instance should be updated when necessary
         """
         return True
 
     async def update(self) -> None:
         """
-        Update the instance state if necessary
-        Necessary when the state is not already synchronizing and when the instance should be updated
-        Try to fix the pending state or terminate
+        Update the instance state if necessary.
+        Necessary when the state is not already synchronizing and when the instance should be updated.
+        Try to fix the pending state or terminate.
         """
         if not self.is_refreshing():
             if self.is_pending() and not await self.should_be_updated():
                 self.log_event_message(enums.StatesMessages.SYNCHRONIZING)
                 await self.synchronize()
             else:
                 await self.trigger_terminate()
@@ -110,14 +129,20 @@
     async def trigger_terminate(self):
         try:
             async with self.lock:
                 await self.terminate()
         finally:
             self.on_terminate()
 
+    def trigger_sync_terminate(self):
+        try:
+            self.sync_terminate()
+        finally:
+            self.on_terminate()
+
     async def synchronize(self, force_synchronization=False, catch_exception=False) -> None:
         """
         Implement the exchange synchronization process
         Should begin by setting the state to REFRESHING
         Should end by :
         - calling terminate if the state is terminated
         - restoring the initial state if nothing has been changed with synchronization or if sync failed
@@ -171,14 +196,21 @@
     async def terminate(self) -> None:
         """
         Implement the state ending process
         Can be portfolio updates, fees request, orders group updates, Trade creation etc...
         """
         raise NotImplementedError("terminate not implemented")
 
+    def sync_terminate(self) -> None:
+        """
+        Implement the state ending process
+        Can be portfolio updates, fees request, orders group updates, Trade creation etc...
+        """
+        raise NotImplementedError("sync_terminate not implemented")
+
     def on_terminate(self) -> None:
         """
         Called after terminate is complete
         """
         self.get_logger().debug(f"{self.__class__.__name__} terminated")
         if not self.terminated.is_set():
             self.terminated.set()
@@ -191,14 +223,17 @@
             self.terminated.set()
 
     async def wait_for_terminate(self, timeout) -> None:
         if self.terminated.is_set():
             return
         await asyncio.wait_for(self.terminated.wait(), timeout=timeout)
 
+    async def wait_for_next_state(self, timeout) -> None:
+        raise NotImplementedError("wait_for_next_state is not implemented")
+
     async def on_refresh_successful(self):
         """
         Called when synchronize succeed to update the instance
         """
         raise NotImplementedError("on_refresh_successful not implemented")
 
     def clear(self):
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/trades.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/channel/trades.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/channel/trades_updater.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/channel/trades_updater.py`

 * *Files 0% similar despite different names*

```diff
@@ -65,15 +65,14 @@
             self.logger.error(f"Fail to initialize trade history : {e}")
 
     async def fetch_and_push(self):
         for symbol in self.channel.exchange_manager.exchange_config.traded_symbol_pairs:
             trades: list = await self.channel.exchange_manager.exchange.get_my_recent_trades(
                 symbol=symbol,
                 limit=self.MAX_OLD_TRADES_TO_FETCH)
-
             if trades:
                 await self.push(trades)
             if not self._is_initialized_event_set:
                 self._set_initialized_event(symbol)
         self._is_initialized_event_set = True
 
     def _set_initialized_event(self, symbol):
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trade_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/trade_factory.py`

 * *Files 2% similar despite different names*

```diff
@@ -77,7 +77,11 @@
                  fee=None,  # TODO
                  total_cost=total_cost)
     return create_trade_from_order(order,
                                    close_status=status,
                                    canceled_time=canceled_time,
                                    creation_time=creation_time,
                                    executed_time=executed_time)
+
+
+def create_trade_from_dict(trader, trade_dict):
+    return trade_class.Trade.from_dict(trader, trade_dict)
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/trades/trades_util.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/trades/trades_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,31 +10,32 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-from octobot_trading.personal_data.transactions cimport transaction
-from octobot_trading.personal_data.transactions.transaction cimport (
-    Transaction,
-)
-from octobot_trading.personal_data.transactions cimport transactions_manager
-from octobot_trading.personal_data.transactions.transactions_manager cimport (
+from octobot_trading.personal_data.transactions import transactions_manager
+from octobot_trading.personal_data.transactions import transaction_factory
+from octobot_trading.personal_data.transactions import transaction
+from octobot_trading.personal_data.transactions import types
+
+from octobot_trading.personal_data.transactions.transactions_manager import (
     TransactionsManager,
 )
-from octobot_trading.personal_data.transactions cimport transaction_factory
-from octobot_trading.personal_data.transactions.transaction_factory cimport (
+from octobot_trading.personal_data.transactions.transaction_factory import (
     create_blockchain_transaction,
     create_realised_pnl_transaction,
     create_fee_transaction,
     create_transfer_transaction,
 )
-from octobot_trading.personal_data.transactions cimport types
-from octobot_trading.personal_data.transactions.types cimport (
+from octobot_trading.personal_data.transactions.transaction import (
+    Transaction,
+)
+from octobot_trading.personal_data.transactions.types import (
     BlockchainTransaction,
     FeeTransaction,
     RealisedPnlTransaction,
     TransferTransaction,
 )
 
 __all__ = [
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/transaction.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,44 +9,35 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import uuid
 
-from octobot_trading.personal_data.transactions import transactions_manager
-from octobot_trading.personal_data.transactions import transaction_factory
-from octobot_trading.personal_data.transactions import transaction
-from octobot_trading.personal_data.transactions import types
-
-from octobot_trading.personal_data.transactions.transactions_manager import (
-    TransactionsManager,
-)
-from octobot_trading.personal_data.transactions.transaction_factory import (
-    create_blockchain_transaction,
-    create_realised_pnl_transaction,
-    create_fee_transaction,
-    create_transfer_transaction,
-)
-from octobot_trading.personal_data.transactions.transaction import (
-    Transaction,
-)
-from octobot_trading.personal_data.transactions.types import (
-    BlockchainTransaction,
-    FeeTransaction,
-    RealisedPnlTransaction,
-    TransferTransaction,
-)
-
-__all__ = [
-    "TransactionsManager",
-    "Transaction",
-    "BlockchainTransaction",
-    "FeeTransaction",
-    "RealisedPnlTransaction",
-    "TransferTransaction",
-    "create_blockchain_transaction",
-    "create_realised_pnl_transaction",
-    "create_fee_transaction",
-    "create_transfer_transaction",
-]
+import octobot_commons.logging as logging
+
+
+class Transaction:
+
+    def __init__(self, exchange_name, creation_time, transaction_type, currency, symbol=None, transaction_id=None):
+        self.logger = logging.get_logger(self.__class__.__name__)
+        self.transaction_id = transaction_id
+        self.transaction_type = transaction_type
+        self.creation_time = creation_time
+
+        self.exchange_name = exchange_name
+        self.symbol = symbol
+        self.currency = currency
+
+        # generate default transaction id
+        if self.transaction_id is None:
+            self.transaction_id = str(uuid.uuid4())
+
+    def set_transaction_id(self, new_id):
+        """
+        Shouldn't be called outside of TransactionsManager.update_transaction_id
+        to maintain TransactionsManager.transactions integrity
+        :param new_id: the new transaction id
+        """
+        self.transaction_id = new_id
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transaction_factory.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/transaction_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transactions_manager.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/fee_transaction.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,32 +1,40 @@
-# cython: language_level=3
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General License for more details.
+#  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-cimport octobot_trading.util as util
+import uuid
 
+import octobot_trading.constants as constants
+import octobot_trading.enums as enums
+import octobot_trading.personal_data.transactions.transaction as transaction
 
-cdef class TransactionsManager(util.Initializable):
-    cdef object logger
 
-    cdef public object transactions
+class FeeTransaction(transaction.Transaction):
+    def __init__(self, exchange_name, creation_time, transaction_type, currency, symbol, quantity,
+                 order_id=None,
+                 funding_rate=constants.ZERO):
+        self.quantity = quantity
+        self.order_id = order_id
+        self.funding_rate = funding_rate
+        super().__init__(exchange_name, creation_time, transaction_type, currency, symbol=symbol)
+        self.transaction_id = f"{self.exchange_name}" \
+                              f"-{self.order_id if self.order_id else str(uuid.uuid4())}" \
+                              f"-{self.symbol}" \
+                              f"-{str(self.creation_time)}"
 
-    cdef void _check_transactions_size(self)
-    cdef void _reset_transactions(self)
-    cdef void _remove_oldest_transactions(self, int nb_to_remove)
+    def is_funding_fee(self):
+        return self.transaction_type is enums.TransactionType.FUNDING_FEE
 
-    cpdef object get_transaction(self, str transaction_id)
-    cpdef object update_transaction_id(self, str transaction_id, str new_transaction_id, bint replace_if_exists=*)  # needs object to forward exceptions
-    cpdef object insert_transaction_instance(self, object transaction, bint replace_if_exists=*)  # needs object to forward exceptions
-    cpdef void clear(self)
+    def is_trading_fee(self):
+        return self.transaction_type is enums.TransactionType.TRADING_FEE
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/transactions_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/transactions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/blockchain_transaction.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/blockchain_transaction.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/fee_transaction.py` & `OctoBot-Trading-2.4.0/octobot_trading/storage/util.py`

 * *Files 24% similar despite different names*

```diff
@@ -8,33 +8,47 @@
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
-#  License along with this library.
-import uuid
-
-import octobot_trading.constants as constants
+#  License along with this library
+import octobot_commons.constants as commons_constants
+import octobot_commons.enums as commons_enums
 import octobot_trading.enums as enums
-import octobot_trading.personal_data.transactions.transaction as transaction
 
 
-class FeeTransaction(transaction.Transaction):
-    def __init__(self, exchange_name, creation_time, transaction_type, currency, symbol, quantity,
-                 order_id=None,
-                 funding_rate=constants.ZERO):
-        self.quantity = quantity
-        self.order_id = order_id
-        self.funding_rate = funding_rate
-        super().__init__(exchange_name, creation_time, transaction_type, currency, symbol=symbol)
-        self.transaction_id = f"{self.exchange_name}" \
-                              f"-{self.order_id if self.order_id else str(uuid.uuid4())}" \
-                              f"-{self.symbol}" \
-                              f"-{str(self.creation_time)}"
+def get_account_type_suffix_from_exchange_manager(exchange_manager) -> str:
+    return get_account_type_suffix(
+        exchange_manager.is_future,
+        exchange_manager.is_margin,
+        exchange_manager.is_sandboxed,
+        exchange_manager.is_trader_simulated
+    )
+
+
+def get_account_type_suffix_from_run_metadata(run_metadata) -> str:
+    trading_type = run_metadata[commons_enums.DBRows.TRADING_TYPE.value]
+    trader_simulator = True  # todo: update when displaying live data in strat designer
+    is_sandboxed = False  # todo: update when displaying live data in strat designer
+    return get_account_type_suffix(
+        trading_type == enums.ExchangeTypes.FUTURE.value,
+        trading_type == enums.ExchangeTypes.MARGIN.value,
+        is_sandboxed,
+        trader_simulator
+    )
 
-    def is_funding_fee(self):
-        return self.transaction_type is enums.TransactionType.FUNDING_FEE
 
-    def is_trading_fee(self):
-        return self.transaction_type is enums.TransactionType.TRADING_FEE
+def get_account_type_suffix(is_future, is_margin, is_sandboxed, is_trader_simulated) -> str:
+    suffix = ""
+    if is_future:
+        suffix = f"{suffix}_{commons_constants.CONFIG_EXCHANGE_FUTURE}"
+    elif is_margin:
+        suffix = f"{suffix}_{commons_constants.CONFIG_EXCHANGE_MARGIN}"
+    else:
+        suffix = f"{suffix}_{commons_constants.CONFIG_EXCHANGE_SPOT}"
+    if is_sandboxed:
+        suffix = f"{suffix}_{commons_constants.CONFIG_EXCHANGE_SANDBOXED}"
+    if is_trader_simulated:
+        suffix = f"{suffix}_{commons_constants.CONFIG_SIMULATOR}"
+    return suffix
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/personal_data/transactions/types/transfer_transaction.py` & `OctoBot-Trading-2.4.0/octobot_trading/personal_data/orders/groups/group_util.py`

 * *Files 27% similar despite different names*

```diff
@@ -9,18 +9,33 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-
+import octobot_trading.personal_data.orders.order_group as order_group
 import octobot_trading.enums as enums
-import octobot_trading.personal_data.transactions.transaction as transaction
+import octobot_commons.tentacles_management as tentacles_management
+import octobot_commons.logging as logging
+
+
+def get_group_class(group_type_str: str):
+    for group_class in tentacles_management.get_all_classes_from_parent(order_group.OrderGroup):
+        if group_type_str == group_class.__name__:
+            return group_class
+    raise KeyError(group_type_str)
 
 
-class TransferTransaction(transaction.Transaction):
-    def __init__(self, exchange_name, creation_time, currency, symbol):
-        super().__init__(exchange_name, creation_time,
-                         transaction_type=enums.TransactionType.TRANSFER,
-                         currency=currency,
-                         symbol=symbol)
+def get_or_create_order_group_from_storage_order_details(order_details, exchange_manager):
+    group = order_details.get(enums.StoredOrdersAttr.GROUP.value, None)
+    if group:
+        try:
+            group_name = group.get(enums.StoredOrdersAttr.GROUP_ID.value, None)
+            if group_name:
+                return exchange_manager.exchange_personal_data.orders_manager.get_or_create_group(
+                    get_group_class(group[enums.StoredOrdersAttr.GROUP_TYPE.value]),
+                    group_name,
+                )
+        except KeyError as err:
+            logging.get_logger("GroupUtil").error(f"Unhandled group type: {err}")
+    return None
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/signals/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/signals/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/signals/channel/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/signals/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/signals/channel/remote_trading_signal.py` & `OctoBot-Trading-2.4.0/octobot_trading/signals/channel/remote_trading_signal.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=W0237
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/signals/channel/signal_producer.py` & `OctoBot-Trading-2.4.0/octobot_trading/signals/channel/signal_producer.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/signals/signal_creation.py` & `OctoBot-Trading-2.4.0/octobot_trading/signals/signal_creation.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/signals/trading_signal_bundle_builder.py` & `OctoBot-Trading-2.4.0/octobot_trading/signals/trading_signal_bundle_builder.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/signals/util.py` & `OctoBot-Trading-2.4.0/octobot_trading/signals/util.py`

 * *Files 2% similar despite different names*

```diff
@@ -55,14 +55,15 @@
         trading_enums.TradingSignalOrdersAttrs.REDUCE_ONLY.value: order.reduce_only,
         trading_enums.TradingSignalOrdersAttrs.POST_ONLY.value: False,
         trading_enums.TradingSignalOrdersAttrs.GROUP_ID.value:
             None if order.order_group is None else order.order_group.name,
         trading_enums.TradingSignalOrdersAttrs.GROUP_TYPE.value:
             None if order.order_group is None else order.order_group.__class__.__name__,
         trading_enums.TradingSignalOrdersAttrs.TAG.value: order.tag,
+        trading_enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: order.associated_entry_ids,
         trading_enums.TradingSignalOrdersAttrs.SHARED_SIGNAL_ORDER_ID.value: order.shared_signal_order_id,
         trading_enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value:
             None if order.triggered_by is None else order.triggered_by.shared_signal_order_id
         if order.has_been_bundled else None,
         trading_enums.TradingSignalOrdersAttrs.CHAINED_TO.value:
             None if order.triggered_by is None else order.triggered_by.shared_signal_order_id,
         trading_enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/storage/__init__.py` & `OctoBot-Trading-2.4.0/octobot_trading/storage/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -16,39 +16,56 @@
 
 
 from octobot_trading.storage import abstract_storage
 from octobot_trading.storage.abstract_storage import (
     AbstractStorage,
 )
 
-
 from octobot_trading.storage import trades_storage
 from octobot_trading.storage.trades_storage import (
     TradesStorage,
 )
 
+from octobot_trading.storage import orders_storage
+from octobot_trading.storage.orders_storage import (
+    OrdersStorage,
+)
 
 from octobot_trading.storage import portfolio_storage
 from octobot_trading.storage.portfolio_storage import (
     PortfolioStorage,
 )
 
-
 from octobot_trading.storage import candles_storage
 from octobot_trading.storage.candles_storage import (
     CandlesStorage,
 )
 
-
 from octobot_trading.storage import transactions_storage
 from octobot_trading.storage.transactions_storage import (
     TransactionsStorage,
 )
 
-
 from octobot_trading.storage import storage_manager
 from octobot_trading.storage.storage_manager import (
     StorageManager,
 )
 
-
-__all__ = ["AbstractStorage", "TradesStorage", "PortfolioStorage", "CandlesStorage", "TransactionsStorage", "StorageManager"]
+from octobot_trading.storage import util
+from octobot_trading.storage.util import (
+    get_account_type_suffix_from_exchange_manager,
+    get_account_type_suffix_from_run_metadata,
+    get_account_type_suffix,
+)
+
+__all__ = [
+    "AbstractStorage",
+    "TradesStorage",
+    "OrdersStorage",
+    "PortfolioStorage",
+    "CandlesStorage",
+    "TransactionsStorage",
+    "StorageManager",
+    "get_account_type_suffix_from_exchange_manager",
+    "get_account_type_suffix_from_run_metadata",
+    "get_account_type_suffix",
+]
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/storage/storage_manager.py` & `OctoBot-Trading-2.4.0/octobot_trading/storage/storage_manager.py`

 * *Files 12% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 import octobot_commons.enums as commons_enums
 import octobot_commons.databases as commons_databases
 import octobot_commons.logging as commons_logging
 import octobot_commons.errors as commons_errors
 
 import octobot_trading.util as util
 import octobot_trading.storage.trades_storage as trades_storage
+import octobot_trading.storage.orders_storage as orders_storage
 import octobot_trading.storage.transactions_storage as transactions_storage
 import octobot_trading.storage.candles_storage as candles_storage
 import octobot_trading.storage.portfolio_storage as portfolio_storage
 
 
 class StorageManager(util.Initializable):
     def __init__(self, exchange_manager):
@@ -39,58 +40,64 @@
 
     async def initialize_impl(self):
         await commons_databases.RunDatabasesProvider.instance().get_run_databases_identifier(
             self.exchange_manager.bot_id
         ).initialize(
             exchange=self.exchange_manager.exchange_name
         )
-        for storage in self._storages():
+        for storage in self._storages(True):
             try:
                 await storage.start()
             except Exception as e:
                 self.logger.exception(e, True, f"Error when initializing {storage}: {e}")
 
     async def stop(self):
-        for storage in self._storages():
-            await storage.stop()
+        for storage in self._storages(False):
+            if storage:
+                await storage.stop()
         self.exchange_manager = None
         self.trades_storage = self.orders_storage = self.transactions_storage = \
             self.portfolio_storage = self.candles_storage = None
 
     async def store_history(self):
         if self.exchange_manager is None:
             raise commons_errors.MissingExchangeDataError("This exchange storage has been stopped")
         for storage in self._historical_storages():
             await storage.store_history()
 
     def _historical_storages(self):
-        for storage in self._storages():
+        for storage in self._storages(True):
             if storage.is_historical:
                 yield storage
 
-    def _storages(self):
+    def _storages(self, create_missing):
         return (
-            self.trades_storage or self._trade_storage_factory(),
-            self.transactions_storage or self._transaction_storage_factory(),
-            self.candles_storage or self._candles_storage_factory(),
-            self.portfolio_storage or self._portfolio_storage_factory(),
+            self.trades_storage or self._trade_storage_factory() if create_missing else self.trades_storage,
+            self.orders_storage or self._order_storage_factory() if create_missing else self.orders_storage,
+            self.transactions_storage or self._transaction_storage_factory() if create_missing else self.transactions_storage,
+            self.candles_storage or self._candles_storage_factory() if create_missing else self.candles_storage,
+            self.portfolio_storage or self._portfolio_storage_factory() if create_missing else self.portfolio_storage,
         )
 
     def _trade_storage_factory(self):
         self.trades_storage = trades_storage.TradesStorage(
             self.exchange_manager,
             commons_display.PlotSettings(
                 chart=commons_enums.PlotCharts.MAIN_CHART.value,
                 x_multiplier=1000,
                 mode="markers",
                 kind="scattergl",
             )
         )
         return self.trades_storage
 
+    def _order_storage_factory(self):
+        self.orders_storage = orders_storage.OrdersStorage(self.exchange_manager)
+        return self.orders_storage
+
     def _transaction_storage_factory(self):
         self.transactions_storage = transactions_storage.TransactionsStorage(
             self.exchange_manager,
             commons_display.PlotSettings(
                 chart=commons_enums.PlotCharts.MAIN_CHART.value,
                 x_multiplier=1000,
                 mode="markers",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/storage/trades_storage.py` & `OctoBot-Trading-2.4.0/octobot_trading/storage/trades_storage.py`

 * *Files 23% similar despite different names*

```diff
@@ -11,18 +11,20 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library
 import octobot_commons.channels_name as channels_name
 import octobot_commons.enums as commons_enums
+import octobot_commons.authentication as authentication
 import octobot_commons.databases as commons_databases
 
 import octobot_trading.enums as enums
 import octobot_trading.storage.abstract_storage as abstract_storage
+import octobot_trading.storage.util as storage_util
 
 
 class TradesStorage(abstract_storage.AbstractStorage):
     LIVE_CHANNEL = channels_name.OctoBotTradingChannelsName.TRADES_CHANNEL.value
     HISTORY_TABLE = commons_enums.DBTables.TRADES.value
 
     async def _live_callback(
@@ -42,36 +44,55 @@
                     self.exchange_manager,
                     self.plot_settings.chart,
                     self.plot_settings.x_multiplier,
                     self.plot_settings.kind,
                     self.plot_settings.mode
                 )
             )
+            await self.trigger_debounced_flush()
+            self._to_update_auth_data_ids_buffer.add(trade[enums.ExchangeConstantsOrderColumns.ID.value])
+            await self.trigger_debounced_update_auth_data(False)
+
+    async def _update_auth_data(self, reset):
+        authenticator = authentication.Authenticator.instance()
+        history = [
+            trade
+            for trade in self.exchange_manager.exchange_personal_data.trades_manager.trades.values()
+            if trade.status is not enums.OrderStatus.CANCELED and trade.trade_id in self._to_update_auth_data_ids_buffer
+        ]
+        if (history or reset) and authenticator.is_initialized():
+            # also update when history is empty to reset trade history
+            await authenticator.update_trades(history, reset)
+            self._to_update_auth_data_ids_buffer.clear()
 
     async def _store_history(self):
-        await self._get_db().log_many(
+        database = self._get_db()
+        await database.replace_all(
             self.HISTORY_TABLE,
             [
                 _format_trade(
                     trade.to_dict(),
                     self.exchange_manager,
                     self.plot_settings.chart,
                     self.plot_settings.x_multiplier,
                     self.plot_settings.kind,
                     self.plot_settings.mode
                 )
                 for trade in self.exchange_manager.exchange_personal_data.trades_manager.trades.values()
                 if trade.status is not enums.OrderStatus.CANCELED
-            ]
+            ],
+            cache=False,
         )
+        await database.flush()
 
     def _get_db(self):
         return commons_databases.RunDatabasesProvider.instance().get_trades_db(
             self.exchange_manager.bot_id,
-            self.exchange_manager.exchange_name
+            storage_util.get_account_type_suffix_from_exchange_manager(self.exchange_manager),
+            self.exchange_manager.exchange_name,
         )
 
 
 def _format_trade(trade_dict, exchange_manager, chart, x_multiplier, kind, mode):
     tag = f"{trade_dict[enums.ExchangeConstantsOrderColumns.TAG.value]} " \
         if trade_dict[enums.ExchangeConstantsOrderColumns.TAG.value] else ""
     symbol = trade_dict[enums.ExchangeConstantsOrderColumns.SYMBOL.value]
@@ -112,37 +133,37 @@
             shape = "arrow-bar-right"
         elif "stop_loss" in trade_dict[enums.ExchangeConstantsOrderColumns.TYPE.value]:
             color = "orange"
             shape = "x"
         else:
             color = "magenta"
             shape = "arrow-bar-left"
-
+    fee = trade_dict[enums.ExchangeConstantsOrderColumns.FEE.value]
+    fee_cost = float(fee[enums.FeePropertyColumns.COST.value] if
+                     fee and fee[enums.FeePropertyColumns.COST.value] else 0)
     return {
-        "x": trade_dict[enums.ExchangeConstantsOrderColumns.TIMESTAMP.value] * x_multiplier,
-        "text": f"{tag}{trade_dict[enums.ExchangeConstantsOrderColumns.TYPE.value]} "
+        TradesStorage.ORIGIN_VALUE_KEY: TradesStorage.sanitize_for_storage(trade_dict),
+        commons_enums.DisplayedElementTypes.CHART.value: chart,
+        commons_enums.DBRows.SYMBOL.value: trade_dict[enums.ExchangeConstantsOrderColumns.SYMBOL.value],
+        commons_enums.DBRows.FEES_AMOUNT.value: fee_cost,
+        commons_enums.DBRows.FEES_CURRENCY.value: fee[enums.FeePropertyColumns.CURRENCY.value]
+        if trade_dict[enums.ExchangeConstantsOrderColumns.FEE.value] else "",
+        commons_enums.DBRows.ID.value: trade_dict[enums.ExchangeConstantsOrderColumns.ID.value],
+        commons_enums.DBRows.TRADING_MODE.value: exchange_manager.trading_modes[0].get_name(),
+        commons_enums.PlotAttributes.X.value: trade_dict[enums.ExchangeConstantsOrderColumns.TIMESTAMP.value] * x_multiplier,
+        commons_enums.PlotAttributes.TEXT.value: f"{tag}{trade_dict[enums.ExchangeConstantsOrderColumns.TYPE.value]} "
                 f"{trade_dict[enums.ExchangeConstantsOrderColumns.SIDE.value]} "
                 f"{trade_dict[enums.ExchangeConstantsOrderColumns.AMOUNT.value]} "
                 f"{trade_dict[enums.ExchangeConstantsOrderColumns.QUANTITY_CURRENCY.value]} "
                 f"at {trade_dict[enums.ExchangeConstantsOrderColumns.PRICE.value]}",
-        "id": trade_dict[enums.ExchangeConstantsOrderColumns.ID.value],
-        "symbol": trade_dict[enums.ExchangeConstantsOrderColumns.SYMBOL.value],
-        "trading_mode": exchange_manager.trading_modes[0].get_name(),
-        "type": trade_dict[enums.ExchangeConstantsOrderColumns.TYPE.value],
-        "volume": float(trade_dict[enums.ExchangeConstantsOrderColumns.AMOUNT.value]),
-        "y": float(trade_dict[enums.ExchangeConstantsOrderColumns.PRICE.value]),
+        commons_enums.PlotAttributes.TYPE.value: trade_dict[enums.ExchangeConstantsOrderColumns.TYPE.value],
+        commons_enums.PlotAttributes.VOLUME.value: float(trade_dict[enums.ExchangeConstantsOrderColumns.AMOUNT.value]),
+        commons_enums.PlotAttributes.Y.value: float(trade_dict[enums.ExchangeConstantsOrderColumns.PRICE.value]),
+        commons_enums.PlotAttributes.KIND.value: kind,
+        commons_enums.PlotAttributes.SIDE.value: trade_dict[enums.ExchangeConstantsOrderColumns.SIDE.value],
+        commons_enums.PlotAttributes.MODE.value: mode,
+        commons_enums.PlotAttributes.SHAPE.value: shape,
+        commons_enums.PlotAttributes.COLOR.value: color,
+        commons_enums.PlotAttributes.SIZE.value: "10",
         "cost": float(trade_dict[enums.ExchangeConstantsOrderColumns.COST.value]),
         "state": trade_dict[enums.ExchangeConstantsOrderColumns.STATUS.value],
-        "chart": chart,
-        "kind": kind,
-        "side": trade_dict[enums.ExchangeConstantsOrderColumns.SIDE.value],
-        "mode": mode,
-        "shape": shape,
-        "color": color,
-        "size": "10",
-        "fees_amount": float(trade_dict[enums.ExchangeConstantsOrderColumns.FEE.value]
-                             [enums.ExchangeConstantsFeesColumns.COST.value] if
-                             trade_dict[enums.ExchangeConstantsOrderColumns.FEE.value] else 0),
-        "fees_currency": trade_dict[enums.ExchangeConstantsOrderColumns.FEE.value][
-            enums.ExchangeConstantsFeesColumns.CURRENCY.value]
-        if trade_dict[enums.ExchangeConstantsOrderColumns.FEE.value] else "",
     }
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/storage/transactions_storage.py` & `OctoBot-Trading-2.4.0/octobot_trading/storage/transactions_storage.py`

 * *Files 19% similar despite different names*

```diff
@@ -13,55 +13,64 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library
 import octobot_commons.enums as commons_enums
 import octobot_commons.databases as commons_databases
 
 import octobot_trading.storage.abstract_storage as abstract_storage
+import octobot_trading.storage.util as storage_util
 
 
 class TransactionsStorage(abstract_storage.AbstractStorage):
     IS_LIVE_CONSUMER = False
     HISTORY_TABLE = commons_enums.DBTables.TRANSACTIONS.value
 
     async def _store_history(self):
         transactions = [
             transaction
             for transaction in self.exchange_manager.exchange_personal_data.transactions_manager.transactions.values()
         ]
         y_data = self.plot_settings.y_data or [0] * len(transactions)
-        await self._get_db().log_many(
+        await self._get_db().replace_all(
             self.HISTORY_TABLE,
             [
                 _format_transaction(
                     transaction,
                     self.exchange_manager,
                     self.plot_settings.chart,
                     self.plot_settings.x_multiplier,
                     self.plot_settings.kind,
                     self.plot_settings.mode,
                     y_data[index]
                 )
                 for index, transaction in enumerate(transactions)
-            ]
+            ],
+            cache=False,
         )
+        await self.trigger_debounced_flush()
 
     def _get_db(self):
         return commons_databases.RunDatabasesProvider.instance().get_transactions_db(
             self.exchange_manager.bot_id,
+            storage_util.get_account_type_suffix_from_exchange_manager(self.exchange_manager),
             self.exchange_manager.exchange_name
         )
 
 
 def _format_transaction(transaction, exchange_manager, chart, x_multiplier, kind, mode, y_data):
     return {
-        "x": transaction.creation_time * x_multiplier,
-        "type": transaction.transaction_type.value,
+        commons_enums.DisplayedElementTypes.CHART.value: chart,
+        commons_enums.DBRows.SYMBOL.value: transaction.symbol,
+        commons_enums.PlotAttributes.X.value: transaction.creation_time * x_multiplier,
+        commons_enums.PlotAttributes.TYPE.value: transaction.transaction_type.value,
+        commons_enums.PlotAttributes.SIDE.value: transaction.side.value if hasattr(transaction, "side") else None,
+        commons_enums.PlotAttributes.Y.value: y_data,
+        commons_enums.PlotAttributes.KIND.value: kind,
+        commons_enums.PlotAttributes.MODE.value: mode,
         "id": transaction.transaction_id,
-        "symbol": transaction.symbol,
         "trading_mode": exchange_manager.trading_modes[0].get_name(),
         "currency": transaction.currency,
         "quantity": float(transaction.quantity) if hasattr(transaction, "quantity") else None,
         "order_id": transaction.order_id if hasattr(transaction, "order_id") else None,
         "funding_rate": float(transaction.funding_rate) if hasattr(transaction, "funding_rate") else None,
         "realised_pnl": float(transaction.realised_pnl) if hasattr(transaction, "realised_pnl") else None,
         "transaction_fee": float(transaction.transaction_fee) if hasattr(transaction, "transaction_fee") else None,
@@ -74,13 +83,8 @@
         if hasattr(transaction, "average_entry_price") else None,
         "average_exit_price": float(transaction.average_exit_price)
         if hasattr(transaction, "average_exit_price") else None,
         "order_exit_price": float(transaction.order_exit_price)
         if hasattr(transaction, "order_exit_price") else None,
         "leverage": float(transaction.leverage) if hasattr(transaction, "leverage") else None,
         "trigger_source": transaction.trigger_source.value if hasattr(transaction, "trigger_source") else None,
-        "side": transaction.side.value if hasattr(transaction, "side") else None,
-        "y": y_data,
-        "chart": chart,
-        "kind": kind,
-        "mode": mode
     }
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/supervisors/__init__.pxd` & `OctoBot-Trading-2.4.0/tests/exchange_data/order_book/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,9 +9,7 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-
-__all__ = []
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/supervisors/abstract_portfolio_supervisor.py` & `OctoBot-Trading-2.4.0/octobot_trading/supervisors/abstract_portfolio_supervisor.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/supervisors/abstract_supervisor.py` & `OctoBot-Trading-2.4.0/octobot_trading/supervisors/abstract_supervisor.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/util/__init__.pxd` & `OctoBot-Trading-2.4.0/octobot_trading/util/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -8,37 +8,52 @@
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
-#  License along with this library.
+#  License along with this library
 
-from octobot_trading.util cimport initializable
-from octobot_trading.util.initializable cimport (
+from octobot_trading.util import initializable
+from octobot_trading.util.initializable import (
     Initializable,
 )
 
-from octobot_trading.util cimport config_util
-from octobot_trading.util.config_util cimport (
+from octobot_trading.util import initialization_util
+from octobot_trading.util.initialization_util import (
+    wait_for_topic_init,
+)
+
+from octobot_trading.util import simulator_updater_utils
+from octobot_trading.util import config_util
+
+from octobot_trading.util.simulator_updater_utils import (
+    stop_and_pause,
+    pause_time_consumer,
+    resume_time_consumer,
+)
+from octobot_trading.util.config_util import (
     is_trader_enabled,
     is_trader_simulator_enabled,
     is_trade_history_loading_enabled,
     is_currency_enabled,
     get_symbols,
     get_all_currencies,
     get_pairs,
     get_market_pair,
     get_reference_market,
     get_traded_pairs_by_currency,
     get_current_bot_live_id,
 )
 
 __all__ = [
+    "stop_and_pause",
+    "pause_time_consumer",
+    "resume_time_consumer",
     "Initializable",
     "is_trader_enabled",
     "is_trader_simulator_enabled",
     "is_trade_history_loading_enabled",
     "is_currency_enabled",
     "get_symbols",
     "get_all_currencies",
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/util/config_util.py` & `OctoBot-Trading-2.4.0/octobot_trading/util/config_util.py`

 * *Files 1% similar despite different names*

```diff
@@ -53,15 +53,15 @@
 def get_symbols(config, enabled_only) -> list:
     if commons_constants.CONFIG_CRYPTO_CURRENCIES in config \
             and isinstance(config[commons_constants.CONFIG_CRYPTO_CURRENCIES], dict):
         return [
             symbol
             for currency, crypto_currency_data in config[commons_constants.CONFIG_CRYPTO_CURRENCIES].items()
             if not enabled_only or is_currency_enabled(config, currency, True)
-            for symbol in crypto_currency_data[commons_constants.CONFIG_CRYPTO_PAIRS]
+            for symbol in crypto_currency_data.get(commons_constants.CONFIG_CRYPTO_PAIRS, [])
             if symbol != commons_constants.CONFIG_SYMBOLS_WILDCARD[0]
         ]
     return []
 
 
 def get_all_currencies(config, enabled_only=False) -> set:
     currencies = set()
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/util/simulator_updater_utils.py` & `OctoBot-Trading-2.4.0/octobot_trading/util/simulator_updater_utils.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/prices/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,8 +8,8 @@
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
-#  License along with this library
+#  License along with this library.
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/exchanges_test_tools.py` & `OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/exchanges_test_tools.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py` & `OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py`

 * *Files 0% similar despite different names*

```diff
@@ -126,11 +126,11 @@
     async def _orders_callback(
             self,
             exchange: str,
             exchange_id: str,
             cryptocurrency: str,
             symbol: str,
             order: dict,
-            is_new: bool,
+            update_type: str,
             is_from_bot: bool,
     ):
         self.channel_callbacks_triggered[channels_name.OctoBotTradingChannelsName.ORDERS_CHANNEL.value] = True
```

### Comparing `OctoBot-Trading-2.3.7/octobot_trading/util/test_tools/websocket_test_tools.py` & `OctoBot-Trading-2.4.0/octobot_trading/util/test_tools/websocket_test_tools.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/requirements.txt` & `OctoBot-Trading-2.4.0/requirements.txt`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-# Setup requirements
-cython==0.29.32
-numpy==1.24.0
+numpy==1.24.3
 
 # Drakkar-Software requirements
-OctoBot-Backtesting>=1.8, <1.9
-Async-Channel>=2.1, <2.2
-OctoBot-Commons>=1.8, <1.9
-OctoBot-Tentacles-Manager>=2.8, <2.9
-trading-backend>=1.0.12
+OctoBot-Backtesting>=1.9, <1.10
+Async-Channel>=2.2, <2.3
+OctoBot-Commons>=1.9, <1.10
+OctoBot-Tentacles-Manager>=2.9, <2.10
+trading-backend>=1.2.3
 
 # Exchange connection requirements
-ccxt==2.4.60 # always ensure real exchanges tests (in tests_additional and authenticated exchange tests) are passing before changing the ccxt version
+ccxt==3.0.74 # always ensure real exchanges tests (in tests_additional and authenticated exchange tests) are passing before changing the ccxt version
 
 cryptography # Never specify a version (managed by https://github.com/Drakkar-Software/OctoBot-PyPi-Linux-Deployer)
 
 # OrderBook requirement
 sortedcontainers==2.4.0
 
 # Scripting requirements
```

### Comparing `OctoBot-Trading-2.3.7/tests/api/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/recent_trades/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/api/test_channels.py` & `OctoBot-Trading-2.4.0/tests/api/test_channels.py`

 * *Files 8% similar despite different names*

```diff
@@ -36,15 +36,15 @@
     pass
 
 
 async def trades_callback(exchange: str, exchange_id: str, cryptocurrency: str, symbol: str, trade, old_trade):
     pass
 
 
-async def order_callback(self, exchange, exchange_id, cryptocurrency, symbol, order, is_new, is_from_bot):
+async def order_callback(self, exchange, exchange_id, cryptocurrency, symbol, order, update_type, is_from_bot):
     pass
 
 
 async def test_subscribe_to_ohlcv_channel(exchange_manager):
     await subscribe_to_ohlcv_channel(ohlcv_callback, exchange_manager.id)
```

### Comparing `OctoBot-Trading-2.3.7/tests/api/test_exchange.py` & `OctoBot-Trading-2.4.0/tests/api/test_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/cli/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/ticker/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/contracts/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchanges/connectors/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/contracts/test_future_contract.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/contracts/test_future_contract.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/contracts/test_margin_contract.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/contracts/test_margin_contract.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/funding/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchanges/implementations/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/funding/test_funding_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/funding/test_funding_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/kline/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchanges/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/kline/test_kline_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/kline/test_kline_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/ohlcv/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchanges/util/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/ohlcv/test_candles_adapter.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/ohlcv/test_candles_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/ohlcv/test_candles_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/ohlcv/test_candles_manager.py`

 * *Files 1% similar despite different names*

```diff
@@ -162,8 +162,8 @@
 
 
 def _gen_candles(size) -> list:
     return [_get_candle(seed) for seed in range(1, size + 1)]
 
 
 def _get_candle(seed):
-    return [seed, seed * 10, seed * 100, seed * 1000, seed * 10000, seed * 100000]
+    return [int(seed), seed * 10, seed * 100, seed * 1000, seed * 10000, seed * 100000]
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/order_book/__init__.py` & `OctoBot-Trading-2.4.0/tests/modes/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/order_book/test_order_book_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/order_book/test_order_book_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/prices/__init__.py` & `OctoBot-Trading-2.4.0/tests/modes/script_keywords/dsl/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/prices/test_price_events_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/prices/test_price_events_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/prices/test_prices_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/prices/test_prices_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/recent_trades/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/recent_trades/test_recent_trades_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/recent_trades/test_recent_trades_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/test_exchange_symbols_data.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/test_exchange_symbols_data.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/ticker/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchange_data/ticker/test_ticker_manager.py` & `OctoBot-Trading-2.4.0/tests/exchange_data/ticker/test_ticker_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchanges/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -43,99 +43,113 @@
 
 @pytest_asyncio.fixture
 async def exchange_manager():
     exchange_manager_instance = ExchangeManager(load_test_config(), DEFAULT_EXCHANGE_NAME)
     exchange_manager_instance.is_spot_only = True
     exchange_manager_instance.is_simulated = False
     await exchange_manager_instance.initialize()
-    yield exchange_manager_instance
-    cancel_ccxt_throttle_task()
-    await exchange_manager_instance.stop()
-    # let updaters gracefully shutdown
-    await wait_asyncio_next_cycle()
+    try:
+        yield exchange_manager_instance
+    finally:
+        cancel_ccxt_throttle_task()
+        await exchange_manager_instance.stop()
+        # let updaters gracefully shutdown
+        await wait_asyncio_next_cycle()
 
 
 @pytest_asyncio.fixture
 async def simulated_exchange_manager():
     exchange_manager_instance = ExchangeManager(load_test_config(), DEFAULT_EXCHANGE_NAME)
     exchange_manager_instance.is_spot_only = True
     exchange_manager_instance.is_simulated = True
     await exchange_manager_instance.initialize()
-    yield exchange_manager_instance
-    cancel_ccxt_throttle_task()
-    await exchange_manager_instance.stop()
-    # let updaters gracefully shutdown
-    await wait_asyncio_next_cycle()
+    try:
+        yield exchange_manager_instance
+    finally:
+        cancel_ccxt_throttle_task()
+        await exchange_manager_instance.stop()
+        # let updaters gracefully shutdown
+        await wait_asyncio_next_cycle()
 
 
 @pytest_asyncio.fixture
 async def margin_exchange_manager():
     exchange_manager_instance = ExchangeManager(load_test_config(), DEFAULT_EXCHANGE_NAME)
     exchange_manager_instance.is_spot_only = False
     exchange_manager_instance.is_margin = True
     await exchange_manager_instance.initialize()
-    yield exchange_manager_instance
-    cancel_ccxt_throttle_task()
-    await exchange_manager_instance.stop()
-    # let updaters gracefully shutdown
-    await wait_asyncio_next_cycle()
+    try:
+        yield exchange_manager_instance
+    finally:
+        cancel_ccxt_throttle_task()
+        await exchange_manager_instance.stop()
+        # let updaters gracefully shutdown
+        await wait_asyncio_next_cycle()
 
 
 @pytest_asyncio.fixture
 async def margin_simulated_exchange_manager():
     exchange_manager_instance = ExchangeManager(load_test_config(), DEFAULT_EXCHANGE_NAME)
     exchange_manager_instance.is_spot_only = False
     exchange_manager_instance.is_simulated = True
     exchange_manager_instance.is_margin = True
     await exchange_manager_instance.initialize()
-    yield exchange_manager_instance
-    cancel_ccxt_throttle_task()
-    await exchange_manager_instance.stop()
-    # let updaters gracefully shutdown
-    await wait_asyncio_next_cycle()
+    try:
+        yield exchange_manager_instance
+    finally:
+        cancel_ccxt_throttle_task()
+        await exchange_manager_instance.stop()
+        # let updaters gracefully shutdown
+        await wait_asyncio_next_cycle()
 
 
 @pytest_asyncio.fixture
 async def future_exchange_manager():
     exchange_manager_instance = ExchangeManager(load_test_config(), DEFAULT_FUTURE_EXCHANGE_NAME)
     exchange_manager_instance.is_spot_only = False
     exchange_manager_instance.is_future = True
     await exchange_manager_instance.initialize()
-    yield exchange_manager_instance
-    cancel_ccxt_throttle_task()
-    await exchange_manager_instance.stop()
-    # let updaters gracefully shutdown
-    await wait_asyncio_next_cycle()
+    try:
+        yield exchange_manager_instance
+    finally:
+        cancel_ccxt_throttle_task()
+        await exchange_manager_instance.stop()
+        # let updaters gracefully shutdown
+        await wait_asyncio_next_cycle()
 
 
 @pytest_asyncio.fixture
 async def future_simulated_exchange_manager():
     exchange_manager_instance = ExchangeManager(load_test_config(), DEFAULT_FUTURE_EXCHANGE_NAME)
     exchange_manager_instance.is_spot_only = False
     exchange_manager_instance.is_simulated = True
     exchange_manager_instance.is_future = True
     await exchange_manager_instance.initialize()
-    yield exchange_manager_instance
-    cancel_ccxt_throttle_task()
-    await exchange_manager_instance.stop()
-    # let updaters gracefully shutdown
-    await wait_asyncio_next_cycle()
+    try:
+        yield exchange_manager_instance
+    finally:
+        cancel_ccxt_throttle_task()
+        await exchange_manager_instance.stop()
+        # let updaters gracefully shutdown
+        await wait_asyncio_next_cycle()
 
 
 @pytest_asyncio.fixture
 async def exchange_builder(request):
     config = None
     exchange_name = DEFAULT_EXCHANGE_NAME
     if hasattr(request, "param"):
         config, exchange_name = request.param
 
     exchange_builder_instance = create_exchange_builder(config if config is not None else load_test_config(),
                                                         exchange_name).is_simulated().is_rest_only()
-    yield exchange_builder_instance
-    await exchange_builder_instance.exchange_manager.stop()
+    try:
+        yield exchange_builder_instance
+    finally:
+        await exchange_builder_instance.exchange_manager.stop()
 
 
 # SIMULATED / BACKTESTING
 DEFAULT_BACKTESTING_SYMBOL = "BTC/USDT"
 DEFAULT_BACKTESTING_SPLIT_SYMBOL = "BTC", "USDT"
 DEFAULT_BACKTESTING_CURRENCY = "BTC"
 DEFAULT_BACKTESTING_MARKET = "USDT"
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/connectors/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/trailing/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/connectors/ccxt/test_ccxt_connector.py` & `OctoBot-Trading-2.4.0/tests/exchanges/connectors/ccxt/test_ccxt_connector.py`

 * *Files 1% similar despite different names*

```diff
@@ -175,8 +175,9 @@
 
 def _get_fees(type, currency, rate, cost):
     return {
         enums.FeePropertyColumns.TYPE.value: type,
         enums.FeePropertyColumns.CURRENCY.value: currency,
         enums.FeePropertyColumns.RATE.value: rate,
         enums.FeePropertyColumns.COST.value: decimal.Decimal(str(cost)),
+        enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: False,
     }
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/implementations/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/implementations/test_default_rest_exchange.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_basic_exchange_wrapper.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# pylint: disable=E0611
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -10,59 +9,51 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import octobot_trading.exchanges as exchanges
-import octobot_commons.enums as commons_enums
 import pytest
+import pytest_asyncio
+import mock
+import ccxt.async_support
+
 
-from tests.exchanges import exchange_manager, DEFAULT_EXCHANGE_NAME
+import octobot_trading.exchanges as exchanges
+import octobot_trading.exchanges.connectors.ccxt.enums as ccxt_enums
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class MockedCCXTConnector(exchanges.CCXTConnector):
-    @classmethod
-    def get_name(cls):
-        return DEFAULT_EXCHANGE_NAME
-
-
-class MockedRestExchange(exchanges.DefaultRestExchange):
-    DEFAULT_CONNECTOR_CLASS = MockedCCXTConnector
-
-    @classmethod
-    def get_exchange_connector_class(cls, exchange_manager):
-        return cls.DEFAULT_CONNECTOR_CLASS
-
-
-@pytest.fixture
-def default_rest_exchange(exchange_manager):
-    return MockedRestExchange(exchange_manager.config, exchange_manager)
-
-
-async def test_start_request_data_and_stop(default_rest_exchange):
-    await default_rest_exchange.initialize()
-    symbol = "BTC/USDT"
-    try:
-        assert len(default_rest_exchange.symbols) > 10
-        assert len(default_rest_exchange.time_frames) > 5
-        market_status = default_rest_exchange.get_market_status(symbol)
-        assert isinstance(market_status, dict)
-        assert market_status
-        ohlcv = await default_rest_exchange.get_symbol_prices(symbol, commons_enums.TimeFrames.ONE_HOUR)
-        assert isinstance(ohlcv, list)
-        assert len(ohlcv) > 50
-        trades = await default_rest_exchange.get_recent_trades(symbol)
-        assert isinstance(trades, list)
-        assert len(trades) > 5
-        ticker = await default_rest_exchange.get_price_ticker(symbol)
-        assert isinstance(ticker, dict)
-        assert ticker
-        book = await default_rest_exchange.get_order_book(symbol)
-        assert isinstance(book, dict)
-        assert book
-    finally:
-        await default_rest_exchange.stop()
+@pytest_asyncio.fixture
+async def basic_exchange_wrapper():
+    async with exchanges.temporary_exchange_wrapper("binanceus", ccxt_enums.ExchangeWrapperLibs.ASYNC_CCXT) as wrapper:
+        return wrapper
+
+
+async def test_constructor(basic_exchange_wrapper):
+    assert isinstance(basic_exchange_wrapper.exchange, ccxt.async_support.binanceus)
+    async with exchanges.temporary_exchange_wrapper("okx", ccxt_enums.ExchangeWrapperLibs.CCXT) as wrapper:
+        assert isinstance(wrapper.exchange, ccxt.okx)
+
+
+async def test_temporary_exchange_wrapper():
+    with mock.patch.object(ccxt.async_support.okx, "close", mock.AsyncMock()) as close_mock:
+        with pytest.raises(ZeroDivisionError):
+            async with exchanges.temporary_exchange_wrapper("okx", ccxt_enums.ExchangeWrapperLibs.ASYNC_CCXT) as wrapper:
+                assert isinstance(wrapper.exchange, ccxt.async_support.okx)
+                close_mock.assert_not_called()
+                1/0
+        close_mock.assert_called_once()
+
+
+async def test_unsupported_lib():
+    with pytest.raises(NotImplementedError):
+        exchanges.BasicExchangeWrapper("binanceus", "plop")
+
+
+async def test_get_available_time_frames(basic_exchange_wrapper):
+    assert len(await basic_exchange_wrapper.get_available_time_frames()) > 10
+    basic_exchange_wrapper.exchange.timeframes = ["1m"]
+    assert await basic_exchange_wrapper.get_available_time_frames() == ["1m"]
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/implementations/test_default_websocket_exchange.py` & `OctoBot-Trading-2.4.0/tests/exchanges/implementations/test_default_websocket_exchange.py`

 * *Files 3% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 import asyncio
 import mock
 
 import octobot_trading.exchanges as exchanges
 import octobot_trading.enums as enums
 import pytest
 
-from tests.exchanges import exchange_manager, DEFAULT_EXCHANGE_NAME
+from tests.exchanges import exchange_manager as exchange_manager_fixture, DEFAULT_EXCHANGE_NAME
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
 class FeedCallback:
     def __init__(self, connector, feed):
@@ -48,16 +48,17 @@
     EXCHANGE_FEEDS = {
         enums.WebsocketFeeds.CANDLE: True,
         enums.WebsocketFeeds.TICKER: True,
         enums.WebsocketFeeds.TRADES: True,
         enums.WebsocketFeeds.L1_BOOK: True,
     }
 
-    def __init__(self, config, exchange_manager, adapter_class=None, additional_config=None):
-        super().__init__(config, exchange_manager, adapter_class=adapter_class, additional_config=additional_config)
+    def __init__(self, config, exchange_manager, adapter_class=None, additional_config=None, websocket_name=None):
+        super().__init__(config, exchange_manager, adapter_class=adapter_class, additional_config=additional_config,
+                         websocket_name=websocket_name)
         self.called_feed_event = {
             feed: asyncio.Event()
             for feed in self.EXCHANGE_FEEDS
         }
         self.callback_mocks = {
             feed: mock.Mock(side_effect=FeedCallback(self, feed))
             for feed in enums.WebsocketFeeds
@@ -114,16 +115,16 @@
 
     @classmethod
     def get_exchange_connector_class(cls, exchange_manager):
         return cls.DEFAULT_CONNECTOR_CLASS
 
 
 @pytest.fixture
-def default_websocket_exchange(exchange_manager):
-    return MockedWebSocketExchange(exchange_manager.config, exchange_manager)
+def default_websocket_exchange(exchange_manager_fixture):
+    yield MockedWebSocketExchange(exchange_manager_fixture.config, exchange_manager_fixture)
 
 
 async def test_start_receive_feeds_and_stop(default_websocket_exchange):
     await default_websocket_exchange.init_websocket(
         default_websocket_exchange.exchange_manager.exchange_config.traded_time_frames,
         default_websocket_exchange.exchange_manager.exchange_config.traded_symbol_pairs,
         default_websocket_exchange.exchange_manager.tentacles_setup_config
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_abstract_exchange.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_abstract_exchange.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,27 +16,31 @@
 import pytest
 import mock
 
 import octobot_trading.exchanges as exchanges
 import octobot_trading.enums as enums
 import octobot_commons.tests.test_config as test_config
 
+from tests import event_loop
+
+
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
 EXCHANGE_NAME = "binanceus"
 
 
 @pytest.fixture
 def abstract_exchange():
     config = test_config.load_test_config()
     return exchanges.AbstractExchange(config, exchanges.ExchangeManager(config, EXCHANGE_NAME))
 
 
+@pytest.mark.asyncio
 async def test_log_order_creation_error(abstract_exchange):
     logger_mock = mock.Mock()
     abstract_exchange.logger = logger_mock
     error = RuntimeError()
     abstract_exchange.log_order_creation_error(error, enums.TraderOrderType.BUY_MARKET, "BTC/USD",
                                                1.0542454, 100.114, 100.114)
     logger_mock.error.assert_called_once()
@@ -46,27 +50,27 @@
     abstract_exchange.log_order_creation_error(error, enums.TraderOrderType.BUY_MARKET, "BTC/USD", 0, None, None)
     logger_mock.error.assert_called_once()
     assert all(f"{e}" in logger_mock.mock_calls[0].args[0] for e in (enums.TraderOrderType.BUY_MARKET, "BTC/USD",
                                                                      0, None, None))
     logger_mock.reset_mock()
 
 
-def test_supports_bundled_order_on_order_creation(abstract_exchange):
+async def test_supports_bundled_order_on_order_creation(abstract_exchange):
     order_mock = mock.Mock()
     order_mock.order_type = enums.TraderOrderType.SELL_MARKET
     assert abstract_exchange.supports_bundled_order_on_order_creation(order_mock, enums.TraderOrderType.STOP_LOSS) \
            is False
     abstract_exchange.SUPPORTED_BUNDLED_ORDERS[enums.TraderOrderType.SELL_MARKET] = [enums.TraderOrderType.SELL_MARKET,
                                                                                      enums.TraderOrderType.BUY_LIMIT]
     assert abstract_exchange.supports_bundled_order_on_order_creation(order_mock, enums.TraderOrderType.STOP_LOSS) \
            is False
     assert abstract_exchange.supports_bundled_order_on_order_creation(order_mock, enums.TraderOrderType.BUY_LIMIT) \
            is True
 
 
-def test_get_order_additional_params(abstract_exchange):
+async def test_get_order_additional_params(abstract_exchange):
     assert abstract_exchange.get_order_additional_params(None) == {}
 
 
-def test_get_bundled_order_parameters(abstract_exchange):
+async def test_get_bundled_order_parameters(abstract_exchange):
     with pytest.raises(NotImplementedError):
-        abstract_exchange.get_bundled_order_parameters()
+        abstract_exchange.get_bundled_order_parameters(None)
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_abstract_websocket_exchange.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_abstract_websocket_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_basic_exchange_wrapper.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_factory.py`

 * *Files 25% similar despite different names*

```diff
@@ -10,50 +10,54 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
-import pytest_asyncio
-import mock
-import ccxt.async_support
 
+from octobot_commons.errors import ConfigTradingError
 
-import octobot_trading.exchanges as exchanges
-import octobot_trading.exchanges.connectors.ccxt.enums as ccxt_enums
+# Import required fixtures
+from tests import event_loop, install_tentacles
+from tests.exchanges import exchange_builder
+from octobot_trading.api.exchange import cancel_ccxt_throttle_task
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-@pytest_asyncio.fixture
-async def basic_exchange_wrapper():
-    async with exchanges.temporary_exchange_wrapper("binanceus", ccxt_enums.ExchangeWrapperLibs.ASYNC_CCXT) as wrapper:
-        return wrapper
+@pytest.mark.usefixtures("event_loop", "exchange_builder")
+async def test_create_without_trading_config(exchange_builder):
+    with pytest.raises(ConfigTradingError):
+        await exchange_builder.build()
 
 
-async def test_constructor(basic_exchange_wrapper):
-    assert isinstance(basic_exchange_wrapper.exchange, ccxt.async_support.binanceus)
-    async with exchanges.temporary_exchange_wrapper("okx", ccxt_enums.ExchangeWrapperLibs.CCXT) as wrapper:
-        assert isinstance(wrapper.exchange, ccxt.okx)
+@pytest.mark.usefixtures("event_loop", "exchange_builder")
+async def test_create_without_installed_trading_mode(exchange_builder):
+    with pytest.raises(ConfigTradingError):
+        await exchange_builder.build()
 
 
-async def test_temporary_exchange_wrapper():
-    with mock.patch.object(ccxt.async_support.okx, "close", mock.AsyncMock()) as close_mock:
-        with pytest.raises(ZeroDivisionError):
-            async with exchanges.temporary_exchange_wrapper("okx", ccxt_enums.ExchangeWrapperLibs.ASYNC_CCXT) as wrapper:
-                assert isinstance(wrapper.exchange, ccxt.async_support.okx)
-                close_mock.assert_not_called()
-                1/0
-        close_mock.assert_called_once()
+@pytest.mark.usefixtures("event_loop", "exchange_builder", "install_tentacles")
+async def test_create_without_installed_trading_mode(exchange_builder):
+    with pytest.raises(ConfigTradingError):
+        await exchange_builder.build()
 
 
-async def test_unsupported_lib():
-    with pytest.raises(NotImplementedError):
-        exchanges.BasicExchangeWrapper("binanceus", "plop")
+@pytest.mark.usefixtures("event_loop", "exchange_builder", "install_tentacles")
+async def test_create(exchange_builder):
+    # await exchange_builder.build() # TODO
+    pass
 
 
-async def test_get_available_time_frames(basic_exchange_wrapper):
-    assert len(await basic_exchange_wrapper.get_available_time_frames()) > 10
-    basic_exchange_wrapper.exchange.timeframes = ["1m"]
-    assert await basic_exchange_wrapper.get_available_time_frames() == ["1m"]
+@pytest.mark.usefixtures("event_loop", "exchange_builder")
+@pytest.mark.parametrize("exchange_builder", [(None, "binanceus")], indirect=["exchange_builder"])
+async def test_create_basic(exchange_builder):
+    exchange_builder.disable_trading_mode()
+    exchange_manager = await exchange_builder.build()
+
+    assert exchange_manager is not None
+    assert exchange_manager.exchange_name == "binanceus"
+
+    cancel_ccxt_throttle_task()
+    await exchange_manager.stop()
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_builder.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_builder.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_config_data.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_config_data.py`

 * *Files 10% similar despite different names*

```diff
@@ -58,15 +58,14 @@
         assert exchange_manager.exchange_config.traded_cryptocurrencies == {
             "Ethereum": ["ETH/USDT"],
             "Avalanche": ["AVAX/BTC"]
         }
         all_pairs = sorted(["AVAX/BTC", "ETH/USDT", "UNI/BTC"])
         all_enabled_pairs = sorted(["AVAX/BTC", "ETH/USDT"])
         assert sorted(exchange_manager.exchange_config.traded_symbol_pairs) == all_enabled_pairs
-        assert sorted(exchange_manager.exchange_config.all_config_symbol_pairs) == all_pairs
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
 
     async def test_traded_pairs_with_wildcard(self):
         config = load_test_config()
         config[CONFIG_CRYPTO_CURRENCIES] = {
             "Bitcoin": {
@@ -86,15 +85,14 @@
         assert "ADA/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "MATIC/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ONT/BTC" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "BTC/USDT" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ETH/USDT" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "AVAX/BNB" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ETH/BTC" in exchange_manager.exchange_config.traded_symbol_pairs
-        assert "ETH/BTC" in exchange_manager.exchange_config.all_config_symbol_pairs
 
         # disabled
         assert "Ethereum" not in exchange_manager.exchange_config.traded_cryptocurrencies
         assert "ADA/ETH" not in exchange_manager.exchange_config.traded_symbol_pairs
 
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
@@ -113,16 +111,14 @@
                 "pairs": ["*"],
             }
         }
         _, exchange_manager = await self.init_default(config=config)
 
         assert "TRX/BTC" in exchange_manager.exchange_config.traded_symbol_pairs
         assert "ADA/BTC" in exchange_manager.exchange_config.traded_symbol_pairs
-        assert "BNB/BTC" in exchange_manager.exchange_config.all_config_symbol_pairs
-        assert "ADA/BTC" in exchange_manager.exchange_config.all_config_symbol_pairs
         assert "Bitcoin" in exchange_manager.exchange_config.traded_cryptocurrencies
 
         # invalid ETH wildcard config
         assert "Ethereum" not in exchange_manager.exchange_config.traded_cryptocurrencies
 
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
@@ -151,21 +147,19 @@
         assert "MATIC/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "LINK/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ONT/BTC" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "BTC/USDT" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ETH/USDT" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "AVAX/BNB" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "BTC/USDT" in exchange_manager.exchange_config.traded_symbol_pairs
-        assert "BTC/USDT" in exchange_manager.exchange_config.all_config_symbol_pairs
 
         # disabled
         assert "Ethereum" not in exchange_manager.exchange_config.traded_cryptocurrencies
         assert "ADA/ETH" not in exchange_manager.exchange_config.traded_symbol_pairs
         assert "ETH/USDT" not in exchange_manager.exchange_config.traded_symbol_pairs
-        assert "ETH/USDT" in exchange_manager.exchange_config.all_config_symbol_pairs
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
 
     async def test_traded_pairs_with_redundancy(self):
         config = load_test_config()
         config[CONFIG_CRYPTO_CURRENCIES] = {
             "Binance Coin": {
@@ -197,11 +191,10 @@
         assert exchange_manager.exchange_config.traded_cryptocurrencies["Binance Coin"] == ["BNB/USDT"]
         assert exchange_manager.exchange_config.traded_cryptocurrencies["Binance USD"] == ["BNB/BUSD"]
         assert exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"] == ["BNB/BTC"]
         assert exchange_manager.exchange_config.traded_cryptocurrencies["Tether"] == ["BNB/USDT"]
 
         sorted_pairs_without_redundancy = sorted(["BNB/USDT", "BNB/BUSD", "BNB/BTC"])
         assert sorted(exchange_manager.exchange_config.traded_symbol_pairs) == sorted_pairs_without_redundancy
-        assert sorted(exchange_manager.exchange_config.all_config_symbol_pairs) == sorted_pairs_without_redundancy
 
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_manager.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_exchange_simulator.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_exchange_simulator.py`

 * *Files 4% similar despite different names*

```diff
@@ -36,14 +36,15 @@
 
 
 def _assert_fee(fee, currency, price, rate, fee_type):
     assert fee[FeePropertyColumns.CURRENCY.value] == currency
     assert fee[FeePropertyColumns.COST.value] == price
     assert fee[FeePropertyColumns.RATE.value] == rate
     assert fee[FeePropertyColumns.TYPE.value] == fee_type
+    assert fee[FeePropertyColumns.IS_FROM_EXCHANGE.value] == False
 
 
 async def test_is_authenticated(backtesting_trader):
     _, exchange_manager, trader_inst = backtesting_trader
     assert not exchange_manager.exchange.authenticated()
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/test_exchanges.py` & `OctoBot-Trading-2.4.0/tests/exchanges/test_exchanges.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/traders/__init__.py` & `OctoBot-Trading-2.4.0/tests/exchanges/traders/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/traders/test_trader.py` & `OctoBot-Trading-2.4.0/tests/exchanges/traders/test_trader.py`

 * *Files 0% similar despite different names*

```diff
@@ -919,35 +919,37 @@
         _, exchange_manager, trader_inst = await self.init_default()
 
         base_order = BuyLimitOrder(trader_inst)
         chained_order = SellLimitOrder(trader_inst)
         assert base_order.is_created()
 
         # without bundle support
-        assert await trader_inst.bundle_chained_order_with_uncreated_order(base_order, chained_order, kw1=1, kw2="hello") \
+        assert await trader_inst.bundle_chained_order_with_uncreated_order(base_order, chained_order, True, kw1=1, kw2="hello") \
                == {}
         # bundled chained_order to base_order
         assert chained_order in base_order.chained_orders
         assert chained_order.triggered_by is base_order
         assert chained_order.has_been_bundled is False
+        assert chained_order.update_with_triggering_order_fees is True
         assert chained_order.exchange_creation_params == {}
         assert chained_order.trader_creation_kwargs == {"kw1": 1, "kw2": "hello"}
         assert chained_order.is_waiting_for_chained_trigger is True
         assert chained_order.is_created() is False
 
         base_order = BuyLimitOrder(trader_inst)
         chained_order = StopLossOrder(trader_inst)
         # with bundle support
         exchange_manager.exchange.SUPPORTED_BUNDLED_ORDERS[base_order.order_type] = [chained_order.order_type]
-        assert await trader_inst.bundle_chained_order_with_uncreated_order(base_order, chained_order, kw1=1, kw2="hello") \
+        assert await trader_inst.bundle_chained_order_with_uncreated_order(base_order, chained_order, False, kw1=1, kw2="hello") \
                == {}
         # bundled chained_order to base_order
         assert chained_order in base_order.chained_orders
         assert chained_order.triggered_by is base_order
         assert chained_order.has_been_bundled is True
+        assert chained_order.update_with_triggering_order_fees is False
         assert chained_order.exchange_creation_params == {}
         assert chained_order.trader_creation_kwargs == {"kw1": 1, "kw2": "hello"}
         assert chained_order.is_waiting_for_chained_trigger is True
         assert chained_order.is_created() is False
 
         await self.stop(exchange_manager)
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/types/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/types/test_websocket_exchange.py` & `OctoBot-Trading-2.4.0/tests/exchanges/types/test_websocket_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/util/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/util/test_exchange_market_status_fixer.py` & `OctoBot-Trading-2.4.0/tests/exchanges/util/test_exchange_market_status_fixer.py`

 * *Files 5% similar despite different names*

```diff
@@ -57,81 +57,93 @@
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(1, 0, 1),
             Ecmsc.LIMITS.value: self._get_limits(None, nan, 0.05, 1e4, nan, None)
         }
 
         assert ExchangeMarketStatusFixer(ms, price_example=current_price).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(1, 0, 1),
-            Ecmsc.LIMITS.value: self._get_limits(0.002190990480628382, 219.0990480628382,
-                                                 current_price / 1000, current_price * 1000,
-                                                 0.010000000000000012, 1000000000.0000011)
+            Ecmsc.LIMITS.value: self._get_limits(
+                0.002190990480628382, 21909.904806283797,
+                0.05, 10000.0,
+                0.0001095495240314191, 219099048.062838
+            )
         }
 
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(nan, None, nan),
             Ecmsc.LIMITS.value: self._get_limits(None, nan, 0.05, 1e4, nan, None)
         }
 
         assert ExchangeMarketStatusFixer(ms, price_example=current_price).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(4, 4, 4),
-            Ecmsc.LIMITS.value: self._get_limits(0.002190990480628382, 219.0990480628382,
-                                                 current_price / 1000, current_price * 1000,
-                                                 0.010000000000000012, 1000000000.0000011)
+            Ecmsc.LIMITS.value: self._get_limits(
+                0.002190990480628382, 21909.904806283797,
+                0.05, 10000.0,
+                0.0001095495240314191, 219099048.062838
+            )
         }
 
         current_price = 1.56e-6
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(nan, None, nan),
             Ecmsc.LIMITS.value: self._get_limits(None, nan, None, None, nan, None)
         }
 
         assert ExchangeMarketStatusFixer(ms, price_example=current_price).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(8, 8, 8),
-            Ecmsc.LIMITS.value: self._get_limits(641.0256410256403, 6410256.4102564035,
-                                                 current_price / 1000, current_price * 1000,
-                                                 9.999999999999991e-07, 9999.99999999999)
+            Ecmsc.LIMITS.value: self._get_limits(
+                641.0256410256403, 64102564102564.04,
+                1.5600000000000002e-09, 0.0015600000000000002,
+                9.999999999999991e-07, 99999999999.99991
+            )
         }
 
         current_price = 1.5678999
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(nan, None, nan),
             Ecmsc.LIMITS.value: self._get_limits(None, nan, 0, 0, nan, None)
         }
 
         assert ExchangeMarketStatusFixer(ms, price_example=current_price).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(7, 7, 7),
-            Ecmsc.LIMITS.value: self._get_limits(6.37795818470299, 637795.8184702988,
-                                                 current_price / 1000, current_price * 1000,
-                                                 0.01, 999999999.9999996)
+            Ecmsc.LIMITS.value: self._get_limits(
+                6.37795818470299, 63779581.84702988,
+                0.0015678999, 1567.8999000000001,
+                0.01, 99999999999.99997
+            )
         }
 
         current_price = 25.87257
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(),
             Ecmsc.LIMITS.value: self._get_limits(None, None, 0, 0, None, None)
         }
 
         assert ExchangeMarketStatusFixer(ms, price_example=current_price).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(5, 5, 5),
-            Ecmsc.LIMITS.value: self._get_limits(0.3865097282566056, 38650.97282566052,
-                                                 current_price / 1000, current_price * 1000,
-                                                 0.010000000000000007, 999999999.9999996)
+            Ecmsc.LIMITS.value: self._get_limits(
+                0.3865097282566056, 3865097.2825660524,
+                0.02587257, current_price * 1000,
+                0.010000000000000007, 99999999999.99997
+            )
         }
 
         current_price = 200.555
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(nan, nan, nan),
             Ecmsc.LIMITS.value: self._get_limits(nan, nan, 3, 3, nan, nan)
         }
 
         assert ExchangeMarketStatusFixer(ms, price_example=current_price).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(3, 3, 3),
-            Ecmsc.LIMITS.value: self._get_limits(0.04986163396574511, 4986.163396574511,
-                                                 current_price / 1000, current_price * 1000,
-                                                 0.01000000000000001, 1000000000.0000011)
+            Ecmsc.LIMITS.value: self._get_limits(
+                0.04986163396574511, 498616.3396574511,
+                3, 3,
+                0.14958490189723533, 1495849.0189723533
+            )
         }
 
     def test_exchange_market_status_fixer_without_market_status(self):
         assert ExchangeMarketStatusFixer({}).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(None, None, None),
             Ecmsc.LIMITS.value: self._get_limits(None, None, None, None, 0, None)
         }
@@ -148,24 +160,24 @@
         }
 
         assert ExchangeMarketStatusFixer(
             {Ecmsc.LIMITS.value: self._get_limits("0.05", "1e4", "plop", nan, "3.3", "11111111111")}
         ).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(None, None, None),
             # replace "plop" and nan with computed numbers
-            Ecmsc.LIMITS.value: self._get_limits(0.05, 1e4, 65.99999999999999, 1111111.1111, 3.3, 11111111111)
+            Ecmsc.LIMITS.value: self._get_limits(0.05, 1e4, None, None, 3.3, 11111111111)
         }
 
         # missing and added keys
         limits = self._get_limits("0.05", "1e4", "plop", nan, "3.3", "11111111111")
         limits["plop"] = {"a": "1"}
         limits[Ecmsc.LIMITS_AMOUNT.value]["plop"] = "2"
         limits[Ecmsc.LIMITS_AMOUNT.value].pop(Ecmsc.LIMITS_AMOUNT_MIN.value)
 
-        expected_limits = self._get_limits(0.05, 1e4, "plop", 1111111.1111, 3.3, 11111111111)
+        expected_limits = self._get_limits(0.05, 1e4, None, None, 3.3, 11111111111)
         expected_limits[Ecmsc.LIMITS_AMOUNT.value].pop(Ecmsc.LIMITS_AMOUNT_MIN.value)
         expected_limits[Ecmsc.LIMITS_AMOUNT.value]["plop"] = "2"
         expected_limits["plop"] = {"a": "1"}
 
         assert ExchangeMarketStatusFixer(
             {Ecmsc.LIMITS.value: limits}
         ).market_status == {
@@ -189,15 +201,15 @@
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(5, 5, 5),
             Ecmsc.LIMITS.value: self._get_limits(0.01, 1e3, nan, nan, 0.05, 1e5)
         }
 
         assert ExchangeMarketStatusFixer(ms).market_status == {
             Ecmsc.PRECISION.value: self._get_precision(5, 5, 5),
-            Ecmsc.LIMITS.value: self._get_limits(0.01, 1e3, 0.05 / 0.01, 1e5 / 1e3, 0.05, 1e5)
+            Ecmsc.LIMITS.value: self._get_limits(0.01, 1e3, None, None, 0.05, 1e5)
         }
 
     def test_exchange_market_status_fixer_without_price_amount(self):
         ms = {
             Ecmsc.PRECISION.value: self._get_precision(5, 5, 5),
             Ecmsc.LIMITS.value: self._get_limits(nan, None, 0.03, 1e4, 0.05, 1e7)
         }
@@ -226,41 +238,43 @@
             assert not check_market_status_values([78272, 0, 0, 5e-10, 100, 0.12])
             assert check_market_status_values([17, 78272, 79, 5e-10, 145, 100])
 
     def test_fix_market_status_limits_with_price(self):
         emsf = ExchangeMarketStatusFixer({}, 98765)
         if not os.getenv('CYTHON_IGNORE'):
             emsf._fix_market_status_limits_with_price()
-            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(0.00010125044297068805,
-                                                                              10.125044297068806,
-                                                                              98.765, 98765000,
-                                                                              0.010000000000000005,
-                                                                              1000000000.0000006)
+            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(
+                0.00010125044297068805, 1012.5044297068805,
+                98.765, 98765000,
+                0.010000000000000005, 100000000000.00005
+            )
 
             emsf = ExchangeMarketStatusFixer({}, 0.00123456)
             emsf._fix_market_status_limits_with_price()
-            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(0.8100051840331779, 8100.051840331779,
-                                                                              1.23456e-06, 1.23456,
-                                                                              1.0000000000000002e-06,
-                                                                              10000.000000000002)
+            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(
+                0.8100051840331779, 81000518403.3177,
+                1.23456e-06, 1.23456,
+                1.0000000000000002e-06, 99999999999.99991
+            )
 
             emsf = ExchangeMarketStatusFixer({}, 0.0000012)
             emsf._fix_market_status_limits_with_price()
-            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(833.3333333333311, 8333333.333333311,
-                                                                              1.2e-9, 0.0012,
-                                                                              9.999999999999974e-07,
-                                                                              9999.999999999973)
+            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(
+                833.3333333333311, 83333333333333.28,
+                1.2e-09, 0.0012,
+                9.999999999999974e-07, 99999999999.99992
+            )
 
             emsf = ExchangeMarketStatusFixer({}, 0.000999)
             emsf._fix_market_status_limits_with_price()
-            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(1.001001001001,
-                                                                              10010.010010009999,
-                                                                              9.99e-07, 0.9990000000000001,
-                                                                              9.999999999999991e-07,
-                                                                              9999.99999999999)
+            assert emsf.market_status[Ecmsc.LIMITS.value] == self._get_limits(
+                1.001001001001, 100100100100.09999,
+                9.99e-07, 0.9990000000000001,
+                9.999999999999991e-07, 99999999999.99991
+            )
 
     # Precision
     def test_get_price_precision(self):
         if not os.getenv('CYTHON_IGNORE'):
             assert ExchangeMarketStatusFixer({}, 10.5555)._get_price_precision() == 4
             assert ExchangeMarketStatusFixer({}, 1014578587.5)._get_price_precision() == 1
             assert ExchangeMarketStatusFixer({}, 1.00000000055)._get_price_precision() == 11
```

### Comparing `OctoBot-Trading-2.3.7/tests/exchanges/util/test_exchange_util.py` & `OctoBot-Trading-2.4.0/tests/exchanges/util/test_exchange_util.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,22 +11,21 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 import mock
-import trading_backend.exchanges
 
-from tests import event_loop
+import trading_backend.exchanges
 import octobot_commons.constants as commons_constants
 import octobot_commons.configuration as commons_configuration
 import octobot_trading.exchanges as exchanges
 
-pytestmark = pytest.mark.asyncio
+from tests import event_loop
 
 
 @pytest.fixture
 def tentacles_setup_config():
     setup_config = mock.Mock()
     setup_config.is_tentacle_activated = mock.Mock(return_value=True)
     return setup_config
@@ -36,14 +35,15 @@
 def exchange_config():
     return {
         commons_constants.CONFIG_EXCHANGE_KEY: commons_configuration.encrypt("01234").decode(),
         commons_constants.CONFIG_EXCHANGE_SECRET: commons_configuration.encrypt("012345").decode()
     }
 
 
+@pytest.mark.asyncio
 async def test_is_compatible_account_with_checked_exchange(exchange_config, tentacles_setup_config):
     with mock.patch.object(trading_backend.exchanges.Huobi, "is_valid_account",
                            mock.AsyncMock(return_value=(True, None))) as is_valid_account_mock:
         compatible, auth, error = await exchanges.is_compatible_account("huobi", exchange_config,
                                                                         tentacles_setup_config, False)
         assert compatible is True
         assert auth is True
@@ -71,22 +71,23 @@
 
 def test_get_partners_explanation_message():
     assert ".info" in exchanges.get_partners_explanation_message()
 
 
 def test_log_time_sync_error():
     logger = mock.Mock()
-    exchanges.log_time_sync_error(logger, "exchange_name", "error", "details")
+    exchanges.log_time_sync_error(logger, "exchange_name", "error", "hello call")
     args = logger.error.call_args[0][0]
     assert "exchange_name".capitalize() in args
     assert "error" in args
-    assert "details" in args
+    assert "hello call" in args
     assert ".info" in args
 
 
+@pytest.mark.asyncio
 async def test_is_compatible_account_with_unchecked_exchange(exchange_config, tentacles_setup_config):
     compatible, auth, error = await exchanges.is_compatible_account("hitbtc", exchange_config, tentacles_setup_config,
                                                                     False)
     assert compatible is False
     assert auth is False
     assert isinstance(error, str)
     exchange_config[commons_constants.CONFIG_EXCHANGE_TYPE] = commons_constants.CONFIG_EXCHANGE_FUTURE
```

### Comparing `OctoBot-Trading-2.3.7/tests/modes/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/modes/script_keywords/__init__.py` & `OctoBot-Trading-2.4.0/tests/modes/script_keywords/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -74,12 +74,12 @@
         'ETH': {'available': decimal.Decimal("20"), 'total': decimal.Decimal("20")},
         'USDT': {'available': decimal.Decimal("30000"), 'total': decimal.Decimal("30000")}
     }, True)
     exchange_manager.client_symbols.append("BTC/USDT")
     exchange_manager.client_symbols.append("ETH/USDT")
     exchange_manager.client_symbols.append("ETH/BTC")
     # init prices with BTC/USDT = 40000, ETH/BTC = 0.1 and ETH/USDT = 4000
-    portfolio_manager.portfolio_value_holder.last_prices_by_trading_pair["BTC/USDT"] = decimal.Decimal("40000")
-    portfolio_manager.portfolio_value_holder.last_prices_by_trading_pair["ETH/USDT"] = decimal.Decimal("4000")
-    portfolio_manager.portfolio_value_holder.last_prices_by_trading_pair["ETH/BTC"] = decimal.Decimal("0.1")
+    portfolio_manager.portfolio_value_holder.value_converter.last_prices_by_trading_pair["BTC/USDT"] = decimal.Decimal("40000")
+    portfolio_manager.portfolio_value_holder.value_converter.last_prices_by_trading_pair["ETH/USDT"] = decimal.Decimal("4000")
+    portfolio_manager.portfolio_value_holder.value_converter.last_prices_by_trading_pair["ETH/BTC"] = decimal.Decimal("0.1")
     portfolio_manager.handle_balance_updated()
     yield context
```

### Comparing `OctoBot-Trading-2.3.7/tests/modes/script_keywords/basic_keywords/test_account_balance.py` & `OctoBot-Trading-2.4.0/tests/modes/script_keywords/basic_keywords/test_account_balance.py`

 * *Files 1% similar despite different names*

```diff
@@ -122,15 +122,15 @@
                                                               decimal.Decimal(2),
                                                               trading_enums.TradeOrderSide.SELL,
                                                               False,
                                                               "reduce_only",
                                                               "is_stop_order") == decimal.Decimal(1)
 
 
-def test_get_locked_amount_in_stop_orders(mock_context):
+async def test_get_locked_amount_in_stop_orders(mock_context):
     mock_context.exchange_manager = mock.Mock()
     mock_context.exchange_manager.exchange_personal_data = mock.Mock()
     mock_context.exchange_manager.exchange_personal_data.orders_manager = mock.Mock()
 
     mock_context.exchange_manager.exchange_personal_data.orders_manager.get_open_orders = mock.Mock(return_value=[])
     assert account_balance._get_locked_amount_in_stop_orders(mock_context, "buy") == trading_constants.ZERO
```

### Comparing `OctoBot-Trading-2.3.7/tests/modes/script_keywords/basic_keywords/test_amount.py` & `OctoBot-Trading-2.4.0/tests/modes/script_keywords/basic_keywords/test_amount.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/modes/script_keywords/dsl/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/modes/script_keywords/dsl/test_quantity.py` & `OctoBot-Trading-2.4.0/tests/modes/script_keywords/dsl/test_quantity.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/modes/test_abstract_mode_consumer.py` & `OctoBot-Trading-2.4.0/tests/modes/test_abstract_mode_consumer.py`

 * *Files 1% similar despite different names*

```diff
@@ -132,15 +132,15 @@
         await consumer.create_new_orders(symbol, -1, EvaluatorStates.LONG, xyz=1, aaa="bbb")
 
 
 async def test_get_holdings_ratio():
     exchange_manager, symbol, consumer = await _get_tools()
     exchange_manager.client_symbols = [symbol]
     exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
-        last_prices_by_trading_pair[symbol] = decimal.Decimal("1000")
+        value_converter.last_prices_by_trading_pair[symbol] = decimal.Decimal("1000")
     exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
         portfolio_current_value = decimal.Decimal("11")
     exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio = {}
     exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio["BTC"] = \
         portfolio_assets.SpotAsset(name="BTC", available=decimal.Decimal("10"), total=decimal.Decimal("10"))
     exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio["USDT"] = \
         portfolio_assets.SpotAsset(name="USDT", available=decimal.Decimal("1000"), total=decimal.Decimal("1000"))
```

### Comparing `OctoBot-Trading-2.3.7/tests/modes/test_abstract_trading_mode.py` & `OctoBot-Trading-2.4.0/tests/modes/test_abstract_trading_mode.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/states/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_cancel_order_state.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_fill_order_state.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,71 +13,59 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import os
 
 import octobot_trading.personal_data
 import octobot_trading.enums as enums
-
 import pytest
+
 from tests import event_loop
 from tests.exchanges import simulated_trader, simulated_exchange_manager
-from tests.personal_data.orders import sell_limit_order, buy_limit_order, buy_market_order, sell_market_order
+from tests.personal_data.orders import sell_limit_order, buy_limit_order, buy_market_order
 
 pytestmark = pytest.mark.asyncio
 
 
-async def test_on_order_refresh_successful(sell_limit_order):
-    sell_limit_order.status = enums.OrderStatus.CANCELED
-    sell_limit_order.exchange_manager.is_backtesting = True
-    await sell_limit_order.initialize()
-    await sell_limit_order.state.on_refresh_successful()
-    assert sell_limit_order.is_cancelled()
-    sell_limit_order.clear()
+async def test_on_order_refresh_successful(buy_limit_order):
+    buy_limit_order.status = enums.OrderStatus.FILLED
+    buy_limit_order.exchange_manager.is_backtesting = True
+    await buy_limit_order.initialize()
+    await buy_limit_order.state.on_refresh_successful()
+    assert buy_limit_order.is_closed()
+    buy_limit_order.clear()
 
 
-async def test_constructor_with_pending_cancel_status(buy_limit_order):
-    # with PENDING_CANCEL status
-    buy_limit_order.status = enums.OrderStatus.PENDING_CANCEL
-    state = octobot_trading.personal_data.CancelOrderState(buy_limit_order, True)
-    assert state.state is enums.OrderStates.CANCELING
+async def test_constructor_with_partially_filled_status(buy_limit_order):
+    # with PARTIALLY_FILLED status
+    buy_limit_order.status = enums.OrderStatus.PARTIALLY_FILLED
+    state = octobot_trading.personal_data.FillOrderState(buy_limit_order, True)
+    assert state.state is enums.OrderStates.FILLING
     assert state.is_pending()
-    assert not state.is_canceled()
+    assert not state.is_filled()
     if not os.getenv('CYTHON_IGNORE'):
         assert state.is_status_pending()
-        assert not state.is_status_cancelled()
-
-
-async def test_constructor_with_cancelled_status(sell_limit_order):
-    # with CANCELED status
-    sell_limit_order.status = enums.OrderStatus.CANCELED
-    state = octobot_trading.personal_data.CancelOrderState(sell_limit_order, True)
-    assert state.state is enums.OrderStates.CANCELED
-    assert not state.is_pending()
-    assert state.is_canceled()
-    if not os.getenv('CYTHON_IGNORE'):
-        assert not state.is_status_pending()
-        assert state.is_status_cancelled()
+        assert not state.is_status_filled()
 
 
-async def test_constructor_with_expired_status(buy_market_order):
-    # with EXPIRED status
-    buy_market_order.status = enums.OrderStatus.EXPIRED
-    state = octobot_trading.personal_data.CancelOrderState(buy_market_order, True)
-    assert state.state is enums.OrderStates.CANCELED
+async def test_constructor_with_filled_status(sell_limit_order):
+    # with FILLED status
+    sell_limit_order.status = enums.OrderStatus.FILLED
+    state = octobot_trading.personal_data.FillOrderState(sell_limit_order, True)
+    assert state.state is enums.OrderStates.FILLED
     assert not state.is_pending()
-    assert state.is_canceled()
+    assert state.is_filled()
     if not os.getenv('CYTHON_IGNORE'):
         assert not state.is_status_pending()
-        assert state.is_status_cancelled()
+        assert state.is_status_filled()
 
 
-async def test_constructor_with_rejected_status(sell_market_order):
-    # with REJECTED status
-    sell_market_order.status = enums.OrderStatus.REJECTED
-    state = octobot_trading.personal_data.CancelOrderState(sell_market_order, True)
-    assert state.state is enums.OrderStates.CANCELED
+async def test_constructor_with_closed_status(buy_market_order):
+    # with CLOSED status
+    buy_market_order.status = enums.OrderStatus.CLOSED
+    state = octobot_trading.personal_data.FillOrderState(buy_market_order, True)
+    assert state.state is enums.OrderStates.FILLED
     assert not state.is_pending()
-    assert state.is_canceled()
+    assert state.is_filled()
     if not os.getenv('CYTHON_IGNORE'):
         assert not state.is_status_pending()
-        assert state.is_status_cancelled()
+        assert state.is_status_filled()
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_close_order_state.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_close_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_open_order_state.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_open_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_order_state.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_order_state_factory.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_order_state_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/states/test_pending_creation_order_state.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/states/test_pending_creation_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/test_decimal_order_adapter.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/test_decimal_order_adapter.py`

 * *Files 5% similar despite different names*

```diff
@@ -286,14 +286,73 @@
     quantity = decimal.Decimal(str(10))
     price = decimal.Decimal(str(4900000))
     assert personal_data.decimal_check_and_adapt_order_details_if_necessary(quantity, price,
                                                                             symbol_market_without_max) == [
                (decimal.Decimal(str(10)), decimal.Decimal(str(4900000)))]
 
 
+async def test_decimal_check_and_adapt_order_details_if_necessary_without_price_limit():
+    # without price limit
+    symbol_market = {
+        Ecmsc.LIMITS.value: {
+            Ecmsc.LIMITS_AMOUNT.value: {
+                Ecmsc.LIMITS_AMOUNT_MIN.value: 0.5,
+                Ecmsc.LIMITS_AMOUNT_MAX.value: 100,
+            },
+            Ecmsc.LIMITS_COST.value: {
+                Ecmsc.LIMITS_COST_MIN.value: 1,
+                Ecmsc.LIMITS_COST_MAX.value: 200
+            },
+            Ecmsc.LIMITS_PRICE.value: {
+                Ecmsc.LIMITS_PRICE_MIN.value: None,
+                Ecmsc.LIMITS_PRICE_MAX.value: None
+            },
+        },
+        Ecmsc.PRECISION.value: {
+            Ecmsc.PRECISION_PRICE.value: 8,
+            Ecmsc.PRECISION_AMOUNT.value: 8
+        }
+    }
+
+    # valid
+    quantity = decimal.Decimal(str(3))
+    price = decimal.Decimal(str(49.9))
+    assert personal_data.decimal_check_and_adapt_order_details_if_necessary(quantity, price, symbol_market) == [
+        (quantity, price)
+    ]
+
+    # quantity too low
+    quantity = decimal.Decimal(str(0.4))
+    price = decimal.Decimal(str(49.9))
+    assert personal_data.decimal_check_and_adapt_order_details_if_necessary(quantity, price, symbol_market) == []
+
+    # quantity too high
+    quantity = decimal.Decimal(str(250))
+    price = decimal.Decimal(str(1.5))
+    assert personal_data.decimal_check_and_adapt_order_details_if_necessary(quantity, price, symbol_market) == [
+        (decimal.Decimal(str(50)), price), (decimal.Decimal(str(100)), price), (decimal.Decimal(str(100)), price)
+    ]
+
+    # cost too low
+    quantity = decimal.Decimal(str(3))
+    price = decimal.Decimal(str(0.01))
+    assert personal_data.decimal_check_and_adapt_order_details_if_necessary(quantity, price, symbol_market) == []
+
+    # cost too high
+    quantity = decimal.Decimal(str(3))
+    price = decimal.Decimal(str(300))
+    assert personal_data.decimal_check_and_adapt_order_details_if_necessary(quantity, price, symbol_market) == [
+        (decimal.Decimal('0.33333333'), decimal.Decimal('300')),
+        (decimal.Decimal('0.66666666'), decimal.Decimal('300')),
+        (decimal.Decimal('0.66666666'), decimal.Decimal('300')),
+        (decimal.Decimal('0.66666666'), decimal.Decimal('300')),
+        (decimal.Decimal('0.66666666'), decimal.Decimal('300'))
+    ]
+
+
 async def test_split_orders():
     symbol_market = {
         Ecmsc.LIMITS.value: {
             Ecmsc.LIMITS_AMOUNT.value: {
                 Ecmsc.LIMITS_AMOUNT_MIN.value: 1,
                 Ecmsc.LIMITS_AMOUNT_MAX.value: 100,
             },
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/test_double_filled_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/test_double_filled_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/test_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/test_order.py`

 * *Files 16% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 import decimal
 
 import octobot_trading.errors as errors
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 import octobot_trading.personal_data as personal_data
 import octobot_trading.personal_data.orders.order_util as order_util
+import octobot_trading.storage.orders_storage as orders_storage
 
 from tests import event_loop
 from tests.exchanges import exchange_manager, simulated_exchange_manager
 from tests.exchanges.traders import trader_simulator
 from tests.exchanges.traders import trader
 from tests.test_utils.random_numbers import random_price
 
@@ -122,23 +123,23 @@
                           symbol="LTC/USDT",
                           quantity=100,
                           price=3.22)
     assert order_sim_inst.status == enums.OrderStatus.OPEN
     assert order_sim_inst.filled_quantity == order_sim_inst.origin_quantity == 100
 
 
-def test_order_state_creation(trader_simulator):
+async def test_order_state_creation(trader_simulator):
     config, exchange_manager_inst, trader_inst = trader_simulator
     order_inst = personal_data.Order(trader_inst)
     # errors.InvalidOrderState exception is caught by context manager
     with order_inst.order_state_creation():
         raise errors.InvalidOrderState()
 
 
-def test_parse_order_type():
+async def test_parse_order_type():
     untyped_raw_order = {
         enums.ExchangeConstantsOrderColumns.SIDE.value: enums.TradeOrderSide.BUY.value,
         enums.ExchangeConstantsOrderColumns.TYPE.value: None,
     }
     untyped_raw_with_maker_order = {
         enums.ExchangeConstantsOrderColumns.SIDE.value: enums.TradeOrderSide.BUY.value,
         enums.ExchangeConstantsOrderColumns.TAKER_OR_MAKER.value: enums.ExchangeConstantsOrderColumns.MAKER.value,
@@ -160,15 +161,15 @@
     assert personal_data.parse_order_type(typed_raw_order) == \
            (enums.TradeOrderSide.SELL, enums.TraderOrderType.SELL_MARKET)
     typed_raw_order[enums.ExchangeConstantsOrderColumns.TYPE.value] = enums.TradeOrderType.LIMIT
     assert personal_data.parse_order_type(typed_raw_order) == \
            (enums.TradeOrderSide.SELL, enums.TraderOrderType.SELL_LIMIT)
 
 
-def test_update_from_raw(trader_simulator):
+async def test_update_from_raw(trader_simulator):
     config, exchange_manager_inst, trader_inst = trader_simulator
     order_inst = personal_data.Order(trader_inst)
     # binance example market order
     raw_order = {
         'id': '362550114',
         'clientOrderId': 'x-T9698eeeeeeeeeeeeee792',
         'timestamp': 1637579281.377,
@@ -206,15 +207,19 @@
     assert order_inst.filled_quantity == decimal.Decimal("44964.0")
     assert order_inst.filled_price == constants.ZERO
     assert order_inst.total_cost == constants.ZERO
     assert order_inst.created_last_price == constants.ZERO
     assert order_inst.timestamp == 1637579281.377
     assert order_inst.canceled_time == 0
     assert order_inst.executed_time == 1637579281.377
-    assert order_inst.fee == {'cost': decimal.Decimal('0.03764836'), 'currency': 'USDT'}
+    assert order_inst.fee == {
+        enums.FeePropertyColumns.COST.value: decimal.Decimal('0.03764836'),
+        enums.FeePropertyColumns.CURRENCY.value: 'USDT',
+        enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: True,
+    }
 
     order_inst = personal_data.Order(trader_inst)
     # binance example limit order
     raw_order = {
         'id': '362550114',
         'clientOrderId': 'x-T9698eeeeeeeeeeeeee792',
         'timestamp': 1637579281.377,
@@ -252,33 +257,40 @@
     assert order_inst.filled_quantity == decimal.Decimal("44964.0")
     assert order_inst.filled_price == decimal.Decimal("13")
     assert order_inst.total_cost == decimal.Decimal("123.6667")
     assert order_inst.created_last_price == decimal.Decimal("12.664")
     assert order_inst.timestamp == 1637579281.377
     assert order_inst.canceled_time == 0
     assert order_inst.executed_time == 1637579281.377
-    assert order_inst.fee == {'cost': decimal.Decimal('0.03764836'), 'currency': 'USDT'}
+    assert order_inst.fee == {
+        enums.FeePropertyColumns.COST.value: decimal.Decimal('0.03764836'),
+        enums.FeePropertyColumns.CURRENCY.value: 'USDT',
+        enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: True,
+    }
 
 
 async def test_set_as_chained_order(trader_simulator):
     config, exchange_manager_inst, trader_inst = trader_simulator
 
     base_order = personal_data.Order(trader_inst)
 
     with pytest.raises(errors.ConflictingOrdersError):
-        await base_order.set_as_chained_order(base_order, True, {})
+        await base_order.set_as_chained_order(base_order, True, {}, True)
     assert base_order.triggered_by is None
     assert base_order.has_been_bundled is False
+    assert base_order.update_with_triggering_order_fees is False
     assert base_order.status is enums.OrderStatus.OPEN
     assert base_order.state is None
 
     chained_order = personal_data.Order(trader_inst)
-    await chained_order.set_as_chained_order(base_order, True, {})
+    await chained_order.set_as_chained_order(base_order, True, {}, True)
     assert chained_order.triggered_by is base_order
     assert chained_order.has_been_bundled is True
+    assert base_order.update_with_triggering_order_fees is False
+    assert chained_order.update_with_triggering_order_fees is True
     assert chained_order.status is enums.OrderStatus.PENDING_CREATION
     assert isinstance(chained_order.state, personal_data.PendingCreationOrderState)
 
 
 async def test_trigger_chained_orders(trader_simulator):
     config, exchange_manager_inst, trader_inst = trader_simulator
 
@@ -332,7 +344,69 @@
     base_order_2.filled_price = decimal.Decimal("4")
     await base_order_1.update_from_order(base_order_2)
     assert base_order_1.order_id == "3"
     assert base_order_1.status == enums.OrderStatus.CANCELED
     assert base_order_1.filled_price == decimal.Decimal("4")
     assert base_order_1.state is state_2
     assert base_order_1.state.order is base_order_1
+
+
+async def test_update_from_order_storage(trader_simulator):
+    config, exchange_manager_inst, trader_inst = trader_simulator
+
+    order = personal_data.BuyLimitOrder(trader_inst)
+    order.update(order_type=enums.TraderOrderType.BUY_LIMIT,
+                 symbol="BTC/USDT",
+                 current_price=decimal.Decimal("70"),
+                 quantity=decimal.Decimal("10"),
+                 price=decimal.Decimal("70"))
+    origin_tag = order.tag
+    origin_trader_creation_kwargs = order.trader_creation_kwargs
+    origin_exchange_creation_params = order.exchange_creation_params
+    origin_shared_signal_order_id = order.shared_signal_order_id
+    origin_has_been_bundled = order.has_been_bundled
+    origin_associated_entry_ids = order.associated_entry_ids
+    origin_update_with_triggering_order_fees = order.update_with_triggering_order_fees
+
+    # wrong format
+    order.update_from_storage_order_details({"hello": "hi there"})
+    assert order.tag is origin_tag
+    assert order.trader_creation_kwargs is origin_trader_creation_kwargs
+    assert order.exchange_creation_params is origin_exchange_creation_params
+    assert order.shared_signal_order_id is origin_shared_signal_order_id
+    assert order.has_been_bundled is origin_has_been_bundled
+    assert order.associated_entry_ids is origin_associated_entry_ids
+    assert order.update_with_triggering_order_fees is origin_update_with_triggering_order_fees
+
+    # partial update
+    order.update_from_storage_order_details({
+        enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value: {"plop": 1},
+        enums.StoredOrdersAttr.SHARED_SIGNAL_ORDER_ID.value: "11"
+    })
+    assert order.tag is origin_tag
+    assert order.trader_creation_kwargs == {"plop": 1} != origin_trader_creation_kwargs
+    assert order.exchange_creation_params is origin_exchange_creation_params
+    assert order.shared_signal_order_id == "11" != origin_shared_signal_order_id
+    assert order.has_been_bundled is origin_has_been_bundled
+    assert order.associated_entry_ids is origin_associated_entry_ids
+    assert order.update_with_triggering_order_fees is origin_update_with_triggering_order_fees
+
+    # full update
+    order.update_from_storage_order_details({
+        orders_storage.OrdersStorage.ORIGIN_VALUE_KEY: {
+            enums.ExchangeConstantsOrderColumns.TAG.value: "t1",
+        },
+        enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value: {"plop2": 1},
+        enums.StoredOrdersAttr.EXCHANGE_CREATION_PARAMS.value: {"ex": 2, "gg": "yesyes"},
+        enums.StoredOrdersAttr.SHARED_SIGNAL_ORDER_ID.value: "11a",
+        enums.StoredOrdersAttr.HAS_BEEN_BUNDLED.value: True,
+        enums.StoredOrdersAttr.ENTRIES.value: ["ABC", "2"],
+        enums.StoredOrdersAttr.UPDATE_WITH_TRIGGERING_ORDER_FEES.value: True,
+    })
+    assert order.tag == "t1" != origin_tag
+    assert order.trader_creation_kwargs == {"plop2": 1} != origin_trader_creation_kwargs
+    assert order.exchange_creation_params == {"ex": 2, "gg": "yesyes"} != origin_exchange_creation_params
+    assert order.shared_signal_order_id == "11a" != origin_shared_signal_order_id
+    assert order.has_been_bundled is True is not origin_has_been_bundled
+    assert order.associated_entry_ids == ["ABC", "2"] != origin_associated_entry_ids
+    assert order.has_been_bundled is True is not origin_has_been_bundled
+    assert order.update_with_triggering_order_fees is True is not origin_update_with_triggering_order_fees
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/test_order_adapter.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/test_order_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/test_order_util.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/test_order_util.py`

 * *Files 1% similar despite different names*

```diff
@@ -103,15 +103,16 @@
         enums.FeePropertyColumns.COST.value: 1
     }
     assert personal_data.get_fees_for_currency(fee1, "BTC") == 1
     assert personal_data.get_fees_for_currency(fee1, "BTC1") == 0
 
     fee2 = {
         enums.FeePropertyColumns.CURRENCY.value: "BTC",
-        enums.FeePropertyColumns.COST.value: 0
+        enums.FeePropertyColumns.COST.value: 0,
+        enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: True
     }
     assert personal_data.get_fees_for_currency(fee2, "BTC") == 0
     assert personal_data.get_fees_for_currency(fee2, "BTC1") == 0
 
     assert personal_data.get_fees_for_currency({}, "BTC") == 0
     assert personal_data.get_fees_for_currency(None, "BTC") == 0
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_buy_limit_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_buy_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_sell_limit_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_sell_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_stop_loss_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_stop_loss_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/limit/test_take_profit_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/limit/test_take_profit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/market/test_buy_market_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/market/test_buy_market_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/market/test_sell_market_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/market/test_sell_market_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/test_unknown_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/test_unknown_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/trailing/__init__.py` & `OctoBot-Trading-2.4.0/tests/personal_data/transactions/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py` & `OctoBot-Trading-2.4.0/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/__init__.py` & `OctoBot-Trading-2.4.0/tests/signals/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/__init__.py` & `OctoBot-Trading-2.4.0/tests/util/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/test_future_asset.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/test_future_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/test_margin_asset.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/test_margin_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/assets/test_spot_asset.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/assets/test_spot_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,15 +33,15 @@
 
 @pytest.fixture
 def historical_portfolio_value_manager(backtesting_trader_with_historical_pf_value_manager):
     config, exchange_manager, trader = backtesting_trader_with_historical_pf_value_manager
     return exchange_manager.exchange_personal_data.portfolio_manager.historical_portfolio_value_manager
 
 
-def test_constructor(historical_portfolio_value_manager):
+async def test_constructor(historical_portfolio_value_manager):
     assert historical_portfolio_value_manager is not None
     assert historical_portfolio_value_manager.portfolio_manager is not None
     assert historical_portfolio_value_manager.saved_time_frames == constants.DEFAULT_SAVED_HISTORICAL_TIMEFRAMES
     assert historical_portfolio_value_manager.historical_portfolio_value == sortedcontainers.SortedDict()
     assert historical_portfolio_value_manager.starting_time is not None
     assert historical_portfolio_value_manager.starting_time == historical_portfolio_value_manager.last_update_time
     assert historical_portfolio_value_manager.starting_portfolio is None
@@ -95,27 +95,41 @@
     }
     assert await historical_portfolio_value_manager.on_new_value(timestamp, value_by_currency_2,
                                                                  save_changes=False) is True
     assert list(historical_portfolio_value_manager.historical_portfolio_value.keys()) == [day_timestamp]
     _check_historical_value(list(historical_portfolio_value_manager.historical_portfolio_value.values())[0],
                             day_timestamp, value_by_currency_2)
 
-    # change currency value, same time
+    # change currency value (minor value change), same time
     value_by_currency_3 = {
-        "BTC": 1.5,
+        "BTC": 1,
         "USD": 3001,
         "HELLO": 666
     }
     # no force update: no change
     assert await historical_portfolio_value_manager.on_new_value(timestamp, value_by_currency_3,
                                                                  save_changes=False) is False
     assert list(historical_portfolio_value_manager.historical_portfolio_value.keys()) == [day_timestamp]
     _check_historical_value(list(historical_portfolio_value_manager.historical_portfolio_value.values())[0],
                             day_timestamp, value_by_currency_2)
-    # force update: actual change
+
+    # change currency value (major value change), same time
+    value_by_currency_major_change = {
+        "BTC": 2.5,
+        "USD": 3001,
+        "HELLO": 666
+    }
+    # major change, no force update: change even if no force
+    assert await historical_portfolio_value_manager.on_new_value(
+        timestamp, value_by_currency_major_change, save_changes=False) is True
+    assert list(historical_portfolio_value_manager.historical_portfolio_value.keys()) == [day_timestamp]
+    _check_historical_value(list(historical_portfolio_value_manager.historical_portfolio_value.values())[0],
+                            day_timestamp, value_by_currency_major_change)
+
+    # force update: actual forced change
     assert await historical_portfolio_value_manager.on_new_value(timestamp, value_by_currency_3,
                                                                  save_changes=False, force_update=True) is True
     assert list(historical_portfolio_value_manager.historical_portfolio_value.keys()) == [day_timestamp]
     _check_historical_value(list(historical_portfolio_value_manager.historical_portfolio_value.values())[0],
                             day_timestamp, value_by_currency_3)
 
     # new timestamp, same day: ignore it
@@ -373,17 +387,24 @@
                             sunday_timestamp, sunday_value_by_currency)
     _check_historical_value(list(historical_portfolio_value_manager.historical_portfolio_value.values())[3],
                             today_timestamp, today_value_by_currency)
 
     # same call, no new timestamp value
     assert await historical_portfolio_value_manager.on_new_values(value_by_currency_by_timestamp,
                                                                   save_changes=False) is False
-    sunday_value_by_currency["USD"] = 999
+    # no major change
+    sunday_value_by_currency["USD"] = 3.1
     assert await historical_portfolio_value_manager.on_new_values(value_by_currency_by_timestamp,
                                                                   save_changes=False) is False
+    # major change
+    sunday_value_by_currency["USD"] = 999
+    assert await historical_portfolio_value_manager.on_new_values(value_by_currency_by_timestamp,
+                                                                  save_changes=False) is True
+    # forced minor change
+    sunday_value_by_currency["USD"] = 999.1
     assert await historical_portfolio_value_manager.on_new_values(value_by_currency_by_timestamp,
                                                                   save_changes=False, force_update=True) is True
     assert list(historical_portfolio_value_manager.historical_portfolio_value.keys()) == [
         friday_timestamp, saturday_timestamp, sunday_timestamp, today_timestamp
     ]
     _check_historical_value(list(historical_portfolio_value_manager.historical_portfolio_value.values())[2],
                             sunday_timestamp, sunday_value_by_currency)
@@ -501,15 +522,15 @@
          late_timestamp: 77}
     historical_portfolio_value_manager.logger.debug.assert_called_once()
     historical_portfolio_value_manager.logger.debug.reset_mock()
 
     # add 1h missing value to convertable pairs
     convertable_pair = "BTC/USD"
     price = 3000
-    historical_portfolio_value_manager.portfolio_manager.portfolio_value_holder.last_prices_by_trading_pair[
+    historical_portfolio_value_manager.portfolio_manager.portfolio_value_holder.value_converter.last_prices_by_trading_pair[
         convertable_pair] = price
     assert historical_portfolio_value_manager.get_historical_values("BTC", commons_enums.TimeFrames.ONE_HOUR) == \
         {friday_timestamp: 1.1, saturday_timestamp: 1.3, sunday_timestamp: 3 / price,
          today_timestamp: 11, today_hour_timestamp: 11, late_timestamp: 77}
     historical_portfolio_value_manager.logger.debug.assert_not_called()
 
     # with time select
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_asset.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio_manager.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio_profitability.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio_profitability.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/test_portfolio_value_holder.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/test_portfolio_value_holder.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,29 +14,30 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import decimal
 import os
 import pytest
 
 import octobot_trading.constants as constants
-from tests.test_utils.random_numbers import decimal_random_quantity, decimal_random_price, random_price
+from tests.test_utils.random_numbers import decimal_random_quantity, decimal_random_price
 
 from tests.exchanges import backtesting_trader, backtesting_config, backtesting_exchange_manager, fake_backtesting
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
 async def test_get_current_crypto_currencies_values(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
     portfolio_value_holder = portfolio_manager.portfolio_value_holder
 
-    assert portfolio_value_holder.get_current_crypto_currencies_values() == {'BTC': constants.ONE, 'USDT': constants.ZERO}
+    assert portfolio_value_holder.get_current_crypto_currencies_values() == \
+           {'BTC': constants.ONE, 'USDT': constants.ZERO}
     portfolio_manager.portfolio.update_portfolio_from_balance({
         'BTC': {'available': decimal_random_quantity(), 'total': decimal_random_quantity()},
         'ETH': {'available': decimal_random_quantity(), 'total': decimal_random_quantity()},
         'XRP': {'available': decimal_random_quantity(), 'total': decimal_random_quantity()},
         'DOT': {'available': decimal_random_quantity(), 'total': decimal_random_quantity()},
         'MATIC': {'available': decimal_random_quantity(), 'total': decimal_random_quantity()},
         'USDT': {'available': decimal_random_quantity(), 'total': decimal_random_quantity()}
@@ -51,54 +52,54 @@
         'MATIC': constants.ZERO,
         'USDT': constants.ZERO
     }
 
     exchange_manager.client_symbols.append("MATIC/BTC")
     exchange_manager.client_symbols.append("XRP/BTC")
     if not os.getenv('CYTHON_IGNORE'):
-        portfolio_value_holder.missing_currency_data_in_exchange.remove("XRP")
+        portfolio_value_holder.value_converter.missing_currency_data_in_exchange.remove("XRP")
         portfolio_manager.handle_mark_price_update("XRP/BTC", decimal.Decimal("0.005"))
         exchange_manager.client_symbols.append("DOT/BTC")
-        portfolio_value_holder.missing_currency_data_in_exchange.remove("DOT")
+        portfolio_value_holder.value_converter.missing_currency_data_in_exchange.remove("DOT")
         portfolio_manager.handle_mark_price_update("DOT/BTC", decimal.Decimal("0.05"))
         exchange_manager.client_symbols.append("BTC/USDT")
 
         assert portfolio_value_holder.get_current_crypto_currencies_values() == {
             'BTC': constants.ONE,
             'ETH': constants.ZERO,
             'XRP': decimal.Decimal("0.005"),
             'DOT': decimal.Decimal("0.05"),
             'MATIC': constants.ZERO,
             'USDT': constants.ZERO
         }
         matic_btc_price = decimal_random_price(max_value=decimal.Decimal(0.05))
-        portfolio_value_holder.missing_currency_data_in_exchange.remove("MATIC")
+        portfolio_value_holder.value_converter.missing_currency_data_in_exchange.remove("MATIC")
         portfolio_manager.handle_mark_price_update("MATIC/BTC", matic_btc_price)
         assert portfolio_value_holder.get_current_crypto_currencies_values() == {
             'BTC': constants.ONE,
             'ETH': constants.ZERO,
             'XRP': decimal.Decimal("0.005"),
             'DOT': decimal.Decimal("0.05"),
             'MATIC': matic_btc_price,
             'USDT': constants.ZERO
         }
         usdt_btc_price = decimal_random_price(max_value=decimal.Decimal('0.01'))
-        portfolio_value_holder.missing_currency_data_in_exchange.remove("USDT")
+        portfolio_value_holder.value_converter.missing_currency_data_in_exchange.remove("USDT")
         portfolio_manager.handle_mark_price_update("BTC/USDT", usdt_btc_price)
         assert portfolio_value_holder.get_current_crypto_currencies_values() == {
             'BTC': constants.ONE,
             'ETH': constants.ZERO,
             'XRP': decimal.Decimal("0.005"),
             'DOT': decimal.Decimal("0.05"),
             'MATIC': matic_btc_price,
             'USDT': constants.ONE / usdt_btc_price
         }
         eth_btc_price = decimal_random_price(max_value=constants.ONE)
         exchange_manager.client_symbols.append("ETH/BTC")
-        portfolio_value_holder.missing_currency_data_in_exchange.remove("ETH")
+        portfolio_value_holder.value_converter.missing_currency_data_in_exchange.remove("ETH")
         portfolio_manager.handle_mark_price_update("ETH/BTC", eth_btc_price)
         assert portfolio_value_holder.get_current_crypto_currencies_values() == {
             'BTC': constants.ONE,
             'ETH': decimal.Decimal(str(eth_btc_price)),
             'XRP': decimal.Decimal("0.005"),
             'DOT': decimal.Decimal("0.05"),
             'MATIC': matic_btc_price,
@@ -144,24 +145,24 @@
         'BTC': decimal.Decimal("10"),
         'ETH': decimal.Decimal("5000"),
         'XRP': constants.ZERO,
         'USDT': constants.ZERO
     }
     if not os.getenv('CYTHON_IGNORE'):
         exchange_manager.client_symbols.append("XRP/BTC")
-        portfolio_value_holder.missing_currency_data_in_exchange.remove("XRP")
+        portfolio_value_holder.value_converter.missing_currency_data_in_exchange.remove("XRP")
         portfolio_manager.handle_mark_price_update("XRP/BTC", decimal.Decimal('0.00001'))
         assert portfolio_value_holder.get_current_holdings_values() == {
             'BTC': decimal.Decimal(10),
             'ETH': decimal.Decimal(5000),
             'XRP': decimal.Decimal(str(0.1)),
             'USDT': constants.ZERO
         }
         exchange_manager.client_symbols.append("BTC/USDT")
-        portfolio_value_holder.missing_currency_data_in_exchange.remove("USDT")
+        portfolio_value_holder.value_converter.missing_currency_data_in_exchange.remove("USDT")
         portfolio_manager.handle_mark_price_update("BTC/USDT", 5000)
         assert portfolio_value_holder.get_current_holdings_values() == {
             'BTC': decimal.Decimal(10),
             'ETH': decimal.Decimal(5000),
             'XRP': decimal.Decimal(str(0.1)),
             'USDT': decimal.Decimal(str(0.2))
         }
@@ -189,12 +190,26 @@
 async def test_update_origin_crypto_currencies_values(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
     portfolio_value_holder = portfolio_manager.portfolio_value_holder
 
     assert portfolio_value_holder.update_origin_crypto_currencies_values("ETH/BTC", decimal.Decimal(str(0.1))) is True
     assert portfolio_value_holder.origin_crypto_currencies_values["ETH"] == decimal.Decimal(str(0.1))
-    assert portfolio_value_holder.last_prices_by_trading_pair["ETH/BTC"] == decimal.Decimal(str(0.1))
+    assert portfolio_value_holder.value_converter.last_prices_by_trading_pair["ETH/BTC"] == decimal.Decimal(str(0.1))
+    # ETH is now priced and BTC is the reference market
+    assert portfolio_value_holder.update_origin_crypto_currencies_values("ETH/BTC", decimal.Decimal(str(0.1))) is False
 
     assert portfolio_value_holder.update_origin_crypto_currencies_values("BTC/USDT", decimal.Decimal(str(100))) is True
-    assert portfolio_value_holder.origin_crypto_currencies_values["USDT"] == decimal.Decimal(constants.ONE / decimal.Decimal(100))
-    assert portfolio_value_holder.last_prices_by_trading_pair["BTC/USDT"] == decimal.Decimal(str(100))
+    assert portfolio_value_holder.origin_crypto_currencies_values["USDT"] == \
+           decimal.Decimal(constants.ONE / decimal.Decimal(100))
+    assert portfolio_value_holder.value_converter.last_prices_by_trading_pair["BTC/USDT"] == decimal.Decimal(str(100))
+    # USDT is now priced and BTC is the reference market
+    assert portfolio_value_holder.update_origin_crypto_currencies_values("BTC/USDT", decimal.Decimal(str(100))) is False
+
+    # with bridge pair (DOT/ETH -> ETH/BTC to compute DOT/BTC)
+    assert portfolio_value_holder.update_origin_crypto_currencies_values("DOT/ETH", decimal.Decimal(str(0.015))) is True
+    assert portfolio_value_holder.origin_crypto_currencies_values["DOT"] == \
+           decimal.Decimal(str(0.015)) * decimal.Decimal(str(0.1))
+    assert portfolio_value_holder.value_converter.last_prices_by_trading_pair["DOT/ETH"] == decimal.Decimal(str(0.015))
+    # USDT is now priced and BTC is the reference market
+    assert portfolio_value_holder.update_origin_crypto_currencies_values("DOT/ETH", decimal.Decimal(str(0.015))) \
+           is False
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/__init__.py` & `OctoBot-Trading-2.4.0/tests_additional/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/test_future_portfolio.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/test_future_portfolio.py`

 * *Files 0% similar despite different names*

```diff
@@ -1314,8 +1314,9 @@
 
 def _disable_fees(exchange_manager):
     exchange_manager.exchange.connector.client.calculate_fee = mock.Mock(return_value={
         enums.FeePropertyColumns.TYPE.value: "maker",
         enums.FeePropertyColumns.CURRENCY.value: "USDT",
         enums.FeePropertyColumns.RATE.value: 0,
         enums.FeePropertyColumns.COST.value: constants.ZERO,
+        enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: False,
     })
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/test_margin_portfolio.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/test_margin_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/portfolios/types/test_spot_portfolio.py` & `OctoBot-Trading-2.4.0/tests/personal_data/portfolios/types/test_spot_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/positions/test_position.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/test_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/positions/test_position_factory.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/test_position_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/positions/test_positions_manager.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/test_positions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/positions/types/test_inverse_position.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/types/test_inverse_position.py`

 * *Files 0% similar despite different names*

```diff
@@ -294,15 +294,15 @@
     position_inst.update_fee_to_close()
     assert position_inst.fee_to_close == constants.ZERO
     await position_inst.update(update_size=constants.ONE_HUNDRED, mark_price=constants.ONE_HUNDRED)
     position_inst.update_fee_to_close()
     assert position_inst.fee_to_close == decimal.Decimal("0.0008")
 
 
-def test_get_two_way_taker_fee_for_quantity_and_price(future_trader_simulator_with_default_inverse):
+async def test_get_two_way_taker_fee_for_quantity_and_price(future_trader_simulator_with_default_inverse):
     config, exchange_manager_inst, trader_inst, default_contract = future_trader_simulator_with_default_inverse
     set_future_exchange_fees(exchange_manager_inst.exchange.connector, default_contract.pair)
 
     # no need to initialize the position
     leverage = decimal.Decimal("2")
     default_contract.set_current_leverage(leverage)
     assert personal_data.InversePosition(trader_inst, default_contract).get_two_way_taker_fee_for_quantity_and_price(
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/positions/types/test_linear_position.py` & `OctoBot-Trading-2.4.0/tests/personal_data/positions/types/test_linear_position.py`

 * *Files 0% similar despite different names*

```diff
@@ -456,15 +456,15 @@
     position_inst.update_fee_to_close()
     assert position_inst.fee_to_close == constants.ZERO
     await position_inst.update(update_size=TWENTY_FIVE, mark_price=FORTY)
     position_inst.update_fee_to_close()
     assert position_inst.fee_to_close == decimal.Decimal("0.4")
 
 
-def test_get_two_way_taker_fee_for_quantity_and_price(future_trader_simulator_with_default_linear):
+async def test_get_two_way_taker_fee_for_quantity_and_price(future_trader_simulator_with_default_linear):
     config, exchange_manager_inst, trader_inst, default_contract = future_trader_simulator_with_default_linear
     set_future_exchange_fees(exchange_manager_inst.exchange.connector, default_contract.pair)
 
     # no need to initialize the position
     leverage = decimal.Decimal("2")
     default_contract.set_current_leverage(leverage)
     assert personal_data.LinearPosition(trader_inst, default_contract).get_two_way_taker_fee_for_quantity_and_price(
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/trades/test_trade_factory.py` & `OctoBot-Trading-2.4.0/tests/personal_data/trades/test_trade_factory.py`

 * *Files 1% similar despite different names*

```diff
@@ -93,15 +93,16 @@
         assert trade.origin_price == decimal.Decimal(str(0.06917684))
         assert trade.executed_price == decimal.Decimal(str(0.06917684))
         assert trade.executed_time == 1502962946216
         assert trade.status == OrderStatus.FILLED
         assert trade.fee == {
             FeePropertyColumns.COST.value: decimal.Decimal("0.0015"),
             FeePropertyColumns.CURRENCY.value: "ETH",
-            FeePropertyColumns.RATE.value: 0.002
+            FeePropertyColumns.RATE.value: 0.002,
+            FeePropertyColumns.IS_FROM_EXCHANGE.value: True
         }
         assert trade.is_closing_order is True
         assert trade.tag is None
 
         await self.stop(exchange_manager)
 
     async def test_create_trade_from_order(self):
```

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/transactions/test_transaction_factory.py` & `OctoBot-Trading-2.4.0/tests/personal_data/transactions/test_transaction_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/personal_data/transactions/test_transactions_manager.py` & `OctoBot-Trading-2.4.0/tests/personal_data/transactions/test_transactions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/signals/test_trading_signal_bundle_builder.py` & `OctoBot-Trading-2.4.0/tests/signals/test_trading_signal_bundle_builder.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/signals/test_util.py` & `OctoBot-Trading-2.4.0/tests/signals/test_util.py`

 * *Files 2% similar despite different names*

```diff
@@ -60,19 +60,21 @@
         enums.TradingSignalOrdersAttrs.GROUP_ID.value: None,
         enums.TradingSignalOrdersAttrs.GROUP_TYPE.value: None,
         enums.TradingSignalOrdersAttrs.TAG.value: "hello",
         enums.TradingSignalOrdersAttrs.SHARED_SIGNAL_ORDER_ID.value: buy_limit_order.shared_signal_order_id,
         enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value: None,
         enums.TradingSignalOrdersAttrs.CHAINED_TO.value: None,
         enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
+        enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: None,
     }
 
     sell_limit_order.add_chained_order(buy_limit_order)
     sell_limit_order.symbol = "BTC/ETH"
-    await buy_limit_order.set_as_chained_order(sell_limit_order, True, {})
+    buy_limit_order.associate_to_entry("1")
+    await buy_limit_order.set_as_chained_order(sell_limit_order, True, {}, False)
     assert signals.create_order_signal_content(
         buy_limit_order,
         enums.TradingSignalOrdersActions.CREATE,
         "strat",
         exchange_manager,
         target_amount="1%",
         target_position="2",
@@ -100,21 +102,24 @@
         enums.TradingSignalOrdersAttrs.GROUP_ID.value: None,
         enums.TradingSignalOrdersAttrs.GROUP_TYPE.value: None,
         enums.TradingSignalOrdersAttrs.TAG.value: "hello",
         enums.TradingSignalOrdersAttrs.SHARED_SIGNAL_ORDER_ID.value: buy_limit_order.shared_signal_order_id,
         enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value: sell_limit_order.shared_signal_order_id,
         enums.TradingSignalOrdersAttrs.CHAINED_TO.value: sell_limit_order.shared_signal_order_id,
         enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
+        enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: ["1"],
     }
 
     order_group = personal_data.OneCancelsTheOtherOrderGroup(
         "group_name",
         buy_limit_order.exchange_manager.exchange_personal_data.orders_manager
     )
     buy_limit_order.add_to_order_group(order_group)
+    buy_limit_order.associate_to_entry("2")
+    buy_limit_order.associate_to_entry("3")
     final_order_desc = {
         enums.TradingSignalCommonsAttrs.ACTION.value: enums.TradingSignalOrdersActions.CREATE.value,
         enums.TradingSignalOrdersAttrs.SIDE.value: enums.TradeOrderSide.BUY.value,
         enums.TradingSignalOrdersAttrs.STRATEGY.value: "strat",
         enums.TradingSignalOrdersAttrs.SYMBOL.value: "BTC/ETH",
         enums.TradingSignalOrdersAttrs.EXCHANGE.value: "binanceus",
         enums.TradingSignalOrdersAttrs.EXCHANGE_TYPE.value: enums.ExchangeTypes.SPOT.value,
@@ -135,14 +140,15 @@
         enums.TradingSignalOrdersAttrs.GROUP_ID.value: order_group.name,
         enums.TradingSignalOrdersAttrs.GROUP_TYPE.value: personal_data.OneCancelsTheOtherOrderGroup.__name__,
         enums.TradingSignalOrdersAttrs.TAG.value: "hello",
         enums.TradingSignalOrdersAttrs.SHARED_SIGNAL_ORDER_ID.value: buy_limit_order.shared_signal_order_id,
         enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value: sell_limit_order.shared_signal_order_id,
         enums.TradingSignalOrdersAttrs.CHAINED_TO.value: sell_limit_order.shared_signal_order_id,
         enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
+        enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: ["1", "2", "3"],
     }
     assert signals.create_order_signal_content(
         buy_limit_order,
         enums.TradingSignalOrdersActions.CREATE,
         "strat",
         exchange_manager,
         target_amount="1%",
```

### Comparing `OctoBot-Trading-2.3.7/tests/test_utils/random_numbers.py` & `OctoBot-Trading-2.4.0/tests/test_utils/random_numbers.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests/util/test_config_util.py` & `OctoBot-Trading-2.4.0/tests/util/test_config_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/real_exchange_tester.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/real_exchange_tester.py`

 * *Files 13% similar despite different names*

```diff
@@ -29,16 +29,17 @@
     EXCHANGE_TYPE = trading_enums.ExchangeTypes.SPOT.value
     SYMBOL = None
     SYMBOL_2 = None
     SYMBOL_3 = None
     # default is 1h, change if necessary
     TIME_FRAME = commons_enums.TimeFrames.ONE_HOUR
     ALLOWED_TIMEFRAMES_WITHOUT_CANDLE = 0
-    CANDLE_SINCE = 631152000000    # 01/01/1990
+    CANDLE_SINCE = 1661990400000  # 1 September 2022 00:00:00
     CANDLE_SINCE_SEC = CANDLE_SINCE / 1000
+    REQUIRES_AUTH = False  # set True when even normally public apis require authentication
 
     # Public methods: to be implemented as tests
     # Use await self._[method_name] to get the test request result
     # ex: market_status = await self.get_market_status()
 
     # unauthenticated API
     async def test_time_frames(self):
@@ -46,14 +47,17 @@
 
     async def test_get_market_status(self):
         pass
 
     async def test_get_symbol_prices(self):
         pass
 
+    async def test_get_historical_symbol_prices(self):
+        pass
+
     async def test_get_kline_price(self):
         pass
 
     async def test_get_order_book(self):
         pass
 
     async def test_get_recent_trades(self):
@@ -86,104 +90,131 @@
     #     pass
     #
     # async def test_cancel_order(self):
     #     pass
     #
     # async def test_create_order(self):
     #     pass
-    
+
     def get_config(self):
         return {
             constants.CONFIG_EXCHANGES: {
                 self.EXCHANGE_NAME: {
                     constants.CONFIG_EXCHANGE_TYPE: self.EXCHANGE_TYPE
                 }
             }
         }
 
     async def time_frames(self):
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return exchange_manager.exchange.time_frames
 
     async def get_market_statuses(self):
         # return 2 different market status with different traded pairs to reduce possible
         # side effects using only one pair.
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return exchange_manager.exchange.get_market_status(self.SYMBOL), \
-                   exchange_manager.exchange.get_market_status(self.SYMBOL_2), \
-                   exchange_manager.exchange.get_market_status(self.SYMBOL_3)
+                exchange_manager.exchange.get_market_status(self.SYMBOL_2), \
+                exchange_manager.exchange.get_market_status(self.SYMBOL_3)
 
     async def get_symbol_prices(self, limit=None, **kwargs):
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return await exchange_manager.exchange.get_symbol_prices(self.SYMBOL, self.TIME_FRAME,
                                                                      limit=limit, **kwargs)
 
     async def get_kline_price(self, **kwargs):
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return await exchange_manager.exchange.get_kline_price(self.SYMBOL, self.TIME_FRAME, **kwargs)
 
     async def get_order_book(self, **kwargs):
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return await exchange_manager.exchange.get_order_book(self.SYMBOL, **kwargs)
 
     async def get_recent_trades(self, limit=50):
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return await exchange_manager.exchange.get_recent_trades(self.SYMBOL, limit=limit)
 
     async def get_price_ticker(self):
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return await exchange_manager.exchange.get_price_ticker(self.SYMBOL)
 
     async def get_all_currencies_price_ticker(self, **kwargs):
-        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config()) as exchange_manager:
+        async with get_exchange_manager(self.EXCHANGE_NAME, self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             return await exchange_manager.exchange.get_all_currencies_price_ticker(**kwargs)
 
     def get_allowed_time_delta(self):
         return (self.ALLOWED_TIMEFRAMES_WITHOUT_CANDLE + 1) * \
-               commons_enums.TimeFramesMinutes[self.TIME_FRAME] * \
-               constants.MINUTE_TO_SECONDS * 1.3
+            commons_enums.TimeFramesMinutes[self.TIME_FRAME] * \
+            constants.MINUTE_TO_SECONDS * 1.3
 
     @staticmethod
     def get_time():
         return Exchange.seconds()
 
     @staticmethod
     def get_ms_time():
         return int(Exchange.milliseconds())
 
+    def get_timeframe_seconds(self):
+        return commons_enums.TimeFramesMinutes[self.TIME_FRAME] * constants.MINUTE_TO_SECONDS
+
+    def get_time_after_time_frames(self, start, time_frames_count):
+        return start + self.get_timeframe_seconds() * time_frames_count
+
     @staticmethod
     def ensure_elements_order(elements, sort_key, reverse=False):
         assert sorted(elements, key=lambda x: x[sort_key], reverse=reverse) == elements
 
     def check_market_status_limits(self, market_status,
                                    normal_price_max=10000, normal_price_min=1e-06,
                                    normal_cost_max=10000, normal_cost_min=1e-06,
                                    low_price_max=1e-07, low_price_min=1e-09,
                                    low_cost_max=1e-03, low_cost_min=1e-06,
                                    expect_invalid_price_limit_values=False,
                                    expect_inferior_or_equal_price_and_cost=False,
-                                   enable_price_and_cost_comparison=True):
+                                   enable_price_and_cost_comparison=True,
+                                   has_price_limits=True):
         min_price = market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_PRICE.value][Ecmsc.LIMITS_PRICE_MIN.value]
+        max_price = market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_PRICE.value][Ecmsc.LIMITS_PRICE_MAX.value]
         min_cost = market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_COST.value][Ecmsc.LIMITS_COST_MIN.value]
+        has_min_or_max_price = min_price not in (None, 0) or max_price not in (None, 0)
+        if has_min_or_max_price and not has_price_limits:
+            raise AssertionError(
+                f"Expect no price limit values but min or max price limit is set (min: {min_price} max: {max_price})"
+            )
+        if not has_min_or_max_price and has_price_limits:
+            raise AssertionError(
+                f"Expect price limit values but min or max price limit is not set (min: {min_price} max: {max_price})"
+            )
         has_price_limit_value = min_price not in (None, 0)
         has_cost_limit_value = min_cost not in (None, 0)
         has_limit_value = has_price_limit_value and has_cost_limit_value
         if (not has_limit_value) and expect_invalid_price_limit_values:
             raise AssertionError("No price and limit value does not mean invalid values")
         if not expect_invalid_price_limit_values and market_status[Ecmsc.SYMBOL.value] == self.SYMBOL_3:
             # if these test are not passing, it means that limits are invalid
             # (limits should be much lower for SYMBOL_3 which is the low price pair, ex: XRP/BTC)
             # => set expect_invalid_price_limit_values to True in call and
             # remove price limit in exchange tentacle market status fixer if this is the case
-            assert (not has_price_limit_value) or low_price_max >= min_price >= low_price_min
+            if has_price_limit_value:
+                assert (not has_price_limit_value) or low_price_max >= min_price >= low_price_min
             assert (not has_cost_limit_value) or low_cost_max >= min_cost >= low_cost_min
         else:
-            assert (not has_price_limit_value) or normal_price_max >= min_price >= normal_price_min
+            if has_price_limit_value:
+                assert (not has_price_limit_value) or normal_price_max >= min_price >= normal_price_min
             assert (not has_cost_limit_value) or normal_cost_max >= min_cost >= normal_cost_min
-        if enable_price_and_cost_comparison and has_limit_value:
+        if has_price_limits and enable_price_and_cost_comparison and has_limit_value:
             # Consistency here is not required by OctoBot. Fix in tentacles if consistency
             # in price/cost comparison becomes required and min_price <= min_cost is false without a good reason
             if expect_inferior_or_equal_price_and_cost:
                 assert min_price >= min_cost
             else:
                 assert min_price <= min_cost
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_ascendex.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_upbit.py`

 * *Files 5% similar despite different names*

```diff
@@ -23,87 +23,98 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestAscendExRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "ascendex"
+class TestUpbitRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "upbit"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
+            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.SIX_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            # on AscendEx, precision is a decimal instead of a number of digits
+            # on this exchange, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in AscendEx tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in AscendEx tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) in [10, 11]
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=5)
-        assert len(symbol_prices) == 5
+        symbol_prices = await self.get_symbol_prices(limit=200)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert limit - 2 <= len(symbol_prices) <= limit  # no idea why but it happens
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
-        # limit param is not yet handled on AscendEx, consider orderbook with a least 6 bids and asks
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) > 5
+        assert len(order_book[Ecobic.ASKS.value]) == 15
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) > 5
+        assert len(order_book[Ecobic.BIDS.value]) == 15
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
@@ -131,18 +142,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value]
-            assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value]
+            assert ticker[Ectc.BID.value] is None
+            assert ticker[Ectc.BID_VOLUME.value] is None
+            assert ticker[Ectc.ASK.value] is None
+            assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
-            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
+            assert ticker[Ectc.PREVIOUS_CLOSE.value]
             assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
-            RealExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
+            assert ticker[Ectc.TIMESTAMP.value]
+            RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_binance.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_binance.py`

 * *Files 3% similar despite different names*

```diff
@@ -81,22 +81,29 @@
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50)
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitfinex.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bitfinex.py`

 * *Files 3% similar despite different names*

```diff
@@ -94,22 +94,29 @@
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert 200 >= len(symbol_prices) >= 200 - candle_limit_error
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50)
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         # await asyncio.sleep(10) # prevent rate api limit
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
@@ -125,15 +132,15 @@
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 25
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) == 50  # broken after ccxt 2.4.60 (trade symbol parsing issue), still the case in 2.5.5
+        assert len(recent_trades) == 50  # broken after ccxt 2.4.60 (trade symbol parsing issue), still the case in 2.8.4
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitget.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bitstamp.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,128 +12,128 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
+import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
-from tests_additional.real_exchanges import get_exchange_manager
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBitgetRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bitget"
-    SYMBOL = "BTC/USDT"
+class TestBitstampRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bitstamp"
+    SYMBOL = "BTC/USD"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
-            # TimeFrames.THREE_MINUTES.value,
-            # TimeFrames.FIVE_MINUTES.value,
+            TimeFrames.THREE_MINUTES.value,
+            TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            # TimeFrames.TWO_HOURS.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            # TimeFrames.SIX_HOURS.value,
-            # TimeFrames.HEIGHT_HOURS.value,
+            TimeFrames.SIX_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            # TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
-            # TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            # on Bitget, precision is a decimal instead of a number of digits
+            # on this exchange, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1  # to be fixed in Bitget tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] < 1  # to be fixed in Bitget tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
-        # without limit
-        symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 100
+        # without limit is not supported replaced by a 500 default limit in bitstamp tentacle
+        symbol_prices = await self.get_symbol_prices(limit=500)
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=50)
-        assert len(symbol_prices) == 50
-        # Bitget is not supporting more than 100 candles per request (exchange side limitation)
         symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 100
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []
-        # "until" param is required: add in tentacle
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50, until=self.get_ms_time())
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 5
+        assert len(order_book[Ecobic.ASKS.value]) >= 2000
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 5
+        assert len(order_book[Ecobic.BIDS.value]) >= 2000
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        tickers = await self.get_all_currencies_price_ticker()
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
+        with pytest.raises(errors.NotSupported):
+            tickers = await self.get_all_currencies_price_ticker()
+            for symbol, ticker in tickers.items():
+                self._check_ticker(ticker, symbol)
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
@@ -149,14 +149,14 @@
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
-            assert ticker[Ectc.OPEN.value] is None
+            assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker, check_open=False)
+            RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bithumb.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bithumb.py`

 * *Files 4% similar despite different names*

```diff
@@ -57,15 +57,15 @@
                    market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
             assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
                    market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) >= 4000
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
@@ -77,23 +77,30 @@
         symbol_prices = (await self.get_symbol_prices())[-200:]
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50)
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
-
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         # kline_price = await self.get_kline_price()
         client = bithumb()
         await client.fetch_markets()
         kline_price = [(await client.fetch_ohlcv(TestBithumbRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
 
@@ -109,15 +116,15 @@
         assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) == 20
+        assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitso.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_gateio.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,112 +12,123 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
-import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBinanceRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bitso"
+class TestGateIORealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "gateio"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
+            TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
-            TimeFrames.ONE_DAY.value,
-            TimeFrames.ONE_WEEK.value,
+            TimeFrames.HEIGHT_HOURS.value,
+            TimeFrames.ONE_DAY.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            # on this exchange, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status,
-                                            low_price_max=1e-06,
-                                            expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False)
+            # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
+            self.check_market_status_limits(market_status, has_price_limits=False,)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) >= 4500
+        assert len(symbol_prices) == 1000
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 50
+        assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 50
+        assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) == 50
+        assert len(recent_trades) > 20
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        with pytest.raises(errors.NotSupported):
-            tickers = await self.get_all_currencies_price_ticker()
+        tickers = await self.get_all_currencies_price_ticker()
+        for symbol, ticker in tickers.items():
+            self._check_ticker(ticker, symbol)
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
@@ -138,9 +149,9 @@
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker, check_open=False)
+            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
+            RealExchangeTester.check_ticker_typing(ticker, check_open=False, check_timestamp=False)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bitstamp.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_huobi.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,115 +12,124 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
-import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBitstampRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bitstamp"
-    SYMBOL = "BTC/USD"
+class TestHuobiRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "huobi"
+    SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
-            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.SIX_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
+            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            # on this exchange, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+            assert 1e-06 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in tentacle
+            assert 1e-09 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1   # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            # invalid values => remove price limit in tentacle
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
-        # without limit is not supported replaced by a 500 default limit in bitstamp tentacle
-        symbol_prices = await self.get_symbol_prices(limit=500)
-        assert len(symbol_prices) == 500
+        # without limit
+        symbol_prices = await self.get_symbol_prices()
+        assert len(symbol_prices) == 150
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) >= 2000
+        assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) >= 2000
+        assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        with pytest.raises(errors.NotSupported):
-            tickers = await self.get_all_currencies_price_ticker()
-            for symbol, ticker in tickers.items():
-                self._check_ticker(ticker, symbol)
+        tickers = await self.get_all_currencies_price_ticker()
+        for symbol, ticker in tickers.items():
+            self._check_ticker(ticker, symbol)
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
@@ -133,17 +142,17 @@
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value] is None
+            assert ticker[Ectc.BID_VOLUME.value]
             assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value] is None
+            assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bittrex.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bittrex.py`

 * *Files 5% similar despite different names*

```diff
@@ -53,15 +53,15 @@
                 Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) >= 744
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
@@ -73,16 +73,29 @@
         symbol_prices = (await self.get_symbol_prices())[-200:]
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         # kline_price = await self.get_kline_price()
         client = bittrex()
         await client.fetch_markets()
         kline_price = [(await client.fetch_ohlcv(TestBittrexRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_bybit.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bybit.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,36 +10,32 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
-import time
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-import octobot_trading.enums as trading_enums
-import octobot_trading.errors as errors
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
 class TestBybitRealExchangeTester(RealExchangeTester):
     EXCHANGE_NAME = "bybit"
-    EXCHANGE_TYPE = trading_enums.ExchangeTypes.FUTURE.value
-    SYMBOL = "BTC/USDT:USDT"
-    SYMBOL_2 = "ETH/USD:ETH"
-    SYMBOL_3 = "XRP/USD:XRP"
+    SYMBOL = "BTC/USDT"
+    SYMBOL_2 = "ETH/BTC"
+    SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
@@ -66,56 +62,56 @@
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in Bybit tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             # min cost and price can be inferior or equal as we are in /USD futures
-            self.check_market_status_limits(market_status,
-                                            low_price_min=0.0001,    # XRP/USD
-                                            low_price_max=0.1,    # XRP/USD
-                                            expect_invalid_price_limit_values=False,
-                                            expect_inferior_or_equal_price_and_cost=True)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) == 200
-        # max is 200 on Bybit
-        symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        # fetching more than 200 candles is fetching candles from the past
-        symbol_prices = await self.get_symbol_prices(limit=500)
+        # can't fetch more than 200 candles
+        symbol_prices = await self.get_symbol_prices(limit=1500)
         assert len(symbol_prices) == 200
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] < self.get_time() - self.get_allowed_time_delta() \
-            * 100
+        # check candles order (oldest first)
+        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+        # check last candle is the current candle
+        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []
-        # "end" param is required: add in tentacle
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50, end=self.get_ms_time())
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
@@ -158,17 +154,17 @@
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value] is None
+            assert ticker[Ectc.BID_VOLUME.value]
             assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value] is None
+            assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
             RealExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_coinbasepro.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_coinbase.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,29 +14,32 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
 import octobot_trading.errors
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
-    ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
+    ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestCoinbaseProRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "coinbasepro"
+class TestCoinbaseRealExchangeTester(RealExchangeTester):
+    # ALL require authentication ?
+    # https://github.com/ccxt/ccxt/issues/16719
+    EXCHANGE_NAME = "coinbase"
     SYMBOL = "BTC/USD"
     SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
+    SYMBOL_3 = "ADA/BTC"
+    REQUIRES_AUTH = True    # set True when even normally public apis require authentication
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
@@ -47,57 +50,68 @@
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in coinbasepro tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in coinbase tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in coinbasepro tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in coinbase tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
+
+    def _get_ohlcv_params(self, limit):
+        # to be added in tentacle
+        to_time = self.get_ms_time()
+        return {
+            "since": to_time - (self.get_timeframe_seconds() * limit * 1000),
+            "limit": limit,
+        }
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 300
+        assert len(symbol_prices) == 5
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=100)
-        assert len(symbol_prices) == 100
+        # max value is 299
+        with pytest.raises(octobot_trading.errors.FailedRequest):
+            await self.get_symbol_prices(**self._get_ohlcv_params(300))
+        symbol_prices = await self.get_symbol_prices(**self._get_ohlcv_params(299))
+        assert len(symbol_prices) == 299
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            with pytest.raises(octobot_trading.errors.FailedRequest):
+                await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)    # not supported
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
-        order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) > 50
-        assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) >= 50
-        assert len(order_book[Ecobic.BIDS.value][0]) == 2
+        with pytest.raises(octobot_trading.errors.NotSupported):
+            await self.get_order_book()
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
@@ -132,10 +146,13 @@
             assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
-            assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker, check_open=False, check_high=False, check_low=False)
+            assert ticker[Ectc.BASE_VOLUME.value] is None
+            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
+            RealExchangeTester.check_ticker_typing(
+                ticker,
+                check_open=False, check_high=False, check_low=False, check_timestamp=False, check_base_volume=False
+            )
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_coinex.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_coinex.py`

 * *Files 4% similar despite different names*

```diff
@@ -61,15 +61,15 @@
                 Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         # default 100 candles
         assert len(symbol_prices) == 100
         # check candles order (oldest first)
@@ -81,22 +81,30 @@
         symbol_prices = await self.get_symbol_prices(limit=550)
         assert len(symbol_prices) == 550
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50)
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
 
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_gateio.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_hollaex.py`

 * *Files 5% similar despite different names*

```diff
@@ -16,98 +16,110 @@
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
-import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestGateIORealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "gateio"
+class TestHollaexRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "hollaex"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
+    SYMBOL_3 = "XRP/USDT"
+    # use one day timeframe to avoid low liquidity issues when fetching candles
+    TIME_FRAME = TimeFrames.ONE_DAY
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
-            TimeFrames.ONE_MINUTE.value,
-            TimeFrames.FIVE_MINUTES.value,
-            TimeFrames.FIFTEEN_MINUTES.value,
-            TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.FOUR_HOURS.value,
-            TimeFrames.HEIGHT_HOURS.value,
-            TimeFrames.ONE_DAY.value
+            TimeFrames.ONE_DAY.value,
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
+                Ecmsc.PRECISION_AMOUNT.value] < 1.0     # to be fixed in tentacle
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1.0     # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
             self.check_market_status_limits(market_status,
-                                            expect_invalid_price_limit_values=True,
+                                            normal_cost_min=1e-07,
+                                            low_price_min=0.01,  # XRP/USDT instead of /BTC
+                                            low_price_max=1,
+                                            low_cost_min=0.01,
+                                            low_cost_max=1,
+                                            expect_invalid_price_limit_values=False,
                                             enable_price_and_cost_comparison=False)
 
     async def test_get_symbol_prices(self):
-        # without limit
-        symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 1000
+        # without limit is not supported replaced by a 500 default limit in hollaex tentacle
+        symbol_prices = await self.get_symbol_prices(limit=500)
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        with pytest.raises(errors.FailedRequest):
-            assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            # sometimes exchange time is not sync
+            assert max_candle_time <= self.get_time_after_time_frames(self.get_time(), 1)
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 5
+        assert len(order_book[Ecobic.ASKS.value]) >= 10
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 5
+        assert len(order_book[Ecobic.BIDS.value]) >= 10
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) > 20
+        assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
@@ -130,18 +142,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value]
+            assert ticker[Ectc.BID.value] is None
             assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value]
+            assert ticker[Ectc.ASK.value] is None
             assert ticker[Ectc.ASK_VOLUME.value] is None
-            assert ticker[Ectc.OPEN.value] is None
+            assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
-            RealExchangeTester.check_ticker_typing(ticker, check_open=False, check_timestamp=False)
+            assert ticker[Ectc.TIMESTAMP.value]
+            RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_hitbtc.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_hitbtc.py`

 * *Files 6% similar despite different names*

```diff
@@ -81,21 +81,29 @@
         symbol_prices = await self.get_symbol_prices(limit=200, sort='DESC')  # to be fixed in hitbtc tentacle
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50)
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+    async def test_get_historical_symbol_prices(self):
+        # try with since and limit (used in data collector)
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price(sort='DESC')  # to be fixed in hitbtc tentacle
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_hollaex.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_bitso.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,111 +12,128 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
+import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestHollaexRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "hollaex"
+class TestBitsoRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bitso"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/USDT"
-    # use one day timeframe to avoid low liquidity issues when fetching candles
-    TIME_FRAME = TimeFrames.ONE_DAY
+    SYMBOL_3 = "TUSD/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
+            TimeFrames.ONE_MINUTE.value,
+            TimeFrames.FIFTEEN_MINUTES.value,
+            TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
+            TimeFrames.FOUR_HOURS.value,
+            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
+            TimeFrames.ONE_WEEK.value,
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1.0     # to be fixed in tentacle
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1.0     # to be fixed in tentacle
+            # on this exchange, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status,
-                                            normal_cost_min=1e-07,
-                                            low_price_min=0.01,  # XRP/USDT instead of /BTC
-                                            low_price_max=1,
-                                            low_cost_min=0.01,
-                                            low_cost_max=1,
-                                            expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False)
+            self.check_market_status_limits(
+                market_status,
+                has_price_limits=True,
+                enable_price_and_cost_comparison=False,
+                low_price_max=1e-05,
+            )
 
     async def test_get_symbol_prices(self):
-        # without limit is not supported replaced by a 500 default limit in hollaex tentacle
-        symbol_prices = await self.get_symbol_prices(limit=500)
-        assert len(symbol_prices) == 500
+        # without limit
+        symbol_prices = await self.get_symbol_prices()
+        assert len(symbol_prices) >= 4500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            # sometimes exchange time is not sync
+            assert max_candle_time <= self.get_time_after_time_frames(self.get_time(), 1)
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) >= 10
+        assert len(order_book[Ecobic.ASKS.value]) == 50
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) >= 10
+        assert len(order_book[Ecobic.BIDS.value]) == 50
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        tickers = await self.get_all_currencies_price_ticker()
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
+        with pytest.raises(errors.NotSupported):
+            tickers = await self.get_all_currencies_price_ticker()
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
@@ -128,18 +145,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value] is None
+            assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value] is None
+            assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
-            assert ticker[Ectc.OPEN.value]
+            assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker)
+            RealExchangeTester.check_ticker_typing(ticker, check_open=False)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_huobi.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_okx.py`

 * *Files 5% similar despite different names*

```diff
@@ -16,81 +16,96 @@
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
-import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestHuobiRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "huobipro"
+class TestOkxRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "okx"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
+            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
+            TimeFrames.SIX_HOURS.value,
+            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            assert 1e-06 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in tentacle
-            assert 1e-09 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1   # to be fixed in tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # invalid values => remove price limit in tentacle
             self.check_market_status_limits(market_status,
-                                            normal_price_max=100000,    # way too high (BTC/USDT)
-                                            expect_invalid_price_limit_values=True,
+                                            normal_cost_min=1e-09,
+                                            low_cost_min=1e-08,
+                                            expect_invalid_price_limit_values=False,
                                             enable_price_and_cost_comparison=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 150
+        assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        with pytest.raises(errors.FailedRequest):
-            assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_kraken.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_kraken.py`

 * *Files 4% similar despite different names*

```diff
@@ -81,22 +81,30 @@
         symbol_prices = (await self.get_symbol_prices())[-200:]
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50)
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         # kline_price = await self.get_kline_price()
         client = kraken()
         await client.fetch_markets()
         kline_price = [(await client.fetch_ohlcv(TestKrakenRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_kucoin.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_kucoin.py`

 * *Files 4% similar despite different names*

```diff
@@ -62,17 +62,15 @@
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
-            self.check_market_status_limits(market_status,
-                                            expect_invalid_price_limit_values=True,
-                                            enable_price_and_cost_comparison=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
@@ -83,24 +81,30 @@
         symbol_prices = await self.get_symbol_prices(limit=100)
         assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []
-        # "endAt" param is required: add in tentacle
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50, endAt=self.get_ms_time())
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            # add "to" param to keep the same API as kucoin futures
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit, to=self.get_ms_time())
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_ndax.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_ndax.py`

 * *Files 10% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBinanceRealExchangeTester(RealExchangeTester):
+class TestNdaxRealExchangeTester(RealExchangeTester):
     EXCHANGE_NAME = "ndax"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/CAD"
     SYMBOL_3 = "XRP/CAD"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
@@ -83,14 +83,35 @@
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
+        # try with since and limit (used in data collector)
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            if limit is None:
+                with pytest.raises(AssertionError):  # not supported
+                    for candle in symbol_prices:
+                        assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
+            else:
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
+
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
@@ -129,20 +150,20 @@
             Ectc.OPEN.value,
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             # todo fix in tentacle: replace 0.0 by None
-            assert ticker[Ectc.HIGH.value] == 0.0
-            assert ticker[Ectc.LOW.value] == 0.0
+            assert ticker[Ectc.HIGH.value]
+            assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
-            assert ticker[Ectc.OPEN.value] == 0.0
+            assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
-            assert ticker[Ectc.BASE_VOLUME.value] == 0.0
+            assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_okcoin.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_okcoin.py`

 * *Files 4% similar despite different names*

```diff
@@ -21,15 +21,15 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestOkcoinRealExchangeTester(TestOkxRealExchangeTester):
+class _TestOkcoinRealExchangeTester(TestOkxRealExchangeTester): #unreachable ?
     EXCHANGE_NAME = "okcoin"
     SYMBOL = "BTC/USD"
     SYMBOL_2 = "ETH/USD"
     SYMBOL_3 = "NYC/USD"
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_okx.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_okx_futures.py`

 * *Files 5% similar despite different names*

```diff
@@ -15,27 +15,27 @@
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+from tests_additional.real_exchanges.real_futures_exchange_tester import RealFuturesExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestOkxRealExchangeTester(RealExchangeTester):
+class TestOkxFuturesRealExchangeTester(RealFuturesExchangeTester):
     EXCHANGE_NAME = "okx"
-    SYMBOL = "BTC/USDT"
-    SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
+    SYMBOL = "BTC/USDT:USDT"
+    SYMBOL_2 = "ETH/USD:ETH"
+    SYMBOL_3 = "XRP/USDT:USDT"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
@@ -53,26 +53,25 @@
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1   # to be fixed in tentacle
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             self.check_market_status_limits(market_status,
-                                            normal_cost_min=1e-08,
-                                            low_cost_min=1e-08,
+                                            low_price_max=1e-05,
                                             expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False)
+                                            enable_price_and_cost_comparison=True)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
@@ -83,24 +82,29 @@
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []
-        # "until" param is required: add in tentacle
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50, until=self.get_ms_time())
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
@@ -124,14 +128,22 @@
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
+    async def test_get_funding_rate(self):
+        funding_rate, ticker_funding_rate = await self.get_funding_rate()
+        # patch FUNDING_RATE and LAST_FUNDING_TIME in tentacle
+        self._check_funding_rate(funding_rate, has_rate=False, has_last_time=False)
+        # no funding info in ticker
+        self._check_funding_rate(ticker_funding_rate, has_rate=False, has_last_time=False,
+                                 has_next_rate=False, has_next_time=False)
+
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -152,8 +164,8 @@
             assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker)
+            RealFuturesExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_phemex.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_phemex.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
-from octobot_commons.enums import TimeFrames, PriceIndexes
+from octobot_commons.enums import TimeFrames, PriceIndexes, TimeFramesMinutes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 import octobot_trading.errors as errors
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
@@ -75,35 +75,41 @@
                                             low_cost_max=1,
                                             expect_invalid_price_limit_values=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) == 100
-        symbol_prices = await self.get_symbol_prices(limit=751)
-        assert len(symbol_prices) == 751
+        symbol_prices = await self.get_symbol_prices(limit=100)
+        assert len(symbol_prices) == 100
+        symbol_prices = await self.get_symbol_prices(limit=500)
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 200
+        assert len(symbol_prices) == 100    # see possibleLimitValues
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+    async def test_get_historical_symbol_prices(self):
+        for limit in (100, None):
+            assert len(await self.get_symbol_prices(since=self.CANDLE_SINCE_SEC, limit=limit)) == 5    # not supported
 
     async def test_get_kline_price(self):
+        # todo add param in tentacle
         kline_price = await self.get_kline_price()
-        assert len(kline_price) == 1
+        # get_kline_price is returning the last 100 candles on phemex
+        assert len(kline_price) == 100
+        kline_price = [kline_price[-1]]
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_poloniex.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_cryptocom.py`

 * *Files 5% similar despite different names*

```diff
@@ -23,77 +23,87 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestPoloniexRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "poloniex"
+class TestCryptoComRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "cryptocom"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
-    TIME_FRAME = TimeFrames.THIRTY_MINUTES  # 1h doesn't exist on Poloniex
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
+            TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
-            TimeFrames.TWO_HOURS.value,
+            TimeFrames.ONE_HOUR.value,
             TimeFrames.FOUR_HOURS.value,
+            TimeFrames.SIX_HOURS.value,
+            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
+            TimeFrames.ONE_WEEK.value,
+            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1   # to be fixed in tentacle
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
+            # on CryptoCom, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in CryptoCom tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in CryptoCom tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # invalid values => remove price limit in tentacle
-            self.check_market_status_limits(market_status,
-                                            normal_price_min=1e-05,  # 1000000 for BTC/USDT, 1e-05 for XRP/BTC, lol
-                                            normal_price_max=10000000,
-                                            expect_invalid_price_limit_values=True,
-                                            enable_price_and_cost_comparison=False)
+            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False,
+                                            enable_price_and_cost_comparison=False,
+                                            normal_cost_min=1e-10, low_cost_min=1e-9)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 100
+        assert len(symbol_prices) == 300
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50)
-        assert len(symbol_prices) == 50
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        for candle in symbol_prices:
-            assert candle[PriceIndexes.IND_PRICE_TIME.value] >= self.CANDLE_SINCE_SEC
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
@@ -135,17 +145,17 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value] is None
+            assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value] is None
+            assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_upbit.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_poloniex.py`

 * *Files 9% similar despite different names*

```diff
@@ -23,84 +23,95 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestUpbitRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "upbit"
+class TestPoloniexRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "poloniex"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
+    TIME_FRAME = TimeFrames.THIRTY_MINUTES  # 1h doesn't exist on Poloniex
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
-            TimeFrames.ONE_MINUTE.value,
-            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
-            TimeFrames.ONE_HOUR.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.ONE_WEEK.value,
-            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            # on this exchange, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1   # to be fixed in tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            # invalid values => remove price limit in tentacle
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 200
+        assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+    async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 15
+        assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 15
+        assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
@@ -135,11 +146,11 @@
             assert ticker[Ectc.BID.value] is None
             assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value] is None
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
-            assert ticker[Ectc.PREVIOUS_CLOSE.value]
+            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.3.7/tests_additional/real_exchanges/test_wavesexchange.py` & `OctoBot-Trading-2.4.0/tests_additional/real_exchanges/test_ascendex.py`

 * *Files 23% similar despite different names*

```diff
@@ -16,27 +16,26 @@
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
-import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestWavesExchangeRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "wavesexchange"
-    SYMBOL = "BTC/USDN"
+class TestAscendExRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "ascendex"
+    SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "WAVES/BTC"
+    SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
@@ -52,70 +51,89 @@
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
             assert market_status
             assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
             assert market_status[Ecmsc.PRECISION.value]
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
+            # on AscendEx, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in AscendEx tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in AscendEx tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 1440
+        assert len(symbol_prices) in [10, 11]
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 200
+        symbol_prices = await self.get_symbol_prices(limit=5)
+        assert len(symbol_prices) == 5
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        with pytest.raises(errors.UnexpectedAdapterError):
-            # try with since and limit (used in data collector)
-            assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=50) == []    # not supported
+    async def test_get_historical_symbol_prices(self):
+        # try with since and limit (used in data collector)
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
+        # limit param is not yet handled on AscendEx, consider orderbook with a least 6 bids and asks
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 6
+        assert len(order_book[Ecobic.ASKS.value]) > 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 6
+        assert len(order_book[Ecobic.BIDS.value]) > 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
+    async def test_get_all_currencies_price_ticker(self):
+        tickers = await self.get_all_currencies_price_ticker()
+        for symbol, ticker in tickers.items():
+            self._check_ticker(ticker, symbol)
+
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -126,18 +144,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value] is None
-            assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value] is None
-            assert ticker[Ectc.ASK_VOLUME.value] is None
+            assert ticker[Ectc.BID.value]
+            assert ticker[Ectc.BID_VOLUME.value]
+            assert ticker[Ectc.ASK.value]
+            assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
             RealExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
```


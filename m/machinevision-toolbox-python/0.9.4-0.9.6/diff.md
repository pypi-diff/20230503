# Comparing `tmp/machinevision-toolbox-python-0.9.4.tar.gz` & `tmp/machinevision-toolbox-python-0.9.6.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/Users/corkep/Dropbox/code/machinevision-toolbox-python/dist/.tmp-fm9fk497/machinevision-toolbox-python-0.9.4.tar", last modified: Sun Jan 15 05:08:58 2023, max compression
+gzip compressed data, was "machinevision-toolbox-python-0.9.6.tar", last modified: Wed May  3 10:42:55 2023, max compression
```

## Comparing `machinevision-toolbox-python-0.9.4.tar` & `machinevision-toolbox-python-0.9.6.tar`

### file list

```diff
@@ -1,55 +1,61 @@
-drwxrwx---   0 corkep     (503) staff       (20)        0 2023-01-15 05:08:57.983767 machinevision-toolbox-python-0.9.4/
--rw-r--r--   0 corkep     (503) staff       (20)     1068 2021-01-26 22:01:12.000000 machinevision-toolbox-python-0.9.4/LICENSE
--rw-rw----   0 corkep     (503) staff       (20)    18918 2023-01-15 05:08:57.983217 machinevision-toolbox-python-0.9.4/PKG-INFO
--rw-r--r--   0 corkep     (503) staff       (20)    17768 2022-10-04 20:27:29.000000 machinevision-toolbox-python-0.9.4/README.md
--rw-r--r--   0 corkep     (503) staff       (20)        6 2023-01-15 05:08:45.000000 machinevision-toolbox-python-0.9.4/RELEASE
-drwxrwx---   0 corkep     (503) staff       (20)        0 2023-01-15 05:08:57.956905 machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/
--rw-rw----   0 corkep     (503) staff       (20)    18918 2023-01-15 05:08:57.000000 machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/PKG-INFO
--rw-rw----   0 corkep     (503) staff       (20)     1745 2023-01-15 05:08:57.000000 machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/SOURCES.txt
--rw-rw----   0 corkep     (503) staff       (20)        1 2023-01-15 05:08:57.000000 machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/dependency_links.txt
--rw-rw----   0 corkep     (503) staff       (20)      198 2023-01-15 05:08:57.000000 machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/requires.txt
--rw-rw----   0 corkep     (503) staff       (20)       21 2023-01-15 05:08:57.000000 machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/top_level.txt
-drwxrwx---   0 corkep     (503) staff       (20)        0 2023-01-15 05:08:57.972164 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/
--rw-r--r--   0 corkep     (503) staff       (20)    19695 2022-10-03 07:43:21.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/BagOfWords.py
--rw-r--r--   0 corkep     (503) staff       (20)    36530 2023-01-10 02:41:17.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/BundleAdjust.py
--rw-r--r--   0 corkep     (503) staff       (20)   134400 2023-01-10 02:02:55.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/Camera.py
--rw-r--r--   0 corkep     (503) staff       (20)    49234 2022-12-13 07:29:20.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageBlobs.py
--rw-r--r--   0 corkep     (503) staff       (20)    17052 2022-10-07 00:58:39.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageColor.py
--rw-r--r--   0 corkep     (503) staff       (20)    13260 2022-10-07 00:58:47.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageConstants.py
--rw-r--r--   0 corkep     (503) staff       (20)    79246 2023-01-08 12:22:35.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageCore.py
--rw-r--r--   0 corkep     (503) staff       (20)    19186 2023-01-07 17:10:30.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageIO.py
--rw-r--r--   0 corkep     (503) staff       (20)     9144 2022-10-07 10:39:24.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageLineFeatures.py
--rw-r--r--   0 corkep     (503) staff       (20)    24484 2022-10-07 00:59:22.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageMorph.py
--rw-r--r--   0 corkep     (503) staff       (20)    14610 2022-10-07 00:59:29.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageMultiview.py
--rw-r--r--   0 corkep     (503) staff       (20)    75358 2023-01-10 02:24:46.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImagePointFeatures.py
--rw-r--r--   0 corkep     (503) staff       (20)    37925 2022-10-16 05:57:57.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageProcessing.py
--rw-r--r--   0 corkep     (503) staff       (20)    22219 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageRegionFeatures.py
--rw-r--r--   0 corkep     (503) staff       (20)    44678 2023-01-08 08:46:47.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageReshape.py
--rw-r--r--   0 corkep     (503) staff       (20)    65044 2022-11-27 00:12:45.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageSpatial.py
--rw-r--r--   0 corkep     (503) staff       (20)    27739 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageWholeFeatures.py
--rw-r--r--   0 corkep     (503) staff       (20)    18255 2022-10-16 06:28:11.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/PointCloud.py
--rw-r--r--   0 corkep     (503) staff       (20)    28487 2023-01-08 04:57:36.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/Sources.py
--rw-r--r--   0 corkep     (503) staff       (20)    59006 2022-11-27 20:44:06.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/VisualServo.py
--rw-r--r--   0 corkep     (503) staff       (20)     1085 2022-11-06 19:15:42.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/__init__.py
-drwxrwx---   0 corkep     (503) staff       (20)        0 2023-01-15 05:08:57.978644 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/
--rw-r--r--   0 corkep     (503) staff       (20)     1428 2023-01-08 07:17:15.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/__init__.py
--rwxr--r--   0 corkep     (503) staff       (20)    54493 2023-01-15 01:34:28.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/color.py
--rw-r--r--   0 corkep     (503) staff       (20)     5454 2023-01-08 04:50:37.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/data.py
--rw-r--r--   0 corkep     (503) staff       (20)     2338 2021-07-18 08:02:53.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/esttheta.py
--rw-r--r--   0 corkep     (503) staff       (20)    10305 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/findpeaks.py
--rw-r--r--   0 corkep     (503) staff       (20)    24436 2022-12-07 21:24:48.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/graphics.py
--rw-r--r--   0 corkep     (503) staff       (20)    36594 2023-01-15 05:08:36.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/imageio.py
--rw-r--r--   0 corkep     (503) staff       (20)    34023 2022-10-23 07:01:26.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/io.py
--rw-r--r--   0 corkep     (503) staff       (20)     2349 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/meshgrid.py
--rw-r--r--   0 corkep     (503) staff       (20)     9928 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/shapes.py
--rw-r--r--   0 corkep     (503) staff       (20)     4660 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/types.py
-drwxrwx---   0 corkep     (503) staff       (20)        0 2023-01-15 05:08:57.981812 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/blocks/
--rw-r--r--   0 corkep     (503) staff       (20)       95 2022-09-28 11:12:30.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/blocks/__init__.py
--rwxr--r--   0 corkep     (503) staff       (20)     1571 2023-01-11 08:39:13.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/blocks/aside_test_blocks.py
--rw-r--r--   0 corkep     (503) staff       (20)     9918 2023-01-11 08:36:40.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/blocks/camera.py
--rwxr--r--   0 corkep     (503) staff       (20)     3789 2022-09-28 11:12:30.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/blocks/tex2icon.py
--rw-r--r--   0 corkep     (503) staff       (20)    17557 2022-09-28 11:12:30.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/camera_derivatives.py
--rw-r--r--   0 corkep     (503) staff       (20)     1396 2022-09-28 11:12:30.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/fiducial.py
--rw-r--r--   0 corkep     (503) staff       (20)     1221 2021-04-22 05:02:55.000000 machinevision-toolbox-python-0.9.4/machinevisiontoolbox/newcameras.py
--rw-rw----   0 corkep     (503) staff       (20)       38 2023-01-15 05:08:57.983854 machinevision-toolbox-python-0.9.4/setup.cfg
--rw-r--r--   0 corkep     (503) staff       (20)     2438 2023-01-08 06:58:39.000000 machinevision-toolbox-python-0.9.4/setup.py
+drwxrwx---   0 corkep     (503) staff       (20)        0 2023-05-03 10:42:55.407884 machinevision-toolbox-python-0.9.6/
+-rw-r--r--   0 corkep     (503) staff       (20)     1068 2021-01-26 22:01:12.000000 machinevision-toolbox-python-0.9.6/LICENSE
+-rw-rw----   0 corkep     (503) staff       (20)    18814 2023-05-03 10:42:55.407331 machinevision-toolbox-python-0.9.6/PKG-INFO
+-rw-r--r--   0 corkep     (503) staff       (20)    17534 2023-01-23 06:08:52.000000 machinevision-toolbox-python-0.9.6/README.md
+drwxrwx---   0 corkep     (503) staff       (20)        0 2023-05-03 10:42:55.288625 machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/
+-rw-rw----   0 corkep     (503) staff       (20)    18814 2023-05-03 10:42:55.000000 machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/PKG-INFO
+-rw-rw----   0 corkep     (503) staff       (20)     1871 2023-05-03 10:42:55.000000 machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/SOURCES.txt
+-rw-rw----   0 corkep     (503) staff       (20)        1 2023-05-03 10:42:55.000000 machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/dependency_links.txt
+-rw-rw----   0 corkep     (503) staff       (20)      276 2023-05-03 10:42:55.000000 machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/requires.txt
+-rw-rw----   0 corkep     (503) staff       (20)       21 2023-05-03 10:42:55.000000 machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/top_level.txt
+drwxrwx---   0 corkep     (503) staff       (20)        0 2023-05-03 10:42:55.361003 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/
+-rw-r--r--   0 corkep     (503) staff       (20)    19680 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/BagOfWords.py
+-rw-r--r--   0 corkep     (503) staff       (20)    36081 2023-03-14 22:06:01.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/BundleAdjust.py
+-rw-r--r--   0 corkep     (503) staff       (20)   135063 2023-03-13 20:32:42.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/Camera.py
+-rw-r--r--   0 corkep     (503) staff       (20)    48997 2023-03-13 20:31:31.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageBlobs.py
+-rw-r--r--   0 corkep     (503) staff       (20)    17111 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageColor.py
+-rw-r--r--   0 corkep     (503) staff       (20)    13307 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageConstants.py
+-rw-r--r--   0 corkep     (503) staff       (20)    79464 2023-03-15 04:46:45.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageCore.py
+-rw-r--r--   0 corkep     (503) staff       (20)    20600 2023-03-15 04:24:24.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageIO.py
+-rw-r--r--   0 corkep     (503) staff       (20)     9104 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageLineFeatures.py
+-rw-r--r--   0 corkep     (503) staff       (20)    23789 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageMorph.py
+-rw-r--r--   0 corkep     (503) staff       (20)    14703 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageMultiview.py
+-rw-r--r--   0 corkep     (503) staff       (20)    76218 2023-03-13 20:29:31.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImagePointFeatures.py
+-rw-r--r--   0 corkep     (503) staff       (20)    37975 2023-03-15 04:50:05.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageProcessing.py
+-rw-r--r--   0 corkep     (503) staff       (20)    22175 2023-03-13 20:30:59.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageRegionFeatures.py
+-rw-r--r--   0 corkep     (503) staff       (20)    45673 2023-03-15 04:34:59.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageReshape.py
+-rw-r--r--   0 corkep     (503) staff       (20)    64761 2023-03-13 21:41:01.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageSpatial.py
+-rw-r--r--   0 corkep     (503) staff       (20)    27698 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageWholeFeatures.py
+-rw-r--r--   0 corkep     (503) staff       (20)    18286 2023-03-14 22:19:23.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/PointCloud.py
+-rw-r--r--   0 corkep     (503) staff       (20)    28615 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/Sources.py
+-rw-r--r--   0 corkep     (503) staff       (20)    59294 2023-03-15 04:51:49.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/VisualServo.py
+-rw-r--r--   0 corkep     (503) staff       (20)     1257 2023-01-26 06:26:45.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/__init__.py
+drwxrwx---   0 corkep     (503) staff       (20)        0 2023-05-03 10:42:55.392128 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/
+-rw-r--r--   0 corkep     (503) staff       (20)     1446 2023-03-14 20:17:58.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/__init__.py
+-rwxr--r--   0 corkep     (503) staff       (20)    54593 2023-01-24 10:11:53.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/color.py
+-rw-r--r--   0 corkep     (503) staff       (20)     5421 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/data.py
+-rw-r--r--   0 corkep     (503) staff       (20)     2323 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/esttheta.py
+-rw-r--r--   0 corkep     (503) staff       (20)    10377 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/findpeaks.py
+-rw-r--r--   0 corkep     (503) staff       (20)    24663 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/graphics.py
+-rw-r--r--   0 corkep     (503) staff       (20)    37425 2023-03-15 04:30:00.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/imageio.py
+-rw-r--r--   0 corkep     (503) staff       (20)     2350 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/meshgrid.py
+-rw-r--r--   0 corkep     (503) staff       (20)     9926 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/shapes.py
+-rw-r--r--   0 corkep     (503) staff       (20)     4716 2023-03-13 20:35:32.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/types.py
+drwxrwx---   0 corkep     (503) staff       (20)        0 2023-05-03 10:42:55.395290 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/blocks/
+-rw-r--r--   0 corkep     (503) staff       (20)      104 2023-01-24 11:07:53.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/blocks/__init__.py
+-rw-r--r--   0 corkep     (503) staff       (20)     9776 2023-04-30 06:22:36.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/blocks/camera.py
+-rwxr--r--   0 corkep     (503) staff       (20)     1572 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/blocks/test_blocks.py
+-rw-r--r--   0 corkep     (503) staff       (20)    17557 2022-09-28 11:12:30.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/camera_derivatives.py
+-rw-r--r--   0 corkep     (503) staff       (20)     1374 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/fiducial.py
+-rw-r--r--   0 corkep     (503) staff       (20)     1225 2023-01-23 02:08:16.000000 machinevision-toolbox-python-0.9.6/machinevisiontoolbox/newcameras.py
+-rw-r--r--   0 corkep     (503) staff       (20)     2221 2023-05-03 10:42:34.000000 machinevision-toolbox-python-0.9.6/pyproject.toml
+-rw-rw----   0 corkep     (503) staff       (20)       38 2023-05-03 10:42:55.408019 machinevision-toolbox-python-0.9.6/setup.cfg
+drwxrwx---   0 corkep     (503) staff       (20)        0 2023-05-03 10:42:55.405750 machinevision-toolbox-python-0.9.6/tests/
+-rw-r--r--   0 corkep     (503) staff       (20)     3120 2022-09-28 11:12:31.000000 machinevision-toolbox-python-0.9.6/tests/test_base_color.py
+-rw-r--r--   0 corkep     (503) staff       (20)     5477 2022-09-28 11:12:31.000000 machinevision-toolbox-python-0.9.6/tests/test_camera.py
+-rw-r--r--   0 corkep     (503) staff       (20)     2516 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.6/tests/test_color.py
+-rw-r--r--   0 corkep     (503) staff       (20)    18846 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.6/tests/test_core.py
+-rw-r--r--   0 corkep     (503) staff       (20)     4669 2022-11-06 19:14:50.000000 machinevision-toolbox-python-0.9.6/tests/test_image_io.py
+-rw-r--r--   0 corkep     (503) staff       (20)     2702 2022-09-28 11:12:31.000000 machinevision-toolbox-python-0.9.6/tests/test_imageprocessing_kernel.py
+-rw-r--r--   0 corkep     (503) staff       (20)    10086 2022-09-28 11:12:31.000000 machinevision-toolbox-python-0.9.6/tests/test_imageprocessing_morph.py
+-rw-r--r--   0 corkep     (503) staff       (20)    11781 2022-09-28 11:12:31.000000 machinevision-toolbox-python-0.9.6/tests/test_processing.py
```

### Comparing `machinevision-toolbox-python-0.9.4/LICENSE` & `machinevision-toolbox-python-0.9.6/LICENSE`

 * *Files identical despite different names*

### Comparing `machinevision-toolbox-python-0.9.4/PKG-INFO` & `machinevision-toolbox-python-0.9.6/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -1,47 +1,21 @@
-Metadata-Version: 2.1
-Name: machinevision-toolbox-python
-Version: 0.9.4
-Summary: A machine vision for education and research
-Home-page: https://github.com/petercorke/machinevision-toolbox-python
-Author: Peter Corke and Dorian Tsai
-License: MIT
-Project-URL: Documentation, https://petercorke.github.io/machinevision-toolbox-python
-Project-URL: Source, https://github.com/petercorke/machinevision-toolbox-python
-Project-URL: Tracker, https://github.com/petercorke/machinevision-toolbox-python/issues
-Project-URL: Coverage, https://codecov.io/gh/petercorke/machinevision-toolbox-python
-Keywords: python machine-vision computer-vision multiview-geometry features color blobs
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Requires-Python: >=3.7
-Description-Content-Type: text/markdown
-Provides-Extra: docs
-Provides-Extra: dev
-License-File: LICENSE
-
 # Machine Vision Toolbox for Python
 
 [![A Python Robotics Package](https://raw.githubusercontent.com/petercorke/robotics-toolbox-python/master/.github/svg/py_collection.min.svg)](https://github.com/petercorke/robotics-toolbox-python)
 [![Powered by Spatial Maths](https://raw.githubusercontent.com/petercorke/spatialmath-python/master/.github/svg/sm_powered.min.svg)](https://github.com/petercorke/spatialmath-python)
 [![QUT Centre for Robotics Open Source](https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg)](https://qcr.github.io)
 
 [![PyPI version](https://badge.fury.io/py/machinevision-toolbox-python.svg)](https://badge.fury.io/py/machinevision-toolbox-python)
 ![Python Version](https://img.shields.io/pypi/pyversions/machinevision-toolbox-python.svg)
 [![Powered by OpenCV](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-python/master/.github/svg/opencv_powered.svg)](https://opencv.org)
 [![Powered by Open3D](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-python/master/.github/svg/open3d_powered.svg)](https://open3d.org)
 [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
 
-[![Build Status](https://github.com/petercorke/spatialmath-python/workflows/build/badge.svg?branch=master)](https://github.com/petercorke/machinevisiontoolbox-python/actions?query=workflow%3Abuild)
+[![Build Status](https://github.com/petercorke/machinevision-toolbox-python/workflows/Test-master/badge.svg?branch=master)](https://github.com/petercorke/machinevision-toolbox-python/actions?query=workflow%3Abuild)
 [![Coverage](https://codecov.io/gh/petercorke/machinevision-toolbox-python/branch/master/graph/badge.svg)](https://codecov.io/gh/petercorke/machinevision-toolbox-python)
-[![Language grade: Python](https://img.shields.io/lgtm/grade/python/g/petercorke/machinevision-toolbox-python.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/petercorke/machinevision-toolbox-python/context:python)
 [![PyPI - Downloads](https://img.shields.io/pypi/dw/machinevision-toolbox-python)](https://pypistats.org/packages/machinevision-toolbox-python)
 
 <!-- [![GitHub stars](https://img.shields.io/github/stars/petercorke/machinevision-toolbox-python.svg?style=social&label=Star)](https://GitHub.com/petercorke/machinevision-toolbox-python/stargazers/) -->
 
 <table style="border:0px">
 <tr style="border:0px">
 <td style="border:0px">
@@ -103,15 +77,14 @@
 
 ### Reading and display an image
 
 ```python
 from machinevisiontoolbox import Image
 mona = Image.Read("monalisa.png")
 mona.disp()
-mona.smooth(sigma=5).disp()
 ```
 
 ![Mona Lisa image](https://github.com/petercorke/machinevision-toolbox-python/raw/master/figs/mona.png)
 
 Images can also be returned by iterators that operate over folders, zip files, local cameras, web cameras and video files.
 
 ### Simple image processing
```

#### html2text {}

```diff
@@ -1,47 +1,28 @@
-Metadata-Version: 2.1 Name: machinevision-toolbox-python Version: 0.9.4
-Summary: A machine vision for education and research Home-page: https://
-github.com/petercorke/machinevision-toolbox-python Author: Peter Corke and
-Dorian Tsai License: MIT Project-URL: Documentation, https://
-petercorke.github.io/machinevision-toolbox-python Project-URL: Source, https://
-github.com/petercorke/machinevision-toolbox-python Project-URL: Tracker, https:
-//github.com/petercorke/machinevision-toolbox-python/issues Project-URL:
-Coverage, https://codecov.io/gh/petercorke/machinevision-toolbox-python
-Keywords: python machine-vision computer-vision multiview-geometry features
-color blobs Classifier: Development Status :: 5 - Production/Stable Classifier:
-Intended Audience :: Developers Classifier: License :: OSI Approved :: MIT
-License Classifier: Programming Language :: Python :: 3.7 Classifier:
-Programming Language :: Python :: 3.8 Classifier: Programming Language ::
-Python :: 3.9 Classifier: Programming Language :: Python :: 3.10 Requires-
-Python: >=3.7 Description-Content-Type: text/markdown Provides-Extra: docs
-Provides-Extra: dev License-File: LICENSE # Machine Vision Toolbox for Python
-[![A Python Robotics Package](https://raw.githubusercontent.com/petercorke/
-robotics-toolbox-python/master/.github/svg/py_collection.min.svg)](https://
-github.com/petercorke/robotics-toolbox-python) [![Powered by Spatial Maths]
-(https://raw.githubusercontent.com/petercorke/spatialmath-python/
-master/.github/svg/sm_powered.min.svg)](https://github.com/petercorke/
-spatialmath-python) [![QUT Centre for Robotics Open Source](https://github.com/
-qcr/qcr.github.io/raw/master/misc/badge.svg)](https://qcr.github.io) [![PyPI
-version](https://badge.fury.io/py/machinevision-toolbox-python.svg)](https://
-badge.fury.io/py/machinevision-toolbox-python) ![Python Version](https://
-img.shields.io/pypi/pyversions/machinevision-toolbox-python.svg) [![Powered by
-OpenCV](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-
-python/master/.github/svg/opencv_powered.svg)](https://opencv.org) [![Powered
-by Open3D](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-
-python/master/.github/svg/open3d_powered.svg)](https://open3d.org) [![License:
-MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://
-opensource.org/licenses/MIT) [![Build Status](https://github.com/petercorke/
-spatialmath-python/workflows/build/badge.svg?branch=master)](https://
-github.com/petercorke/machinevisiontoolbox-python/
-actions?query=workflow%3Abuild) [![Coverage](https://codecov.io/gh/petercorke/
-machinevision-toolbox-python/branch/master/graph/badge.svg)](https://
-codecov.io/gh/petercorke/machinevision-toolbox-python) [![Language grade:
-Python](https://img.shields.io/lgtm/grade/python/g/petercorke/machinevision-
-toolbox-python.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/
-petercorke/machinevision-toolbox-python/context:python) [![PyPI - Downloads]
+# Machine Vision Toolbox for Python [![A Python Robotics Package](https://
+raw.githubusercontent.com/petercorke/robotics-toolbox-python/master/.github/
+svg/py_collection.min.svg)](https://github.com/petercorke/robotics-toolbox-
+python) [![Powered by Spatial Maths](https://raw.githubusercontent.com/
+petercorke/spatialmath-python/master/.github/svg/sm_powered.min.svg)](https://
+github.com/petercorke/spatialmath-python) [![QUT Centre for Robotics Open
+Source](https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg)](https:
+//qcr.github.io) [![PyPI version](https://badge.fury.io/py/machinevision-
+toolbox-python.svg)](https://badge.fury.io/py/machinevision-toolbox-python) !
+[Python Version](https://img.shields.io/pypi/pyversions/machinevision-toolbox-
+python.svg) [![Powered by OpenCV](https://raw.githubusercontent.com/petercorke/
+machinevision-toolbox-python/master/.github/svg/opencv_powered.svg)](https://
+opencv.org) [![Powered by Open3D](https://raw.githubusercontent.com/petercorke/
+machinevision-toolbox-python/master/.github/svg/open3d_powered.svg)](https://
+open3d.org) [![License: MIT](https://img.shields.io/badge/License-MIT-
+yellow.svg)](https://opensource.org/licenses/MIT) [![Build Status](https://
+github.com/petercorke/machinevision-toolbox-python/workflows/Test-master/
+badge.svg?branch=master)](https://github.com/petercorke/machinevision-toolbox-
+python/actions?query=workflow%3Abuild) [![Coverage](https://codecov.io/gh/
+petercorke/machinevision-toolbox-python/branch/master/graph/badge.svg)](https:/
+/codecov.io/gh/petercorke/machinevision-toolbox-python) [![PyPI - Downloads]
 (https://img.shields.io/pypi/dw/machinevision-toolbox-python)](https://
 pypistats.org/packages/machinevision-toolbox-python)
 [https://github.com/petercorke/     A Python implementation of the Machine_Vision_Toolbox_for_MATLAB®
 machinevision-toolbox-python/raw/       * GitHub_repository
 master/figs/                            * Documentation
 VisionToolboxLogo_NoBackgnd@2x.png]     * Examples_and_details
                                         * Installation
@@ -66,37 +47,37 @@
 from float32 and the BGR color order. - it is has similarity to the Machine
 Vision Toolbox for MATLAB. # Getting going ## Using pip Install a snapshot from
 PyPI ``` % pip install machinevision-toolbox-python ``` ## From GitHub Install
 the current code base from GitHub and pip install a link to that cloned copy
 ``` % git clone https://github.com/petercorke/machinevision-toolbox-python.git
 % cd machinevision-toolbox-python % pip install -e . ``` # Examples ### Reading
 and display an image ```python from machinevisiontoolbox import Image mona =
-Image.Read("monalisa.png") mona.disp() mona.smooth(sigma=5).disp() ``` ![Mona
-Lisa image](https://github.com/petercorke/machinevision-toolbox-python/raw/
-master/figs/mona.png) Images can also be returned by iterators that operate
-over folders, zip files, local cameras, web cameras and video files. ### Simple
-image processing The toolbox supports many operations on images such as 2D
-filtering, edge detection, mathematical morphology, colorspace conversion,
-padding, cropping, resizing, rotation and warping. ```python mona.smooth
-(sigma=5).disp() ``` ![Mona Lisa image with smoothing](https://github.com/
-petercorke/machinevision-toolbox-python/raw/master/figs/mona_smooth.png) There
-are also many functions that operate on pairs of image. All the arithmetic
-operators are overloaded, and there are methods to combine images in more
-complex ways. Multiple images can be stacked horizontal, vertically or tiled in
-a 2D grid. For example, we could display the original and smoothed images side
-by side ```python Image.Hstack([mona, mona.smooth(sigma=5)]).disp() ``` where
-`Hstack` is a class method that creates a new image by stacking the images from
-its argument, an image sequence, horizontally. ![Mona Lisa image with
-smoothing](https://github.com/petercorke/machinevision-toolbox-python/raw/
-master/figs/mona+smooth.png) ### Binary blobs A common problem in robotic
-vision is to extract features from the image, to describe the position, size,
-shape and orientation of objects in the scene. For simple binary scenes blob
-features are commonly used. ```python im = Image.Read("shark2.png") # read a
-binary image of two sharks im.disp(); # display it with interactive viewing
-tool blobs = im.blobs() # find all the white blobs print(blobs)
+Image.Read("monalisa.png") mona.disp() ``` ![Mona Lisa image](https://
+github.com/petercorke/machinevision-toolbox-python/raw/master/figs/mona.png)
+Images can also be returned by iterators that operate over folders, zip files,
+local cameras, web cameras and video files. ### Simple image processing The
+toolbox supports many operations on images such as 2D filtering, edge
+detection, mathematical morphology, colorspace conversion, padding, cropping,
+resizing, rotation and warping. ```python mona.smooth(sigma=5).disp() ``` !
+[Mona Lisa image with smoothing](https://github.com/petercorke/machinevision-
+toolbox-python/raw/master/figs/mona_smooth.png) There are also many functions
+that operate on pairs of image. All the arithmetic operators are overloaded,
+and there are methods to combine images in more complex ways. Multiple images
+can be stacked horizontal, vertically or tiled in a 2D grid. For example, we
+could display the original and smoothed images side by side ```python
+Image.Hstack([mona, mona.smooth(sigma=5)]).disp() ``` where `Hstack` is a class
+method that creates a new image by stacking the images from its argument, an
+image sequence, horizontally. ![Mona Lisa image with smoothing](https://
+github.com/petercorke/machinevision-toolbox-python/raw/master/figs/
+mona+smooth.png) ### Binary blobs A common problem in robotic vision is to
+extract features from the image, to describe the position, size, shape and
+orientation of objects in the scene. For simple binary scenes blob features are
+commonly used. ```python im = Image.Read("shark2.png") # read a binary image of
+two sharks im.disp(); # display it with interactive viewing tool blobs =
+im.blobs() # find all the white blobs print(blobs)
 âââââ¬âââââââââ¬âââââââââââââââ¬âââââââââââ¬ââââââââ¬ââââââââ¬ââââââââââââââ¬âââââââââ¬âââââââââ
 âid â parent â centroid â area â touch â perim â circularity â
 orient â aspect â
 âââââ¼âââââââââ¼âââââââââââââââ¼âââââââââââ¼ââââââââ¼ââââââââ¼ââââââââââââââ¼âââââââââ¼âââââââââ¤
 â 0 â -1 â 371.2, 355.2 â 7.59e+03 â False â 557.6 â 0.341 â
 82.9Â° â 0.976 â â 1 â -1 â 171.2, 155.2 â 7.59e+03 â False â
 557.6 â 0.341 â 82.9Â° â 0.976 â
```

### Comparing `machinevision-toolbox-python-0.9.4/README.md` & `machinevision-toolbox-python-0.9.6/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,47 @@
+Metadata-Version: 2.1
+Name: machinevision-toolbox-python
+Version: 0.9.6
+Summary: Python tools for machine vision - education and research
+Author: Dorian Tsai
+Author-email: Peter Corke <rvc@petercorke.com>
+Project-URL: Homepage, https://github.com/petercorke/machinevision-toolbox-python
+Project-URL: Bug Tracker, https://github.com/pypa/sampleproject/issues
+Project-URL: Documentation, https://petercorke.github.io/machinevision-toolbox-python
+Project-URL: Source, https://github.com/petercorke/machinevision-toolbox-python
+Keywords: machine vision,computer vision,multiview geometry,stereo vision,bundle adjustment,visual servoing,image features,color,blobs,morphology,image segmentation,opencv,open3d
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Developers
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.7
+Description-Content-Type: text/markdown
+Provides-Extra: dev
+Provides-Extra: docs
+License-File: LICENSE
+
 # Machine Vision Toolbox for Python
 
 [![A Python Robotics Package](https://raw.githubusercontent.com/petercorke/robotics-toolbox-python/master/.github/svg/py_collection.min.svg)](https://github.com/petercorke/robotics-toolbox-python)
 [![Powered by Spatial Maths](https://raw.githubusercontent.com/petercorke/spatialmath-python/master/.github/svg/sm_powered.min.svg)](https://github.com/petercorke/spatialmath-python)
 [![QUT Centre for Robotics Open Source](https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg)](https://qcr.github.io)
 
 [![PyPI version](https://badge.fury.io/py/machinevision-toolbox-python.svg)](https://badge.fury.io/py/machinevision-toolbox-python)
 ![Python Version](https://img.shields.io/pypi/pyversions/machinevision-toolbox-python.svg)
 [![Powered by OpenCV](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-python/master/.github/svg/opencv_powered.svg)](https://opencv.org)
 [![Powered by Open3D](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-python/master/.github/svg/open3d_powered.svg)](https://open3d.org)
 [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
 
-[![Build Status](https://github.com/petercorke/spatialmath-python/workflows/build/badge.svg?branch=master)](https://github.com/petercorke/machinevisiontoolbox-python/actions?query=workflow%3Abuild)
+[![Build Status](https://github.com/petercorke/machinevision-toolbox-python/workflows/Test-master/badge.svg?branch=master)](https://github.com/petercorke/machinevision-toolbox-python/actions?query=workflow%3Abuild)
 [![Coverage](https://codecov.io/gh/petercorke/machinevision-toolbox-python/branch/master/graph/badge.svg)](https://codecov.io/gh/petercorke/machinevision-toolbox-python)
-[![Language grade: Python](https://img.shields.io/lgtm/grade/python/g/petercorke/machinevision-toolbox-python.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/petercorke/machinevision-toolbox-python/context:python)
 [![PyPI - Downloads](https://img.shields.io/pypi/dw/machinevision-toolbox-python)](https://pypistats.org/packages/machinevision-toolbox-python)
 
 <!-- [![GitHub stars](https://img.shields.io/github/stars/petercorke/machinevision-toolbox-python.svg?style=social&label=Star)](https://GitHub.com/petercorke/machinevision-toolbox-python/stargazers/) -->
 
 <table style="border:0px">
 <tr style="border:0px">
 <td style="border:0px">
@@ -78,15 +103,14 @@
 
 ### Reading and display an image
 
 ```python
 from machinevisiontoolbox import Image
 mona = Image.Read("monalisa.png")
 mona.disp()
-mona.smooth(sigma=5).disp()
 ```
 
 ![Mona Lisa image](https://github.com/petercorke/machinevision-toolbox-python/raw/master/figs/mona.png)
 
 Images can also be returned by iterators that operate over folders, zip files, local cameras, web cameras and video files.
 
 ### Simple image processing
```

#### html2text {}

```diff
@@ -1,31 +1,46 @@
-# Machine Vision Toolbox for Python [![A Python Robotics Package](https://
-raw.githubusercontent.com/petercorke/robotics-toolbox-python/master/.github/
-svg/py_collection.min.svg)](https://github.com/petercorke/robotics-toolbox-
-python) [![Powered by Spatial Maths](https://raw.githubusercontent.com/
-petercorke/spatialmath-python/master/.github/svg/sm_powered.min.svg)](https://
-github.com/petercorke/spatialmath-python) [![QUT Centre for Robotics Open
-Source](https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg)](https:
-//qcr.github.io) [![PyPI version](https://badge.fury.io/py/machinevision-
-toolbox-python.svg)](https://badge.fury.io/py/machinevision-toolbox-python) !
-[Python Version](https://img.shields.io/pypi/pyversions/machinevision-toolbox-
-python.svg) [![Powered by OpenCV](https://raw.githubusercontent.com/petercorke/
-machinevision-toolbox-python/master/.github/svg/opencv_powered.svg)](https://
-opencv.org) [![Powered by Open3D](https://raw.githubusercontent.com/petercorke/
-machinevision-toolbox-python/master/.github/svg/open3d_powered.svg)](https://
-open3d.org) [![License: MIT](https://img.shields.io/badge/License-MIT-
-yellow.svg)](https://opensource.org/licenses/MIT) [![Build Status](https://
-github.com/petercorke/spatialmath-python/workflows/build/
-badge.svg?branch=master)](https://github.com/petercorke/machinevisiontoolbox-
-python/actions?query=workflow%3Abuild) [![Coverage](https://codecov.io/gh/
-petercorke/machinevision-toolbox-python/branch/master/graph/badge.svg)](https:/
-/codecov.io/gh/petercorke/machinevision-toolbox-python) [![Language grade:
-Python](https://img.shields.io/lgtm/grade/python/g/petercorke/machinevision-
-toolbox-python.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/
-petercorke/machinevision-toolbox-python/context:python) [![PyPI - Downloads]
+Metadata-Version: 2.1 Name: machinevision-toolbox-python Version: 0.9.6
+Summary: Python tools for machine vision - education and research Author:
+Dorian Tsai Author-email: Peter Corke
+petercorke.com> Project-URL: Homepage, https://github.com/petercorke/
+machinevision-toolbox-python Project-URL: Bug Tracker, https://github.com/pypa/
+sampleproject/issues Project-URL: Documentation, https://petercorke.github.io/
+machinevision-toolbox-python Project-URL: Source, https://github.com/
+petercorke/machinevision-toolbox-python Keywords: machine vision,computer
+vision,multiview geometry,stereo vision,bundle adjustment,visual servoing,image
+features,color,blobs,morphology,image segmentation,opencv,open3d Classifier:
+Development Status :: 5 - Production/Stable Classifier: Intended Audience ::
+Developers Classifier: Programming Language :: Python :: 3.7 Classifier:
+Programming Language :: Python :: 3.8 Classifier: Programming Language ::
+Python :: 3.9 Classifier: Programming Language :: Python :: 3.10 Classifier:
+Programming Language :: Python :: 3.11 Classifier: License :: OSI Approved ::
+MIT License Classifier: Operating System :: OS Independent Requires-Python:
+>=3.7 Description-Content-Type: text/markdown Provides-Extra: dev Provides-
+Extra: docs License-File: LICENSE # Machine Vision Toolbox for Python [![A
+Python Robotics Package](https://raw.githubusercontent.com/petercorke/robotics-
+toolbox-python/master/.github/svg/py_collection.min.svg)](https://github.com/
+petercorke/robotics-toolbox-python) [![Powered by Spatial Maths](https://
+raw.githubusercontent.com/petercorke/spatialmath-python/master/.github/svg/
+sm_powered.min.svg)](https://github.com/petercorke/spatialmath-python) [![QUT
+Centre for Robotics Open Source](https://github.com/qcr/qcr.github.io/raw/
+master/misc/badge.svg)](https://qcr.github.io) [![PyPI version](https://
+badge.fury.io/py/machinevision-toolbox-python.svg)](https://badge.fury.io/py/
+machinevision-toolbox-python) ![Python Version](https://img.shields.io/pypi/
+pyversions/machinevision-toolbox-python.svg) [![Powered by OpenCV](https://
+raw.githubusercontent.com/petercorke/machinevision-toolbox-python/
+master/.github/svg/opencv_powered.svg)](https://opencv.org) [![Powered by
+Open3D](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-
+python/master/.github/svg/open3d_powered.svg)](https://open3d.org) [![License:
+MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://
+opensource.org/licenses/MIT) [![Build Status](https://github.com/petercorke/
+machinevision-toolbox-python/workflows/Test-master/badge.svg?branch=master)]
+(https://github.com/petercorke/machinevision-toolbox-python/
+actions?query=workflow%3Abuild) [![Coverage](https://codecov.io/gh/petercorke/
+machinevision-toolbox-python/branch/master/graph/badge.svg)](https://
+codecov.io/gh/petercorke/machinevision-toolbox-python) [![PyPI - Downloads]
 (https://img.shields.io/pypi/dw/machinevision-toolbox-python)](https://
 pypistats.org/packages/machinevision-toolbox-python)
 [https://github.com/petercorke/     A Python implementation of the Machine_Vision_Toolbox_for_MATLAB®
 machinevision-toolbox-python/raw/       * GitHub_repository
 master/figs/                            * Documentation
 VisionToolboxLogo_NoBackgnd@2x.png]     * Examples_and_details
                                         * Installation
@@ -50,37 +65,37 @@
 from float32 and the BGR color order. - it is has similarity to the Machine
 Vision Toolbox for MATLAB. # Getting going ## Using pip Install a snapshot from
 PyPI ``` % pip install machinevision-toolbox-python ``` ## From GitHub Install
 the current code base from GitHub and pip install a link to that cloned copy
 ``` % git clone https://github.com/petercorke/machinevision-toolbox-python.git
 % cd machinevision-toolbox-python % pip install -e . ``` # Examples ### Reading
 and display an image ```python from machinevisiontoolbox import Image mona =
-Image.Read("monalisa.png") mona.disp() mona.smooth(sigma=5).disp() ``` ![Mona
-Lisa image](https://github.com/petercorke/machinevision-toolbox-python/raw/
-master/figs/mona.png) Images can also be returned by iterators that operate
-over folders, zip files, local cameras, web cameras and video files. ### Simple
-image processing The toolbox supports many operations on images such as 2D
-filtering, edge detection, mathematical morphology, colorspace conversion,
-padding, cropping, resizing, rotation and warping. ```python mona.smooth
-(sigma=5).disp() ``` ![Mona Lisa image with smoothing](https://github.com/
-petercorke/machinevision-toolbox-python/raw/master/figs/mona_smooth.png) There
-are also many functions that operate on pairs of image. All the arithmetic
-operators are overloaded, and there are methods to combine images in more
-complex ways. Multiple images can be stacked horizontal, vertically or tiled in
-a 2D grid. For example, we could display the original and smoothed images side
-by side ```python Image.Hstack([mona, mona.smooth(sigma=5)]).disp() ``` where
-`Hstack` is a class method that creates a new image by stacking the images from
-its argument, an image sequence, horizontally. ![Mona Lisa image with
-smoothing](https://github.com/petercorke/machinevision-toolbox-python/raw/
-master/figs/mona+smooth.png) ### Binary blobs A common problem in robotic
-vision is to extract features from the image, to describe the position, size,
-shape and orientation of objects in the scene. For simple binary scenes blob
-features are commonly used. ```python im = Image.Read("shark2.png") # read a
-binary image of two sharks im.disp(); # display it with interactive viewing
-tool blobs = im.blobs() # find all the white blobs print(blobs)
+Image.Read("monalisa.png") mona.disp() ``` ![Mona Lisa image](https://
+github.com/petercorke/machinevision-toolbox-python/raw/master/figs/mona.png)
+Images can also be returned by iterators that operate over folders, zip files,
+local cameras, web cameras and video files. ### Simple image processing The
+toolbox supports many operations on images such as 2D filtering, edge
+detection, mathematical morphology, colorspace conversion, padding, cropping,
+resizing, rotation and warping. ```python mona.smooth(sigma=5).disp() ``` !
+[Mona Lisa image with smoothing](https://github.com/petercorke/machinevision-
+toolbox-python/raw/master/figs/mona_smooth.png) There are also many functions
+that operate on pairs of image. All the arithmetic operators are overloaded,
+and there are methods to combine images in more complex ways. Multiple images
+can be stacked horizontal, vertically or tiled in a 2D grid. For example, we
+could display the original and smoothed images side by side ```python
+Image.Hstack([mona, mona.smooth(sigma=5)]).disp() ``` where `Hstack` is a class
+method that creates a new image by stacking the images from its argument, an
+image sequence, horizontally. ![Mona Lisa image with smoothing](https://
+github.com/petercorke/machinevision-toolbox-python/raw/master/figs/
+mona+smooth.png) ### Binary blobs A common problem in robotic vision is to
+extract features from the image, to describe the position, size, shape and
+orientation of objects in the scene. For simple binary scenes blob features are
+commonly used. ```python im = Image.Read("shark2.png") # read a binary image of
+two sharks im.disp(); # display it with interactive viewing tool blobs =
+im.blobs() # find all the white blobs print(blobs)
 âââââ¬âââââââââ¬âââââââââââââââ¬âââââââââââ¬ââââââââ¬ââââââââ¬ââââââââââââââ¬âââââââââ¬âââââââââ
 âid â parent â centroid â area â touch â perim â circularity â
 orient â aspect â
 âââââ¼âââââââââ¼âââââââââââââââ¼âââââââââââ¼ââââââââ¼ââââââââ¼ââââââââââââââ¼âââââââââ¼âââââââââ¤
 â 0 â -1 â 371.2, 355.2 â 7.59e+03 â False â 557.6 â 0.341 â
 82.9Â° â 0.976 â â 1 â -1 â 171.2, 155.2 â 7.59e+03 â False â
 557.6 â 0.341 â 82.9Â° â 0.976 â
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/PKG-INFO` & `machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/PKG-INFO`

 * *Files 6% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 Metadata-Version: 2.1
 Name: machinevision-toolbox-python
-Version: 0.9.4
-Summary: A machine vision for education and research
-Home-page: https://github.com/petercorke/machinevision-toolbox-python
-Author: Peter Corke and Dorian Tsai
-License: MIT
+Version: 0.9.6
+Summary: Python tools for machine vision - education and research
+Author: Dorian Tsai
+Author-email: Peter Corke <rvc@petercorke.com>
+Project-URL: Homepage, https://github.com/petercorke/machinevision-toolbox-python
+Project-URL: Bug Tracker, https://github.com/pypa/sampleproject/issues
 Project-URL: Documentation, https://petercorke.github.io/machinevision-toolbox-python
 Project-URL: Source, https://github.com/petercorke/machinevision-toolbox-python
-Project-URL: Tracker, https://github.com/petercorke/machinevision-toolbox-python/issues
-Project-URL: Coverage, https://codecov.io/gh/petercorke/machinevision-toolbox-python
-Keywords: python machine-vision computer-vision multiview-geometry features color blobs
+Keywords: machine vision,computer vision,multiview geometry,stereo vision,bundle adjustment,visual servoing,image features,color,blobs,morphology,image segmentation,opencv,open3d
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: OS Independent
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
-Provides-Extra: docs
 Provides-Extra: dev
+Provides-Extra: docs
 License-File: LICENSE
 
 # Machine Vision Toolbox for Python
 
 [![A Python Robotics Package](https://raw.githubusercontent.com/petercorke/robotics-toolbox-python/master/.github/svg/py_collection.min.svg)](https://github.com/petercorke/robotics-toolbox-python)
 [![Powered by Spatial Maths](https://raw.githubusercontent.com/petercorke/spatialmath-python/master/.github/svg/sm_powered.min.svg)](https://github.com/petercorke/spatialmath-python)
 [![QUT Centre for Robotics Open Source](https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg)](https://qcr.github.io)
 
 [![PyPI version](https://badge.fury.io/py/machinevision-toolbox-python.svg)](https://badge.fury.io/py/machinevision-toolbox-python)
 ![Python Version](https://img.shields.io/pypi/pyversions/machinevision-toolbox-python.svg)
 [![Powered by OpenCV](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-python/master/.github/svg/opencv_powered.svg)](https://opencv.org)
 [![Powered by Open3D](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-python/master/.github/svg/open3d_powered.svg)](https://open3d.org)
 [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
 
-[![Build Status](https://github.com/petercorke/spatialmath-python/workflows/build/badge.svg?branch=master)](https://github.com/petercorke/machinevisiontoolbox-python/actions?query=workflow%3Abuild)
+[![Build Status](https://github.com/petercorke/machinevision-toolbox-python/workflows/Test-master/badge.svg?branch=master)](https://github.com/petercorke/machinevision-toolbox-python/actions?query=workflow%3Abuild)
 [![Coverage](https://codecov.io/gh/petercorke/machinevision-toolbox-python/branch/master/graph/badge.svg)](https://codecov.io/gh/petercorke/machinevision-toolbox-python)
-[![Language grade: Python](https://img.shields.io/lgtm/grade/python/g/petercorke/machinevision-toolbox-python.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/petercorke/machinevision-toolbox-python/context:python)
 [![PyPI - Downloads](https://img.shields.io/pypi/dw/machinevision-toolbox-python)](https://pypistats.org/packages/machinevision-toolbox-python)
 
 <!-- [![GitHub stars](https://img.shields.io/github/stars/petercorke/machinevision-toolbox-python.svg?style=social&label=Star)](https://GitHub.com/petercorke/machinevision-toolbox-python/stargazers/) -->
 
 <table style="border:0px">
 <tr style="border:0px">
 <td style="border:0px">
@@ -103,15 +103,14 @@
 
 ### Reading and display an image
 
 ```python
 from machinevisiontoolbox import Image
 mona = Image.Read("monalisa.png")
 mona.disp()
-mona.smooth(sigma=5).disp()
 ```
 
 ![Mona Lisa image](https://github.com/petercorke/machinevision-toolbox-python/raw/master/figs/mona.png)
 
 Images can also be returned by iterators that operate over folders, zip files, local cameras, web cameras and video files.
 
 ### Simple image processing
```

#### html2text {}

```diff
@@ -1,47 +1,46 @@
-Metadata-Version: 2.1 Name: machinevision-toolbox-python Version: 0.9.4
-Summary: A machine vision for education and research Home-page: https://
-github.com/petercorke/machinevision-toolbox-python Author: Peter Corke and
-Dorian Tsai License: MIT Project-URL: Documentation, https://
-petercorke.github.io/machinevision-toolbox-python Project-URL: Source, https://
-github.com/petercorke/machinevision-toolbox-python Project-URL: Tracker, https:
-//github.com/petercorke/machinevision-toolbox-python/issues Project-URL:
-Coverage, https://codecov.io/gh/petercorke/machinevision-toolbox-python
-Keywords: python machine-vision computer-vision multiview-geometry features
-color blobs Classifier: Development Status :: 5 - Production/Stable Classifier:
-Intended Audience :: Developers Classifier: License :: OSI Approved :: MIT
-License Classifier: Programming Language :: Python :: 3.7 Classifier:
+Metadata-Version: 2.1 Name: machinevision-toolbox-python Version: 0.9.6
+Summary: Python tools for machine vision - education and research Author:
+Dorian Tsai Author-email: Peter Corke
+petercorke.com> Project-URL: Homepage, https://github.com/petercorke/
+machinevision-toolbox-python Project-URL: Bug Tracker, https://github.com/pypa/
+sampleproject/issues Project-URL: Documentation, https://petercorke.github.io/
+machinevision-toolbox-python Project-URL: Source, https://github.com/
+petercorke/machinevision-toolbox-python Keywords: machine vision,computer
+vision,multiview geometry,stereo vision,bundle adjustment,visual servoing,image
+features,color,blobs,morphology,image segmentation,opencv,open3d Classifier:
+Development Status :: 5 - Production/Stable Classifier: Intended Audience ::
+Developers Classifier: Programming Language :: Python :: 3.7 Classifier:
 Programming Language :: Python :: 3.8 Classifier: Programming Language ::
-Python :: 3.9 Classifier: Programming Language :: Python :: 3.10 Requires-
-Python: >=3.7 Description-Content-Type: text/markdown Provides-Extra: docs
-Provides-Extra: dev License-File: LICENSE # Machine Vision Toolbox for Python
-[![A Python Robotics Package](https://raw.githubusercontent.com/petercorke/
-robotics-toolbox-python/master/.github/svg/py_collection.min.svg)](https://
-github.com/petercorke/robotics-toolbox-python) [![Powered by Spatial Maths]
-(https://raw.githubusercontent.com/petercorke/spatialmath-python/
-master/.github/svg/sm_powered.min.svg)](https://github.com/petercorke/
-spatialmath-python) [![QUT Centre for Robotics Open Source](https://github.com/
-qcr/qcr.github.io/raw/master/misc/badge.svg)](https://qcr.github.io) [![PyPI
-version](https://badge.fury.io/py/machinevision-toolbox-python.svg)](https://
-badge.fury.io/py/machinevision-toolbox-python) ![Python Version](https://
-img.shields.io/pypi/pyversions/machinevision-toolbox-python.svg) [![Powered by
-OpenCV](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-
-python/master/.github/svg/opencv_powered.svg)](https://opencv.org) [![Powered
-by Open3D](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-
+Python :: 3.9 Classifier: Programming Language :: Python :: 3.10 Classifier:
+Programming Language :: Python :: 3.11 Classifier: License :: OSI Approved ::
+MIT License Classifier: Operating System :: OS Independent Requires-Python:
+>=3.7 Description-Content-Type: text/markdown Provides-Extra: dev Provides-
+Extra: docs License-File: LICENSE # Machine Vision Toolbox for Python [![A
+Python Robotics Package](https://raw.githubusercontent.com/petercorke/robotics-
+toolbox-python/master/.github/svg/py_collection.min.svg)](https://github.com/
+petercorke/robotics-toolbox-python) [![Powered by Spatial Maths](https://
+raw.githubusercontent.com/petercorke/spatialmath-python/master/.github/svg/
+sm_powered.min.svg)](https://github.com/petercorke/spatialmath-python) [![QUT
+Centre for Robotics Open Source](https://github.com/qcr/qcr.github.io/raw/
+master/misc/badge.svg)](https://qcr.github.io) [![PyPI version](https://
+badge.fury.io/py/machinevision-toolbox-python.svg)](https://badge.fury.io/py/
+machinevision-toolbox-python) ![Python Version](https://img.shields.io/pypi/
+pyversions/machinevision-toolbox-python.svg) [![Powered by OpenCV](https://
+raw.githubusercontent.com/petercorke/machinevision-toolbox-python/
+master/.github/svg/opencv_powered.svg)](https://opencv.org) [![Powered by
+Open3D](https://raw.githubusercontent.com/petercorke/machinevision-toolbox-
 python/master/.github/svg/open3d_powered.svg)](https://open3d.org) [![License:
 MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://
 opensource.org/licenses/MIT) [![Build Status](https://github.com/petercorke/
-spatialmath-python/workflows/build/badge.svg?branch=master)](https://
-github.com/petercorke/machinevisiontoolbox-python/
+machinevision-toolbox-python/workflows/Test-master/badge.svg?branch=master)]
+(https://github.com/petercorke/machinevision-toolbox-python/
 actions?query=workflow%3Abuild) [![Coverage](https://codecov.io/gh/petercorke/
 machinevision-toolbox-python/branch/master/graph/badge.svg)](https://
-codecov.io/gh/petercorke/machinevision-toolbox-python) [![Language grade:
-Python](https://img.shields.io/lgtm/grade/python/g/petercorke/machinevision-
-toolbox-python.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/
-petercorke/machinevision-toolbox-python/context:python) [![PyPI - Downloads]
+codecov.io/gh/petercorke/machinevision-toolbox-python) [![PyPI - Downloads]
 (https://img.shields.io/pypi/dw/machinevision-toolbox-python)](https://
 pypistats.org/packages/machinevision-toolbox-python)
 [https://github.com/petercorke/     A Python implementation of the Machine_Vision_Toolbox_for_MATLAB®
 machinevision-toolbox-python/raw/       * GitHub_repository
 master/figs/                            * Documentation
 VisionToolboxLogo_NoBackgnd@2x.png]     * Examples_and_details
                                         * Installation
@@ -66,37 +65,37 @@
 from float32 and the BGR color order. - it is has similarity to the Machine
 Vision Toolbox for MATLAB. # Getting going ## Using pip Install a snapshot from
 PyPI ``` % pip install machinevision-toolbox-python ``` ## From GitHub Install
 the current code base from GitHub and pip install a link to that cloned copy
 ``` % git clone https://github.com/petercorke/machinevision-toolbox-python.git
 % cd machinevision-toolbox-python % pip install -e . ``` # Examples ### Reading
 and display an image ```python from machinevisiontoolbox import Image mona =
-Image.Read("monalisa.png") mona.disp() mona.smooth(sigma=5).disp() ``` ![Mona
-Lisa image](https://github.com/petercorke/machinevision-toolbox-python/raw/
-master/figs/mona.png) Images can also be returned by iterators that operate
-over folders, zip files, local cameras, web cameras and video files. ### Simple
-image processing The toolbox supports many operations on images such as 2D
-filtering, edge detection, mathematical morphology, colorspace conversion,
-padding, cropping, resizing, rotation and warping. ```python mona.smooth
-(sigma=5).disp() ``` ![Mona Lisa image with smoothing](https://github.com/
-petercorke/machinevision-toolbox-python/raw/master/figs/mona_smooth.png) There
-are also many functions that operate on pairs of image. All the arithmetic
-operators are overloaded, and there are methods to combine images in more
-complex ways. Multiple images can be stacked horizontal, vertically or tiled in
-a 2D grid. For example, we could display the original and smoothed images side
-by side ```python Image.Hstack([mona, mona.smooth(sigma=5)]).disp() ``` where
-`Hstack` is a class method that creates a new image by stacking the images from
-its argument, an image sequence, horizontally. ![Mona Lisa image with
-smoothing](https://github.com/petercorke/machinevision-toolbox-python/raw/
-master/figs/mona+smooth.png) ### Binary blobs A common problem in robotic
-vision is to extract features from the image, to describe the position, size,
-shape and orientation of objects in the scene. For simple binary scenes blob
-features are commonly used. ```python im = Image.Read("shark2.png") # read a
-binary image of two sharks im.disp(); # display it with interactive viewing
-tool blobs = im.blobs() # find all the white blobs print(blobs)
+Image.Read("monalisa.png") mona.disp() ``` ![Mona Lisa image](https://
+github.com/petercorke/machinevision-toolbox-python/raw/master/figs/mona.png)
+Images can also be returned by iterators that operate over folders, zip files,
+local cameras, web cameras and video files. ### Simple image processing The
+toolbox supports many operations on images such as 2D filtering, edge
+detection, mathematical morphology, colorspace conversion, padding, cropping,
+resizing, rotation and warping. ```python mona.smooth(sigma=5).disp() ``` !
+[Mona Lisa image with smoothing](https://github.com/petercorke/machinevision-
+toolbox-python/raw/master/figs/mona_smooth.png) There are also many functions
+that operate on pairs of image. All the arithmetic operators are overloaded,
+and there are methods to combine images in more complex ways. Multiple images
+can be stacked horizontal, vertically or tiled in a 2D grid. For example, we
+could display the original and smoothed images side by side ```python
+Image.Hstack([mona, mona.smooth(sigma=5)]).disp() ``` where `Hstack` is a class
+method that creates a new image by stacking the images from its argument, an
+image sequence, horizontally. ![Mona Lisa image with smoothing](https://
+github.com/petercorke/machinevision-toolbox-python/raw/master/figs/
+mona+smooth.png) ### Binary blobs A common problem in robotic vision is to
+extract features from the image, to describe the position, size, shape and
+orientation of objects in the scene. For simple binary scenes blob features are
+commonly used. ```python im = Image.Read("shark2.png") # read a binary image of
+two sharks im.disp(); # display it with interactive viewing tool blobs =
+im.blobs() # find all the white blobs print(blobs)
 âââââ¬âââââââââ¬âââââââââââââââ¬âââââââââââ¬ââââââââ¬ââââââââ¬ââââââââââââââ¬âââââââââ¬âââââââââ
 âid â parent â centroid â area â touch â perim â circularity â
 orient â aspect â
 âââââ¼âââââââââ¼âââââââââââââââ¼âââââââââââ¼ââââââââ¼ââââââââ¼ââââââââââââââ¼âââââââââ¼âââââââââ¤
 â 0 â -1 â 371.2, 355.2 â 7.59e+03 â False â 557.6 â 0.341 â
 82.9Â° â 0.976 â â 1 â -1 â 171.2, 155.2 â 7.59e+03 â False â
 557.6 â 0.341 â 82.9Â° â 0.976 â
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevision_toolbox_python.egg-info/SOURCES.txt` & `machinevision-toolbox-python-0.9.6/machinevision_toolbox_python.egg-info/SOURCES.txt`

 * *Files 27% similar despite different names*

```diff
@@ -1,11 +1,10 @@
 LICENSE
 README.md
-RELEASE
-setup.py
+pyproject.toml
 machinevision_toolbox_python.egg-info/PKG-INFO
 machinevision_toolbox_python.egg-info/SOURCES.txt
 machinevision_toolbox_python.egg-info/dependency_links.txt
 machinevision_toolbox_python.egg-info/requires.txt
 machinevision_toolbox_python.egg-info/top_level.txt
 machinevisiontoolbox/BagOfWords.py
 machinevisiontoolbox/BundleAdjust.py
@@ -34,15 +33,21 @@
 machinevisiontoolbox/base/__init__.py
 machinevisiontoolbox/base/color.py
 machinevisiontoolbox/base/data.py
 machinevisiontoolbox/base/esttheta.py
 machinevisiontoolbox/base/findpeaks.py
 machinevisiontoolbox/base/graphics.py
 machinevisiontoolbox/base/imageio.py
-machinevisiontoolbox/base/io.py
 machinevisiontoolbox/base/meshgrid.py
 machinevisiontoolbox/base/shapes.py
 machinevisiontoolbox/base/types.py
 machinevisiontoolbox/blocks/__init__.py
-machinevisiontoolbox/blocks/aside_test_blocks.py
 machinevisiontoolbox/blocks/camera.py
-machinevisiontoolbox/blocks/tex2icon.py
+machinevisiontoolbox/blocks/test_blocks.py
+tests/test_base_color.py
+tests/test_camera.py
+tests/test_color.py
+tests/test_core.py
+tests/test_image_io.py
+tests/test_imageprocessing_kernel.py
+tests/test_imageprocessing_morph.py
+tests/test_processing.py
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/BagOfWords.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/BagOfWords.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,31 +3,30 @@
 from collections import Counter
 from machinevisiontoolbox.ImagePointFeatures import BaseFeature2D
 import numpy as np
 import cv2 as cv
 
 # TODO: remove top N% and bottom M% of words by frequency
 class BagOfWords:
-
     def __init__(self, images, k=2_000, nstopwords=0, attempts=1, seed=None):
         r"""
         Bag of words class
 
         :param images: a sequence of images or set of image features
         :type images: :class:`~machinevisiontoolbox.Image` iterable, :class:`~machinevisiontoolbox.PointFeatures.BaseFeature2D`
         :param k: number of visual words, defaults to 2000
         :type k: int, optional
         :param nstopwords: number of stop words, defaults to 50
         :type nstopwords: int, optional
         :param attempts: number of k-means attempts, defaults to 1
         :type attempts: int, optional
 
         Bag of words is a powerful feature-based method for matching images
-        from widely different viewpoints. 
-        
+        from widely different viewpoints.
+
         This class creates a bag of words from a sequence of images or a set of
         point features.  In the former case, the features will have an ``.id``
         equal to the index of the image in the sequence.  For the latter case,
         features must have a valid ``.id`` attribute indicating which image in
         the bag they belong to.
 
         k-means clustering is performed to assign a word label to every feature.
@@ -41,20 +40,20 @@
 
         Stop words are those visual words that occur most often and we can
         remove ``nstopwords`` of them. The centroids are reordered so that the
         last ``nstopwords`` rows correspond to the stop words.  When a new set
         of image features is assigned labels from the ``.centroids`` any with a
         label greater that ``.nstopwords`` is a stop word and can be discarded.
 
-        :reference: 
+        :reference:
             - Video Google: a text retrieval approach to object matching in videos
-              J.Sivic and A.Zisserman, 
-              in Proc. Ninth IEEE Int. Conf. on Computer Vision, 
+              J.Sivic and A.Zisserman,
+              in Proc. Ninth IEEE Int. Conf. on Computer Vision,
               pp.1470-1477, Oct. 2003.
-            - Robotics, Vision & Control for Python, Section 12.4.2, 
+            - Robotics, Vision & Control for Python, Section 12.4.2,
                 P. Corke, Springer 2023.
 
         :seealso: :meth:`recall` :meth:`~machinevisiontoolbox.ImagePointFeatures.BaseFeature2D`
             :meth:`~machinevisiontoolbox.ImagePointFeatures.SIFT`
             `cv2.kmeans <https://docs.opencv.org/master/d5/d38/group__core__cluster.html#ga9a34dc06c6ec9460e90860f15bcd2f88>`_
         """
 
@@ -69,34 +68,35 @@
             features = []
             for image in images:
                 features += image.SIFT()
         features.sort(by="scale", inplace=True)
 
         self._images = images
 
-        # save the image id's 
+        # save the image id's
         self._image_id = np.r_[features.id]
         self._nimages = self._image_id.max() + 1
         self._features = features
 
         # do the clustering
         # NO IDEA WHAT EPSILON ACTUALLY MEANS, NORM OF THE SHIFT IN CENTROIDS?
         # NO IDEA HOW TO TELL WHAT CRITERIA IT TERMINATES ON
         criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 10, 1.0)
 
         if seed is not None:
             cv.setRNGSeed(seed)
 
         ret, labels, centroids = cv.kmeans(
-                        data=features._descriptor, 
-                        K=k,
-                        bestLabels=None,
-                        criteria=criteria,
-                        attempts=attempts,
-                        flags=cv.KMEANS_RANDOM_CENTERS)
+            data=features._descriptor,
+            K=k,
+            bestLabels=None,
+            criteria=criteria,
+            attempts=attempts,
+            flags=cv.KMEANS_RANDOM_CENTERS,
+        )
 
         self._k = k
 
         self._words = labels.ravel()
         self._labels = labels.ravel()
         self._centroids = centroids
         self._word_freq_vectors = None
@@ -124,29 +124,29 @@
 
         # total number of occurences of word i
         # multiple occurences in the one image count only as one
         ni = (W > 0).sum(axis=1)
         idf = np.log(N / ni)
 
         M = []
-        
+
         for i in range(self.nimages):
             # number of words in this image
             nd = W[:, i].sum()
 
             # word occurrence frequency
             nid = W[:, i]
 
-            with np.errstate(divide='ignore', invalid='ignore'):
+            with np.errstate(divide="ignore", invalid="ignore"):
                 v = nid / nd * idf
 
             v[~np.isfinite(v)] = 0
             M.append(v)
 
-        self._word_freq_vectors =  np.column_stack(M)
+        self._word_freq_vectors = np.column_stack(M)
         self._idf = idf
 
     def wwfv(self, i=None):
         """
         Weighted word frequency vector for image
 
         :param i: image within bag, defaults to all images
@@ -294,15 +294,15 @@
 
     def __str__(self):
         s = f"BagOfWords: {len(self.words)} features from {self.nimages} images"
         s += f", {self.nwords} words, {self.nstopwords} stop words"
         return s
 
     def _remove_stopwords(self, verbose=True):
-        #BagOfWords.remove_stop Remove stop words
+        # BagOfWords.remove_stop Remove stop words
         #
         # B.remove_stop(N) removes the N most frequent words (the stop words)
         # from the self.  All remaining words are renumbered so that the word
         # labels are consecutive.
 
         # words, freq = self.wordfreq()
         # index = np.argsort(-freq)  # sort descending order
@@ -310,18 +310,20 @@
         # # top ``nstopwords`` most frequent are the stop words
         # stopwords = words[index[:self._nstopwords]]
 
         unique_words, freq = self.wordfreq()
 
         # unique_words will be [0,k)
         index = np.argsort(-freq)  # sort descending order
-        stopwords = unique_words[index[:self.nstopwords]]  # array of stop words
+        stopwords = unique_words[index[: self.nstopwords]]  # array of stop words
 
         stopfeatures = freq[stopwords].sum()
-        print(f"Removing {stopfeatures} features ({stopfeatures/len(self.words) * 100:.1f}%) associated with {self.nstopwords} most frequent words")
+        print(
+            f"Removing {stopfeatures} features ({stopfeatures/len(self.words) * 100:.1f}%) associated with {self.nstopwords} most frequent words"
+        )
 
         k = np.full(index.shape, False, dtype=bool)
         k[stopwords] = True
         # k = freq > stop_cut  # index of all the stop words
         # indices of all non-stop words, followed by all stop words
         map = np.hstack((unique_words[~k], unique_words[k]))
         # create a dictionary from old label to new label
@@ -330,15 +332,15 @@
         for w in unique_words:
             mapdict[map[w]] = w
 
         # map the word labels
         words = np.array([mapdict[w] for w in self.words])
 
         self._labels = words
-        
+
         # only retain the non stop words
         keep = words < self.nstopwords
         self._words = words[keep]
         self._image_id = self._image_id[keep]
         self._features = self._features[keep]
 
         # rearrange the cluster centroids
@@ -349,69 +351,73 @@
         Compute similarity between bag and query images
 
         :param other: bag of words
         :type other: BagOfWords
         :return: confusion matrix
         :rtype: ndarray(M,N)
 
-        The array has rows corresponding to the images in ``self`` and 
+        The array has rows corresponding to the images in ``self`` and
         columns corresponding to the images in ``other``.
 
         :seealso: :meth:`.closest`
         """
         if isinstance(arg, np.ndarray):
             wwfv = arg
             sim = np.empty((wwfv.shape[1], self.nimages))
-            
+
             for j, vj in enumerate(wwfv.T):
                 for i in range(self.nimages):
                     vi = self.wwfv(i)
 
-                    with np.errstate(divide='ignore', invalid='ignore'):
-                        sim[j, i] = np.dot(vi.ravel(), vj) / (np.linalg.norm(vi) * np.linalg.norm(vj))
+                    with np.errstate(divide="ignore", invalid="ignore"):
+                        sim[j, i] = np.dot(vi.ravel(), vj) / (
+                            np.linalg.norm(vi) * np.linalg.norm(vj)
+                        )
         else:
             images = arg
-            if not hasattr(images, '__iter__'):
+            if not hasattr(images, "__iter__"):
                 # if not iterable like a FileCollection or VideoFile turn the image
                 # into a list of 1
                 images = [images]
 
             # similarity has bag index as column, query index as row
             sim = np.empty((len(images), self.nimages))
             for j, image in enumerate(images):
-                features = image.SIFT(id='image')
+                features = image.SIFT(id="image")
 
                 # assign features to given cluster centroids
                 # the elements of matches are:
                 #  queryIdx: new feature index
                 #  trainingIdx: cluster centre index
                 bfm = cv.BFMatcher(cv.NORM_L2, crossCheck=False)
                 matches = bfm.match(features._descriptor, self._centroids)
                 words = np.array([m.trainIdx for m in matches])
 
                 keep = words < self.nstopwords
                 words = words[keep]
 
                 # word occurrence frequency
                 nid = BagOfWords._word_freq_vector(words, self.k - self.nstopwords)
-            
+
                 # number of words in this image
                 nd = nid.sum()
 
-                with np.errstate(divide='ignore', invalid='ignore'):
+                with np.errstate(divide="ignore", invalid="ignore"):
                     v2 = nid / nd * self._idf
 
                 v2[~np.isfinite(v2)] = 0
 
                 for i in range(self.nimages):
                     v1 = self.wwfv(i).ravel()
 
-                    with np.errstate(divide='ignore', invalid='ignore'):
-                        sim[j, i] = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
-        
+                    with np.errstate(divide="ignore", invalid="ignore"):
+                        sim[j, i] = np.dot(v1, v2) / (
+                            np.linalg.norm(v1) * np.linalg.norm(v2)
+                        )
+
         if sim.shape[0] == 1:
             sim = sim[0, :]
         return sim
 
     def retrieve(self, images):
 
         S = self.similarity(images).ravel()
@@ -460,15 +466,15 @@
         :return: visual words, visual word frequency
         :rtype: ndarray, ndarray
 
         Returns two arrays, one containing all visual words, the other containing
         the frequency of the corresponding word across all images.
         """
 
-        #BagOfWords.wordfreq Word frequency statistics
+        # BagOfWords.wordfreq Word frequency statistics
         #
         # [W,N] = B.wordfreq[] is a vector of word labels W and the corresponding
         # elements of N are the number of occurrences of that word.
         return np.unique(self.words, return_counts=True)
 
     def closest(self, S, i):
         """
@@ -481,54 +487,55 @@
         :return: index of the recalled image and similarity
         :rtype: int, float
 
         :seealso: :meth:`similarity`
         """
         s = S[:, i]
         index = np.argsort(-s)
-        
+
         return index, s[index]
 
     def contains(self, word):
         """
         Images that contain specified word
 
         :param word: visual word label
         :type word: int
         :return: list of images containing this word
         :rtype: list
 
         :seealso: :meth:`exemplars`
         """
         return np.unique(self._image_id[self.words == word])
-            
 
-    def exemplars(self, word, images=None, maxperimage=2, columns=10, max=None, width=50, **kwargs):
+    def exemplars(
+        self, word, images=None, maxperimage=2, columns=10, max=None, width=50, **kwargs
+    ):
         """
         Composite image containing exemplars of specified word
 
         :param word: visual word label
         :type word: int
-        :param images: the set of images corresponding to this bag, only 
+        :param images: the set of images corresponding to this bag, only
             required if the bag was constructed from features not images.
         :param maxperimage: maximum number of exemplars drawn from any one image, defaults to 2
         :type maxperimage: int, optional
         :param columns: number of exemplar images in each row, defaults to 10
         :type columns: int, optional
         :param max: maximum number of exemplar images, defaults to None
         :type max: int, optional
         :param width: width of image thumbnail, defaults to 50
         :type width: int, optional
         :return: composite image
         :rtype: :class:`~machinevisiontoolbox.Image`
 
         Produces a grid of examples of a particular visual word.
 
-        :seealso: :meth:`contains` 
-            :meth:`~machinevisiontoolbox.ImagePointFeatures.BaseFeature2D.support` 
+        :seealso: :meth:`contains`
+            :meth:`~machinevisiontoolbox.ImagePointFeatures.BaseFeature2D.support`
             :meth:`~machinevisiontoolbox.Image.Tile`
         """
         from machinevisiontoolbox import Image
 
         exemplars = []
         count = Counter()
         if images is None:
@@ -541,24 +548,25 @@
 
             exemplars.append(feature.support(images, width))
             if max is not None and len(exemplars) >= max:
                 break
 
         return Image.Tile(exemplars, columns=columns, **kwargs)
 
+
 if __name__ == "__main__":
 
     import numpy as np
     import matplotlib.pyplot as plt
     from machinevisiontoolbox import *
     import cv2 as cv
 
     cv.setRNGSeed(0)
 
-    images = ImageCollection('campus/*.png', mono=True)
+    images = ImageCollection("campus/*.png", mono=True)
 
     features = []
     for image in images:
         features += image.SIFT()
     # sort them in descending order by strength
     features.sort(by="scale", inplace=True)
 
@@ -566,15 +574,14 @@
 
     ex = []
     for i in range(400):
         ex.append(features[i].support(images))
 
     Image.Tile(ex, columns=20).disp(plain=True)
 
-
     feature = features[108]
     print(feature)
 
     bag = BagOfWords(features, 2_000)
 
     w = bag.word(108)
     print(w)
@@ -596,34 +603,30 @@
     print(bag.wwfv().shape)
 
     print(bag.similarity(bag.wwfv(3)))
     print(bag.similarity(images[:5]))
 
     sim_8 = bag.similarity(images[8]).ravel()
     print(sim_8)
-    k = np.argsort(-sim_8);
+    k = np.argsort(-sim_8)
     print(np.c_[sim_8[k], k])
 
     ss = []
     for i in range(4):
         ss.append(images[k[i]])
     Image.Tile(ss, columns=2).disp()
 
-    holdout = ImageCollection("campus/holdout/*.png", mono=True);
+    holdout = ImageCollection("campus/holdout/*.png", mono=True)
 
     sim = bag.similarity(holdout)
 
     sim_2 = bag.similarity(holdout[2]).ravel()
     print(sim_2)
-    k = np.argsort(-sim_2);
+    k = np.argsort(-sim_2)
     print(np.c_[sim_2[k], k])
 
     ss = [holdout[2]]
     for i in range(3):
         ss.append(images[k[i]])
     Image.Tile(ss, columns=2).disp()
 
     Image(sim).disp(block=True)
-
-
-
-
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/BundleAdjust.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/BundleAdjust.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,32 @@
 import time
 import numpy as np
-import scipy as sp
+from scipy import sparse
 
 try:
     import pgraph
+
     pgraph_installed = True
 except:
-    print('pgraph not installed')
+    print("pgraph not installed")
     pgraph_installed = False
 from spatialmath import base
 from spatialmath import SE3, SO3, UnitQuaternion
 import matplotlib.pyplot as plt
 
 from machinevisiontoolbox import CentralCamera
 
 # We use the PGraph graph package and subclass the nodes and edges for an
 # undirected graph
 #
 # Each node has an index into the state vector given by its index and index2
 # properties.  These are initialized by a call to update_index
 
 if pgraph_installed:
+
     class _Common:
         @property
         def index(self):
             """
             Index into the state vector (base method)
 
             :return: the index of the start of this object's state in the state vector
@@ -51,15 +53,14 @@
             :rtype: bool
 
             This viewpoint or landmark will not be adjusted during optimization.
             """
             return self._fixed
 
     class ViewPoint(pgraph.UVertex, _Common):
-
         def __init__(self, x, fixed=False, color=None):
             """
             Create new camera viewpoint
 
             :param x: viewpoint pose as translation + vector part of unit quaternion
             :type x: array_like(6)
             :param fixed: camera is fixed, defaults to False
@@ -71,15 +72,15 @@
             the camera is not ``fixed`` it will be adjusted during the
             optimization.
 
             :seealso: :class:`PGraph.UVertex`
             """
             super().__init__()
 
-            self.coord = x    
+            self.coord = x
             self._fixed = fixed
             self._color = color
 
         @property
         def pose(self):
             """
             Get pose of camera
@@ -100,15 +101,15 @@
             :param P: landmark coordinate
             :type P: ndarray(3)
             :param fixed: point is fixed, defaults to False
             :type fixed: bool, optional
 
             Represent a world point in the bundle adjustment problem.  If the
             point is not ``fixed`` it will be adjusted during the optimization.
-            
+
             :seealso: :meth:`pgraph.UVertex`
             """
             super().__init__()
             self._P = P
             self._fixed = fixed
 
         @property
@@ -116,29 +117,30 @@
             """
             Get landmark position
 
             :return: landmark position in 3D
             :rtype: ndarray(3)
             """
             return self._P
+
     class Observation(pgraph.Edge):
         def __init__(self, camera, landmark, uv):
             """
             Create new landmark observation
 
             :param camera: the camera that made the observation
             :type camera: :class:`ViewPoint`
             :param landmark: the observed landmark
             :type landmark: :class:`Landmark`
             :param uv: the image plane coordinates of the observed landmark
             :type uv: ndarray(2)
 
             Represent the observation of a point by a camera in the bundle
             adjustment problem.
-            
+
             :seealso: :meth:`pgraph.Edge`
             """
             super().__init__(camera, landmark, cost=0)
             self._p = uv
 
         @property
         def p(self):
@@ -146,16 +148,16 @@
             Get image plane projection
 
             :return: observed projection of landmark on image plane
             :rtype: ndarray(2)
             """
 
             return self._p
-    class BundleAdjust:
 
+    class BundleAdjust:
         def __init__(self, camera):
             r"""
             Create a bundle adjustment problem
 
             :param camera: model of the moving camera
             :type camera: CentralCamera instance
 
@@ -175,15 +177,15 @@
             to movable cameras and landmarks.
 
 
             .. warning:: This class assumes that all camera views have the same camera
                 intrinsics.
 
             :reference:
-                - Robotics, Vision & Control for Python, Section 14.3.2, 
+                - Robotics, Vision & Control for Python, Section 14.3.2,
                   P. Corke, Springer 2023.
 
             :seealso: :meth:`optimize` :class:`~machinevisiontoolbox.Camera.CentralCamera` :class:`pgraph.UGraph`
             """
             self.camera = camera
 
             # we use a PGraph object to represent nodes and edges as an undirected graph:
@@ -192,22 +194,22 @@
             #  - Landmark for  vertices representing landmark positions as (x,
             #    y, z)
             #  - Observation for edges representing the observation of a landmark by
             #    a view
             #
             self.g = pgraph.UGraph(6)  # initialize the graph, nodes have 6D coordinates
 
-            self._nviews = 0  #number of cameras
-            self._nlandmarks = 0 #number of landmark points
+            self._nviews = 0  # number of cameras
+            self._nlandmarks = 0  # number of landmark points
             self._nvarstate = 0
 
-            self.views = []           # list of view nodes
-            self.landmarks = []       # list of landmark nodes
-            
-            self.fixedviews = []      # list of view nodes that are fixed
+            self.views = []  # list of view nodes
+            self.landmarks = []  # list of landmark nodes
+
+            self.fixedviews = []  # list of view nodes that are fixed
             self.fixedlandmarks = []  # list of landmark nodes that are fixed
 
             self.index_valid = False
 
         def update_index(self):
             if self.index_valid:
                 return
@@ -263,15 +265,15 @@
             :rtype: int
 
             This includes fixed views and landmarks whose state will not be
             updated in the opimization.
 
             :seealso: :meth:`nvarstate`
             """
-            return  6 * self.nviews + 3 * self.nlandmarks
+            return 6 * self.nviews + 3 * self.nlandmarks
 
         @property
         def nvarstates(self):
             """
             Length of variable state vector
 
             :return: Length of the variable state vector
@@ -279,37 +281,38 @@
 
             This is the length of the subset of the state vector that excludes
             fixed views and landmarks. It only includes cameras and landmarks
             whose state will be updated in the opimization.
 
             :seealso: :meth:`nstates`
             """
-            return  6 * (self.nviews - len(self.fixedviews)) \
-                + 3 * (self.nlandmarks - len(self.fixedlandmarks))
+            return 6 * (self.nviews - len(self.fixedviews)) + 3 * (
+                self.nlandmarks - len(self.fixedlandmarks)
+            )
 
-        def add_view(self, pose, fixed=False, color='black'):
+        def add_view(self, pose, fixed=False, color="black"):
             """
             Add camera view to bundle adjustment problem
 
             :param pose: camera pose
             :type pose: :class:`~spatialmath.pose3d.SE3`,  array_like(7)
             :param fixed: the camera is fixed, defaults to False
             :type fixed: bool, optional
             :return: new camera viewpoint
             :rtype: :class:`ViewPoint`
-            
+
             Creates a camera node and adds it to the bundle adjustment problem.
-            
+
             The camera ``pose``  can be :class:`~spatialmath.pose3d.SE3` or a vector (1x7)
             comprising translation and unit quaternion in vector form.
 
             If the camera is fixed (anchored) it will not be adjusted in the
             optimization process.
-            
-            .. note:: Adds a :class:`ViewPoint` object as a node in the 
+
+            .. note:: Adds a :class:`ViewPoint` object as a node in the
                 underlying scene graph.
 
             :seealso: :meth:`add_landmark` :meth:`add_projection`
             """
             if isinstance(pose, SE3):
                 t = pose.t
                 q = base.r2q(pose.R)
@@ -325,15 +328,15 @@
             v.name = f"view#{self._nviews}"
             self._nviews += 1
 
             self.g.add_vertex(v)
             self.views.append(v)
             if fixed:
                 self.fixedviews.append(v)
-            v.ba = self # back reference to the BA problem
+            v.ba = self  # back reference to the BA problem
             self.index_valid = False
             return v
 
         def add_landmark(self, P, fixed=False):
             """
             Add 3D landmark point to bundle adjustment problem
 
@@ -345,57 +348,57 @@
             :rtype: :class:`Landmark` instance
 
             Create a landmark node and add it to the bundle adjustment problem.
 
             If the landmark is fixed (anchored) it will not be adjusted in the
             optimization process.
 
-            .. note:: Adds a :class:`Landmark` object as a node in the 
+            .. note:: Adds a :class:`Landmark` object as a node in the
                 underlying scene graph.
 
-            :seealso: :meth:`add_view` :meth:`add_projection` 
+            :seealso: :meth:`add_view` :meth:`add_projection`
             """
             base.assertvector(P, 3)
-            
+
             # P = np.r_[P, 0, 0, 0]
 
             l = Landmark(P, fixed=fixed)
             l.name = f"landmark#{self._nlandmarks}"
             l.coord = P
             self._nlandmarks += 1
             self.g.add_vertex(l)
             self.landmarks.append(l)
             if fixed:
                 self.fixedlandmarks.append(c)
-            l.ba = self # back reference to the BA problem
+            l.ba = self  # back reference to the BA problem
             self.index_valid = False
             return l
 
         def add_projection(self, viewpoint, landmark, uv):
             """
             Add camera observation to bundle adjustment problem
 
             :param view: camera viewpoint
             :type view: :class:`ViewPoint`
             :param landmark: landmark point
             :type landmark: :class:`Landmark`
             :param uv: image plane coordinate
             :type uv: array_like(2)
-            
+
             Add an observation by ``viewpoint`` of a ``landmark`` to the bundle
-            adjustment problem.  
+            adjustment problem.
 
             .. note:: Adds a :class:`Observation` object as an edge in the
                 underlying scene graph.
 
             :seealso: :meth:`add_view` :meth:`add_landmark`
             """
-            assert len(uv) == 2, 'uv must be a 2-vector'
-            
-            edge = Observation(viewpoint, landmark, uv.flatten()) # create edge object
+            assert len(uv) == 2, "uv must be a 2-vector"
+
+            edge = Observation(viewpoint, landmark, uv.flatten())  # create edge object
             e = viewpoint.connect(landmark, edge=edge)  # connect nodes with it
             e.name = viewpoint.name + "--" + landmark.name
 
         @classmethod
         def load_SBA(cls, cameraFile, pointFile, calibFile, imagesize=None):
             """
             Load bundle adjustment data files
@@ -408,124 +411,130 @@
             :type calibFile: str
             :param imagesize: image plane dimensions in pixels, if not given infer
                 it from principal point data in ``calibFile``
             :type imagesize: array_like(2)
 
             Provides access to bundle adjustment problems from data files as distributed with the SBA package.
             Details of the file format are given in the source code comments.
-            
+
             Example:
-            
+
             To solve the 7-point bundle adjustment problem distributed with
             SBA 1.6::
-            
+
                 >>> ba = Bundle.load_SBA('7cams.txt', '7pts.txt', 'calib.txt')
                 >>> X = ba.optimize()
 
             :reference:
                 - Sparse Bundle Adjustment package by Manolis Lourakis,
                   http://users.ics.forth.gr/~lourakis/sba
-            
+
             :seealso: :meth:`add_view` :meth:`add_landmark` :meth:`add_projection`
             """
-            # Adopted from sba-1.6/matlab/eucsbademo.m 
+            # Adopted from sba-1.6/matlab/eucsbademo.m
 
             # read calibration parameters
             #
             # f/rho_u  skew      u0
             # 0        f/rho_v   v0
-            # 0        0         1  
+            # 0        0         1
             K = np.loadtxt(calibFile)
 
             # create the camera object
             if imagesize is None:
                 # no image plane size given
                 # infer it from the principal point
                 imagesize = 2 * K[:2, 2]
 
             camera = CentralCamera(
-                f=K[0, 0],
-                rho = [1, K[0, 0] / K[1, 1]],
-                pp = K[:2, 2],
-                imagesize = imagesize
+                f=K[0, 0], rho=[1, K[0, 0] / K[1, 1]], pp=K[:2, 2], imagesize=imagesize
             )
 
             # create a bundle adjustment instance
             ba = cls(camera)
 
             # read camera views
             #
-            # each line is: qs qx qy qz tx ty tz 
+            # each line is: qs qx qy qz tx ty tz
             for pose in np.loadtxt(cameraFile):
                 ba.add_view(pose)
 
             # read points and projections
-            # 
+            #
             # The lines are of the form:
             #
             # X Y Z  NFRAMES  FRAME0 x0 y0  FRAME1 x1 y1 ...
             #
             # corresponding to a single 3D point and multiple projections:
-            # 
+            #
             # - X, Y, Z is the points' Euclidean 3D coordinates,
             # - NFRAMES the total number of camera views in which the point is
-            #   visible and there will follow NFRAMES subsequent triplets 
+            #   visible and there will follow NFRAMES subsequent triplets
             # - FRAME x y specifies that the 3D point in question projects to pixel
-            #   (x, y) in view number FRAME. 
-            # 
+            #   (x, y) in view number FRAME.
+            #
             # For example, the line:
             #
             # 100.0 200.0 300.0 3  2 270.0 114.1 4 234.2 321.7 5 173.6 425.8
             #
-            # describes a world point (100.0, 200.0, 300.0) that is visible in 
+            # describes a world point (100.0, 200.0, 300.0) that is visible in
             # three views: view 2 at (270.0, 114.1), view 4 at (234.2, 321.7) and
             # view 5 at (173.6, 425.8)
-            with open(pointFile, 'r') as file:
+            with open(pointFile, "r") as file:
                 npts = 0
                 for line in file:
-                    if len(line) == 0 or line[0] == '#':
+                    if len(line) == 0 or line[0] == "#":
                         continue
 
                     data = line.split()
 
-                    #read X, Y, Z, nframes
+                    # read X, Y, Z, nframes
                     P = np.array([float(x) for x in data[:3]])
                     data = data[3:]
                     npts += 1
-                
-                    #create a node for this point
+
+                    # create a node for this point
                     landmark = ba.add_landmark(P)
-                    
-                    #now find which cameras it was seen by
+
+                    # now find which cameras it was seen by
                     nframes = int(data.pop(0))
-                    for i in range(nframes):  #read "nframes" id, x, y triplets
+                    for i in range(nframes):  # read "nframes" id, x, y triplets
                         id = int(data.pop(0))
                         u = float(data.pop(0))
                         v = float(data.pop(0))
 
-                        #add a landmark projection
+                        # add a landmark projection
                         ba.add_projection(ba.views[id], landmark, np.r_[u, v])
             return ba
-        
+
         # =============== METHODS TO SOLVE PROBLEMS ==================== #
-        
-        def optimize(self, x=None, animate=False, lmbda=0.1, 
-            lmbdamin=1e-8, dxmin=1e-4, tol=0.5, iterations=1000, verbose=False):
+
+        def optimize(
+            self,
+            x=None,
+            animate=False,
+            lmbda=0.1,
+            lmbdamin=1e-8,
+            dxmin=1e-4,
+            tol=0.5,
+            iterations=1000,
+            verbose=False,
+        ):
             """
             Perform the bundle adjustment
 
             :param x: state vector, defaults to the state vector in the instance
             :type Xx: ndarray(N), optional
             :param animate: graphically animate the updates, defaults to False
             :type animate: bool, optional
             :param lmbda: initial damping term, defaults to 0.1
             :type lmbda: float, optional
             :param lmbdamin: minimum value of ``lmbda``, defaults to 1e-8
             :type lmbdamin: float, optional
-            :param dxmin: terminate optimization if state update norm falls below this 
+            :param dxmin: terminate optimization if state update norm falls below this
                 threshold, defaults to 1e-4
             :type dxmin: float, optional
             :param tol: terminate optimization if error total reprojection error
                 falls below this threshold, defaults to 0.5 pixels
             :type tol: float, optional
             :param iterations: maximum number of iterations, defaults to 1000
             :type iterations: int, optional
@@ -536,54 +545,54 @@
 
             Performs a Levenberg-Marquadt style optimization of the bundle
             adjustment problem which repeatedly calls :meth:`solve`.  Adjusts
             camera poses and landmark positions in order to minimize the total
             reprojection error.
 
             :reference:
-                - Robotics, Vision & Control for Python, Section 14.3.2, 
+                - Robotics, Vision & Control for Python, Section 14.3.2,
                   P. Corke, Springer 2023.
 
             :seealso: :meth:`nstates` :meth:`solve` :meth:`build_linear_system`
             """
 
             self.update_index()
-            
+
             if x is None:
                 x = self.getstate()
             x0 = x
-            
+
             t0 = time.perf_counter()
-            
+
             print(f"Bundle adjustment cost {self.errors(x0):.3g} -- initial")
             for i in range(iterations):
                 if animate:
                     if not retain:
                         plt.clf()
                     g2.plot()
                     plt.pause(0.5)
-                
+
                 ta = time.perf_counter()
                 # solve for the step
                 dx, energy = self.solve(x, lmbda)
 
                 # update the state
                 x_new = self.updatestate(x, dx)
 
                 # compute new value of cost
                 enew = self.errors(x_new)
-                
+
                 dt = time.perf_counter() - ta
                 print(f"Bundle adjustment cost {enew:.3g} (solved in {dt:.2f} sec)")
                 # are we there yet?
                 if enew < tol:
                     break
-                
+
                 # have we stopped moving
-                if  base.norm(dx) < dxmin:
+                if base.norm(dx) < dxmin:
                     break
 
                 # do the Levenberg-Marquadt thing, was it a good update?
                 if enew < energy:
                     # step is accepted
                     x = x_new
                     if lmbda > lmbdamin:
@@ -591,170 +600,171 @@
                     if verbose:
                         print(f" -- step accepted: lambda = {lmbda:g}")
                 else:
                     # step is rejected
                     lmbda *= 4
                     if verbose:
                         print(f" -- step rejected: lambda ={lmbda:g}")
-            
+
             tf = time.perf_counter()
             err = np.sqrt(enew / self.g.ne)
             print(f"\n * {i + 1} iterations in {tf - t0:.1f} seconds")
             print(f" * Final RMS error is {err:.2f} pixels")
-            
+
             return x_new, err
-        
+
         def solve(self, x, lmbda=0.0):
             r"""
             Solve for state update
 
             :param x: state vector
             :type x: ndarray(N)
             :param lmbda: damping term, defaults to 0.0
             :type lmbda: float, optional
             :return: :math:`\delta \vec{X}`, update to the variable state vector
             :rtype: ndarray(M)
 
             Determines the state update :math:`\delta \vec{x}` by creating and
             solving the linear equation
-            
+
             .. math:: \mat{H} \delta \vec{x} = \vec{b}
-            
-            where :math:`\mat{H}` is the Hessian and :math:`\mat{b}` is the the 
+
+            where :math:`\mat{H}` is the Hessian and :math:`\mat{b}` is the the
             projection error.
 
             .. note::
                 - The damping term ``lmbda`` is added to the diagonal of the
                   Hessian to prevent problems when the Hessian is nearly
                   singular.
                 - If the problem includes fixed cameras or landmarks then
                   :math:`\mbox{len}(\delta \vec{x}) < \mbox{len}(\vec{x})`
                   since fixed elements are omitted from the variable state
                   vector used for the optimization.
 
             :reference:
-                - Robotics, Vision & Control for Python, Section 14.3.2, F.2.4, 
+                - Robotics, Vision & Control for Python, Section 14.3.2, F.2.4,
                   P. Corke, Springer 2023.
 
             :seealso: :meth:`build_linear_system`
             """
             # create the Hessian and error vector
             H, b, e = self.build_linear_system(x)
-            
+
             # add damping term to the diagonal
             for i in range(self.nvarstates):
                 H[i, i] += lmbda
-            
+
             # solve for the state update
-            #- could replace this with the Schur complement trick
-            deltax = sp.sparse.linalg.spsolve(H.tocsr(), b.tocsr())
+            # - could replace this with the Schur complement trick
+            deltax = sparse.linalg.spsolve(H.tocsr(), b.tocsr())
             return deltax, e
-        
-        #build the Hessian and measurement vector
+
+        # build the Hessian and measurement vector
         def build_linear_system(self, x):
             r"""
             Build the linear system
 
             :param x: state vector
             :type x: ndarray(N)
             :return: Hessian :math:`\mat{H}(\vec{x})` and projection error :math:`\vec{b}`
             :rtype: sparse_array(N,N), sparse_ndarray(N,1), float
 
             Build the block structured Hessian matrix based on current bundle
             adjustment state and the Jacobians.
 
             :reference:
-                - Robotics, Vision & Control for Python, Section 14.3.2, F.2.4, 
+                - Robotics, Vision & Control for Python, Section 14.3.2, F.2.4,
                   P. Corke, Springer 2023.
 
             :seealso: :meth:`spy` :meth:`~Camera.CentralCamera.derivatives`
             """
 
-            # this function is slow.  lil matrices have similar speed to dok 
+            # this function is slow.  lil matrices have similar speed to dok
             # matrices
             # H += A is slower than H = H + A
 
             from scipy.sparse import lil_matrix
-            #allocate sparse matrices
+
+            # allocate sparse matrices
             H = lil_matrix((self.nvarstates, self.nvarstates))
-            b = lil_matrix((self.nvarstates,1))
+            b = lil_matrix((self.nvarstates, 1))
 
             etotal = 0
 
-            #loop over views
+            # loop over views
             for view in self.views:
-                
+
                 # get camera pose
                 k = view.index
-                X = x[k:k+6]
-                
-                #loop over all points viewed from this camera
+                X = x[k : k + 6]
+
+                # loop over all points viewed from this camera
                 for (landmark, edge) in view.incidences():
 
                     k = landmark.index
-                    P = x[k:k+3]  # get landmark position
-            
+                    P = x[k : k + 3]  # get landmark position
+
                     # for this view and landmark, get observation
                     uv = edge.p
-                    
+
                     # compute Jacobians and predicted projection
                     uvhat, JA, JB = self.camera.derivatives(X, P)
 
                     # compute reprojection error as a column vector
                     e = np.c_[uvhat - uv]
                     etotal = etotal + e.T @ e
-                    
+
                     i = view.index2
                     j = landmark.index2
 
                     # compute the block components of H and b for this edge
                     if not view.isfixed and not landmark.isfixed:
                         # adjustable point and view
                         H_ii = JA.T @ JA
                         H_ij = JA.T @ JB
                         H_jj = JB.T @ JB
-                        
-                        H[i:i+6, i:i+6] = H[i:i+6, i:i+6] + H_ii
-                        H[i:i+6, j:j+3] = H[i:i+6, j:j+3] + H_ij
-                        H[j:j+3, i:i+6] = H[j:j+3, i:i+6] + H_ij.T
-                        H[j:j+3, j:j+3] = H[j:j+3, j:j+3] + H_jj
-                        
-                        b[i:i+6, 0] = b[i:i+6, 0] - JA.T @ e
-                        b[j:j+3, 0] = b[j:j+3, 0] - JB.T @ e
-                        
+
+                        H[i : i + 6, i : i + 6] = H[i : i + 6, i : i + 6] + H_ii
+                        H[i : i + 6, j : j + 3] = H[i : i + 6, j : j + 3] + H_ij
+                        H[j : j + 3, i : i + 6] = H[j : j + 3, i : i + 6] + H_ij.T
+                        H[j : j + 3, j : j + 3] = H[j : j + 3, j : j + 3] + H_jj
+
+                        b[i : i + 6, 0] = b[i : i + 6, 0] - JA.T @ e
+                        b[j : j + 3, 0] = b[j : j + 3, 0] - JB.T @ e
+
                     elif view.isfixed and not landmark.isfixed:
                         # fixed camera and adjustable point
-                        
-                        H[j:j+3, j:j+3] = H[j:j+3, j:j+3] + JB.T @ JB
-                        b[j:j+3, 0] = b[j:j+3, 0] - JB.T @ e
-                        
+
+                        H[j : j + 3, j : j + 3] = H[j : j + 3, j : j + 3] + JB.T @ JB
+                        b[j : j + 3, 0] = b[j : j + 3, 0] - JB.T @ e
+
                     elif not view.isfixed and landmark.isfixed:
                         # adjustable camera and fixed point
-                        
-                        H[i:i+6, i:i+6] = H[i:i+6, i:i+6] + JA.T @ JA
-                        b[i:i+6, 0] = b[i:i+6, 0] - JA.T @ e
+
+                        H[i : i + 6, i : i + 6] = H[i : i + 6, i : i + 6] + JA.T @ JA
+                        b[i : i + 6, 0] = b[i : i + 6, 0] - JA.T @ e
 
             return H, b, etotal
-                
+
         def spyH(self, x, block=False):
             """
             Display sparsity of Hessian
 
             :param x: state vector
             :type x: ndarray(N)
 
             Use Matplotlib to display the zero and non-zero elements of the
             Hessian.
 
-            :seealso: :meth:`build_linear_system` 
+            :seealso: :meth:`build_linear_system`
             """
             H, *_ = self.build_linear_system(x)
             plt.spy(H)
             plt.show(block=True)
-        
+
         def getstate(self):
             """
             Get the state vector
 
             :return: state  vector
             :rtype: ndarray(N)
 
@@ -762,48 +772,48 @@
             then the position of all landmarks.  That information is provided at
             problem initialization by calls to :meth:`add_view` and
             :meth:`add_landmark`.
 
             :seealso: :meth:`setstate` :meth:`nstates` :meth:`add_view` :meth:`add_landmark`
             """
             x = []
-            
-            for view in self.views:  #step through camera nodes
+
+            for view in self.views:  # step through camera nodes
                 x.extend(view.coord)
 
-            for landmark in self.landmarks:  #step through landmark nodes
+            for landmark in self.landmarks:  # step through landmark nodes
                 x.extend(landmark.coord)
 
             return np.array(x)
-        
+
         def setstate(self, x):
             """
             Update camera and landmark state
 
             :param x: new state vector
             :type x: ndarray(N)
 
             Copy new state data into the nodes of the bundle adjustment graph.
             Those nodes corresponding to fixed cameras or landmarks are
             unchanged.
 
             :seealso: :meth:`updatestate` :meth:`getstate`
             """
-            
-            for view in self.views:  #step through view nodes
+
+            for view in self.views:  # step through view nodes
                 X = x[:6]
                 x = x[6:]
                 if not view.isfixed:
                     view.coord = X
-            
+
             for landmark in self.landmarks:
-                    X = x[:3]
-                    x = x[3:]
-                    if not landmark.isfixed:
-                        landmark.coord = X
+                X = x[:3]
+                x = x[3:]
+                if not landmark.isfixed:
+                    landmark.coord = X
 
         def updatestate(self, x, dx):
             """
             Update the state vector
 
             :param x: state vector
             :type x: ndarray(N)
@@ -821,67 +831,67 @@
             xnew = np.zeros(x.shape)
 
             # for each camera we need to compound the camera pose with the
             # incremental relative pose
             for view in self.views:
                 k = view.index
                 if view.isfixed:
-                    xnew[k:k+6] = x[k:k+6]
+                    xnew[k : k + 6] = x[k : k + 6]
                 else:
                     # current pose
-                    X = x[k:k+6]
+                    X = x[k : k + 6]
                     t = X[:3]
                     qv = X[3:]
-                    
+
                     # incremental pose
                     k2 = view.index2
-                    dX = dx[k2:k2+6]
+                    dX = dx[k2 : k2 + 6]
                     dt = dX[:3]
                     dqv = dX[3:]
 
-                    tnew = t + dt  #assume translation in old frame
+                    tnew = t + dt  # assume translation in old frame
                     qvnew = UnitQuaternion.qvmul(qv, dqv)
-                    
-                    xnew[k:k+6] = np.r_[tnew, qvnew]
 
-            #for each landmark we add the increment to its position
+                    xnew[k : k + 6] = np.r_[tnew, qvnew]
+
+            # for each landmark we add the increment to its position
             for landmark in self.landmarks:
                 k = landmark.index
-                P = x[k:k+3]
+                P = x[k : k + 3]
                 if landmark.isfixed:
-                    xnew[k:k+3] = P
+                    xnew[k : k + 3] = P
                 else:
                     k2 = landmark.index2
-                    dP = dx[k2:k2+3]
-                    xnew[k:k+3] = P + dP
+                    dP = dx[k2 : k2 + 3]
+                    xnew[k : k + 3] = P + dP
 
             return xnew
-        
-        #Compute total squared reprojection error
+
+        # Compute total squared reprojection error
         def errors(self, x=None):
             """
             Total reprojection error
 
             :param x: state vector, defaults to state vector in instance
             :type x: ndarray(N), optional
             :return: total residual
             :rtype: float
 
             Compute the total reprojection error, of all projected landmarks
             on all camera viewpoints. Is ideally zero.
 
             :seealso: :meth:`getresidual`
             """
-            
+
             if x is None:
                 x = self.getstate()
             r = self.getresidual(x)
-            
+
             return np.sum(r)
-        
+
         def getresidual(self, x=None):
             r"""
             Get error residuals
 
             :param X: state vector, defaults to state vector in instance
             :type X: ndarray(N), optional
             :return: residuals :math:`\mat{R}` for each observation
@@ -894,35 +904,35 @@
             :seealso: :meth:`errors`
             """
             # this is the squared reprojection errors
             self.update_index()
 
             if x is None:
                 x = self.getstate()
-            
+
             residual = np.zeros((self.nviews, self.nlandmarks))
             # loop over views
             for view in self.views:
-                
+
                 # get view pose
                 k = view.index
-                X = x[k:k+6]
+                X = x[k : k + 6]
 
                 # loop over all points viewed from this camera
                 for (landmark, edge) in view.incidences():
 
                     k = landmark.index
-                    P = x[k:k+3]  # get landmark position
-                    
+                    P = x[k : k + 3]  # get landmark position
+
                     uv = edge.p
-                    
+
                     uvhat, *_ = self.camera.derivatives(X, P)
                     if np.any(np.isnan(uvhat)):
-                        print('bad uvhat in residual')
-                    
+                        print("bad uvhat in residual")
+
                     # compute reprojection error
                     e = uvhat - uv
                     residual[view.id, landmark.id] = np.dot(e, e)
             return residual
 
         @property
         def graph(self):
@@ -936,90 +946,101 @@
             :class:`ViewPoint`, and nodes representing landmarks, of type
             :class:`Landmark`. An edge, of type :class:`Observation`, exists
             between a landmark and the viewpoint that observed, and the edge has
             the associated image plane projection.
             """
             return self.g
 
-        def plot(self, camera={}, ax=None, **kwargs):
+        def plot(self, camera={}, block=None, ax=None, **kwargs):
             """
             Plot the scene graph
 
             :param camera: options passed to :obj:`CentralCamera.plot`, defaults to {}
             :type camera: dict, optional
             :param ax: axis to plot into, defaults to None
             :type ax: Axes, optional
             :param kwargs: options passed to :obj:`PGraph.plot`
 
             Display the nodes and edges of the scene graph as an embedded graph.
             Overlay camera icons to indicate the camera viewpoint nodes.
 
             :seealso: :meth:`graph`
             """
-            if ax is None:
-                # plt.clf()  # causes spurious 2d plot with Jupyter
-                ax = base.plotvol3()
-            self.g.plot(**kwargs) #edge=dict(color=0.8*np.r_[1, 1, 1]), **kwargs)
+            # plt.clf()  # causes spurious 2d plot with Jupyter
+            ax = base.plotvol3(ax=ax)
+            self.g.plot(**kwargs)  # edge=dict(color=0.8*np.r_[1, 1, 1]), **kwargs)
             # ax.set_aspect('equal')
-            
+
             # colorOrder = get(gca, 'ColorOrder')
             for view in self.views:
                 cam = self.camera.move(view.pose)
                 # cidx = mod(i-1, numrows(colorOrder))+1
                 # color = colorOrder(cidx,:)
-                cam.plot(pose=view.pose, ax=ax, color=view._color, **camera) # 'color', color, 'persist')
+                cam.plot(
+                    pose=view.pose, ax=ax, color=view._color, **camera
+                )  # 'color', color, 'persist')
             # ax.set_aspect('equal')
-            ax.set_xlabel('X (m)')
-            ax.set_ylabel('Y (m)')
-            ax.set_zlabel('Z (m)')
+            ax.set_xlabel("X (m)")
+            ax.set_ylabel("Y (m)")
+            ax.set_zlabel("Z (m)")
             plt.grid(True)
 
+            if block is not None:
+                plt.show(block=block)
+                
         def __repr__(self):
             """
             String representation
 
             :return: multiline string describing key parameters of bundle adjustment problem
             :rtype: str
             """
             return str(self)
-            
+
         def __str__(self):
             """
             String representation
 
             :return: multiline string describing key parameters of bundle adjustment problem
             :rtype: str
             """
-            s = 'Bundle adjustment problem:'
+            s = "Bundle adjustment problem:"
             s += f"  {self.nviews} views\n"
             fixedcam = [i for i, view in enumerate(self.views) if view.isfixed]
             if len(fixedcam) > 0:
                 s += f"    {len(fixedcam)} locked views: {fixedcam}\n"
-            fixedlandmarks = [i for i, landmark in enumerate(self.landmarks) if landmark.isfixed]
+            fixedlandmarks = [
+                i for i, landmark in enumerate(self.landmarks) if landmark.isfixed
+            ]
             if len(fixedlandmarks) > 0:
                 s += f"    {len(fixedlandmarks)} locked landmarks: {fixedlandmarks}\n"
 
             s += f"  {self.nlandmarks} landmarks\n"
-            
+
             s += f"  {self.g.ne} projections\n"
-            
+
             s += f"  {self.nstates} total states\n"
             s += f"  {self.nvarstates} variable states\n"
             s += f"  {self.g.ne * 2} equations\n"
             v = np.array(self.g.connectivity(self.views))
-            s += f"  landmarks per view: min={v.min():d}, max={v.max():d}, avg={v.mean():.1f}\n"
-            l = np.array(self.g.connectivity(self.landmarks))
-            s += f"  views per landmark: min={l.min():d}, max={l.max():d}, avg={l.mean():.1f}\n"
+            if len(self.views) > 0:
+                s += f"  landmarks per view: min={v.min():d}, max={v.max():d}, avg={v.mean():.1f}\n"
+            if len(self.landmarks) > 0:
+                l = np.array(self.g.connectivity(self.landmarks))
+                s += f"  views per landmark: min={l.min():d}, max={l.max():d}, avg={l.mean():.1f}\n"
             return s
+
 else:
+
     class BundleAdjust:
         pass
 
+
 if __name__ == "__main__":
 
     from spatialmath import UnitQuaternion
 
-    ba = BundleAdjust.load_sba('7cams.txt', '7pts.txt', 'calib.txt')
+    ba = BundleAdjust.load_sba("7cams.txt", "7pts.txt", "calib.txt")
     print(ba)
     print(ba.camera)
 
-    ba.optimize(verbose=False)
+    ba.optimize(verbose=False)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/Camera.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/Camera.py`

 * *Files 4% similar despite different names*

```diff
@@ -46,8355 +46,8397 @@
 000002d0: 6e61 6d65 6474 7570 6c65 0a66 726f 6d20  namedtuple.from 
 000002e0: 7370 6174 6961 6c6d 6174 6820 696d 706f  spatialmath impo
 000002f0: 7274 2053 4533 0a69 6d70 6f72 7420 7370  rt SE3.import sp
 00000300: 6174 6961 6c6d 6174 682e 6261 7365 2061  atialmath.base a
 00000310: 7320 736d 6261 7365 0a0a 6672 6f6d 206d  s smbase..from m
 00000320: 6163 6869 6e65 7669 7369 6f6e 746f 6f6c  achinevisiontool
 00000330: 626f 7820 696d 706f 7274 2049 6d61 6765  box import Image
-00000340: 0a0a 636c 6173 7320 4361 6d65 7261 4261  ..class CameraBa
-00000350: 7365 2841 4243 293a 0a0a 2020 2020 2320  se(ABC):..    # 
-00000360: 6c69 7374 206f 6620 6174 7472 6962 7574  list of attribut
-00000370: 6573 0a20 2020 205f 6e61 6d65 203d 204e  es.    _name = N
-00000380: 6f6e 6520 2020 2020 2023 2063 616d 6572  one      # camer
-00000390: 6120 206e 616d 6520 2873 7472 696e 6729  a  name (string)
-000003a0: 0a20 2020 205f 6361 6d74 7970 6520 3d20  .    _camtype = 
-000003b0: 4e6f 6e65 2020 2023 2063 616d 6572 6120  None   # camera 
-000003c0: 7479 7065 2028 7374 7269 6e67 290a 0a20  type (string).. 
-000003d0: 2020 205f 696d 6167 6573 697a 6520 3d20     _imagesize = 
-000003e0: 4e6f 6e65 2020 2020 2020 2020 2320 6e75  None        # nu
-000003f0: 6d62 6572 206f 6620 7069 7865 6c73 2028  mber of pixels (
-00000400: 686f 7269 7a6f 6e74 616c 2c20 7665 7274  horizontal, vert
-00000410: 6963 616c 290a 2020 2020 5f70 7020 3d20  ical).    _pp = 
-00000420: 4e6f 6e65 2020 2020 2020 2020 2320 7072  None        # pr
-00000430: 696e 6369 7061 6c20 706f 696e 7420 2868  incipal point (h
-00000440: 6f72 697a 6f6e 7461 6c2c 2076 6572 7469  orizontal, verti
-00000450: 6361 6c29 0a20 2020 205f 7268 6f75 203d  cal).    _rhou =
-00000460: 204e 6f6e 6520 2020 2020 2023 2070 6978   None      # pix
-00000470: 656c 2069 6d61 6765 7369 7a65 2028 7369  el imagesize (si
-00000480: 6e67 6c65 2070 6978 656c 2920 686f 7269  ngle pixel) hori
-00000490: 7a6f 6e74 616c 0a20 2020 205f 7268 6f76  zontal.    _rhov
-000004a0: 203d 204e 6f6e 6520 2020 2020 2023 2070   = None      # p
-000004b0: 6978 656c 2069 6d61 6765 7369 7a65 2028  ixel imagesize (
-000004c0: 7369 6e67 6c65 2070 6978 656c 2920 7665  single pixel) ve
-000004d0: 7274 6963 616c 0a20 2020 205f 696d 6167  rtical.    _imag
-000004e0: 6520 3d20 4e6f 6e65 2020 2020 2023 2069  e = None     # i
-000004f0: 6d61 6765 2028 544f 444f 2069 6d61 6765  mage (TODO image
-00000500: 2063 6c61 7373 3f29 2c20 666f 7220 6e6f   class?), for no
-00000510: 772c 206a 7573 7420 6e75 6d70 7920 6172  w, just numpy ar
-00000520: 7261 790a 0a20 2020 205f 5420 3d20 5b5d  ray..    _T = []
-00000530: 2020 2020 2020 2020 2023 2063 616d 6572           # camer
-00000540: 6120 706f 7365 2028 686f 6d6f 6765 6e65  a pose (homogene
-00000550: 6f75 7320 7472 616e 7366 6f72 6d2c 2053  ous transform, S
-00000560: 4533 2063 6c61 7373 290a 0a20 2020 205f  E3 class)..    _
-00000570: 6178 203d 205b 5d20 2020 2020 2020 2023  ax = []        #
-00000580: 2066 6f72 2070 6c6f 7474 696e 672c 2061   for plotting, a
-00000590: 7865 7320 6861 6e64 6c65 0a0a 2020 2020  xes handle..    
-000005a0: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-000005b0: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
-000005c0: 2020 2020 6e61 6d65 3d4e 6f6e 652c 0a20      name=None,. 
-000005d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000005e0: 6361 6d74 7970 653d 2763 656e 7472 616c  camtype='central
-000005f0: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
-00000600: 2020 2020 7268 6f3d 312c 0a20 2020 2020      rho=1,.     
-00000610: 2020 2020 2020 2020 2020 2020 696d 6167              imag
-00000620: 6573 697a 653d 4e6f 6e65 2c0a 2020 2020  esize=None,.    
-00000630: 2020 2020 2020 2020 2020 2020 2073 656e               sen
-00000640: 736f 7273 697a 653d 4e6f 6e65 2c0a 2020  sorsize=None,.  
-00000650: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00000660: 703d 4e6f 6e65 2c0a 2020 2020 2020 2020  p=None,.        
-00000670: 2020 2020 2020 2020 206e 6f69 7365 3d4e           noise=N
-00000680: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
-00000690: 2020 2020 2020 706f 7365 3d4e 6f6e 652c        pose=None,
-000006a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000006b0: 2020 6c69 6d69 7473 3d4e 6f6e 652c 0a20    limits=None,. 
-000006c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000006d0: 6c61 6265 6c73 3d4e 6f6e 652c 0a20 2020  labels=None,.   
-000006e0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-000006f0: 6564 3d4e 6f6e 6529 3a0a 2020 2020 2020  ed=None):.      
-00000700: 2020 2222 2241 6273 7472 6163 7420 6361    """Abstract ca
-00000710: 6d65 7261 2062 6173 6520 636c 6173 730a  mera base class.
-00000720: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-00000730: 6e61 6d65 3a20 6361 6d65 7261 2069 6e73  name: camera ins
-00000740: 7461 6e63 6520 6e61 6d65 2c20 6465 6661  tance name, defa
-00000750: 756c 7473 2074 6f20 4e6f 6e65 0a20 2020  ults to None.   
-00000760: 2020 2020 203a 7479 7065 206e 616d 653a       :type name:
-00000770: 2073 7472 2c20 6f70 7469 6f6e 616c 0a20   str, optional. 
-00000780: 2020 2020 2020 203a 7061 7261 6d20 6361         :param ca
-00000790: 6d74 7970 653a 2063 616d 6572 6120 7072  mtype: camera pr
-000007a0: 6f6a 6563 7469 6f6e 2074 7970 652c 2064  ojection type, d
-000007b0: 6566 6175 6c74 7320 746f 2027 6365 6e74  efaults to 'cent
-000007c0: 7261 6c27 0a20 2020 2020 2020 203a 7479  ral'.        :ty
-000007d0: 7065 2063 616d 7479 7065 3a20 7374 722c  pe camtype: str,
-000007e0: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
-000007f0: 2020 3a70 6172 616d 2072 686f 3a20 7069    :param rho: pi
-00000800: 7865 6c20 7369 7a65 2c20 6465 6661 756c  xel size, defaul
-00000810: 7473 2074 6f20 310a 2020 2020 2020 2020  ts to 1.        
-00000820: 3a74 7970 6520 7268 6f3a 2073 6361 6c61  :type rho: scala
-00000830: 7220 6f72 2061 7272 6179 5f6c 696b 6528  r or array_like(
-00000840: 3229 2c20 6f70 7469 6f6e 616c 0a20 2020  2), optional.   
-00000850: 2020 2020 203a 7061 7261 6d20 696d 6167       :param imag
-00000860: 6573 697a 653a 2069 6d61 6765 2064 696d  esize: image dim
-00000870: 656e 7369 6f6e 2069 6e20 7069 7865 6c73  ension in pixels
-00000880: 2c20 6465 6661 756c 7473 2074 6f20 4e6f  , defaults to No
-00000890: 6e65 0a20 2020 2020 2020 203a 7479 7065  ne.        :type
-000008a0: 2069 6d61 6765 7369 7a65 3a20 696e 7420   imagesize: int 
-000008b0: 6f72 2061 7272 6179 5f6c 696b 6528 3229  or array_like(2)
-000008c0: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
-000008d0: 2020 203a 7061 7261 6d20 7365 6e73 6f72     :param sensor
-000008e0: 7369 7a65 3a20 696d 6167 6520 7365 6e73  size: image sens
-000008f0: 6f72 2073 697a 652c 2064 6566 6175 6c74  or size, default
-00000900: 7320 746f 204e 6f6e 650a 2020 2020 2020  s to None.      
-00000910: 2020 3a74 7970 6520 7365 6e73 6f72 7369    :type sensorsi
-00000920: 7a65 3a20 6172 7261 795f 6c69 6b65 2832  ze: array_like(2
-00000930: 292c 206f 7074 696f 6e61 6c0a 2020 2020  ), optional.    
-00000940: 2020 2020 3a70 6172 616d 2070 703a 2070      :param pp: p
-00000950: 7269 6e63 6970 616c 2070 6f69 6e74 2070  rincipal point p
-00000960: 6f73 6974 696f 6e2c 2064 6566 6175 6c74  osition, default
-00000970: 7320 746f 204e 6f6e 650a 2020 2020 2020  s to None.      
-00000980: 2020 3a74 7970 6520 7070 3a20 6172 7261    :type pp: arra
-00000990: 795f 6c69 6b65 2832 292c 206f 7074 696f  y_like(2), optio
-000009a0: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
-000009b0: 616d 206e 6f69 7365 3a20 7374 616e 6461  am noise: standa
-000009c0: 7264 2064 6576 6961 7469 6f6e 206f 6620  rd deviation of 
-000009d0: 696d 6167 6520 706c 616e 6520 7072 6f6a  image plane proj
-000009e0: 6563 7469 6f6e 206e 6f69 7365 2c20 6465  ection noise, de
-000009f0: 6661 756c 7473 2074 6f20 4e6f 6e65 0a20  faults to None. 
-00000a00: 2020 2020 2020 203a 7479 7065 206e 6f69         :type noi
-00000a10: 7365 3a20 666c 6f61 742c 206f 7074 696f  se: float, optio
-00000a20: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
-00000a30: 616d 2070 6f73 653a 2063 616d 6572 6120  am pose: camera 
-00000a40: 706f 7365 2c20 6465 6661 756c 7473 2074  pose, defaults t
-00000a50: 6f20 4e6f 6e65 0a20 2020 2020 2020 203a  o None.        :
-00000a60: 7479 7065 2070 6f73 653a 203a 636c 6173  type pose: :clas
-00000a70: 733a 607e 7370 6174 6961 6c6d 6174 682e  s:`~spatialmath.
-00000a80: 2e70 6f73 6533 642e 5345 3360 2c20 6f70  .pose3d.SE3`, op
-00000a90: 7469 6f6e 616c 0a20 2020 2020 2020 203a  tional.        :
-00000aa0: 7061 7261 6d20 6c69 6d69 7473 3a20 626f  param limits: bo
-00000ab0: 756e 6473 206f 6620 7669 7274 7561 6c20  unds of virtual 
-00000ac0: 696d 6167 6520 706c 616e 6520 5b75 6d69  image plane [umi
-00000ad0: 6e2c 2075 6d61 782c 2076 6d69 6e2c 2076  n, umax, vmin, v
-00000ae0: 6d61 785d 2c20 6465 6661 756c 7473 2074  max], defaults t
-00000af0: 6f20 4e6f 6e65 0a20 2020 2020 2020 203a  o None.        :
-00000b00: 7479 7065 206c 696d 6974 733a 2061 7272  type limits: arr
-00000b10: 6179 5f6c 696b 6528 3429 2c20 6f70 7469  ay_like(4), opti
-00000b20: 6f6e 616c 0a20 2020 2020 2020 203a 7061  onal.        :pa
-00000b30: 7261 6d20 6c61 6265 6c73 3a20 6178 6973  ram labels: axis
-00000b40: 206c 6162 656c 7320 666f 7220 7669 7274   labels for virt
-00000b50: 7561 6c20 696d 6167 6520 706c 616e 652c  ual image plane,
-00000b60: 2064 6566 6175 6c74 7320 746f 2060 6028   defaults to ``(
-00000b70: 2775 272c 2027 7627 2960 600a 2020 2020  'u', 'v')``.    
-00000b80: 2020 2020 3a74 7970 6520 6c61 6265 6c73      :type labels
-00000b90: 3a20 322d 7475 706c 6520 6f66 2073 7472  : 2-tuple of str
-00000ba0: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
-00000bb0: 2020 203a 7061 7261 6d20 7365 6564 3a20     :param seed: 
-00000bc0: 7261 6e64 6f6d 206e 756d 6265 7220 7365  random number se
-00000bd0: 6564 2066 6f72 2070 726f 6a65 6374 696f  ed for projectio
-00000be0: 6e20 6e6f 6973 652c 2064 6566 6175 6c74  n noise, default
-00000bf0: 7320 746f 204e 6f6e 650a 2020 2020 2020  s to None.      
-00000c00: 2020 3a74 7970 6520 7365 6564 3a20 696e    :type seed: in
-00000c10: 742c 206f 7074 696f 6e61 6c0a 2020 2020  t, optional.    
-00000c20: 2020 2020 3a72 6169 7365 7320 5479 7065      :raises Type
-00000c30: 4572 726f 723a 206e 616d 6520 6d75 7374  Error: name must
-00000c40: 2062 6520 6120 7374 7269 6e67 0a20 2020   be a string.   
-00000c50: 2020 2020 203a 7261 6973 6573 2054 7970       :raises Typ
-00000c60: 6545 7272 6f72 3a20 6361 6d74 7970 6520  eError: camtype 
-00000c70: 6d75 7374 2062 6520 6120 7374 7269 6e67  must be a string
-00000c80: 0a20 2020 2020 2020 203a 7261 6973 6573  .        :raises
-00000c90: 2056 616c 7565 4572 726f 723a 2072 686f   ValueError: rho
-00000ca0: 206d 7573 7420 6265 2061 2031 2d20 6f72   must be a 1- or
-00000cb0: 2032 2d65 6c65 6d65 6e74 2076 6563 746f   2-element vecto
-00000cc0: 720a 0a20 2020 2020 2020 2054 6869 7320  r..        This 
-00000cd0: 6162 7374 7261 6374 2063 6c61 7373 2069  abstract class i
-00000ce0: 7320 7468 6520 6261 7365 2066 6f72 2061  s the base for a
-00000cf0: 6c6c 2063 616d 6572 6120 7072 6f6a 6563  ll camera projec
-00000d00: 7469 6f6e 206d 6f64 656c 0a20 2020 2020  tion model.     
-00000d10: 2020 2063 6c61 7373 6573 2e20 2041 6c6c     classes.  All
-00000d20: 2062 6173 6563 6c61 7373 2063 6f6e 7374   baseclass const
-00000d30: 7275 6374 6f72 7320 7375 7070 6f72 7420  ructors support 
-00000d40: 7468 6573 6520 6f70 7469 6f6e 732e 0a20  these options.. 
-00000d50: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00000d60: 2020 2069 6620 6e61 6d65 2069 7320 4e6f     if name is No
-00000d70: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00000d80: 7365 6c66 2e5f 6e61 6d65 203d 2063 616d  self._name = cam
-00000d90: 7479 7065 0a20 2020 2020 2020 2065 6c73  type.        els
-00000da0: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
-00000db0: 6620 6e6f 7420 6973 696e 7374 616e 6365  f not isinstance
-00000dc0: 286e 616d 652c 2073 7472 293a 0a20 2020  (name, str):.   
-00000dd0: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-00000de0: 7365 2054 7970 6545 7272 6f72 286e 616d  se TypeError(nam
-00000df0: 652c 2027 6e61 6d65 206d 7573 7420 6265  e, 'name must be
-00000e00: 2061 2073 7472 696e 6727 290a 2020 2020   a string').    
-00000e10: 2020 2020 2020 2020 7365 6c66 2e5f 6e61          self._na
-00000e20: 6d65 203d 206e 616d 650a 0a20 2020 2020  me = name..     
-00000e30: 2020 2069 6620 6e6f 7420 6973 696e 7374     if not isinst
-00000e40: 616e 6365 2863 616d 7479 7065 2c20 7374  ance(camtype, st
-00000e50: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00000e60: 7261 6973 6520 5479 7065 4572 726f 7228  raise TypeError(
-00000e70: 6361 6d74 7970 652c 2027 6361 6d74 7970  camtype, 'camtyp
-00000e80: 6520 6d75 7374 2062 6520 6120 7374 7269  e must be a stri
-00000e90: 6e67 2729 0a20 2020 2020 2020 2073 656c  ng').        sel
-00000ea0: 662e 5f63 616d 7479 7065 203d 2063 616d  f._camtype = cam
-00000eb0: 7479 7065 0a0a 2020 2020 2020 2020 6966  type..        if
-00000ec0: 2069 6d61 6765 7369 7a65 2069 7320 4e6f   imagesize is No
-00000ed0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00000ee0: 6966 2070 7020 6973 204e 6f6e 653a 0a20  if pp is None:. 
-00000ef0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00000f00: 656c 662e 7070 203d 2028 302c 2030 290a  elf.pp = (0, 0).
-00000f10: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00000f20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00000f30: 2020 7365 6c66 2e70 7020 3d20 7070 0a20    self.pp = pp. 
-00000f40: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00000f50: 2020 2020 2020 2020 2073 656c 662e 696d           self.im
-00000f60: 6167 6573 697a 6520 3d20 696d 6167 6573  agesize = images
-00000f70: 697a 650a 2020 2020 2020 2020 2020 2020  ize.            
-00000f80: 6966 2070 7020 6973 204e 6f6e 653a 0a20  if pp is None:. 
-00000f90: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00000fa0: 656c 662e 7070 203d 205b 7820 2f20 3220  elf.pp = [x / 2 
-00000fb0: 666f 7220 7820 696e 2073 656c 662e 696d  for x in self.im
-00000fc0: 6167 6573 697a 655d 0a20 2020 2020 2020  agesize].       
-00000fd0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00000fe0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00000ff0: 7070 203d 2070 700a 0a20 2020 2020 2020  pp = pp..       
-00001000: 2069 6620 7365 6e73 6f72 7369 7a65 2069   if sensorsize i
-00001010: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-00001020: 2020 2020 2020 2020 7365 6c66 2e5f 7268          self._rh
-00001030: 6f75 203d 2073 656e 736f 7273 697a 655b  ou = sensorsize[
-00001040: 305d 202f 2073 656c 662e 696d 6167 6573  0] / self.images
-00001050: 697a 655b 315d 0a20 2020 2020 2020 2020  ize[1].         
-00001060: 2020 2073 656c 662e 5f72 686f 7620 3d20     self._rhov = 
-00001070: 7365 6e73 6f72 7369 7a65 5b31 5d20 2f20  sensorsize[1] / 
-00001080: 7365 6c66 2e69 6d61 6765 7369 7a65 5b30  self.imagesize[0
-00001090: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
-000010a0: 2020 2020 2020 2020 2020 2020 7268 6f20              rho 
-000010b0: 3d20 6261 7365 2e67 6574 7665 6374 6f72  = base.getvector
-000010c0: 2872 686f 290a 2020 2020 2020 2020 2020  (rho).          
-000010d0: 2020 6966 206c 656e 2872 686f 2920 3d3d    if len(rho) ==
-000010e0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-000010f0: 2020 2020 7365 6c66 2e5f 7268 6f75 203d      self._rhou =
-00001100: 2072 686f 5b30 5d0a 2020 2020 2020 2020   rho[0].        
-00001110: 2020 2020 2020 2020 7365 6c66 2e5f 7268          self._rh
-00001120: 6f76 203d 2072 686f 5b30 5d0a 2020 2020  ov = rho[0].    
-00001130: 2020 2020 2020 2020 656c 6966 206c 656e          elif len
-00001140: 2872 686f 2920 3d3d 2032 3a0a 2020 2020  (rho) == 2:.    
-00001150: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00001160: 2e5f 7268 6f75 203d 2072 686f 5b30 5d0a  ._rhou = rho[0].
-00001170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001180: 7365 6c66 2e5f 7268 6f76 203d 2072 686f  self._rhov = rho
-00001190: 5b31 5d0a 2020 2020 2020 2020 2020 2020  [1].            
-000011a0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-000011b0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-000011c0: 6545 7272 6f72 2872 686f 2c20 2772 686f  eError(rho, 'rho
-000011d0: 206d 7573 7420 6265 2061 2031 2d20 6f72   must be a 1- or
-000011e0: 2032 2d65 6c65 6d65 6e74 2076 6563 746f   2-element vecto
-000011f0: 7227 290a 0a20 2020 2020 2020 2069 6620  r')..        if 
-00001200: 6e6f 6973 6520 6973 206e 6f74 204e 6f6e  noise is not Non
-00001210: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
-00001220: 656c 662e 5f6e 6f69 7365 203d 206e 6f69  elf._noise = noi
-00001230: 7365 0a0a 2020 2020 2020 2020 7365 6c66  se..        self
-00001240: 2e5f 7261 6e64 6f6d 203d 206e 702e 7261  ._random = np.ra
-00001250: 6e64 6f6d 2e64 6566 6175 6c74 5f72 6e67  ndom.default_rng
-00001260: 2873 6565 6429 0a20 2020 2020 2020 2020  (seed).         
-00001270: 2020 200a 2020 2020 2020 2020 6966 2070     .        if p
-00001280: 6f73 6520 6973 204e 6f6e 653a 0a20 2020  ose is None:.   
-00001290: 2020 2020 2020 2020 2073 656c 662e 5f70           self._p
-000012a0: 6f73 6520 3d20 5345 3328 290a 2020 2020  ose = SE3().    
-000012b0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000012c0: 2020 2020 2020 7365 6c66 2e5f 706f 7365        self._pose
-000012d0: 203d 2053 4533 2870 6f73 6529 0a0a 2020   = SE3(pose)..  
-000012e0: 2020 2020 2020 7365 6c66 2e70 6f73 6530        self.pose0
-000012f0: 203d 2073 656c 662e 706f 7365 0a0a 2020   = self.pose..  
-00001300: 2020 2020 2020 7365 6c66 2e5f 6e6f 6973        self._nois
-00001310: 6520 3d20 6e6f 6973 650a 0a20 2020 2020  e = noise..     
-00001320: 2020 2073 656c 662e 5f69 6d61 6765 203d     self._image =
-00001330: 204e 6f6e 650a 0a20 2020 2020 2020 2073   None..        s
-00001340: 656c 662e 5f61 7820 3d20 4e6f 6e65 0a0a  elf._ax = None..
-00001350: 2020 2020 2020 2020 7365 6c66 2e5f 6469          self._di
-00001360: 7374 6f72 7469 6f6e 203d 204e 6f6e 650a  stortion = None.
-00001370: 2020 2020 2020 2020 7365 6c66 2e6c 6162          self.lab
-00001380: 656c 7320 3d20 6c61 6265 6c73 0a20 2020  els = labels.   
-00001390: 2020 2020 2073 656c 662e 6c69 6d69 7473       self.limits
-000013a0: 203d 206c 696d 6974 730a 0a20 2020 2064   = limits..    d
-000013b0: 6566 2072 6573 6574 2873 656c 6629 3a0a  ef reset(self):.
-000013c0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-000013d0: 2020 2020 5265 7365 7420 6361 6d65 7261      Reset camera
-000013e0: 2070 6f73 6520 2862 6173 6520 6d65 7468   pose (base meth
-000013f0: 6f64 290a 0a20 2020 2020 2020 2052 6573  od)..        Res
-00001400: 746f 7265 2063 616d 6572 6120 746f 2061  tore camera to a
-00001410: 2063 6f70 7920 6f66 2074 6865 2070 6f73   copy of the pos
-00001420: 6520 6769 7665 6e20 746f 2074 6865 2063  e given to the c
-00001430: 6f6e 7374 7275 6374 6f72 2e20 2054 6865  onstructor.  The
-00001440: 2063 6f70 790a 2020 2020 2020 2020 6d65   copy.        me
-00001450: 616e 7320 7468 6174 2074 6865 2063 616d  ans that the cam
-00001460: 6572 6120 706f 7365 2063 616e 2062 6520  era pose can be 
-00001470: 6d6f 6469 6669 6564 2066 7265 656c 792c  modified freely,
-00001480: 2077 6974 686f 7574 2064 6573 7472 6f79   without destroy
-00001490: 696e 670a 2020 2020 2020 2020 7468 6520  ing.        the 
-000014a0: 696e 6974 6961 6c20 706f 7365 2076 616c  initial pose val
-000014b0: 7565 2e0a 2020 2020 2020 2020 2222 220a  ue..        """.
-000014c0: 2020 2020 2020 2020 7365 6c66 2e70 6f73          self.pos
-000014d0: 6520 3d20 7365 6c66 2e70 6f73 6530 2e63  e = self.pose0.c
-000014e0: 6f70 7928 290a 0a20 2020 2064 6566 205f  opy()..    def _
-000014f0: 5f73 7472 5f5f 2873 656c 6629 3a0a 2020  _str__(self):.  
-00001500: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00001510: 2020 5374 7269 6e67 2072 6570 7265 7365    String represe
-00001520: 6e74 6174 696f 6e20 6f66 2063 616d 6572  ntation of camer
-00001530: 6120 7061 7261 6d65 7465 7273 2028 6261  a parameters (ba
-00001540: 7365 206d 6574 686f 6429 0a0a 2020 2020  se method)..    
-00001550: 2020 2020 3a72 6574 7572 6e3a 2073 7472      :return: str
-00001560: 696e 6720 7265 7072 6573 656e 7461 7469  ing representati
-00001570: 6f6e 0a20 2020 2020 2020 203a 7274 7970  on.        :rtyp
-00001580: 653a 2073 7472 0a0a 2020 2020 2020 2020  e: str..        
-00001590: 4d75 6c74 692d 6c69 6e65 2073 7472 696e  Multi-line strin
-000015a0: 6720 7265 7072 6573 656e 7461 7469 6f6e  g representation
-000015b0: 206f 6620 6361 6d65 7261 2069 6e74 7269   of camera intri
-000015c0: 6e73 6963 2061 6e64 2065 7874 7269 6e73  nsic and extrins
-000015d0: 6963 0a20 2020 2020 2020 2070 6172 616d  ic.        param
-000015e0: 6574 6572 732e 0a20 2020 2020 2020 2022  eters..        "
-000015f0: 2222 0a20 2020 2020 2020 2023 2054 4f44  "".        # TOD
-00001600: 4f2c 2069 6d61 6765 7369 7a65 2073 686f  O, imagesize sho
-00001610: 756c 6420 6265 2069 6e74 6567 6572 730a  uld be integers.
-00001620: 2020 2020 2020 2020 7320 3d20 2727 0a20          s = ''. 
-00001630: 2020 2020 2020 2073 656c 662e 666d 7420         self.fmt 
-00001640: 3d20 277b 3a3e 3135 737d 3a20 7b7d 5c6e  = '{:>15s}: {}\n
-00001650: 270a 2020 2020 2020 2020 7320 2b3d 2073  '.        s += s
-00001660: 656c 662e 666d 742e 666f 726d 6174 2827  elf.fmt.format('
-00001670: 4e61 6d65 272c 2073 656c 662e 6e61 6d65  Name', self.name
-00001680: 202b 2027 205b 2720 2b20 7365 6c66 2e5f   + ' [' + self._
-00001690: 5f63 6c61 7373 5f5f 2e5f 5f6e 616d 655f  _class__.__name_
-000016a0: 5f20 2b20 275d 2729 0a20 2020 2020 2020  _ + ']').       
-000016b0: 2073 202b 3d20 7365 6c66 2e66 6d74 2e66   s += self.fmt.f
-000016c0: 6f72 6d61 7428 2770 6978 656c 2073 697a  ormat('pixel siz
-000016d0: 6527 2c20 2720 7820 272e 6a6f 696e 285b  e', ' x '.join([
-000016e0: 7374 7228 7829 2066 6f72 2078 2069 6e20  str(x) for x in 
-000016f0: 7365 6c66 2e72 686f 5d29 290a 2020 2020  self.rho])).    
-00001700: 2020 2020 6966 2073 656c 662e 696d 6167      if self.imag
-00001710: 6573 697a 6520 6973 206e 6f74 204e 6f6e  esize is not Non
-00001720: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
-00001730: 202b 3d20 7365 6c66 2e66 6d74 2e66 6f72   += self.fmt.for
-00001740: 6d61 7428 2769 6d61 6765 2073 697a 6527  mat('image size'
-00001750: 2c20 2720 7820 272e 6a6f 696e 285b 7374  , ' x '.join([st
-00001760: 7228 7829 2066 6f72 2078 2069 6e20 7365  r(x) for x in se
-00001770: 6c66 2e69 6d61 6765 7369 7a65 5d29 290a  lf.imagesize])).
-00001780: 2020 2020 2020 2020 7320 2b3d 2073 656c          s += sel
-00001790: 662e 666d 742e 666f 726d 6174 2827 706f  f.fmt.format('po
-000017a0: 7365 272c 2073 656c 662e 706f 7365 2e73  se', self.pose.s
-000017b0: 7472 6c69 6e65 2866 6d74 3d22 7b3a 2e33  trline(fmt="{:.3
-000017c0: 677d 222c 206f 7269 656e 743d 2272 7079  g}", orient="rpy
-000017d0: 2f79 787a 2229 290a 2020 2020 2020 2020  /yxz")).        
-000017e0: 7265 7475 726e 2073 0a0a 2020 2020 6465  return s..    de
-000017f0: 6620 5f5f 7265 7072 5f5f 2873 656c 6629  f __repr__(self)
-00001800: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-00001810: 2020 2020 2020 5265 6164 6162 6c65 2072        Readable r
-00001820: 6570 7265 7365 6e74 6174 696f 206f 6620  epresentatio of 
-00001830: 6361 6d65 7261 2070 6172 616d 6574 6572  camera parameter
-00001840: 7320 2862 6173 6520 6d65 7468 6f64 290a  s (base method).
-00001850: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
-00001860: 3a20 7374 7269 6e67 2072 6570 7265 7365  : string represe
-00001870: 6e74 6174 696f 6e0a 2020 2020 2020 2020  ntation.        
-00001880: 3a72 7479 7065 3a20 7374 720a 0a20 2020  :rtype: str..   
-00001890: 2020 2020 204d 756c 7469 2d6c 696e 6520       Multi-line 
-000018a0: 7374 7269 6e67 2072 6570 7265 7365 6e74  string represent
-000018b0: 6174 696f 6e20 6f66 2063 616d 6572 6120  ation of camera 
-000018c0: 696e 7472 696e 7369 6320 616e 6420 6578  intrinsic and ex
-000018d0: 7472 696e 7369 630a 2020 2020 2020 2020  trinsic.        
-000018e0: 7061 7261 6d65 7465 7273 2e0a 2020 2020  parameters..    
-000018f0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00001900: 7265 7475 726e 2073 7472 2873 656c 6629  return str(self)
-00001910: 0a20 2020 2020 2020 200a 2020 2020 4061  .        .    @a
-00001920: 6273 7472 6163 746d 6574 686f 640a 2020  bstractmethod.  
-00001930: 2020 6465 6620 7072 6f6a 6563 745f 706f    def project_po
-00001940: 696e 7428 7365 6c66 2c20 502c 202a 2a6b  int(self, P, **k
-00001950: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-00001960: 7061 7373 0a0a 2020 2020 6465 6620 7072  pass..    def pr
-00001970: 6f6a 6563 745f 6c69 6e65 2873 656c 662c  oject_line(self,
-00001980: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
-00001990: 293a 0a20 2020 2020 2020 2072 6169 7365  ):.        raise
-000019a0: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
-000019b0: 7272 6f72 2827 6e6f 7420 696d 706c 656d  rror('not implem
-000019c0: 656e 7465 6420 666f 7220 7468 6973 2063  ented for this c
-000019d0: 616d 6572 6120 6d6f 6465 6c27 290a 0a20  amera model').. 
-000019e0: 2020 2064 6566 2070 726f 6a65 6374 5f63     def project_c
-000019f0: 6f6e 6963 2873 656c 662c 202a 6172 6773  onic(self, *args
-00001a00: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
-00001a10: 2020 2020 2072 6169 7365 204e 6f74 496d       raise NotIm
-00001a20: 706c 656d 656e 7465 6445 7272 6f72 2827  plementedError('
-00001a30: 6e6f 7420 696d 706c 656d 656e 7465 6420  not implemented 
-00001a40: 666f 7220 7468 6973 2063 616d 6572 6120  for this camera 
-00001a50: 6d6f 6465 6c27 290a 0a20 2020 2040 7072  model')..    @pr
-00001a60: 6f70 6572 7479 0a20 2020 2064 6566 206e  operty.    def n
-00001a70: 616d 6528 7365 6c66 293a 0a20 2020 2020  ame(self):.     
-00001a80: 2020 2022 2222 0a20 2020 2020 2020 2053     """.        S
-00001a90: 6574 2f67 6574 2063 616d 6572 6120 6e61  et/get camera na
-00001aa0: 6d65 2028 6261 7365 206d 6574 686f 6429  me (base method)
-00001ab0: 0a0a 2020 2020 2020 2020 4120 6361 6d65  ..        A came
-00001ac0: 7261 2068 6173 2061 2073 7472 696e 672d  ra has a string-
-00001ad0: 7661 6c75 6564 206e 616d 6520 7468 6174  valued name that
-00001ae0: 2063 616e 2062 6520 7265 6164 2061 6e64   can be read and
-00001af0: 2077 7269 7474 656e 2e0a 0a20 2020 2020   written...     
-00001b00: 2020 2045 7861 6d70 6c65 3a0a 0a20 2020     Example:..   
-00001b10: 2020 2020 202e 2e20 7275 6e62 6c6f 636b       .. runblock
-00001b20: 3a3a 2070 7963 6f6e 0a0a 2020 2020 2020  :: pycon..      
-00001b30: 2020 2020 2020 3e3e 3e20 6672 6f6d 206d        >>> from m
-00001b40: 6163 6869 6e65 7669 7369 6f6e 746f 6f6c  achinevisiontool
-00001b50: 626f 7820 696d 706f 7274 2043 656e 7472  box import Centr
-00001b60: 616c 4361 6d65 7261 0a20 2020 2020 2020  alCamera.       
-00001b70: 2020 2020 203e 3e3e 2063 616d 6572 6120       >>> camera 
-00001b80: 3d20 4365 6e74 7261 6c43 616d 6572 6128  = CentralCamera(
-00001b90: 293b 0a20 2020 2020 2020 2020 2020 203e  );.            >
-00001ba0: 3e3e 2063 616d 6572 612e 6e61 6d65 0a20  >> camera.name. 
-00001bb0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-00001bc0: 616d 6572 612e 6e61 6d65 203d 2022 666f  amera.name = "fo
-00001bd0: 6f22 0a20 2020 2020 2020 2020 2020 203e  o".            >
-00001be0: 3e3e 2063 616d 6572 612e 6e61 6d65 0a20  >> camera.name. 
-00001bf0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00001c00: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00001c10: 6e61 6d65 0a0a 2020 2020 406e 616d 652e  name..    @name.
-00001c20: 7365 7474 6572 0a20 2020 2064 6566 206e  setter.    def n
-00001c30: 616d 6528 7365 6c66 2c20 6e65 776e 616d  ame(self, newnam
-00001c40: 6529 3a0a 2020 2020 2020 2020 2222 220a  e):.        """.
-00001c50: 2020 2020 2020 2020 5365 7420 6361 6d65          Set came
-00001c60: 7261 206e 616d 650a 0a20 2020 2020 2020  ra name..       
-00001c70: 203a 7061 7261 6d20 6e65 776e 616d 653a   :param newname:
-00001c80: 2063 616d 6572 6120 6e61 6d65 0a20 2020   camera name.   
-00001c90: 2020 2020 203a 7479 7065 206e 6577 6e61       :type newna
-00001ca0: 6d65 3a20 7374 720a 2020 2020 2020 2020  me: str.        
-00001cb0: 2222 220a 2020 2020 2020 2020 6966 2069  """.        if i
-00001cc0: 7369 6e73 7461 6e63 6528 6e65 776e 616d  sinstance(newnam
-00001cd0: 652c 2073 7472 293a 0a20 2020 2020 2020  e, str):.       
-00001ce0: 2020 2020 2073 656c 662e 5f6e 616d 6520       self._name 
-00001cf0: 3d20 6e65 776e 616d 650a 2020 2020 2020  = newname.      
-00001d00: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00001d10: 2020 2020 7261 6973 6520 5479 7065 4572      raise TypeEr
-00001d20: 726f 7228 6e65 776e 616d 652c 2027 6e61  ror(newname, 'na
-00001d30: 6d65 206d 7573 7420 6265 2061 2073 7472  me must be a str
-00001d40: 696e 6727 290a 0a20 2020 2040 7072 6f70  ing')..    @prop
-00001d50: 6572 7479 0a20 2020 2064 6566 2063 616d  erty.    def cam
-00001d60: 7479 7065 2873 656c 6629 3a0a 2020 2020  type(self):.    
-00001d70: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00001d80: 5365 742f 6765 7420 6361 6d65 7261 2074  Set/get camera t
-00001d90: 7970 6520 2862 6173 6520 6d65 7468 6f64  ype (base method
-00001da0: 290a 0a20 2020 2020 2020 2041 2063 616d  )..        A cam
-00001db0: 6572 6120 6861 7320 6120 7374 7269 6e67  era has a string
-00001dc0: 2d76 616c 7565 6420 7479 7065 2074 6861  -valued type tha
-00001dd0: 7420 6361 6e20 6265 2072 6561 6420 616e  t can be read an
-00001de0: 6420 7772 6974 7465 6e2e 2020 5468 6973  d written.  This
-00001df0: 0a20 2020 2020 2020 2069 7320 756e 6971  .        is uniq
-00001e00: 7565 2074 6f20 7468 6520 6361 6d65 7261  ue to the camera
-00001e10: 2073 7562 636c 6173 7320 616e 6420 7072   subclass and pr
-00001e20: 6f6a 6563 7469 6f6e 206d 6f64 656c 2e0a  ojection model..
-00001e30: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
-00001e40: 3a0a 0a20 2020 2020 2020 202e 2e20 7275  :..        .. ru
-00001e50: 6e62 6c6f 636b 3a3a 2070 7963 6f6e 0a0a  nblock:: pycon..
-00001e60: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00001e70: 6672 6f6d 206d 6163 6869 6e65 7669 7369  from machinevisi
-00001e80: 6f6e 746f 6f6c 626f 7820 696d 706f 7274  ontoolbox import
-00001e90: 2043 656e 7472 616c 4361 6d65 7261 0a20   CentralCamera. 
-00001ea0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-00001eb0: 616d 6572 6120 3d20 4365 6e74 7261 6c43  amera = CentralC
-00001ec0: 616d 6572 6128 293b 0a20 2020 2020 2020  amera();.       
-00001ed0: 2020 2020 203e 3e3e 2063 616d 6572 612e       >>> camera.
-00001ee0: 6361 6d74 7970 650a 2020 2020 2020 2020  camtype.        
-00001ef0: 2020 2020 3e3e 3e20 6361 6d65 7261 2e63      >>> camera.c
-00001f00: 616d 7479 7065 203d 2022 666f 6f22 0a20  amtype = "foo". 
-00001f10: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-00001f20: 616d 6572 612e 6361 6d74 7970 650a 2020  amera.camtype.  
-00001f30: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00001f40: 2020 7265 7475 726e 2073 656c 662e 5f63    return self._c
-00001f50: 616d 7479 7065 0a0a 2020 2020 4063 616d  amtype..    @cam
-00001f60: 7479 7065 2e73 6574 7465 720a 2020 2020  type.setter.    
-00001f70: 6465 6620 6361 6d74 7970 6528 7365 6c66  def camtype(self
-00001f80: 2c20 6e65 7763 616d 7479 7065 293a 0a20  , newcamtype):. 
-00001f90: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00001fa0: 2020 2053 6574 2063 616d 6572 6120 7479     Set camera ty
-00001fb0: 7065 0a0a 2020 2020 2020 2020 3a70 6172  pe..        :par
-00001fc0: 616d 206e 6577 6361 6d74 7970 653a 2063  am newcamtype: c
-00001fd0: 616d 6572 6120 7072 6f6a 6563 7469 6f6e  amera projection
-00001fe0: 2074 7970 650a 2020 2020 2020 2020 3a74   type.        :t
-00001ff0: 7970 6520 6e65 7763 616d 7479 7065 3a20  ype newcamtype: 
-00002000: 7374 720a 2020 2020 2020 2020 2222 220a  str.        """.
-00002010: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-00002020: 7461 6e63 6528 6e65 7763 616d 7479 7065  tance(newcamtype
-00002030: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
-00002040: 2020 2020 7365 6c66 2e5f 6361 6d74 7970      self._camtyp
-00002050: 6520 3d20 6e65 7763 616d 7479 7065 0a20  e = newcamtype. 
-00002060: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00002070: 2020 2020 2020 2020 2072 6169 7365 2054           raise T
-00002080: 7970 6545 7272 6f72 286e 6577 6361 6d74  ypeError(newcamt
-00002090: 7970 652c 2027 6361 6d74 7970 6520 6d75  ype, 'camtype mu
-000020a0: 7374 2062 6520 6120 7374 7269 6e67 2729  st be a string')
-000020b0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-000020c0: 2020 2020 6465 6620 696d 6167 6573 697a      def imagesiz
-000020d0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
-000020e0: 2022 2222 0a20 2020 2020 2020 2053 6574   """.        Set
-000020f0: 2f67 6574 2073 697a 6520 6f66 2076 6972  /get size of vir
-00002100: 7475 616c 2069 6d61 6765 2070 6c61 6e65  tual image plane
-00002110: 2028 6261 7365 206d 6574 686f 6429 0a0a   (base method)..
-00002120: 2020 2020 2020 2020 5468 6520 6469 6d65          The dime
-00002130: 6e73 696f 6e73 206f 6620 7468 6520 7669  nsions of the vi
-00002140: 7274 7561 6c20 696d 6167 6520 706c 616e  rtual image plan
-00002150: 6520 6973 2061 2032 2d74 7570 6c65 2c20  e is a 2-tuple, 
-00002160: 7769 6474 6820 616e 640a 2020 2020 2020  width and.      
-00002170: 2020 6865 6967 6874 2c20 7468 6174 2063    height, that c
-00002180: 616e 2062 6520 7265 6164 206f 7220 7772  an be read or wr
-00002190: 6974 7465 6e2e 2020 466f 7220 7772 6974  itten.  For writ
-000021a0: 696e 6720 7468 6520 7369 7a65 206d 7573  ing the size mus
-000021b0: 7420 6265 2061 6e0a 2020 2020 2020 2020  t be an.        
-000021c0: 6974 6572 6162 6c65 206f 6620 6c65 6e67  iterable of leng
-000021d0: 7468 2032 2e0a 0a20 2020 2020 2020 2045  th 2...        E
-000021e0: 7861 6d70 6c65 3a0a 0a20 2020 2020 2020  xample:..       
-000021f0: 202e 2e20 7275 6e62 6c6f 636b 3a3a 2070   .. runblock:: p
-00002200: 7963 6f6e 0a0a 2020 2020 2020 2020 2020  ycon..          
-00002210: 2020 3e3e 3e20 6672 6f6d 206d 6163 6869    >>> from machi
-00002220: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
-00002230: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
-00002240: 6d65 7261 0a20 2020 2020 2020 2020 2020  mera.           
-00002250: 203e 3e3e 2063 616d 6572 6120 3d20 4365   >>> camera = Ce
-00002260: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
-00002270: 756c 7428 293b 0a20 2020 2020 2020 2020  ult();.         
-00002280: 2020 203e 3e3e 2063 616d 6572 612e 696d     >>> camera.im
-00002290: 6167 6573 697a 650a 2020 2020 2020 2020  agesize.        
-000022a0: 2020 2020 3e3e 3e20 6361 6d65 7261 2e69      >>> camera.i
-000022b0: 6d61 6765 7369 7a65 203d 2028 3530 302c  magesize = (500,
-000022c0: 2035 3030 290a 2020 2020 2020 2020 2020   500).          
-000022d0: 2020 3e3e 3e20 6361 6d65 7261 2e69 6d61    >>> camera.ima
-000022e0: 6765 7369 7a65 0a0a 2020 2020 2020 2020  gesize..        
-000022f0: 3a6e 6f74 653a 2049 6620 7468 6520 7072  :note: If the pr
-00002300: 696e 6369 7061 6c20 706f 696e 7420 6973  incipal point is
-00002310: 206e 6f74 2073 6574 2c20 7468 656e 2073   not set, then s
-00002320: 6574 7469 6e67 2069 6d61 6765 7369 7a65  etting imagesize
-00002330: 0a20 2020 2020 2020 2020 2020 2073 6574  .            set
-00002340: 7320 7468 6520 7072 696e 6369 7061 6c20  s the principal 
-00002350: 706f 696e 7420 746f 2074 6865 2063 656e  point to the cen
-00002360: 7472 6520 6f66 2074 6865 2069 6d61 6765  tre of the image
-00002370: 2070 6c61 6e65 2e0a 0a20 2020 2020 2020   plane...       
-00002380: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
-00002390: 3a60 7769 6474 6860 203a 6d65 7468 3a60  :`width` :meth:`
-000023a0: 6865 6967 6874 6020 3a6d 6574 683a 606e  height` :meth:`n
-000023b0: 7560 203a 6d65 7468 3a60 6e76 600a 2020  u` :meth:`nv`.  
-000023c0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-000023d0: 2020 7265 7475 726e 2073 656c 662e 5f69    return self._i
-000023e0: 6d61 6765 7369 7a65 0a0a 2020 2020 4069  magesize..    @i
-000023f0: 6d61 6765 7369 7a65 2e73 6574 7465 720a  magesize.setter.
-00002400: 2020 2020 6465 6620 696d 6167 6573 697a      def imagesiz
-00002410: 6528 7365 6c66 2c20 6e70 6978 293a 0a20  e(self, npix):. 
-00002420: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00002430: 2020 2053 6574 2069 6d61 6765 2070 6c61     Set image pla
-00002440: 6e65 2073 697a 650a 0a20 2020 2020 2020  ne size..       
-00002450: 203a 7061 7261 6d20 6e70 6978 3a20 5b64   :param npix: [d
-00002460: 6573 6372 6970 7469 6f6e 5d0a 2020 2020  escription].    
-00002470: 2020 2020 3a74 7970 6520 6e70 6978 3a20      :type npix: 
-00002480: 6172 7261 795f 6c69 6b65 2832 290a 2020  array_like(2).  
-00002490: 2020 2020 2020 3a72 6169 7365 7320 5661        :raises Va
-000024a0: 6c75 6545 7272 6f72 3a20 6261 6420 7661  lueError: bad va
-000024b0: 6c75 650a 0a20 2020 2020 2020 2053 6574  lue..        Set
-000024c0: 7320 7468 6520 7369 7a65 206f 6620 7468  s the size of th
-000024d0: 6520 7669 7274 7561 6c20 696d 6167 6520  e virtual image 
-000024e0: 706c 616e 652e 0a20 2020 2020 2020 200a  plane..        .
-000024f0: 2020 2020 2020 2020 3a6e 6f74 653a 2049          :note: I
-00002500: 6620 7468 6520 7072 696e 6369 706c 6520  f the principle 
-00002510: 706f 696e 7420 6973 206e 6f74 2073 6574  point is not set
-00002520: 2c20 7468 656e 2069 740a 2020 2020 2020  , then it.      
-00002530: 2020 2020 2020 6973 2073 6574 2074 6f20        is set to 
-00002540: 7468 6520 6365 6e74 7265 206f 6620 7468  the centre of th
-00002550: 6520 696d 6167 6520 706c 616e 652e 0a0a  e image plane...
-00002560: 2020 2020 2020 2020 3a73 6565 616c 736f          :seealso
-00002570: 3a20 3a6d 6574 683a 6077 6964 7468 6020  : :meth:`width` 
-00002580: 3a6d 6574 683a 6068 6569 6768 7460 203a  :meth:`height` :
-00002590: 6d65 7468 3a60 6e75 6020 3a6d 6574 683a  meth:`nu` :meth:
-000025a0: 606e 7660 0a20 2020 2020 2020 2022 2222  `nv`.        """
-000025b0: 0a20 2020 2020 2020 206e 7069 7820 3d20  .        npix = 
-000025c0: 6261 7365 2e67 6574 7665 6374 6f72 286e  base.getvector(n
-000025d0: 7069 782c 2064 7479 7065 3d27 696e 7427  pix, dtype='int'
-000025e0: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
-000025f0: 286e 7069 7829 203d 3d20 313a 0a20 2020  (npix) == 1:.   
-00002600: 2020 2020 2020 2020 2073 656c 662e 5f69           self._i
-00002610: 6d61 6765 7369 7a65 203d 206e 702e 725f  magesize = np.r_
-00002620: 5b6e 7069 785b 305d 2c20 6e70 6978 5b30  [npix[0], npix[0
-00002630: 5d5d 0a20 2020 2020 2020 2065 6c69 6620  ]].        elif 
-00002640: 6c65 6e28 6e70 6978 2920 696e 2028 322c  len(npix) in (2,
-00002650: 2033 293a 0a20 2020 2020 2020 2020 2020   3):.           
-00002660: 2023 2069 676e 6f72 6520 636f 6c6f 7220   # ignore color 
-00002670: 6469 6d65 6e73 696f 6e20 696e 2063 6173  dimension in cas
-00002680: 6520 6974 2069 7320 6769 7665 6e0a 2020  e it is given.  
-00002690: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-000026a0: 696d 6167 6573 697a 6520 3d20 6e70 6978  imagesize = npix
-000026b0: 5b3a 325d 0a20 2020 2020 2020 2065 6c73  [:2].        els
-000026c0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-000026d0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-000026e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000026f0: 206e 7069 782c 2027 696d 6167 6573 697a   npix, 'imagesiz
-00002700: 6520 6d75 7374 2062 6520 6120 312d 206f  e must be a 1- o
-00002710: 7220 322d 656c 656d 656e 7420 7665 6374  r 2-element vect
-00002720: 6f72 2729 0a20 2020 2020 2020 2069 6620  or').        if 
-00002730: 7365 6c66 2e5f 7070 2069 7320 4e6f 6e65  self._pp is None
-00002740: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00002750: 6c66 2e5f 7070 203d 2073 656c 662e 5f69  lf._pp = self._i
-00002760: 6d61 6765 7369 7a65 202f 2032 0a0a 2020  magesize / 2..  
-00002770: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00002780: 6465 6620 6e75 2873 656c 6629 3a0a 2020  def nu(self):.  
-00002790: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-000027a0: 2020 4765 7420 696d 6167 6520 706c 616e    Get image plan
-000027b0: 6520 7769 6474 6820 2862 6173 6520 6d65  e width (base me
-000027c0: 7468 6f64 290a 0a20 2020 2020 2020 203a  thod)..        :
-000027d0: 7265 7475 726e 3a20 7769 6474 680a 2020  return: width.  
-000027e0: 2020 2020 2020 3a72 7479 7065 3a20 696e        :rtype: in
-000027f0: 740a 0a20 2020 2020 2020 204e 756d 6265  t..        Numbe
-00002800: 7220 6f66 2070 6978 656c 7320 696e 2074  r of pixels in t
-00002810: 6865 2075 2d64 6972 6563 7469 6f6e 2028  he u-direction (
-00002820: 7769 6474 6829 0a0a 2020 2020 2020 2020  width)..        
-00002830: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
-00002840: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
-00002850: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
-00002860: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
-00002870: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
-00002880: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
-00002890: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
-000028a0: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
-000028b0: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
-000028c0: 6175 6c74 2829 3b0a 2020 2020 2020 2020  ault();.        
-000028d0: 2020 2020 3e3e 3e20 6361 6d65 7261 2e6e      >>> camera.n
-000028e0: 750a 0a20 2020 2020 2020 203a 7365 6561  u..        :seea
-000028f0: 6c73 6f3a 203a 6d65 7468 3a60 6e76 6020  lso: :meth:`nv` 
-00002900: 3a6d 6574 683a 6077 6964 7468 6020 3a6d  :meth:`width` :m
-00002910: 6574 683a 6069 6d61 6765 7369 7a65 600a  eth:`imagesize`.
-00002920: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00002930: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00002940: 5f69 6d61 6765 7369 7a65 5b30 5d0a 0a20  _imagesize[0].. 
-00002950: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00002960: 2064 6566 206e 7628 7365 6c66 293a 0a20   def nv(self):. 
-00002970: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00002980: 2020 2047 6574 2069 6d61 6765 2070 6c61     Get image pla
-00002990: 6e65 2068 6569 6768 7420 2862 6173 6520  ne height (base 
-000029a0: 6d65 7468 6f64 290a 0a20 2020 2020 2020  method)..       
-000029b0: 203a 7265 7475 726e 3a20 6865 6967 6874   :return: height
-000029c0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-000029d0: 2069 6e74 0a0a 2020 2020 2020 2020 4e75   int..        Nu
-000029e0: 6d62 6572 206f 6620 7069 7865 6c73 2069  mber of pixels i
-000029f0: 6e20 7468 6520 762d 6469 7265 6374 696f  n the v-directio
-00002a00: 6e20 2868 6569 6768 7429 0a0a 2020 2020  n (height)..    
-00002a10: 2020 2020 4578 616d 706c 653a 0a0a 2020      Example:..  
-00002a20: 2020 2020 2020 2e2e 2072 756e 626c 6f63        .. runbloc
-00002a30: 6b3a 3a20 7079 636f 6e0a 0a20 2020 2020  k:: pycon..     
-00002a40: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
-00002a50: 6d61 6368 696e 6576 6973 696f 6e74 6f6f  machinevisiontoo
-00002a60: 6c62 6f78 2069 6d70 6f72 7420 4365 6e74  lbox import Cent
-00002a70: 7261 6c43 616d 6572 610a 2020 2020 2020  ralCamera.      
-00002a80: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
-00002a90: 203d 2043 656e 7472 616c 4361 6d65 7261   = CentralCamera
-00002aa0: 2e44 6566 6175 6c74 2829 3b0a 2020 2020  .Default();.    
-00002ab0: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-00002ac0: 7261 2e6e 760a 0a20 2020 2020 2020 203a  ra.nv..        :
-00002ad0: 7365 6561 6c73 6f3a 203a 6d65 7468 3a60  seealso: :meth:`
-00002ae0: 6e75 6020 3a6d 6574 683a 6068 6569 6768  nu` :meth:`heigh
-00002af0: 7460 2020 3a6d 6574 683a 6069 6d61 6765  t`  :meth:`image
-00002b00: 7369 7a65 600a 2020 2020 2020 2020 2222  size`.        ""
-00002b10: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-00002b20: 2073 656c 662e 5f69 6d61 6765 7369 7a65   self._imagesize
-00002b30: 5b31 5d0a 0a20 2020 2040 7072 6f70 6572  [1]..    @proper
-00002b40: 7479 0a20 2020 2064 6566 2077 6964 7468  ty.    def width
-00002b50: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00002b60: 2222 220a 2020 2020 2020 2020 4765 7420  """.        Get 
-00002b70: 696d 6167 6520 706c 616e 6520 7769 6474  image plane widt
-00002b80: 6820 2862 6173 6520 6d65 7468 6f64 290a  h (base method).
-00002b90: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
-00002ba0: 3a20 7769 6474 680a 2020 2020 2020 2020  : width.        
-00002bb0: 3a72 7479 7065 3a20 696e 740a 0a20 2020  :rtype: int..   
-00002bc0: 2020 2020 2049 6d61 6765 2070 6c61 6e65       Image plane
-00002bd0: 2068 6569 6768 742c 206e 756d 6265 7220   height, number 
-00002be0: 6f66 2070 6978 656c 7320 696e 2074 6865  of pixels in the
-00002bf0: 2076 2d64 6972 6563 7469 6f6e 0a0a 2020   v-direction..  
-00002c00: 2020 2020 2020 4578 616d 706c 653a 0a0a        Example:..
-00002c10: 2020 2020 2020 2020 2e2e 2072 756e 626c          .. runbl
-00002c20: 6f63 6b3a 3a20 7079 636f 6e0a 0a20 2020  ock:: pycon..   
-00002c30: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
-00002c40: 6d20 6d61 6368 696e 6576 6973 696f 6e74  m machinevisiont
-00002c50: 6f6f 6c62 6f78 2069 6d70 6f72 7420 4365  oolbox import Ce
-00002c60: 6e74 7261 6c43 616d 6572 610a 2020 2020  ntralCamera.    
-00002c70: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-00002c80: 7261 203d 2043 656e 7472 616c 4361 6d65  ra = CentralCame
-00002c90: 7261 2e44 6566 6175 6c74 2829 3b0a 2020  ra.Default();.  
-00002ca0: 2020 2020 2020 2020 2020 3e3e 3e20 6361            >>> ca
-00002cb0: 6d65 7261 2e77 6964 7468 0a0a 2020 2020  mera.width..    
-00002cc0: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
-00002cd0: 6574 683a 606e 7560 203a 6d65 7468 3a60  eth:`nu` :meth:`
-00002ce0: 6865 6967 6874 600a 2020 2020 2020 2020  height`.        
-00002cf0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00002d00: 726e 2073 656c 662e 5f69 6d61 6765 7369  rn self._imagesi
-00002d10: 7a65 5b30 5d0a 0a20 2020 2040 7072 6f70  ze[0]..    @prop
-00002d20: 6572 7479 0a20 2020 2064 6566 2068 6569  erty.    def hei
-00002d30: 6768 7428 7365 6c66 293a 0a20 2020 2020  ght(self):.     
-00002d40: 2020 2022 2222 0a20 2020 2020 2020 2047     """.        G
-00002d50: 6574 2069 6d61 6765 2070 6c61 6e65 2068  et image plane h
-00002d60: 6569 6768 7420 2862 6173 6520 6d65 7468  eight (base meth
-00002d70: 6f64 290a 0a20 2020 2020 2020 203a 7265  od)..        :re
-00002d80: 7475 726e 3a20 6865 6967 6874 0a20 2020  turn: height.   
-00002d90: 2020 2020 203a 7274 7970 653a 2069 6e74       :rtype: int
-00002da0: 0a0a 2020 2020 2020 2020 496d 6167 6520  ..        Image 
-00002db0: 706c 616e 6520 7769 6474 682c 206e 756d  plane width, num
-00002dc0: 6265 7220 6f66 2070 6978 656c 7320 696e  ber of pixels in
-00002dd0: 2074 6865 2075 2d64 6972 6563 7469 6f6e   the u-direction
-00002de0: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-00002df0: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
-00002e00: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
-00002e10: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00002e20: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
-00002e30: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
-00002e40: 7420 4365 6e74 7261 6c43 616d 6572 610a  t CentralCamera.
-00002e50: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00002e60: 6361 6d65 7261 203d 2043 656e 7472 616c  camera = Central
-00002e70: 4361 6d65 7261 2e44 6566 6175 6c74 2829  Camera.Default()
-00002e80: 3b0a 2020 2020 2020 2020 2020 2020 3e3e  ;.            >>
-00002e90: 3e20 6361 6d65 7261 2e68 6569 6768 740a  > camera.height.
-00002ea0: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
-00002eb0: 6f3a 203a 6d65 7468 3a60 6e76 6020 3a6d  o: :meth:`nv` :m
-00002ec0: 6574 683a 6077 6964 7468 600a 2020 2020  eth:`width`.    
-00002ed0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00002ee0: 7265 7475 726e 2073 656c 662e 5f69 6d61  return self._ima
-00002ef0: 6765 7369 7a65 5b31 5d0a 0a20 2020 2040  gesize[1]..    @
-00002f00: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00002f10: 2070 7028 7365 6c66 293a 0a20 2020 2020   pp(self):.     
-00002f20: 2020 2022 2222 0a20 2020 2020 2020 2053     """.        S
-00002f30: 6574 2f67 6574 2070 7269 6e63 6970 616c  et/get principal
-00002f40: 2070 6f69 6e74 2063 6f6f 7264 696e 6174   point coordinat
-00002f50: 6520 2862 6173 6520 6d65 7468 6f64 290a  e (base method).
-00002f60: 0a20 2020 2020 2020 2054 6865 2070 7269  .        The pri
-00002f70: 6e63 6970 616c 2070 6f69 6e74 2069 7320  ncipal point is 
-00002f80: 7468 6520 636f 6f72 6469 6e61 7465 206f  the coordinate o
-00002f90: 6620 7468 6520 706f 696e 7420 7768 6572  f the point wher
-00002fa0: 650a 2020 2020 2020 2020 7468 6520 6f70  e.        the op
-00002fb0: 7469 6361 6c20 6178 6973 2070 6965 7263  tical axis pierc
-00002fc0: 6573 2074 6865 2069 6d61 6765 2070 6c61  es the image pla
-00002fd0: 6e65 2e20 2049 7420 6973 2061 2032 2d74  ne.  It is a 2-t
-00002fe0: 7570 6c65 2077 6869 6368 2063 616e 0a20  uple which can. 
-00002ff0: 2020 2020 2020 2062 6520 7265 6164 206f         be read o
-00003000: 7220 7772 6974 7465 6e2e 2020 466f 7220  r written.  For 
-00003010: 7772 6974 696e 6720 7468 6520 7369 7a65  writing the size
-00003020: 206d 7573 7420 6265 2061 6e0a 2020 2020   must be an.    
-00003030: 2020 2020 6974 6572 6162 6c65 206f 6620      iterable of 
-00003040: 6c65 6e67 7468 2032 2e0a 0a20 2020 2020  length 2...     
-00003050: 2020 2045 7861 6d70 6c65 3a0a 0a20 2020     Example:..   
-00003060: 2020 2020 202e 2e20 7275 6e62 6c6f 636b       .. runblock
-00003070: 3a3a 2070 7963 6f6e 0a0a 2020 2020 2020  :: pycon..      
-00003080: 2020 2020 2020 3e3e 3e20 6672 6f6d 206d        >>> from m
-00003090: 6163 6869 6e65 7669 7369 6f6e 746f 6f6c  achinevisiontool
-000030a0: 626f 7820 696d 706f 7274 2043 656e 7472  box import Centr
-000030b0: 616c 4361 6d65 7261 0a20 2020 2020 2020  alCamera.       
-000030c0: 2020 2020 203e 3e3e 2063 616d 6572 6120       >>> camera 
-000030d0: 3d20 4365 6e74 7261 6c43 616d 6572 612e  = CentralCamera.
-000030e0: 4465 6661 756c 7428 293b 0a20 2020 2020  Default();.     
-000030f0: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
-00003100: 612e 7070 0a0a 2020 2020 2020 2020 3a73  a.pp..        :s
-00003110: 6565 616c 736f 3a20 3a6d 6574 683a 6075  eealso: :meth:`u
-00003120: 3060 203a 6d65 7468 3a60 7630 600a 2020  0` :meth:`v0`.  
-00003130: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00003140: 2020 7265 7475 726e 2073 656c 662e 5f70    return self._p
-00003150: 700a 0a20 2020 2040 7070 2e73 6574 7465  p..    @pp.sette
-00003160: 720a 2020 2020 6465 6620 7070 2873 656c  r.    def pp(sel
-00003170: 662c 2070 7029 3a0a 2020 2020 2020 2020  f, pp):.        
-00003180: 2222 220a 2020 2020 2020 2020 5365 7420  """.        Set 
-00003190: 7072 696e 6369 7061 6c20 706f 696e 7420  principal point 
-000031a0: 636f 6f72 6469 6e61 7465 0a0a 2020 2020  coordinate..    
-000031b0: 2020 2020 3a70 6172 616d 2070 703a 2070      :param pp: p
-000031c0: 7269 6e63 6970 616c 2070 6f69 6e74 0a20  rincipal point. 
-000031d0: 2020 2020 2020 203a 7479 7065 2070 703a         :type pp:
-000031e0: 2061 7272 6179 5f6c 696b 6528 3229 0a0a   array_like(2)..
-000031f0: 2020 2020 2020 2020 3a73 6565 616c 736f          :seealso
-00003200: 3a20 3a6d 6574 683a 6070 7060 203a 6d65  : :meth:`pp` :me
-00003210: 7468 3a60 7530 6020 3a6d 6574 683a 6076  th:`u0` :meth:`v
-00003220: 3060 0a20 2020 2020 2020 2022 2222 0a20  0`.        """. 
-00003230: 2020 2020 2020 2070 7020 3d20 6261 7365         pp = base
-00003240: 2e67 6574 7665 6374 6f72 2870 7029 0a20  .getvector(pp). 
-00003250: 2020 2020 2020 2069 6620 6c65 6e28 7070         if len(pp
-00003260: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
-00003270: 2020 2020 7365 6c66 2e5f 7070 203d 206e      self._pp = n
-00003280: 702e 725f 5b70 705b 305d 2c20 7070 5b30  p.r_[pp[0], pp[0
-00003290: 5d5d 0a20 2020 2020 2020 2065 6c69 6620  ]].        elif 
-000032a0: 6c65 6e28 7070 2920 3d3d 2032 3a0a 2020  len(pp) == 2:.  
-000032b0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-000032c0: 7070 203d 2070 700a 2020 2020 2020 2020  pp = pp.        
-000032d0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-000032e0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-000032f0: 6f72 2870 702c 2027 7070 206d 7573 7420  or(pp, 'pp must 
-00003300: 6265 2061 2031 2d20 6f72 2032 2d65 6c65  be a 1- or 2-ele
-00003310: 6d65 6e74 2076 6563 746f 7227 290a 0a20  ment vector').. 
-00003320: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00003330: 2064 6566 2075 3028 7365 6c66 293a 0a20   def u0(self):. 
-00003340: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00003350: 2020 2047 6574 2070 7269 6e63 6970 616c     Get principal
-00003360: 2070 6f69 6e74 3a20 686f 7269 7a6f 6e74   point: horizont
-00003370: 616c 2063 6f6f 7264 696e 6174 6520 2862  al coordinate (b
-00003380: 6173 6520 6d65 7468 6f64 290a 0a20 2020  ase method)..   
-00003390: 2020 2020 203a 7265 7475 726e 3a20 686f       :return: ho
-000033a0: 7269 7a6f 6e74 616c 2063 6f6d 706f 6e65  rizontal compone
-000033b0: 6e74 206f 6620 7072 696e 6369 7061 6c20  nt of principal 
-000033c0: 706f 696e 740a 2020 2020 2020 2020 3a72  point.        :r
-000033d0: 7479 7065 3a20 666c 6f61 740a 0a20 2020  type: float..   
-000033e0: 2020 2020 2045 7861 6d70 6c65 3a0a 0a20       Example:.. 
-000033f0: 2020 2020 2020 202e 2e20 7275 6e62 6c6f         .. runblo
-00003400: 636b 3a3a 2070 7963 6f6e 0a0a 2020 2020  ck:: pycon..    
-00003410: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-00003420: 206d 6163 6869 6e65 7669 7369 6f6e 746f   machinevisionto
-00003430: 6f6c 626f 7820 696d 706f 7274 2043 656e  olbox import Cen
-00003440: 7472 616c 4361 6d65 7261 0a20 2020 2020  tralCamera.     
-00003450: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
-00003460: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
-00003470: 6128 293b 0a20 2020 2020 2020 2020 2020  a();.           
-00003480: 203e 3e3e 2063 616d 6572 612e 7530 0a0a   >>> camera.u0..
-00003490: 2020 2020 2020 2020 3a73 6565 616c 736f          :seealso
-000034a0: 3a20 3a6d 6574 683a 6076 3060 203a 6d65  : :meth:`v0` :me
-000034b0: 7468 3a60 7070 600a 2020 2020 2020 2020  th:`pp`.        
-000034c0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-000034d0: 726e 2073 656c 662e 5f70 705b 305d 0a0a  rn self._pp[0]..
-000034e0: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-000034f0: 2020 6465 6620 7630 2873 656c 6629 3a0a    def v0(self):.
-00003500: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00003510: 2020 2020 4765 7420 7072 696e 6369 7061      Get principa
-00003520: 6c20 706f 696e 743a 2076 6572 7469 6361  l point: vertica
-00003530: 6c20 636f 6f72 6469 6e61 7465 2028 6261  l coordinate (ba
-00003540: 7365 206d 6574 686f 6429 0a0a 2020 2020  se method)..    
-00003550: 2020 2020 3a72 6574 7572 6e3a 2076 6572      :return: ver
-00003560: 7469 6361 6c20 636f 6d70 6f6e 656e 7420  tical component 
-00003570: 6f66 2070 7269 6e63 6970 616c 2070 6f69  of principal poi
-00003580: 6e74 0a20 2020 2020 2020 203a 7274 7970  nt.        :rtyp
-00003590: 653a 2066 6c6f 6174 0a0a 2020 2020 2020  e: float..      
-000035a0: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
-000035b0: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-000035c0: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
-000035d0: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
-000035e0: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-000035f0: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
-00003600: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-00003610: 2020 2020 3e3e 3e20 6361 6d65 7261 203d      >>> camera =
-00003620: 2043 656e 7472 616c 4361 6d65 7261 2829   CentralCamera()
-00003630: 3b0a 2020 2020 2020 2020 2020 2020 3e3e  ;.            >>
-00003640: 3e20 6361 6d65 7261 2e76 300a 0a20 2020  > camera.v0..   
-00003650: 2020 2020 203a 7365 6561 6c73 6f3a 203a       :seealso: :
-00003660: 6d65 7468 3a60 7530 6020 3a6d 6574 683a  meth:`u0` :meth:
-00003670: 6070 7060 0a20 2020 2020 2020 2022 2222  `pp`.        """
-00003680: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00003690: 7365 6c66 2e5f 7070 5b31 5d0a 0a20 2020  self._pp[1]..   
-000036a0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-000036b0: 6566 2072 686f 7528 7365 6c66 293a 0a20  ef rhou(self):. 
-000036c0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-000036d0: 2020 2047 6574 2070 6978 656c 2077 6964     Get pixel wid
-000036e0: 7468 2028 6261 7365 206d 6574 686f 6429  th (base method)
-000036f0: 0a0a 2020 2020 2020 2020 3a72 6574 7572  ..        :retur
-00003700: 6e3a 2068 6f72 697a 6f6e 7461 6c20 7069  n: horizontal pi
-00003710: 7865 6c20 7369 7a65 0a20 2020 2020 2020  xel size.       
-00003720: 203a 7274 7970 653a 2066 6c6f 6174 0a0a   :rtype: float..
-00003730: 2020 2020 2020 2020 4578 616d 706c 653a          Example:
-00003740: 0a0a 2020 2020 2020 2020 2e2e 2072 756e  ..        .. run
-00003750: 626c 6f63 6b3a 3a20 7079 636f 6e0a 0a20  block:: pycon.. 
-00003760: 2020 2020 2020 2020 2020 203e 3e3e 2066             >>> f
-00003770: 726f 6d20 6d61 6368 696e 6576 6973 696f  rom machinevisio
-00003780: 6e74 6f6f 6c62 6f78 2069 6d70 6f72 7420  ntoolbox import 
-00003790: 4365 6e74 7261 6c43 616d 6572 610a 2020  CentralCamera.  
-000037a0: 2020 2020 2020 2020 2020 3e3e 3e20 6361            >>> ca
-000037b0: 6d65 7261 203d 2043 656e 7472 616c 4361  mera = CentralCa
-000037c0: 6d65 7261 2e44 6566 6175 6c74 2829 3b0a  mera.Default();.
-000037d0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-000037e0: 6361 6d65 7261 2e72 686f 750a 0a20 2020  camera.rhou..   
-000037f0: 2020 2020 203a 7365 6561 6c73 6f3a 203a       :seealso: :
-00003800: 6d65 7468 3a60 7268 6f76 6020 3a6d 6574  meth:`rhov` :met
-00003810: 683a 6072 686f 600a 2020 2020 2020 2020  h:`rho`.        
-00003820: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00003830: 726e 2073 656c 662e 5f72 686f 750a 0a20  rn self._rhou.. 
-00003840: 2020 2023 2074 6869 7320 6973 2067 656e     # this is gen
-00003850: 6572 616c 6c79 2074 6865 2063 656e 7472  erally the centr
-00003860: 6520 6f66 2074 6865 2069 6d61 6765 2c20  e of the image, 
-00003870: 6861 7320 7370 6563 6961 6c20 6d65 616e  has special mean
-00003880: 696e 6720 666f 720a 2020 2020 2320 7065  ing for.    # pe
-00003890: 7273 7065 6374 6976 6520 6361 6d65 7261  rspective camera
-000038a0: 0a20 2020 200a 2020 2020 4070 726f 7065  .    .    @prope
-000038b0: 7274 790a 2020 2020 6465 6620 7268 6f76  rty.    def rhov
-000038c0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-000038d0: 2222 220a 2020 2020 2020 2020 4765 7420  """.        Get 
-000038e0: 7069 7865 6c20 7769 6474 6820 2862 6173  pixel width (bas
-000038f0: 6520 6d65 7468 6f64 290a 0a20 2020 2020  e method)..     
-00003900: 2020 203a 7265 7475 726e 3a20 7665 7274     :return: vert
-00003910: 6963 616c 2070 6978 656c 2073 697a 650a  ical pixel size.
-00003920: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-00003930: 666c 6f61 740a 0a20 2020 2020 2020 2045  float..        E
-00003940: 7861 6d70 6c65 3a0a 0a20 2020 2020 2020  xample:..       
-00003950: 202e 2e20 7275 6e62 6c6f 636b 3a3a 2070   .. runblock:: p
-00003960: 7963 6f6e 0a0a 2020 2020 2020 2020 2020  ycon..          
-00003970: 2020 3e3e 3e20 6672 6f6d 206d 6163 6869    >>> from machi
-00003980: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
-00003990: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
-000039a0: 6d65 7261 0a20 2020 2020 2020 2020 2020  mera.           
-000039b0: 203e 3e3e 2063 616d 6572 6120 3d20 4365   >>> camera = Ce
-000039c0: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
-000039d0: 756c 7428 293b 0a20 2020 2020 2020 2020  ult();.         
-000039e0: 2020 203e 3e3e 2063 616d 6572 612e 7268     >>> camera.rh
-000039f0: 6f76 0a0a 2020 2020 2020 2020 3a73 6565  ov..        :see
-00003a00: 616c 736f 3a20 3a6d 6574 683a 6072 686f  also: :meth:`rho
-00003a10: 7660 203a 6d65 7468 3a60 7268 6f60 0a20  v` :meth:`rho`. 
-00003a20: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00003a30: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00003a40: 7268 6f76 0a0a 2020 2020 4070 726f 7065  rhov..    @prope
-00003a50: 7274 790a 2020 2020 6465 6620 7268 6f28  rty.    def rho(
-00003a60: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-00003a70: 2222 0a20 2020 2020 2020 2047 6574 2070  "".        Get p
-00003a80: 6978 656c 2064 696d 656e 7369 6f6e 7320  ixel dimensions 
-00003a90: 2862 6173 6520 6d65 7468 6f64 290a 0a20  (base method).. 
-00003aa0: 2020 2020 2020 203a 7265 7475 726e 3a20         :return: 
-00003ab0: 686f 7269 7a6f 6e74 616c 2070 6978 656c  horizontal pixel
-00003ac0: 2073 697a 650a 2020 2020 2020 2020 3a72   size.        :r
-00003ad0: 7479 7065 3a20 6e64 6172 7261 7928 3229  type: ndarray(2)
-00003ae0: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-00003af0: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
-00003b00: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
-00003b10: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00003b20: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
-00003b30: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
-00003b40: 7420 4365 6e74 7261 6c43 616d 6572 610a  t CentralCamera.
-00003b50: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00003b60: 6361 6d65 7261 203d 2043 656e 7472 616c  camera = Central
-00003b70: 4361 6d65 7261 2829 3b0a 2020 2020 2020  Camera();.      
-00003b80: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
-00003b90: 2e72 686f 760a 0a20 2020 2020 2020 203a  .rhov..        :
-00003ba0: 7365 6561 6c73 6f3a 203a 6d65 7468 3a60  seealso: :meth:`
-00003bb0: 7268 6f75 6020 3a6d 6574 683a 6072 686f  rhou` :meth:`rho
-00003bc0: 7660 0a20 2020 2020 2020 2022 2222 0a0a  v`.        """..
-00003bd0: 2020 2020 2020 2020 7265 7475 726e 206e          return n
-00003be0: 702e 6172 7261 7928 5b73 656c 662e 5f72  p.array([self._r
-00003bf0: 686f 752c 2073 656c 662e 5f72 686f 765d  hou, self._rhov]
-00003c00: 290a 0a20 2020 2023 2040 7072 6f70 6572  )..    # @proper
-00003c10: 7479 0a20 2020 2023 2064 6566 2069 6d61  ty.    # def ima
-00003c20: 6765 2873 656c 6629 3a0a 2020 2020 2320  ge(self):.    # 
-00003c30: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00003c40: 5f69 6d61 6765 0a0a 2020 2020 2320 4069  _image..    # @i
-00003c50: 6d61 6765 2e73 6574 7465 720a 2020 2020  mage.setter.    
-00003c60: 2320 6465 6620 696d 6167 6528 7365 6c66  # def image(self
-00003c70: 2c20 6e65 7769 6d61 6765 293a 0a20 2020  , newimage):.   
-00003c80: 2023 2020 2020 2022 2222 0a0a 0a20 2020   #     """...   
-00003c90: 2023 2020 2020 203a 7061 7261 6d20 6e65   #     :param ne
-00003ca0: 7769 6d61 6765 3a20 5b64 6573 6372 6970  wimage: [descrip
-00003cb0: 7469 6f6e 5d0a 2020 2020 2320 2020 2020  tion].    #     
-00003cc0: 3a74 7970 6520 6e65 7769 6d61 6765 3a20  :type newimage: 
-00003cd0: 5b74 7970 655d 0a20 2020 2023 2020 2020  [type].    #    
-00003ce0: 2022 2222 0a20 2020 2023 2020 2020 2073   """.    #     s
-00003cf0: 656c 662e 5f69 6d61 6765 203d 2049 6d61  elf._image = Ima
-00003d00: 6765 286e 6577 696d 6167 6529 0a0a 2020  ge(newimage)..  
-00003d10: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00003d20: 6465 6620 706f 7365 2873 656c 6629 3a0a  def pose(self):.
-00003d30: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00003d40: 2020 2020 5365 742f 6765 7420 6361 6d65      Set/get came
-00003d50: 7261 2070 6f73 6520 2862 6173 6520 6d65  ra pose (base me
-00003d60: 7468 6f64 290a 0a20 2020 2020 2020 2054  thod)..        T
-00003d70: 6865 2063 616d 6572 6120 706f 7365 2077  he camera pose w
-00003d80: 6974 6820 7265 7370 6563 7420 746f 2074  ith respect to t
-00003d90: 6865 2067 6c6f 6261 6c20 6672 616d 6520  he global frame 
-00003da0: 6361 6e20 6265 2072 6561 6420 6f72 2077  can be read or w
-00003db0: 7269 7474 656e 0a20 2020 2020 2020 2061  ritten.        a
-00003dc0: 7320 616e 203a 636c 6173 733a 607e 7370  s an :class:`~sp
-00003dd0: 6174 6961 6c6d 6174 682e 2e70 6f73 6533  atialmath..pose3
-00003de0: 642e 5345 3360 2069 6e73 7461 6e63 652e  d.SE3` instance.
-00003df0: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-00003e00: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
-00003e10: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
-00003e20: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00003e30: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
-00003e40: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
-00003e50: 7420 4365 6e74 7261 6c43 616d 6572 610a  t CentralCamera.
-00003e60: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00003e70: 6672 6f6d 2073 7061 7469 616c 6d61 7468  from spatialmath
-00003e80: 2069 6d70 6f72 7420 5345 330a 2020 2020   import SE3.    
-00003e90: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-00003ea0: 7261 203d 2043 656e 7472 616c 4361 6d65  ra = CentralCame
-00003eb0: 7261 2829 3b0a 2020 2020 2020 2020 2020  ra();.          
-00003ec0: 2020 3e3e 3e20 6361 6d65 7261 2e70 6f73    >>> camera.pos
-00003ed0: 650a 2020 2020 2020 2020 2020 2020 3e3e  e.            >>
-00003ee0: 3e20 6361 6d65 7261 2e70 6f73 6520 3d20  > camera.pose = 
-00003ef0: 5345 332e 5472 616e 7328 312c 2032 2c20  SE3.Trans(1, 2, 
-00003f00: 3329 0a20 2020 2020 2020 2020 2020 203e  3).            >
-00003f10: 3e3e 2063 616d 6572 610a 0a20 2020 2020  >> camera..     
-00003f20: 2020 203a 6e6f 7465 3a20 4368 616e 6765     :note: Change
-00003f30: 7320 7468 6520 706f 7365 206f 6620 7468  s the pose of th
-00003f40: 6520 6375 7272 656e 7420 6361 6d65 7261  e current camera
-00003f50: 2069 6e73 7461 6e63 652c 2077 6865 7265   instance, where
-00003f60: 6173 0a20 2020 2020 2020 2020 2020 203a  as.            :
-00003f70: 6d65 7468 3a60 6d6f 7665 6020 636c 6f6e  meth:`move` clon
-00003f80: 6573 2074 6865 2063 616d 6572 6120 696e  es the camera in
-00003f90: 7374 616e 6365 2077 6974 6820 6120 6e65  stance with a ne
-00003fa0: 7720 706f 7365 2e0a 0a20 2020 2020 2020  w pose...       
-00003fb0: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
-00003fc0: 3a60 6d6f 7665 600a 2020 2020 2020 2020  :`move`.        
-00003fd0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00003fe0: 726e 2073 656c 662e 5f70 6f73 650a 0a20  rn self._pose.. 
-00003ff0: 2020 2040 706f 7365 2e73 6574 7465 720a     @pose.setter.
-00004000: 2020 2020 6465 6620 706f 7365 2873 656c      def pose(sel
-00004010: 662c 206e 6577 706f 7365 293a 0a20 2020  f, newpose):.   
-00004020: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00004030: 2053 6574 2063 616d 6572 6120 706f 7365   Set camera pose
-00004040: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
-00004050: 206e 6577 706f 7365 3a20 706f 7365 206f   newpose: pose o
-00004060: 6620 6361 6d65 7261 2066 7261 6d65 0a20  f camera frame. 
-00004070: 2020 2020 2020 203a 7479 7065 206e 6577         :type new
-00004080: 706f 7365 3a20 3a63 6c61 7373 3a60 7e73  pose: :class:`~s
-00004090: 7061 7469 616c 6d61 7468 2e2e 706f 7365  patialmath..pose
-000040a0: 3364 2e53 4533 6020 6f72 206e 6461 7272  3d.SE3` or ndarr
-000040b0: 6179 2834 2c34 290a 0a20 2020 2020 2020  ay(4,4)..       
-000040c0: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
-000040d0: 3a60 6d6f 7665 600a 2020 2020 2020 2020  :`move`.        
-000040e0: 2222 220a 2020 2020 2020 2020 7365 6c66  """.        self
-000040f0: 2e5f 706f 7365 203d 2053 4533 286e 6577  ._pose = SE3(new
-00004100: 706f 7365 290a 0a20 2020 2040 7072 6f70  pose)..    @prop
-00004110: 6572 7479 0a20 2020 2064 6566 206e 6f69  erty.    def noi
-00004120: 7365 2873 656c 6629 3a0a 2020 2020 2020  se(self):.      
-00004130: 2020 2222 220a 2020 2020 2020 2020 5365    """.        Se
-00004140: 742f 4765 7420 7072 6f6a 6563 7469 6f6e  t/Get projection
-00004150: 206e 6f69 7365 2028 6261 7365 206d 6574   noise (base met
-00004160: 686f 6429 0a0a 2020 2020 2020 2020 3a72  hod)..        :r
-00004170: 6574 7572 6e3a 2073 7461 6e64 6172 6420  eturn: standard 
-00004180: 6465 7669 6174 696f 6e20 6f66 206e 6f69  deviation of noi
-00004190: 7365 2061 6464 6564 2074 6f20 7072 6f6a  se added to proj
-000041a0: 6563 7465 6420 696d 6167 6520 706c 616e  ected image plan
-000041b0: 6520 706f 696e 7473 0a20 2020 2020 2020  e points.       
-000041c0: 203a 7274 7970 653a 2066 6c6f 6174 0a0a   :rtype: float..
-000041d0: 2020 2020 2020 2020 5468 6520 6e6f 6973          The nois
-000041e0: 6520 7061 7261 6d65 7465 7220 6973 2073  e parameter is s
-000041f0: 6574 2062 7920 7468 6520 6f62 6a65 6374  et by the object
-00004200: 2063 6f6e 7374 7275 6374 6f72 2e0a 0a20   constructor... 
-00004210: 2020 2020 2020 2045 7861 6d70 6c65 3a0a         Example:.
-00004220: 0a20 2020 2020 2020 202e 2e20 7275 6e62  .        .. runb
-00004230: 6c6f 636b 3a3a 2070 7963 6f6e 0a0a 2020  lock:: pycon..  
-00004240: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
-00004250: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
-00004260: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
-00004270: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
-00004280: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-00004290: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
-000042a0: 6572 612e 4465 6661 756c 7428 293b 0a20  era.Default();. 
-000042b0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-000042c0: 616d 6572 612e 7072 6f6a 6563 745f 706f  amera.project_po
-000042d0: 696e 7428 5b30 2c20 302c 2033 5d29 0a20  int([0, 0, 3]). 
-000042e0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-000042f0: 616d 6572 612e 6e6f 6973 6520 3d20 320a  amera.noise = 2.
-00004300: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00004310: 6361 6d65 7261 2e70 726f 6a65 6374 5f70  camera.project_p
-00004320: 6f69 6e74 285b 302c 2030 2c20 325d 290a  oint([0, 0, 2]).
-00004330: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00004340: 6361 6d65 7261 2e70 726f 6a65 6374 5f70  camera.project_p
-00004350: 6f69 6e74 285b 302c 2030 2c20 325d 290a  oint([0, 0, 2]).
-00004360: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
-00004370: 6f3a 203a 6d65 7468 3a60 7072 6f6a 6563  o: :meth:`projec
-00004380: 7460 0a20 2020 2020 2020 2022 2222 0a20  t`.        """. 
-00004390: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-000043a0: 6c66 2e5f 6e6f 6973 650a 0a20 2020 2040  lf._noise..    @
-000043b0: 6e6f 6973 652e 7365 7474 6572 0a20 2020  noise.setter.   
-000043c0: 2064 6566 206e 6f69 7365 2873 656c 662c   def noise(self,
-000043d0: 206e 6f69 7365 293a 0a20 2020 2020 2020   noise):.       
-000043e0: 2073 656c 662e 5f6e 6f69 7365 203d 206e   self._noise = n
-000043f0: 6f69 7365 0a0a 2020 2020 6465 6620 6d6f  oise..    def mo
-00004400: 7665 2873 656c 662c 2054 2c20 6e61 6d65  ve(self, T, name
-00004410: 3d4e 6f6e 652c 2072 656c 6174 6976 653d  =None, relative=
-00004420: 4661 6c73 6529 3a0a 2020 2020 2020 2020  False):.        
-00004430: 2222 220a 2020 2020 2020 2020 4d6f 7665  """.        Move
-00004440: 2063 616d 6572 6120 2862 6173 6520 6d65   camera (base me
-00004450: 7468 6f64 290a 0a20 2020 2020 2020 203a  thod)..        :
-00004460: 7061 7261 6d20 543a 2070 6f73 6520 6f66  param T: pose of
-00004470: 2063 616d 6572 6120 6672 616d 650a 2020   camera frame.  
-00004480: 2020 2020 2020 3a74 7970 6520 543a 203a        :type T: :
-00004490: 636c 6173 733a 607e 7370 6174 6961 6c6d  class:`~spatialm
-000044a0: 6174 682e 2e70 6f73 6533 642e 5345 3360  ath..pose3d.SE3`
-000044b0: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-000044c0: 7265 6c61 7469 7665 3a20 6d6f 7665 2072  relative: move r
-000044d0: 656c 6174 6976 6520 746f 2070 6f73 6520  elative to pose 
-000044e0: 6f66 206f 7269 6769 6e61 6c20 6361 6d65  of original came
-000044f0: 7261 2c20 6465 6661 756c 7473 2074 6f20  ra, defaults to 
-00004500: 4661 6c73 650a 2020 2020 2020 2020 3a74  False.        :t
-00004510: 7970 6520 7265 6c61 7469 7665 3a20 626f  ype relative: bo
-00004520: 6f6c 2c20 6f70 7469 6f6e 616c 0a20 2020  ol, optional.   
-00004530: 2020 2020 203a 7265 7475 726e 3a20 6e65       :return: ne
-00004540: 7720 6361 6d65 7261 206f 626a 6563 740a  w camera object.
-00004550: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-00004560: 3a63 6c61 7373 3a60 4361 6d65 7261 4261  :class:`CameraBa
-00004570: 7365 6020 7375 6263 6c61 7373 0a0a 2020  se` subclass..  
-00004580: 2020 2020 2020 5265 7475 726e 7320 6120        Returns a 
-00004590: 636f 7079 206f 6620 7468 6520 6361 6d65  copy of the came
-000045a0: 7261 206f 626a 6563 7420 7769 7468 2070  ra object with p
-000045b0: 6f73 6520 7365 7420 746f 2060 6054 6060  ose set to ``T``
-000045c0: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
-000045d0: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
-000045e0: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
-000045f0: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
-00004600: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
-00004610: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
-00004620: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
-00004630: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00004640: 2066 726f 6d20 7370 6174 6961 6c6d 6174   from spatialmat
-00004650: 6820 696d 706f 7274 2053 4533 0a20 2020  h import SE3.   
-00004660: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-00004670: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
-00004680: 6572 6128 293b 0a20 2020 2020 2020 2020  era();.         
-00004690: 2020 203e 3e3e 2063 616d 6572 612e 6d6f     >>> camera.mo
-000046a0: 7665 2853 4533 2e54 7261 6e73 2830 2e31  ve(SE3.Trans(0.1
-000046b0: 2c20 302e 322c 2030 2e33 2929 0a20 2020  , 0.2, 0.3)).   
-000046c0: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-000046d0: 6572 610a 0a20 2020 2020 2020 203a 6e6f  era..        :no
-000046e0: 7465 3a20 5468 6520 6060 706c 6f74 6060  te: The ``plot``
-000046f0: 206d 6574 686f 6420 6f66 2074 6869 7320   method of this 
-00004700: 636c 6f6e 6564 2063 616d 6572 6120 7769  cloned camera wi
-00004710: 6c6c 2063 7265 6174 6520 6120 6e65 770a  ll create a new.
-00004720: 2020 2020 2020 2020 2020 2020 7769 6e64              wind
-00004730: 6f77 2e0a 0a20 2020 2020 2020 203a 7365  ow...        :se
-00004740: 6561 6c73 6f3a 203a 6d65 7468 3a60 706f  ealso: :meth:`po
-00004750: 7365 600a 2020 2020 2020 2020 2222 220a  se`.        """.
-00004760: 2020 2020 2020 2020 6e65 7763 616d 6572          newcamer
-00004770: 6120 3d20 636f 7079 2e63 6f70 7928 7365  a = copy.copy(se
-00004780: 6c66 290a 2020 2020 2020 2020 6966 206e  lf).        if n
-00004790: 616d 6520 6973 206e 6f74 204e 6f6e 653a  ame is not None:
-000047a0: 0a20 2020 2020 2020 2020 2020 206e 6577  .            new
-000047b0: 6361 6d65 7261 2e6e 616d 6520 3d20 6e61  camera.name = na
-000047c0: 6d65 0a20 2020 2020 2020 2065 6c73 653a  me.        else:
-000047d0: 0a20 2020 2020 2020 2020 2020 206e 6577  .            new
-000047e0: 6361 6d65 7261 2e6e 616d 6520 3d20 7365  camera.name = se
-000047f0: 6c66 2e6e 616d 6520 2b20 222d 6d6f 7665  lf.name + "-move
-00004800: 6422 0a20 2020 2020 2020 206e 6577 6361  d".        newca
-00004810: 6d65 7261 2e5f 6178 203d 204e 6f6e 650a  mera._ax = None.
-00004820: 2020 2020 2020 2020 6966 2072 656c 6174          if relat
-00004830: 6976 653a 0a20 2020 2020 2020 2020 2020  ive:.           
-00004840: 206e 6577 6361 6d65 7261 2e70 6f73 6520   newcamera.pose 
-00004850: 3d20 7365 6c66 2e70 6f73 6520 2a20 540a  = self.pose * T.
-00004860: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00004870: 2020 2020 2020 2020 2020 6e65 7763 616d            newcam
-00004880: 6572 612e 706f 7365 203d 2054 0a20 2020  era.pose = T.   
-00004890: 2020 2020 2072 6574 7572 6e20 6e65 7763       return newc
-000048a0: 616d 6572 610a 0a20 2020 2023 202d 2d2d  amera..    # ---
-000048b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000048c0: 2d2d 2d2d 2070 6c6f 7474 696e 6720 2d2d  ---- plotting --
-000048d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000048e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000048f0: 2d20 230a 0a20 2020 2064 6566 205f 6e65  - #..    def _ne
-00004900: 775f 696d 6167 6570 6c61 6e65 2873 656c  w_imageplane(sel
-00004910: 662c 2066 6967 3d4e 6f6e 652c 2061 783d  f, fig=None, ax=
-00004920: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
-00004930: 2222 0a20 2020 2020 2020 2043 7265 6174  "".        Creat
-00004940: 6520 6120 6e65 7720 7669 7274 7561 6c20  e a new virtual 
-00004950: 696d 6167 6520 706c 616e 6520 6966 2072  image plane if r
-00004960: 6571 7569 7265 640a 0a20 2020 2020 2020  equired..       
-00004970: 203a 7061 7261 6d20 6669 673a 204d 6174   :param fig: Mat
-00004980: 706c 6f74 6c69 6220 6669 6775 7265 206e  plotlib figure n
-00004990: 756d 6265 722c 2064 6566 6175 6c74 7320  umber, defaults 
-000049a0: 746f 204e 6f6e 650a 2020 2020 2020 2020  to None.        
-000049b0: 3a74 7970 6520 6669 673a 2069 6e74 2c20  :type fig: int, 
-000049c0: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
-000049d0: 203a 7061 7261 6d20 6178 3a20 4d61 7470   :param ax: Matp
-000049e0: 6c6f 746c 6f62 2061 7865 732c 2064 6566  lotlob axes, def
-000049f0: 6175 6c74 7320 746f 204e 6f6e 650a 2020  aults to None.  
-00004a00: 2020 2020 2020 3a74 7970 6520 6178 3a20        :type ax: 
-00004a10: 3a63 6c61 7373 3a60 6d61 7470 6c6f 746c  :class:`matplotl
-00004a20: 6962 2e61 7865 7360 2c20 6f70 7469 6f6e  ib.axes`, option
-00004a30: 616c 0a20 2020 2020 2020 203a 7265 7475  al.        :retu
-00004a40: 726e 3a20 7768 6574 6865 7220 7669 7274  rn: whether virt
-00004a50: 7561 6c20 696d 6167 6520 706c 616e 6520  ual image plane 
-00004a60: 6578 6973 7473 0a20 2020 2020 2020 203a  exists.        :
-00004a70: 7274 7970 653a 2062 6f6f 6c0a 0a20 2020  rtype: bool..   
-00004a80: 2020 2020 2049 6620 7468 6973 2063 616d       If this cam
-00004a90: 6572 6120 616c 7265 6164 7920 6861 7320  era already has 
-00004aa0: 6120 7669 7274 7561 6c20 696d 6167 6520  a virtual image 
-00004ab0: 706c 616e 652c 2072 6574 7572 6e20 5472  plane, return Tr
-00004ac0: 7565 2e0a 2020 2020 2020 2020 4f74 6865  ue..        Othe
-00004ad0: 7277 6973 652c 2063 7265 6174 6520 616e  rwise, create an
-00004ae0: 2061 7865 732c 2061 6e64 206f 7074 696f   axes, and optio
-00004af0: 6e61 6c6c 7920 6120 2066 6967 7572 652c  nally a  figure,
-00004b00: 2061 6e64 2072 6574 7572 6e20 4661 6c73   and return Fals
-00004b10: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
-00004b20: 2020 2020 2020 2069 6620 5f69 736e 6f74         if _isnot
-00004b30: 6562 6f6f 6b28 293a 0a20 2020 2020 2020  ebook():.       
-00004b40: 2020 2020 2020 2020 2061 7820 3d20 706c           ax = pl
-00004b50: 742e 6763 6128 2920 2023 2072 6574 7572  t.gca()  # retur
-00004b60: 6e20 6375 7272 656e 7420 6f72 2063 7265  n current or cre
-00004b70: 6174 6520 6e65 770a 2020 2020 2020 2020  ate new.        
-00004b80: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00004b90: 5f61 7820 6973 204e 6f6e 6520 6f72 2073  _ax is None or s
-00004ba0: 656c 662e 5f61 7820 6973 206e 6f74 2061  elf._ax is not a
-00004bb0: 783a 0a20 2020 2020 2020 2020 2020 2020  x:.             
-00004bc0: 2020 2020 2020 2073 656c 662e 5f61 7820         self._ax 
-00004bd0: 3d20 6178 0a20 2020 2020 2020 2020 2020  = ax.           
-00004be0: 2020 2020 2020 2020 2073 656c 662e 5f66           self._f
-00004bf0: 6967 203d 2070 6c74 2e67 6366 2829 0a20  ig = plt.gcf(). 
-00004c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c10: 2020 2072 6574 7572 6e20 4661 6c73 650a     return False.
-00004c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c30: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00004c40: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00004c50: 2054 7275 650a 0a20 2020 2020 2020 2065   True..        e
-00004c60: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00004c70: 2023 2069 6620 6e6f 7420 4a75 7079 7465   # if not Jupyte
-00004c80: 722c 2072 6575 7365 2061 6e20 6578 6973  r, reuse an exis
-00004c90: 7469 6e67 2069 6d61 6765 706c 616e 6520  ting imageplane 
-00004ca0: 706c 6f74 0a20 2020 2020 2020 2020 2020  plot.           
-00004cb0: 2069 6620 7365 6c66 2e5f 6178 2069 7320   if self._ax is 
-00004cc0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00004cd0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00004ce0: 2054 7275 650a 0a20 2020 2020 2020 2069   True..        i
-00004cf0: 6620 2866 6967 2069 7320 4e6f 6e65 2920  f (fig is None) 
-00004d00: 616e 6420 2861 7820 6973 204e 6f6e 6529  and (ax is None)
-00004d10: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
-00004d20: 6372 6561 7465 206f 7572 206f 776e 2068  create our own h
-00004d30: 616e 646c 6520 666f 7220 7468 6520 6669  andle for the fi
-00004d40: 6775 7265 2f70 6c6f 740a 2020 2020 2020  gure/plot.      
-00004d50: 2020 2020 2020 2320 7072 696e 7428 2763        # print('c
-00004d60: 7265 6174 696e 6720 6e65 7720 6669 6775  reating new figu
-00004d70: 7265 2061 6e64 2061 7865 7320 666f 7220  re and axes for 
-00004d80: 6361 6d65 7261 2729 0a20 2020 2020 2020  camera').       
-00004d90: 2020 2020 2066 6967 2c20 6178 203d 2070       fig, ax = p
-00004da0: 6c74 2e73 7562 706c 6f74 7328 2920 2023  lt.subplots()  #
-00004db0: 2054 4f44 4f20 2a61 7267 732c 202a 2a6b   TODO *args, **k
-00004dc0: 7761 7267 733f 0a20 2020 2020 2020 2023  wargs?.        #
-00004dd0: 2054 4f44 4f20 656c 6966 2061 7820 6973   TODO elif ax is
-00004de0: 2061 2070 6c6f 7420 6861 6e64 6c65 2c20   a plot handle, 
-00004df0: 656c 7365 2072 6169 7365 2056 616c 7565  else raise Value
-00004e00: 4572 726f 720a 2020 2020 2020 2020 7365  Error.        se
-00004e10: 6c66 2e5f 6178 203d 2061 780a 2020 2020  lf._ax = ax.    
-00004e20: 2020 2020 7365 6c66 2e5f 6669 6720 3d20      self._fig = 
-00004e30: 6669 670a 2020 2020 2020 2020 7265 7475  fig.        retu
-00004e40: 726e 2046 616c 7365 0a0a 2020 2020 6465  rn False..    de
-00004e50: 6620 5f69 6e69 745f 696d 6167 6570 6c61  f _init_imagepla
-00004e60: 6e65 2873 656c 662c 2066 6967 3d4e 6f6e  ne(self, fig=Non
-00004e70: 652c 2061 783d 4e6f 6e65 293a 0a20 2020  e, ax=None):.   
-00004e80: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00004e90: 2043 7265 6174 6520 706c 6f74 2077 696e   Create plot win
-00004ea0: 646f 7720 666f 7220 6361 6d65 7261 2069  dow for camera i
-00004eb0: 6d61 6765 2070 6c61 6e65 0a0a 2020 2020  mage plane..    
-00004ec0: 2020 2020 3a70 6172 616d 2066 6967 3a20      :param fig: 
-00004ed0: 6669 6775 7265 2074 6f20 706c 6f74 2069  figure to plot i
-00004ee0: 6e74 6f2c 2064 6566 6175 6c74 7320 746f  nto, defaults to
-00004ef0: 204e 6f6e 650a 2020 2020 2020 2020 3a74   None.        :t
-00004f00: 7970 6520 6669 673a 2066 6967 7572 6520  ype fig: figure 
-00004f10: 6861 6e64 6c65 2c20 6f70 7469 6f6e 616c  handle, optional
-00004f20: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-00004f30: 6178 3a20 6178 6973 2074 6f20 706c 6f74  ax: axis to plot
-00004f40: 2069 6e74 6f2c 2064 6566 6175 6c74 7320   into, defaults 
-00004f50: 746f 204e 6f6e 650a 2020 2020 2020 2020  to None.        
-00004f60: 3a74 7970 6520 6178 3a20 3244 2061 7869  :type ax: 2D axi
-00004f70: 7320 6861 6e64 6c65 2c20 6f70 7469 6f6e  s handle, option
-00004f80: 616c 0a20 2020 2020 2020 203a 7265 7475  al.        :retu
-00004f90: 726e 3a20 6669 6775 7265 2061 6e64 2061  rn: figure and a
-00004fa0: 7869 730a 2020 2020 2020 2020 3a72 7479  xis.        :rty
-00004fb0: 7065 3a20 2866 6967 2c20 6178 6973 290a  pe: (fig, axis).
-00004fc0: 0a20 2020 2020 2020 2043 7265 6174 6573  .        Creates
-00004fd0: 2061 2032 4420 6178 6973 2074 6861 7420   a 2D axis that 
-00004fe0: 7265 7072 6573 656e 7473 2074 6865 2069  represents the i
-00004ff0: 6d61 6765 2070 6c61 6e65 206f 6620 7468  mage plane of th
-00005000: 6520 7669 7274 7561 6c0a 2020 2020 2020  e virtual.      
-00005010: 2020 6361 6d65 7261 2e0a 0a20 2020 2020    camera...     
-00005020: 2020 203a 7365 6561 6c73 6f3a 203a 6d65     :seealso: :me
-00005030: 7468 3a60 706c 6f74 6020 3a6d 6574 683a  th:`plot` :meth:
-00005040: 606d 6573 6860 0a20 2020 2020 2020 2022  `mesh`.        "
-00005050: 2222 0a20 2020 2020 2020 2069 6620 7365  "".        if se
-00005060: 6c66 2e5f 6e65 775f 696d 6167 6570 6c61  lf._new_imagepla
-00005070: 6e65 2866 6967 2c20 6178 293a 0a20 2020  ne(fig, ax):.   
-00005080: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00005090: 7365 6c66 2e5f 6178 0a0a 2020 2020 2020  self._ax..      
-000050a0: 2020 6178 203d 2073 656c 662e 5f61 780a    ax = self._ax.
-000050b0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-000050c0: 2e5f 696d 6167 6520 6973 206e 6f74 204e  ._image is not N
-000050d0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-000050e0: 2023 2069 6620 6361 6d65 7261 2068 6173   # if camera has
-000050f0: 2061 6e20 696d 6167 652c 2064 6973 706c   an image, displ
-00005100: 6179 2073 6169 6420 696d 6167 650a 2020  ay said image.  
-00005110: 2020 2020 2020 2020 2020 6964 6973 7028            idisp(
-00005120: 7365 6c66 2e5f 696d 6167 652c 0a20 2020  self._image,.   
-00005130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005140: 2020 2066 6967 3d66 6967 2c0a 2020 2020     fig=fig,.    
-00005150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005160: 2020 6178 3d61 782c 0a20 2020 2020 2020    ax=ax,.       
-00005170: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00005180: 6974 6c65 3d73 656c 662e 5f6e 616d 652c  itle=self._name,
-00005190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000051a0: 2020 2020 2020 2064 7261 776f 6e6c 793d         drawonly=
-000051b0: 5472 7565 290a 2020 2020 2020 2020 656c  True).        el
-000051c0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000051d0: 6966 2073 656c 662e 6c69 6d69 7473 2069  if self.limits i
-000051e0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-000051f0: 2020 2020 2020 2020 6178 2e73 6574 5f78          ax.set_x
-00005200: 6c69 6d28 302c 2073 656c 662e 6e75 290a  lim(0, self.nu).
-00005210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005220: 6178 2e73 6574 5f79 6c69 6d28 302c 2073  ax.set_ylim(0, s
-00005230: 656c 662e 6e76 290a 2020 2020 2020 2020  elf.nv).        
-00005240: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00005250: 2020 2020 2020 2020 2020 6178 2e73 6574            ax.set
-00005260: 5f78 6c69 6d28 7365 6c66 2e6c 696d 6974  _xlim(self.limit
-00005270: 735b 305d 2c20 7365 6c66 2e6c 696d 6974  s[0], self.limit
-00005280: 735b 315d 290a 2020 2020 2020 2020 2020  s[1]).          
-00005290: 2020 2020 2020 6178 2e73 6574 5f79 6c69        ax.set_yli
-000052a0: 6d28 7365 6c66 2e6c 696d 6974 735b 325d  m(self.limits[2]
-000052b0: 2c20 7365 6c66 2e6c 696d 6974 735b 335d  , self.limits[3]
-000052c0: 290a 2020 2020 2020 2020 2020 2020 6178  ).            ax
-000052d0: 2e61 7574 6f73 6361 6c65 2846 616c 7365  .autoscale(False
-000052e0: 290a 2020 2020 2020 2020 2020 2020 6178  ).            ax
-000052f0: 2e73 6574 5f61 7370 6563 7428 2765 7175  .set_aspect('equ
-00005300: 616c 2729 0a20 2020 2020 2020 2020 2020  al').           
-00005310: 2061 782e 696e 7665 7274 5f79 6178 6973   ax.invert_yaxis
-00005320: 2829 0a20 2020 2020 2020 2020 2020 2061  ().            a
-00005330: 782e 6772 6964 2854 7275 6529 0a20 2020  x.grid(True).   
-00005340: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00005350: 2e6c 6162 656c 7320 6973 204e 6f6e 653a  .labels is None:
-00005360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005370: 2061 782e 7365 745f 786c 6162 656c 2827   ax.set_xlabel('
-00005380: 7520 2870 6978 656c 7329 2729 0a20 2020  u (pixels)').   
-00005390: 2020 2020 2020 2020 2020 2020 2061 782e               ax.
-000053a0: 7365 745f 796c 6162 656c 2827 7620 2870  set_ylabel('v (p
-000053b0: 6978 656c 7329 2729 0a20 2020 2020 2020  ixels)').       
-000053c0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-000053d0: 2020 2020 2020 2020 2020 2061 782e 7365             ax.se
-000053e0: 745f 786c 6162 656c 2873 656c 662e 6c61  t_xlabel(self.la
-000053f0: 6265 6c73 5b30 5d29 0a20 2020 2020 2020  bels[0]).       
-00005400: 2020 2020 2020 2020 2061 782e 7365 745f           ax.set_
-00005410: 796c 6162 656c 2873 656c 662e 6c61 6265  ylabel(self.labe
-00005420: 6c73 5b31 5d29 0a20 2020 2020 2020 2020  ls[1]).         
-00005430: 2020 2061 782e 7365 745f 7469 746c 6528     ax.set_title(
-00005440: 7365 6c66 2e6e 616d 6529 0a20 2020 2020  self.name).     
-00005450: 2020 2020 2020 2061 782e 7365 745f 6661         ax.set_fa
-00005460: 6365 636f 6c6f 7228 276c 6967 6874 7965  cecolor('lightye
-00005470: 6c6c 6f77 2729 0a20 2020 2020 2020 2020  llow').         
-00005480: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-00005490: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-000054a0: 2020 2020 2020 2020 2061 782e 6669 6775           ax.figu
-000054b0: 7265 2e63 616e 7661 732e 6d61 6e61 6765  re.canvas.manage
-000054c0: 722e 7365 745f 7769 6e64 6f77 5f74 6974  r.set_window_tit
-000054d0: 6c65 2827 4d61 6368 696e 6520 5669 7369  le('Machine Visi
-000054e0: 6f6e 2054 6f6f 6c62 6f78 2066 6f72 2050  on Toolbox for P
-000054f0: 7974 686f 6e27 290a 2020 2020 2020 2020  ython').        
-00005500: 2020 2020 6578 6365 7074 2041 7474 7269      except Attri
-00005510: 6275 7465 4572 726f 723a 0a20 2020 2020  buteError:.     
-00005520: 2020 2020 2020 2020 2020 2023 2063 616e             # can
-00005530: 2068 6170 7065 6e20 6475 7269 6e67 2075   happen during u
-00005540: 6e69 7420 7465 7374 2077 6974 686f 7574  nit test without
-00005550: 2047 5549 0a20 2020 2020 2020 2020 2020   GUI.           
-00005560: 2020 2020 2070 6173 730a 0a20 2020 2020       pass..     
-00005570: 2020 2023 2054 4f44 4f20 6669 6775 7265     # TODO figure
-00005580: 206f 7574 2061 7865 7320 7469 636b 732c   out axes ticks,
-00005590: 2065 7463 0a20 2020 2020 2020 2072 6574   etc.        ret
-000055a0: 7572 6e20 6178 2020 2320 6c69 6b65 6c79  urn ax  # likely
-000055b0: 2074 6869 7320 7265 7475 726e 2069 7320   this return is 
-000055c0: 6e6f 7420 6e65 6365 7373 6172 790a 0a20  not necessary.. 
-000055d0: 2020 2064 6566 2063 6c66 2873 656c 6629     def clf(self)
-000055e0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-000055f0: 2020 2020 2020 436c 6561 7220 7468 6520        Clear the 
-00005600: 7669 7274 7561 6c20 696d 6167 6520 706c  virtual image pl
-00005610: 616e 6520 2862 6173 6520 6d65 7468 6f64  ane (base method
-00005620: 290a 0a20 2020 2020 2020 2045 7665 7279  )..        Every
-00005630: 2063 616d 6572 6120 6f62 6a65 6374 2068   camera object h
-00005640: 6173 2061 2076 6972 7475 616c 2069 6d61  as a virtual ima
-00005650: 6765 2070 6c61 6e65 2064 7261 776e 2075  ge plane drawn u
-00005660: 7369 6e67 204d 6174 706c 6f74 6c69 622e  sing Matplotlib.
-00005670: 0a20 2020 2020 2020 2052 656d 6f76 6520  .        Remove 
-00005680: 616c 6c20 706f 696e 7473 2061 6e64 206c  all points and l
-00005690: 696e 6573 2066 726f 6d20 7468 6520 696d  ines from the im
-000056a0: 6167 6520 706c 616e 652e 0a20 2020 2020  age plane..     
-000056b0: 2020 200a 2020 2020 2020 2020 3a73 6565     .        :see
-000056c0: 616c 736f 3a20 3a6d 6574 683a 6070 6c6f  also: :meth:`plo
-000056d0: 745f 706f 696e 7460 203a 6d65 7468 3a60  t_point` :meth:`
-000056e0: 706c 6f74 5f6c 696e 6560 203a 6d65 7468  plot_line` :meth
-000056f0: 3a60 6469 7370 600a 2020 2020 2020 2020  :`disp`.        
-00005700: 2222 220a 2020 2020 2020 2020 6966 2073  """.        if s
-00005710: 656c 662e 5f61 7820 6973 206e 6f74 204e  elf._ax is not N
-00005720: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00005730: 2066 6f72 2061 7274 6973 7420 696e 2073   for artist in s
-00005740: 656c 662e 5f61 782e 6765 745f 6368 696c  elf._ax.get_chil
-00005750: 6472 656e 2829 3a0a 2020 2020 2020 2020  dren():.        
-00005760: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-00005770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005780: 2061 7274 6973 742e 7265 6d6f 7665 2829   artist.remove()
-00005790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000057a0: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
-000057b0: 2020 2020 2020 2020 2020 2020 2070 6173               pas
-000057c0: 730a 0a20 2020 2064 6566 2070 6c6f 745f  s..    def plot_
-000057d0: 706f 696e 7428 7365 6c66 2c20 502c 202a  point(self, P, *
-000057e0: 666d 742c 2072 6574 7572 6e5f 6172 7469  fmt, return_arti
-000057f0: 7374 3d46 616c 7365 2c20 6f62 6a70 6f73  st=False, objpos
-00005800: 653d 4e6f 6e65 2c20 706f 7365 3d4e 6f6e  e=None, pose=Non
-00005810: 652c 2061 783d 4e6f 6e65 2c20 2a2a 6b77  e, ax=None, **kw
-00005820: 6172 6773 293a 0a20 2020 2020 2020 2022  args):.        "
-00005830: 2222 0a20 2020 2020 2020 2050 6c6f 7420  "".        Plot 
-00005840: 706f 696e 7473 206f 6e20 7669 7274 7561  points on virtua
-00005850: 6c20 696d 6167 6520 706c 616e 6520 2862  l image plane (b
-00005860: 6173 6520 6d65 7468 6f64 290a 0a20 2020  ase method)..   
-00005870: 2020 2020 203a 7061 7261 6d20 503a 2033       :param P: 3
-00005880: 4420 776f 726c 6420 706f 696e 7420 6f72  D world point or
-00005890: 2070 6f69 6e74 732c 206f 7220 3244 2069   points, or 2D i
-000058a0: 6d61 6765 2070 6c61 6e65 2070 6f69 6e74  mage plane point
-000058b0: 206f 7220 706f 696e 7473 0a20 2020 2020   or points.     
-000058c0: 2020 203a 7479 7065 2050 3a20 6e64 6172     :type P: ndar
-000058d0: 7261 7928 332c 292c 206e 6461 7272 6179  ray(3,), ndarray
-000058e0: 2833 2c4e 292c 206f 7220 6e64 6172 7261  (3,N), or ndarra
-000058f0: 7928 322c 292c 206e 6461 7272 6179 2832  y(2,), ndarray(2
-00005900: 2c4e 290a 2020 2020 2020 2020 3a70 6172  ,N).        :par
-00005910: 616d 206f 626a 706f 7365 3a20 7472 616e  am objpose: tran
-00005920: 7366 6f72 6d61 7469 6f6e 2066 6f72 2074  sformation for t
-00005930: 6865 2033 4420 706f 696e 7473 2c20 6465  he 3D points, de
-00005940: 6661 756c 7473 2074 6f20 4e6f 6e65 0a20  faults to None. 
-00005950: 2020 2020 2020 203a 7479 7065 206f 626a         :type obj
-00005960: 706f 7365 3a20 3a63 6c61 7373 3a60 7e73  pose: :class:`~s
-00005970: 7061 7469 616c 6d61 7468 2e2e 706f 7365  patialmath..pose
-00005980: 3364 2e53 4533 602c 206f 7074 696f 6e61  3d.SE3`, optiona
-00005990: 6c0a 2020 2020 2020 2020 3a70 6172 616d  l.        :param
-000059a0: 2070 6f73 653a 2070 6f73 6520 6f66 2074   pose: pose of t
-000059b0: 6865 2063 616d 6572 612c 2064 6566 6175  he camera, defau
-000059c0: 6c74 7320 746f 204e 6f6e 650a 2020 2020  lts to None.    
-000059d0: 2020 2020 3a74 7970 6520 706f 7365 3a20      :type pose: 
-000059e0: 3a63 6c61 7373 3a60 7e73 7061 7469 616c  :class:`~spatial
-000059f0: 6d61 7468 2e2e 706f 7365 3364 2e53 4533  math..pose3d.SE3
-00005a00: 602c 206f 7074 696f 6e61 6c0a 2020 2020  `, optional.    
-00005a10: 2020 2020 3a70 6172 616d 2061 783a 2061      :param ax: a
-00005a20: 7865 7320 746f 2070 6c6f 7420 696e 746f  xes to plot into
-00005a30: 0a20 2020 2020 2020 203a 7479 7065 2061  .        :type a
-00005a40: 783a 203a 636c 6173 733a 606d 6174 706c  x: :class:`matpl
-00005a50: 6f74 6c69 622e 6178 6573 600a 2020 2020  otlib.axes`.    
-00005a60: 2020 2020 3a70 6172 616d 206b 7761 7267      :param kwarg
-00005a70: 733a 2061 6464 6974 696f 6e61 6c20 6172  s: additional ar
-00005a80: 6775 6d65 6e74 7320 7061 7373 6564 2074  guments passed t
-00005a90: 6f20 3a6f 626a 3a60 7e6d 6174 706c 6f74  o :obj:`~matplot
-00005aa0: 6c69 622e 7079 706c 6f74 2e70 6c6f 7460  lib.pyplot.plot`
-00005ab0: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
-00005ac0: 3a20 4d61 7470 6c6f 746c 6962 206c 696e  : Matplotlib lin
-00005ad0: 6520 6f62 6a65 6374 730a 2020 2020 2020  e objects.      
-00005ae0: 2020 3a72 7479 7065 3a20 6c69 7374 206f    :rtype: list o
-00005af0: 6620 3a63 6c61 7373 3a60 7e6d 6174 706c  f :class:`~matpl
-00005b00: 6f74 6c69 622e 6c69 6e65 732e 4c69 6e65  otlib.lines.Line
-00005b10: 3264 600a 0a20 2020 2020 2020 2033 4420  2d`..        3D 
-00005b20: 776f 726c 6420 706f 696e 7473 2061 7265  world points are
-00005b30: 2066 6972 7374 2070 726f 6a65 6374 6564   first projected
-00005b40: 2074 6f20 7468 6520 696d 6167 6520 706c   to the image pl
-00005b50: 616e 6520 616e 6420 7468 656e 200a 2020  ane and then .  
-00005b60: 2020 2020 2020 706c 6f74 7465 6420 6f6e        plotted on
-00005b70: 2074 6865 2063 616d 6572 6127 7320 7669   the camera's vi
-00005b80: 7274 7561 6c20 696d 6167 6520 706c 616e  rtual image plan
-00005b90: 652e 0a20 2020 2020 2020 2050 6f69 6e74  e..        Point
-00005ba0: 7320 6172 6520 6f72 6761 6e69 7a65 6420  s are organized 
-00005bb0: 6173 2063 6f6c 756d 6e73 206f 6620 7468  as columns of th
-00005bc0: 6520 6172 7261 7973 2e0a 0a20 2020 2020  e arrays...     
-00005bd0: 2020 2045 7861 6d70 6c65 3a3a 0a0a 2020     Example::..  
-00005be0: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
-00005bf0: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
-00005c00: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
-00005c10: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
-00005c20: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
-00005c30: 6d20 7370 6174 6961 6c6d 6174 6820 696d  m spatialmath im
-00005c40: 706f 7274 2053 4533 0a20 2020 2020 2020  port SE3.       
-00005c50: 2020 2020 203e 3e3e 2063 616d 6572 6120       >>> camera 
-00005c60: 3d20 4365 6e74 7261 6c43 616d 6572 612e  = CentralCamera.
-00005c70: 4465 6661 756c 7428 290a 2020 2020 2020  Default().      
-00005c80: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
-00005c90: 2e70 6c6f 745f 706f 696e 7428 5b30 2e32  .plot_point([0.2
-00005ca0: 2c20 302e 332c 2032 5d29 0a20 2020 2020  , 0.3, 2]).     
-00005cb0: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
-00005cc0: 612e 706c 6f74 5f70 6f69 6e74 285b 302e  a.plot_point([0.
-00005cd0: 322c 2030 2e33 2c20 325d 2c20 2772 2a27  2, 0.3, 2], 'r*'
-00005ce0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
-00005cf0: 3e20 6361 6d65 7261 2e70 6c6f 745f 706f  > camera.plot_po
-00005d00: 696e 7428 5b30 2e32 2c20 302e 332c 2032  int([0.2, 0.3, 2
-00005d10: 5d2c 2070 6f73 653d 5345 3328 302e 312c  ], pose=SE3(0.1,
-00005d20: 2030 2c20 3029 290a 0a20 2020 2020 2020   0, 0))..       
-00005d30: 202e 2e20 706c 6f74 3a3a 0a0a 2020 2020   .. plot::..    
-00005d40: 2020 2020 2020 2020 6672 6f6d 206d 6163          from mac
-00005d50: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
-00005d60: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
-00005d70: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
-00005d80: 2020 2066 726f 6d20 7370 6174 6961 6c6d     from spatialm
-00005d90: 6174 6820 696d 706f 7274 2053 4533 0a20  ath import SE3. 
-00005da0: 2020 2020 2020 2020 2020 2063 616d 6572             camer
-00005db0: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
-00005dc0: 612e 4465 6661 756c 7428 290a 2020 2020  a.Default().    
-00005dd0: 2020 2020 2020 2020 6361 6d65 7261 2e70          camera.p
-00005de0: 6c6f 745f 706f 696e 7428 5b30 2e32 2c20  lot_point([0.2, 
-00005df0: 302e 332c 2032 5d29 0a20 2020 2020 2020  0.3, 2]).       
-00005e00: 2020 2020 2063 616d 6572 612e 706c 6f74       camera.plot
-00005e10: 5f70 6f69 6e74 285b 302e 322c 2030 2e33  _point([0.2, 0.3
-00005e20: 2c20 325d 2c20 2772 2a27 290a 2020 2020  , 2], 'r*').    
-00005e30: 2020 2020 2020 2020 6361 6d65 7261 2e70          camera.p
-00005e40: 6c6f 745f 706f 696e 7428 5b30 2e32 2c20  lot_point([0.2, 
-00005e50: 302e 332c 2032 5d2c 2070 6f73 653d 5345  0.3, 2], pose=SE
-00005e60: 3328 302e 312c 2030 2c20 3029 290a 0a20  3(0.1, 0, 0)).. 
-00005e70: 2020 2020 2020 203a 6e6f 7465 3a0a 2020         :note:.  
-00005e80: 2020 2020 2020 2020 2020 2d20 5375 6363            - Succ
-00005e90: 6573 7369 7665 2063 616c 6c73 2061 6464  essive calls add
-00005ea0: 2069 7465 6d73 2074 6f20 7468 6520 7669   items to the vi
-00005eb0: 7274 7561 6c20 696d 6167 6520 706c 616e  rtual image plan
-00005ec0: 652e 0a20 2020 2020 2020 2020 2020 202d  e..            -
-00005ed0: 2054 6869 7320 6d65 7468 6f64 2069 7320   This method is 
-00005ee0: 636f 6d6d 6f6e 2074 6f20 616c 6c20 6060  common to all ``
-00005ef0: 4361 6d65 7261 4261 7365 6060 2073 7562  CameraBase`` sub
-00005f00: 636c 6173 7365 732c 2062 7574 2069 740a  classes, but it.
-00005f10: 2020 2020 2020 2020 2020 2020 2020 696e                in
-00005f20: 766f 6b65 7320 6120 6361 6d65 7261 2d73  vokes a camera-s
-00005f30: 7065 6369 6669 6320 7072 6f6a 6563 7469  pecific projecti
-00005f40: 6f6e 206d 6574 686f 642e 0a0a 2020 2020  on method...    
-00005f50: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
-00005f60: 6574 683a 6070 6c6f 745f 6c69 6e65 3260  eth:`plot_line2`
-00005f70: 203a 6d65 7468 3a60 706c 6f74 5f6c 696e   :meth:`plot_lin
-00005f80: 6533 6020 3a6d 6574 683a 6070 6c6f 745f  e3` :meth:`plot_
-00005f90: 7769 7265 6672 616d 6560 203a 6d65 7468  wireframe` :meth
-00005fa0: 3a60 636c 6660 0a20 2020 2020 2020 2022  :`clf`.        "
-00005fb0: 2222 0a20 2020 2020 2020 2073 656c 662e  "".        self.
-00005fc0: 5f69 6e69 745f 696d 6167 6570 6c61 6e65  _init_imageplane
-00005fd0: 2861 7829 0a0a 2020 2020 2020 2020 6966  (ax)..        if
-00005fe0: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
-00005ff0: 502c 206e 702e 6e64 6172 7261 7929 3a0a  P, np.ndarray):.
-00006000: 2020 2020 2020 2020 2020 2020 5020 3d20              P = 
-00006010: 6261 7365 2e67 6574 7665 6374 6f72 2850  base.getvector(P
-00006020: 290a 0a20 2020 2020 2020 2069 6620 502e  )..        if P.
-00006030: 7368 6170 655b 305d 203d 3d20 333a 0a20  shape[0] == 3:. 
-00006040: 2020 2020 2020 2020 2020 2023 2070 6c6f             # plo
-00006050: 7420 776f 726c 6420 706f 696e 7473 0a20  t world points. 
-00006060: 2020 2020 2020 2020 2020 2070 203d 2073             p = s
-00006070: 656c 662e 7072 6f6a 6563 745f 706f 696e  elf.project_poin
-00006080: 7428 502c 2070 6f73 653d 706f 7365 2c20  t(P, pose=pose, 
-00006090: 6f62 6a70 6f73 653d 6f62 6a70 6f73 6529  objpose=objpose)
-000060a0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-000060b0: 2020 2020 2020 2020 2020 2023 2070 6c6f             # plo
-000060c0: 7420 696d 6167 6520 706c 616e 6520 706f  t image plane po
-000060d0: 696e 7473 0a20 2020 2020 2020 2020 2020  ints.           
-000060e0: 2070 203d 2050 0a0a 2020 2020 2020 2020   p = P..        
-000060f0: 6966 2070 2e73 6861 7065 5b30 5d20 213d  if p.shape[0] !=
-00006100: 2032 3a0a 2020 2020 2020 2020 2020 2020   2:.            
-00006110: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00006120: 2827 7020 6d75 7374 2068 6176 6520 6265  ('p must have be
-00006130: 2028 322c 292c 2028 332c 292c 2028 322c   (2,), (3,), (2,
-00006140: 6e29 2c20 2833 2c6e 2927 290a 0a20 2020  n), (3,n)')..   
-00006150: 2020 2020 2064 6566 6175 6c74 7320 3d20       defaults = 
-00006160: 6469 6374 286d 6172 6b65 7273 697a 653d  dict(markersize=
-00006170: 362c 2063 6f6c 6f72 3d27 6b27 290a 2020  6, color='k').  
-00006180: 2020 2020 2020 6966 206c 656e 2866 6d74        if len(fmt
-00006190: 2920 3d3d 2030 3a0a 2020 2020 2020 2020  ) == 0:.        
-000061a0: 2020 2020 666d 7420 3d20 5b27 6f27 5d0a      fmt = ['o'].
-000061b0: 2020 2020 2020 2020 2020 2020 6b77 6172              kwar
-000061c0: 6773 203d 207b 2a2a 6465 6661 756c 7473  gs = {**defaults
-000061d0: 2c20 2a2a 6b77 6172 6773 7d0a 0a20 2020  , **kwargs}..   
-000061e0: 2020 2020 2061 7274 6973 7420 3d20 7365       artist = se
-000061f0: 6c66 2e5f 6178 2e70 6c6f 7428 705b 302c  lf._ax.plot(p[0,
-00006200: 203a 5d2c 2070 5b31 2c20 3a5d 2c20 2a66   :], p[1, :], *f
-00006210: 6d74 2c20 2a2a 6b77 6172 6773 290a 2020  mt, **kwargs).  
-00006220: 2020 2020 2020 6966 2070 6c74 2e69 7369        if plt.isi
-00006230: 6e74 6572 6163 7469 7665 2829 3a0a 2020  nteractive():.  
-00006240: 2020 2020 2020 2020 2020 706c 742e 7368            plt.sh
-00006250: 6f77 2862 6c6f 636b 3d46 616c 7365 290a  ow(block=False).
-00006260: 0a20 2020 2020 2020 2069 6620 7265 7475  .        if retu
-00006270: 726e 5f61 7274 6973 743a 0a20 2020 2020  rn_artist:.     
-00006280: 2020 2020 2020 2072 6574 7572 6e20 702c         return p,
-00006290: 2061 7274 6973 745b 305d 0a20 2020 2020   artist[0].     
-000062a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000062b0: 2020 2020 2072 6574 7572 6e20 700a 0a20       return p.. 
-000062c0: 2020 2064 6566 2070 6c6f 745f 6c69 6e65     def plot_line
-000062d0: 3228 7365 6c66 2c20 6c2c 202a 6172 6773  2(self, l, *args
-000062e0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
-000062f0: 2020 2020 2072 2222 220a 2020 2020 2020       r""".      
-00006300: 2020 506c 6f74 2032 4420 6c69 6e65 206f    Plot 2D line o
-00006310: 6e20 7669 7274 7561 6c20 696d 6167 6520  n virtual image 
-00006320: 706c 616e 6520 2862 6173 6520 6d65 7468  plane (base meth
-00006330: 6f64 290a 0a20 2020 2020 2020 203a 7061  od)..        :pa
-00006340: 7261 6d20 6c3a 2068 6f6d 6f67 656e 656f  ram l: homogeneo
-00006350: 7573 206c 696e 650a 2020 2020 2020 2020  us line.        
-00006360: 3a74 7970 6520 6c3a 2061 7272 6179 5f6c  :type l: array_l
-00006370: 696b 6528 3329 0a20 2020 2020 2020 203a  ike(3).        :
-00006380: 7061 7261 6d20 6b77 6172 6773 3a20 6172  param kwargs: ar
-00006390: 6775 6d65 6e74 7320 7061 7373 6564 2074  guments passed t
-000063a0: 6f20 6060 706c 6f74 6060 0a0a 2020 2020  o ``plot``..    
-000063b0: 2020 2020 506c 6f74 2074 6865 2068 6f6d      Plot the hom
-000063c0: 6f67 656e 656f 7573 206c 696e 6520 6f6e  ogeneous line on
-000063d0: 2074 6865 2063 616d 6572 6127 7320 7669   the camera's vi
-000063e0: 7274 7561 6c20 696d 6167 6520 706c 616e  rtual image plan
-000063f0: 652e 2054 6865 206c 696e 650a 2020 2020  e. The line.    
-00006400: 2020 2020 6973 2065 7870 7265 7373 6564      is expressed
-00006410: 2069 6e20 7468 6520 666f 726d 0a20 2020   in the form.   
-00006420: 2020 2020 200a 2020 2020 2020 2020 2e2e       .        ..
-00006430: 206d 6174 683a 3a20 5c65 6c6c 5f30 2075   math:: \ell_0 u
-00006440: 202b 205c 656c 6c5f 3120 7620 2b20 5c65   + \ell_1 v + \e
-00006450: 6c6c 5f32 203d 2030 0a0a 2020 2020 2020  ll_2 = 0..      
-00006460: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
-00006470: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-00006480: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
-00006490: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
-000064a0: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-000064b0: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
-000064c0: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-000064d0: 2020 2020 3e3e 3e20 6361 6d65 7261 203d      >>> camera =
-000064e0: 2043 656e 7472 616c 4361 6d65 7261 2e44   CentralCamera.D
-000064f0: 6566 6175 6c74 2829 0a20 2020 2020 2020  efault().       
-00006500: 2020 2020 203e 3e3e 2063 616d 6572 612e       >>> camera.
-00006510: 706c 6f74 5f6c 696e 6532 285b 312c 2030  plot_line2([1, 0
-00006520: 2e32 2c20 2d35 3030 5d29 0a0a 2020 2020  .2, -500])..    
-00006530: 2020 2020 3a6e 6f74 653a 0a20 2020 2020      :note:.     
-00006540: 2020 2020 2020 202d 2053 7563 6365 7373         - Success
-00006550: 6976 6520 6361 6c6c 7320 6164 6420 6974  ive calls add it
-00006560: 656d 7320 746f 2074 6865 2076 6972 7475  ems to the virtu
-00006570: 616c 2069 6d61 6765 2070 6c61 6e65 2e0a  al image plane..
-00006580: 2020 2020 2020 2020 2020 2020 2d20 5468              - Th
-00006590: 6973 206d 6574 686f 6420 6973 2063 6f6d  is method is com
-000065a0: 6d6f 6e20 746f 2061 6c6c 2060 6043 616d  mon to all ``Cam
-000065b0: 6572 6142 6173 6560 6020 7375 6263 6c61  eraBase`` subcla
-000065c0: 7373 6573 2c20 6275 7420 6974 0a20 2020  sses, but it.   
-000065d0: 2020 2020 2020 2020 2020 2069 6e76 6f6b             invok
-000065e0: 6573 2061 2063 616d 6572 612d 7370 6563  es a camera-spec
-000065f0: 6966 6963 2070 726f 6a65 6374 696f 6e20  ific projection 
-00006600: 6d65 7468 6f64 2e0a 0a20 2020 2020 2020  method...       
-00006610: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
-00006620: 3a60 706c 6f74 5f70 6f69 6e74 6020 3a6d  :`plot_point` :m
-00006630: 6574 683a 6070 6c6f 745f 6c69 6e65 3360  eth:`plot_line3`
-00006640: 203a 6d65 7468 3a60 636c 6660 0a20 2020   :meth:`clf`.   
-00006650: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00006660: 2023 2067 6574 2068 616e 646c 6520 666f   # get handle fo
-00006670: 7220 7468 6973 2063 616d 6572 6120 696d  r this camera im
-00006680: 6167 6520 706c 616e 650a 2020 2020 2020  age plane.      
-00006690: 2020 7365 6c66 2e5f 696e 6974 5f69 6d61    self._init_ima
-000066a0: 6765 706c 616e 6528 290a 2020 2020 2020  geplane().      
-000066b0: 2020 706c 742e 6175 746f 7363 616c 6528    plt.autoscale(
-000066c0: 4661 6c73 6529 0a0a 2020 2020 2020 2020  False)..        
-000066d0: 6261 7365 2e70 6c6f 745f 686f 6d6c 696e  base.plot_homlin
-000066e0: 6528 6c2c 202a 6172 6773 2c20 6178 3d73  e(l, *args, ax=s
-000066f0: 656c 662e 5f61 782c 202a 2a6b 7761 7267  elf._ax, **kwarg
-00006700: 7329 0a0a 0a20 2020 2023 2064 6566 2070  s)...    # def p
-00006710: 6c6f 745f 6c69 6e65 3328 7365 6c66 2c20  lot_line3(self, 
-00006720: 4c2c 206e 7374 6570 733d 3231 2c20 2a2a  L, nsteps=21, **
-00006730: 6b77 6172 6773 293a 0a20 2020 2023 2020  kwargs):.    #  
-00006740: 2020 2022 2222 0a20 2020 2023 2020 2020     """.    #    
-00006750: 2050 6c6f 7420 3344 206c 696e 6520 6f6e   Plot 3D line on
-00006760: 2076 6972 7475 616c 2069 6d61 6765 2070   virtual image p
-00006770: 6c61 6e65 2028 6261 7365 206d 6574 686f  lane (base metho
-00006780: 6429 0a0a 2020 2020 2320 2020 2020 3a70  d)..    #     :p
-00006790: 6172 616d 204c 3a20 3344 206c 696e 6520  aram L: 3D line 
-000067a0: 6f72 206c 696e 6573 2069 6e20 506c 7563  or lines in Pluc
-000067b0: 6b65 7220 636f 6f72 6469 6e61 7465 730a  ker coordinates.
-000067c0: 2020 2020 2320 2020 2020 3a74 7970 6520      #     :type 
-000067d0: 4c3a 203a 636c 6173 733a 607e 7370 6174  L: :class:`~spat
-000067e0: 6961 6c6d 6174 682e 2e67 656f 6d33 642e  ialmath..geom3d.
-000067f0: 4c69 6e65 3360 0a20 2020 2023 2020 2020  Line3`.    #    
-00006800: 203a 7061 7261 6d20 6b77 6172 6773 3a20   :param kwargs: 
-00006810: 6172 6775 6d65 6e74 7320 7061 7373 6564  arguments passed
-00006820: 2074 6f20 6060 706c 6f74 6060 0a0a 2020   to ``plot``..  
-00006830: 2020 2320 2020 2020 5468 6520 506c 7563    #     The Pluc
-00006840: 6b65 7220 6c69 6e65 7320 6172 6520 7072  ker lines are pr
-00006850: 6f6a 6563 7465 6420 746f 2074 6865 2063  ojected to the c
-00006860: 616d 6572 6127 7320 7669 7274 7561 6c20  amera's virtual 
-00006870: 696d 6167 6520 706c 616e 6520 616e 640a  image plane and.
-00006880: 2020 2020 2320 2020 2020 706c 6f74 7465      #     plotte
-00006890: 642e 2020 4561 6368 206c 696e 6520 6973  d.  Each line is
-000068a0: 2061 7070 726f 7869 6d61 7465 6420 6279   approximated by
-000068b0: 2060 606e 7374 6570 7360 6020 706f 696e   ``nsteps`` poin
-000068c0: 7473 2c20 6561 6368 206f 6620 7768 6963  ts, each of whic
-000068d0: 680a 2020 2020 2320 2020 2020 6973 2070  h.    #     is p
-000068e0: 726f 6a65 6374 6564 2c20 616c 6c6f 7769  rojected, allowi
-000068f0: 6e67 2073 7472 6169 6768 7420 6c69 6e65  ng straight line
-00006900: 7320 746f 2061 7070 6561 7220 6375 7276  s to appear curv
-00006910: 6564 2061 6674 6572 2070 726f 6a65 6374  ed after project
-00006920: 696f 6e2e 0a0a 2020 2020 2320 2020 2020  ion...    #     
-00006930: 4578 616d 706c 653a 0a0a 2020 2020 2320  Example:..    # 
-00006940: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-00006950: 3a20 7079 636f 6e0a 0a20 2020 2023 2020  : pycon..    #  
-00006960: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
-00006970: 6d61 6368 696e 6576 6973 696f 6e74 6f6f  machinevisiontoo
-00006980: 6c62 6f78 2069 6d70 6f72 7420 4365 6e74  lbox import Cent
-00006990: 7261 6c43 616d 6572 612c 206d 6b63 7562  ralCamera, mkcub
-000069a0: 650a 2020 2020 2320 2020 2020 2020 2020  e.    #         
-000069b0: 3e3e 3e20 6672 6f6d 2073 7061 7469 616c  >>> from spatial
-000069c0: 6d61 7468 2069 6d70 6f72 7420 4c69 6e65  math import Line
-000069d0: 330a 2020 2020 2320 2020 2020 2020 2020  3.    #         
-000069e0: 3e3e 3e20 6361 6d65 7261 203d 2043 656e  >>> camera = Cen
-000069f0: 7472 616c 4361 6d65 7261 2829 0a20 2020  tralCamera().   
-00006a00: 2023 2020 2020 2020 2020 203e 3e3e 206c   #         >>> l
-00006a10: 696e 6520 3d20 4c69 6e65 332e 4a6f 696e  ine = Line3.Join
-00006a20: 2828 2d31 2c20 2d32 2c20 2d33 292c 2028  ((-1, -2, -3), (
-00006a30: 342c 2035 2c20 3629 290a 2020 2020 2320  4, 5, 6)).    # 
-00006a40: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-00006a50: 7261 2e70 6c6f 745f 6c69 6e65 3328 6c69  ra.plot_line3(li
-00006a60: 6e65 2c20 276b 2d2d 2729 0a0a 2020 2020  ne, 'k--')..    
-00006a70: 2320 2020 2020 2e2e 206e 6f74 653a 3a0a  #     .. note::.
-00006a80: 2020 2020 2320 2020 2020 2020 2020 2d20      #         - 
-00006a90: 5375 6363 6573 7369 7665 2063 616c 6c73  Successive calls
-00006aa0: 2061 6464 2069 7465 6d73 2074 6f20 7468   add items to th
-00006ab0: 6520 7669 7274 7561 6c20 696d 6167 6520  e virtual image 
-00006ac0: 706c 616e 652e 0a20 2020 2023 2020 2020  plane..    #    
-00006ad0: 2020 2020 202d 2054 6869 7320 6d65 7468       - This meth
-00006ae0: 6f64 2069 7320 636f 6d6d 6f6e 2074 6f20  od is common to 
-00006af0: 616c 6c20 6060 4361 6d65 7261 4261 7365  all ``CameraBase
-00006b00: 6060 2073 7562 636c 6173 7365 732c 2062  `` subclasses, b
-00006b10: 7574 2069 740a 2020 2020 2320 2020 2020  ut it.    #     
-00006b20: 2020 2020 2020 696e 766f 6b65 7320 6120        invokes a 
-00006b30: 6361 6d65 7261 2d73 7065 6369 6669 6320  camera-specific 
-00006b40: 7072 6f6a 6563 7469 6f6e 206d 6574 686f  projection metho
-00006b50: 642e 0a20 2020 2020 2020 2020 2020 2020  d..             
-00006b60: 200a 2020 2020 2320 2020 2020 3a73 6565   .    #     :see
-00006b70: 616c 736f 3a20 3a6d 6574 683a 6070 6c6f  also: :meth:`plo
-00006b80: 745f 706f 696e 7460 203a 6d65 7468 3a60  t_point` :meth:`
-00006b90: 706c 6f74 5f6c 696e 6532 6020 3a6d 6574  plot_line2` :met
-00006ba0: 683a 6070 6c6f 745f 7769 7265 6672 616d  h:`plot_wirefram
-00006bb0: 6560 203a 6d65 7468 3a60 636c 6660 0a20  e` :meth:`clf`. 
-00006bc0: 2020 2023 2020 2020 2022 2222 0a20 2020     #     """.   
-00006bd0: 2023 2020 2020 2023 2064 7261 7720 3344   #     # draw 3D
-00006be0: 206c 696e 6520 7365 676d 656e 7473 0a20   line segments. 
-00006bf0: 2020 2023 2020 2020 2073 203d 206e 702e     #     s = np.
-00006c00: 6c69 6e73 7061 6365 2830 2c20 312c 206e  linspace(0, 1, n
-00006c10: 7374 6570 7329 0a0a 2020 2020 2020 2020  steps)..        
-00006c20: 2320 7468 6973 2069 7320 6163 7475 616c  # this is actual
-00006c30: 6c79 2070 7265 7474 7920 7472 6963 6b79  ly pretty tricky
-00006c40: 0a20 2020 2020 2020 2023 2020 2d20 686f  .        #  - ho
-00006c50: 7720 746f 2064 6574 6572 6d69 6e65 2077  w to determine w
-00006c60: 6869 6368 2070 6172 7420 6f66 2074 6865  hich part of the
-00006c70: 2033 4420 6c69 6e65 2069 7320 7669 7369   3D line is visi
-00006c80: 626c 650a 2020 2020 2020 2020 2320 202d  ble.        #  -
-00006c90: 2069 6620 6869 6768 6c79 2063 7572 7665   if highly curve
-00006ca0: 6420 6974 206d 6179 2062 6520 696e 2074  d it may be in t
-00006cb0: 776f 206f 7220 6d6f 7265 2073 6567 6d65  wo or more segme
-00006cc0: 6e74 730a 2020 2020 2020 2020 2320 666f  nts.        # fo
-00006cd0: 7220 6c69 6e65 2069 6e20 4c3a 0a20 2020  r line in L:.   
-00006ce0: 2020 2020 2023 2020 2020 206c 203d 2073       #     l = s
-00006cf0: 656c 662e 7072 6f6a 6563 745f 6c69 6e65  elf.project_line
-00006d00: 286c 696e 6529 0a0a 2020 2020 2020 2020  (line)..        
-00006d10: 2320 2020 2020 2320 7374 7261 6967 6874  #     # straight
-00006d20: 2077 6f72 6c64 206c 696e 6573 2061 7265   world lines are
-00006d30: 206e 6f74 2073 7472 6169 6768 742c 2070   not straight, p
-00006d40: 6c6f 7420 7468 656d 2070 6965 6365 7769  lot them piecewi
-00006d50: 7365 0a20 2020 2020 2020 2023 2020 2020  se.        #    
-00006d60: 2050 203d 2028 3120 2d20 7329 202a 2050   P = (1 - s) * P
-00006d70: 305b 3a2c 206e 702e 6e65 7761 7869 735d  0[:, np.newaxis]
-00006d80: 202b 2073 202a 2050 325b 3a2c 206e 702e   + s * P2[:, np.
-00006d90: 6e65 7761 7869 735d 0a20 2020 2020 2020  newaxis].       
-00006da0: 2023 2020 2020 2075 7620 3d20 7365 6c66   #     uv = self
-00006db0: 2e70 726f 6a65 6374 5f70 6f69 6e74 2850  .project_point(P
-00006dc0: 2c20 706f 7365 3d70 6f73 6529 0a0a 2020  , pose=pose)..  
-00006dd0: 2020 6465 6620 706c 6f74 5f77 6972 6566    def plot_wiref
-00006de0: 7261 6d65 2873 656c 662c 2058 2c20 592c  rame(self, X, Y,
-00006df0: 205a 2c20 2a66 6d74 2c20 6f62 6a70 6f73   Z, *fmt, objpos
-00006e00: 653d 4e6f 6e65 2c20 706f 7365 3d4e 6f6e  e=None, pose=Non
-00006e10: 652c 206e 7374 6570 733d 3231 2c20 2a2a  e, nsteps=21, **
-00006e20: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
-00006e30: 2022 2222 0a20 2020 2020 2020 2050 6c6f   """.        Plo
-00006e40: 7420 3344 2077 6972 6566 7261 6d65 2069  t 3D wireframe i
-00006e50: 6e20 7669 7274 7561 6c20 696d 6167 6520  n virtual image 
-00006e60: 706c 616e 6520 2862 6173 6520 6d65 7468  plane (base meth
-00006e70: 6f64 290a 0a20 2020 2020 2020 203a 7061  od)..        :pa
-00006e80: 7261 6d20 583a 2077 6f72 6c64 2058 2063  ram X: world X c
-00006e90: 6f6f 7264 696e 6174 6573 0a20 2020 2020  oordinates.     
-00006ea0: 2020 203a 7479 7065 2058 3a20 6e64 6172     :type X: ndar
-00006eb0: 7261 7928 4e2c 4d29 0a20 2020 2020 2020  ray(N,M).       
-00006ec0: 203a 7061 7261 6d20 593a 2077 6f72 6c64   :param Y: world
-00006ed0: 2059 2063 6f6f 7264 696e 6174 6573 0a20   Y coordinates. 
-00006ee0: 2020 2020 2020 203a 7479 7065 2059 3a20         :type Y: 
-00006ef0: 6e64 6172 7261 7928 4e2c 4d29 0a20 2020  ndarray(N,M).   
-00006f00: 2020 2020 203a 7061 7261 6d20 5a3a 2077       :param Z: w
-00006f10: 6f72 6c64 205a 2063 6f6f 7264 696e 6174  orld Z coordinat
-00006f20: 6573 0a20 2020 2020 2020 203a 7479 7065  es.        :type
-00006f30: 205a 3a20 6e64 6172 7261 7928 4e2c 4d29   Z: ndarray(N,M)
-00006f40: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-00006f50: 6f62 6a70 6f73 653a 2074 7261 6e73 666f  objpose: transfo
-00006f60: 726d 6174 696f 6e20 666f 7220 7468 6520  rmation for the 
-00006f70: 7769 7265 6672 616d 6520 706f 696e 7473  wireframe points
-00006f80: 2c20 6465 6661 756c 7473 2074 6f20 4e6f  , defaults to No
-00006f90: 6e65 0a20 2020 2020 2020 203a 7479 7065  ne.        :type
-00006fa0: 206f 626a 706f 7365 3a20 3a63 6c61 7373   objpose: :class
-00006fb0: 3a60 7e73 7061 7469 616c 6d61 7468 2e2e  :`~spatialmath..
-00006fc0: 706f 7365 3364 2e53 4533 602c 206f 7074  pose3d.SE3`, opt
-00006fd0: 696f 6e61 6c0a 2020 2020 2020 2020 3a70  ional.        :p
-00006fe0: 6172 616d 2070 6f73 653a 2070 6f73 6520  aram pose: pose 
-00006ff0: 6f66 2074 6865 2063 616d 6572 612c 2064  of the camera, d
-00007000: 6566 6175 6c74 7320 746f 204e 6f6e 650a  efaults to None.
-00007010: 2020 2020 2020 2020 3a74 7970 6520 706f          :type po
-00007020: 7365 3a20 3a63 6c61 7373 3a60 7e73 7061  se: :class:`~spa
-00007030: 7469 616c 6d61 7468 2e2e 706f 7365 3364  tialmath..pose3d
-00007040: 2e53 4533 602c 206f 7074 696f 6e61 6c0a  .SE3`, optional.
-00007050: 2020 2020 2020 2020 3a70 6172 616d 206e          :param n
-00007060: 7374 6570 733a 206e 756d 6265 7220 6f66  steps: number of
-00007070: 2070 6f69 6e74 7320 666f 7220 6561 6368   points for each
-00007080: 2077 6972 6566 7261 6d65 2073 6567 6d65   wireframe segme
-00007090: 6e74 2c20 6465 6661 756c 7473 2074 6f20  nt, defaults to 
-000070a0: 3231 0a20 2020 2020 2020 203a 7479 7065  21.        :type
-000070b0: 206e 7374 6570 733a 2069 6e74 2c20 6f70   nsteps: int, op
-000070c0: 7469 6f6e 616c 0a20 2020 2020 2020 203a  tional.        :
-000070d0: 7061 7261 6d20 6b77 6172 6773 3a20 6172  param kwargs: ar
-000070e0: 6775 6d65 6e74 7320 7061 7373 6564 2074  guments passed t
-000070f0: 6f20 6060 706c 6f74 6060 0a0a 2020 2020  o ``plot``..    
-00007100: 2020 2020 5468 6520 3344 2077 6972 6566      The 3D wiref
-00007110: 7261 6d65 2069 7320 7072 6f6a 6563 7465  rame is projecte
-00007120: 6420 746f 2074 6865 2063 616d 6572 6127  d to the camera'
-00007130: 7320 7669 7274 7561 6c20 696d 6167 6520  s virtual image 
-00007140: 706c 616e 652e 2020 4561 6368 0a20 2020  plane.  Each.   
-00007150: 2020 2020 2077 6972 6520 6c69 6e6b 2069       wire link i
-00007160: 6e20 7468 6520 7769 7265 6672 616d 6520  n the wireframe 
-00007170: 6973 2061 7070 726f 7869 6d61 7465 6420  is approximated 
-00007180: 6279 2060 606e 7374 6570 7360 6020 706f  by ``nsteps`` po
-00007190: 696e 7473 2c20 6561 6368 206f 660a 2020  ints, each of.  
-000071a0: 2020 2020 2020 7768 6963 6820 6973 2070        which is p
-000071b0: 726f 6a65 6374 6564 2c20 616c 6c6f 7769  rojected, allowi
-000071c0: 6e67 2073 7472 6169 6768 7420 6564 6765  ng straight edge
-000071d0: 7320 746f 2061 7070 6561 7220 6375 7276  s to appear curv
-000071e0: 6564 2e0a 0a20 2020 2020 2020 2045 7861  ed...        Exa
-000071f0: 6d70 6c65 3a3a 0a0a 2020 2020 2020 2020  mple::..        
-00007200: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
-00007210: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
-00007220: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
-00007230: 4361 6d65 7261 2c20 6d6b 6375 6265 0a20  Camera, mkcube. 
-00007240: 2020 2020 2020 2020 2020 203e 3e3e 2066             >>> f
-00007250: 726f 6d20 7370 6174 6961 6c6d 6174 6820  rom spatialmath 
-00007260: 696d 706f 7274 2053 4533 0a20 2020 2020  import SE3.     
-00007270: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
-00007280: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
-00007290: 612e 4465 6661 756c 7428 290a 2020 2020  a.Default().    
-000072a0: 2020 2020 2020 2020 3e3e 3e20 582c 2059          >>> X, Y
-000072b0: 2c20 5a20 3d20 6d6b 6375 6265 2830 2e32  , Z = mkcube(0.2
-000072c0: 2c20 706f 7365 3d53 4533 2830 2c20 302c  , pose=SE3(0, 0,
-000072d0: 2031 292c 2065 6467 653d 5472 7565 290a   1), edge=True).
-000072e0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-000072f0: 6361 6d65 7261 2e70 6c6f 745f 7769 7265  camera.plot_wire
-00007300: 6672 616d 6528 582c 2059 2c20 5a2c 2027  frame(X, Y, Z, '
-00007310: 6b2d 2d27 290a 0a20 2020 2020 2020 202e  k--')..        .
-00007320: 2e20 706c 6f74 3a3a 0a0a 2020 2020 2020  . plot::..      
-00007330: 2020 2020 2020 6672 6f6d 206d 6163 6869        from machi
-00007340: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
-00007350: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
-00007360: 6d65 7261 2c20 6d6b 6375 6265 0a20 2020  mera, mkcube.   
-00007370: 2020 2020 2020 2020 2066 726f 6d20 7370           from sp
-00007380: 6174 6961 6c6d 6174 6820 696d 706f 7274  atialmath import
-00007390: 2053 4533 0a20 2020 2020 2020 2020 2020   SE3.           
-000073a0: 2063 616d 6572 6120 3d20 4365 6e74 7261   camera = Centra
-000073b0: 6c43 616d 6572 612e 4465 6661 756c 7428  lCamera.Default(
-000073c0: 290a 2020 2020 2020 2020 2020 2020 582c  ).            X,
-000073d0: 2059 2c20 5a20 3d20 6d6b 6375 6265 2830   Y, Z = mkcube(0
-000073e0: 2e32 2c20 706f 7365 3d53 4533 2830 2c20  .2, pose=SE3(0, 
-000073f0: 302c 2031 292c 2065 6467 653d 5472 7565  0, 1), edge=True
-00007400: 290a 2020 2020 2020 2020 2020 2020 6361  ).            ca
-00007410: 6d65 7261 2e70 6c6f 745f 7769 7265 6672  mera.plot_wirefr
-00007420: 616d 6528 582c 2059 2c20 5a2c 2027 6b2d  ame(X, Y, Z, 'k-
-00007430: 2d27 290a 0a20 2020 2020 2020 203a 7365  -')..        :se
-00007440: 6561 6c73 6f3a 203a 6675 6e63 3a60 6d6b  ealso: :func:`mk
-00007450: 6375 6265 6020 3a6f 626a 3a60 7370 6174  cube` :obj:`spat
-00007460: 6961 6c6d 6174 682e 6261 7365 2e63 796c  ialmath.base.cyl
-00007470: 696e 6465 7260 203a 6f62 6a3a 6073 7061  inder` :obj:`spa
-00007480: 7469 616c 6d61 7468 2e62 6173 652e 7370  tialmath.base.sp
-00007490: 6865 7265 6020 3a6f 626a 3a60 7370 6174  here` :obj:`spat
-000074a0: 6961 6c6d 6174 682e 6261 7365 2e63 7562  ialmath.base.cub
-000074b0: 6f69 6460 0a20 2020 2020 2020 2022 2222  oid`.        """
-000074c0: 0a0a 2020 2020 2020 2020 2320 7365 6c66  ..        # self
-000074d0: 2e5f 6178 2e70 6c6f 745f 7375 7266 6163  ._ax.plot_surfac
-000074e0: 6528 582c 2059 2c20 5a29 0a20 2020 2020  e(X, Y, Z).     
-000074f0: 2020 2023 2070 6c74 2e73 686f 7728 290a     # plt.show().
-00007500: 2020 200a 2020 2020 2020 2020 2320 6368     .        # ch
-00007510: 6563 6b20 7468 6174 206d 6573 6820 6d61  eck that mesh ma
-00007520: 7472 6963 6573 2063 6f6e 666f 726d 0a20  trices conform. 
-00007530: 2020 2020 2020 2069 6620 582e 7368 6170         if X.shap
-00007540: 6520 213d 2059 2e73 6861 7065 206f 7220  e != Y.shape or 
-00007550: 582e 7368 6170 6520 213d 205a 2e73 6861  X.shape != Z.sha
-00007560: 7065 3a0a 2020 2020 2020 2020 2020 2020  pe:.            
-00007570: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00007580: 2827 6d61 7472 6963 6573 206d 7573 7420  ('matrices must 
-00007590: 6265 2074 6865 2073 616d 6520 7368 6170  be the same shap
-000075a0: 6527 290a 2020 2020 2020 2020 0a20 2020  e').        .   
-000075b0: 2020 2020 2069 6620 706f 7365 2069 7320       if pose is 
-000075c0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-000075d0: 2020 706f 7365 203d 2073 656c 662e 706f    pose = self.po
-000075e0: 7365 0a20 2020 2020 2020 2069 6620 6f62  se.        if ob
-000075f0: 6a70 6f73 6520 6973 206e 6f74 204e 6f6e  jpose is not Non
-00007600: 653a 0a20 2020 2020 2020 2020 2020 2070  e:.            p
-00007610: 6f73 6520 3d20 6f62 6a70 6f73 652e 696e  ose = objpose.in
-00007620: 7628 2920 2a20 706f 7365 0a20 2020 2020  v() * pose.     
-00007630: 2020 200a 2020 2020 2020 2020 2320 6765     .        # ge
-00007640: 7420 6861 6e64 6c65 2066 6f72 2074 6869  t handle for thi
-00007650: 7320 6361 6d65 7261 2069 6d61 6765 2070  s camera image p
-00007660: 6c61 6e65 0a20 2020 2020 2020 2073 656c  lane.        sel
-00007670: 662e 5f69 6e69 745f 696d 6167 6570 6c61  f._init_imagepla
-00007680: 6e65 2829 0a20 2020 2020 2020 2070 6c74  ne().        plt
-00007690: 2e61 7574 6f73 6361 6c65 2846 616c 7365  .autoscale(False
-000076a0: 290a 2020 2020 2020 2020 0a20 2020 2020  ).        .     
-000076b0: 2020 2023 2064 7261 7720 3344 206c 696e     # draw 3D lin
-000076c0: 6520 7365 676d 656e 7473 0a20 2020 2020  e segments.     
-000076d0: 2020 2073 203d 206e 702e 6c69 6e73 7061     s = np.linspa
-000076e0: 6365 2830 2c20 312c 206e 7374 6570 7329  ce(0, 1, nsteps)
-000076f0: 0a0a 2020 2020 2020 2020 2320 632e 636c  ..        # c.cl
-00007700: 660a 2020 2020 2020 2020 2320 686f 6c64  f.        # hold
-00007710: 6f6e 203d 2063 2e68 6f6c 6428 3129 3b0a  on = c.hold(1);.
-00007720: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-00007730: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
-00007740: 582e 7368 6170 655b 305d 2d31 293a 2020  X.shape[0]-1):  
-00007750: 2020 2020 2320 693d 313a 6e75 6d72 6f77      # i=1:numrow
-00007760: 7328 5829 2d31 0a20 2020 2020 2020 2020  s(X)-1.         
-00007770: 2020 2066 6f72 206a 2069 6e20 7261 6e67     for j in rang
-00007780: 6528 582e 7368 6170 655b 315d 2d31 293a  e(X.shape[1]-1):
-00007790: 2020 2320 6a3d 313a 6e75 6d63 6f6c 7328    # j=1:numcols(
-000077a0: 5829 2d31 0a20 2020 2020 2020 2020 2020  X)-1.           
-000077b0: 2020 2020 2050 3020 3d20 6e70 2e72 5f5b       P0 = np.r_[
-000077c0: 585b 692c 206a 5d2c 2059 5b69 2c20 6a5d  X[i, j], Y[i, j]
-000077d0: 2c20 5a5b 692c 206a 5d5d 0a20 2020 2020  , Z[i, j]].     
-000077e0: 2020 2020 2020 2020 2020 2050 3120 3d20             P1 = 
-000077f0: 6e70 2e72 5f5b 585b 692b 312c 206a 5d2c  np.r_[X[i+1, j],
-00007800: 2059 5b69 2b31 2c20 6a5d 2c20 5a5b 692b   Y[i+1, j], Z[i+
-00007810: 312c 206a 5d5d 0a20 2020 2020 2020 2020  1, j]].         
-00007820: 2020 2020 2020 2050 3220 3d20 6e70 2e72         P2 = np.r
-00007830: 5f5b 585b 692c 206a 2b31 5d2c 2059 5b69  _[X[i, j+1], Y[i
-00007840: 2c20 6a2b 315d 2c20 5a5b 692c 206a 2b31  , j+1], Z[i, j+1
-00007850: 5d5d 0a20 2020 2020 2020 2020 2020 2020  ]].             
-00007860: 2020 200a 2020 2020 2020 2020 2020 2020     .            
-00007870: 2020 2020 6966 2073 656c 662e 6361 6d74      if self.camt
-00007880: 7970 6520 3d3d 2027 7065 7273 7065 6374  ype == 'perspect
-00007890: 6976 6527 3a0a 2020 2020 2020 2020 2020  ive':.          
-000078a0: 2020 2020 2020 2020 2020 2320 7374 7261            # stra
-000078b0: 6967 6874 2077 6f72 6c64 206c 696e 6573  ight world lines
-000078c0: 2061 7265 2073 7472 6169 6768 7420 6f6e   are straight on
-000078d0: 2074 6865 2069 6d61 6765 2070 6c61 6e65   the image plane
-000078e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000078f0: 2020 2020 2075 7620 3d20 7365 6c66 2e70       uv = self.p
-00007900: 726f 6a65 6374 5f70 6f69 6e74 286e 702e  roject_point(np.
-00007910: 635f 5b50 302c 2050 315d 2c20 706f 7365  c_[P0, P1], pose
-00007920: 3d70 6f73 6529 0a20 2020 2020 2020 2020  =pose).         
-00007930: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00007940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007950: 2023 2073 7472 6169 6768 7420 776f 726c   # straight worl
-00007960: 6420 6c69 6e65 7320 6172 6520 6e6f 7420  d lines are not 
-00007970: 7374 7261 6967 6874 2c20 706c 6f74 2074  straight, plot t
-00007980: 6865 6d20 7069 6563 6577 6973 650a 2020  hem piecewise.  
-00007990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000079a0: 2020 5020 3d20 2831 202d 2073 2920 2a20    P = (1 - s) * 
-000079b0: 5030 5b3a 2c20 6e70 2e6e 6577 6178 6973  P0[:, np.newaxis
-000079c0: 5d20 2b20 7320 2a20 5031 5b3a 2c20 6e70  ] + s * P1[:, np
-000079d0: 2e6e 6577 6178 6973 5d0a 2020 2020 2020  .newaxis].      
-000079e0: 2020 2020 2020 2020 2020 2020 2020 7576                uv
-000079f0: 203d 2073 656c 662e 7072 6f6a 6563 745f   = self.project_
-00007a00: 706f 696e 7428 502c 2070 6f73 653d 706f  point(P, pose=po
-00007a10: 7365 290a 0a20 2020 2020 2020 2020 2020  se)..           
-00007a20: 2020 2020 2073 656c 662e 5f61 782e 706c       self._ax.pl
-00007a30: 6f74 2875 765b 302c 203a 5d2c 2075 765b  ot(uv[0, :], uv[
-00007a40: 312c 203a 5d2c 202a 666d 742c 202a 2a6b  1, :], *fmt, **k
-00007a50: 7761 7267 7329 0a20 2020 2020 2020 2020  wargs).         
-00007a60: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-00007a70: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00007a80: 6361 6d74 7970 6520 3d3d 2027 7065 7273  camtype == 'pers
-00007a90: 7065 6374 6976 6527 3a0a 2020 2020 2020  pective':.      
-00007aa0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00007ab0: 7374 7261 6967 6874 2077 6f72 6c64 206c  straight world l
-00007ac0: 696e 6573 2061 7265 2073 7472 6169 6768  ines are straigh
-00007ad0: 7420 6f6e 2074 6865 2069 6d61 6765 2070  t on the image p
-00007ae0: 6c61 6e65 0a20 2020 2020 2020 2020 2020  lane.           
-00007af0: 2020 2020 2020 2020 2075 7620 3d20 7365           uv = se
-00007b00: 6c66 2e70 726f 6a65 6374 5f70 6f69 6e74  lf.project_point
-00007b10: 286e 702e 635f 5b50 302c 2050 325d 2c20  (np.c_[P0, P2], 
-00007b20: 706f 7365 3d70 6f73 6529 0a20 2020 2020  pose=pose).     
-00007b30: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00007b40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007b50: 2020 2020 2023 2073 7472 6169 6768 7420       # straight 
-00007b60: 776f 726c 6420 6c69 6e65 7320 6172 6520  world lines are 
-00007b70: 6e6f 7420 7374 7261 6967 6874 2c20 706c  not straight, pl
-00007b80: 6f74 2074 6865 6d20 7069 6563 6577 6973  ot them piecewis
-00007b90: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00007ba0: 2020 2020 2020 5020 3d20 2831 202d 2073        P = (1 - s
-00007bb0: 2920 2a20 5030 5b3a 2c20 6e70 2e6e 6577  ) * P0[:, np.new
-00007bc0: 6178 6973 5d20 2b20 7320 2a20 5032 5b3a  axis] + s * P2[:
-00007bd0: 2c20 6e70 2e6e 6577 6178 6973 5d0a 2020  , np.newaxis].  
-00007be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007bf0: 2020 7576 203d 2073 656c 662e 7072 6f6a    uv = self.proj
-00007c00: 6563 745f 706f 696e 7428 502c 2070 6f73  ect_point(P, pos
-00007c10: 653d 706f 7365 290a 0a20 2020 2020 2020  e=pose)..       
-00007c20: 2020 2020 2020 2020 2073 656c 662e 5f61           self._a
-00007c30: 782e 706c 6f74 2875 765b 302c 203a 5d2c  x.plot(uv[0, :],
-00007c40: 2075 765b 312c 203a 5d2c 202a 666d 742c   uv[1, :], *fmt,
-00007c50: 202a 2a6b 7761 7267 7329 0a0a 2020 2020   **kwargs)..    
-00007c60: 2020 2020 0a20 2020 2020 2020 2066 6f72      .        for
-00007c70: 206a 2069 6e20 7261 6e67 6528 582e 7368   j in range(X.sh
-00007c80: 6170 655b 315d 2d31 293a 2020 2320 6a3d  ape[1]-1):  # j=
-00007c90: 313a 6e75 6d63 6f6c 7328 5829 2d31 0a20  1:numcols(X)-1. 
-00007ca0: 2020 2020 2020 2020 2020 2050 3020 3d20             P0 = 
-00007cb0: 5b58 5b2d 312c 6a5d 2c20 2020 595b 2d31  [X[-1,j],   Y[-1
-00007cc0: 2c6a 5d2c 2020 205a 5b2d 312c 6a5d 5d0a  ,j],   Z[-1,j]].
-00007cd0: 2020 2020 2020 2020 2020 2020 5031 203d              P1 =
-00007ce0: 205b 585b 2d31 2c6a 2b31 5d2c 2059 5b2d   [X[-1,j+1], Y[-
-00007cf0: 312c 6a2b 315d 2c20 5a5b 2d31 2c6a 2b31  1,j+1], Z[-1,j+1
-00007d00: 5d5d 0a20 2020 2020 2020 2020 2020 200a  ]].            .
-00007d10: 2020 2020 2020 2020 2020 2020 2320 6966              # if
-00007d20: 2063 2e70 6572 7370 6563 7469 7665 0a20   c.perspective. 
-00007d30: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00007d40: 2073 7472 6169 6768 7420 776f 726c 6420   straight world 
-00007d50: 6c69 6e65 7320 6172 6520 7374 7261 6967  lines are straig
-00007d60: 6874 206f 6e20 7468 6520 696d 6167 6520  ht on the image 
-00007d70: 706c 616e 650a 2020 2020 2020 2020 2020  plane.          
-00007d80: 2020 7576 203d 2073 656c 662e 7072 6f6a    uv = self.proj
-00007d90: 6563 745f 706f 696e 7428 6e70 2e63 5f5b  ect_point(np.c_[
-00007da0: 5030 2c20 5031 5d2c 2070 6f73 653d 706f  P0, P1], pose=po
-00007db0: 7365 293b 0a20 2020 2020 2020 2020 2020  se);.           
-00007dc0: 2023 2065 6c73 650a 2020 2020 2020 2020   # else.        
-00007dd0: 2020 2020 2320 2020 2020 2320 7374 7261      #     # stra
-00007de0: 6967 6874 2077 6f72 6c64 206c 696e 6573  ight world lines
-00007df0: 2061 7265 206e 6f74 2073 7472 6169 6768   are not straigh
-00007e00: 742c 2070 6c6f 7420 7468 656d 2070 6965  t, plot them pie
-00007e10: 6365 7769 7365 0a20 2020 2020 2020 2020  cewise.         
-00007e20: 2020 2023 2020 2020 2050 203d 2062 7378     #     P = bsx
-00007e30: 6675 6e28 4074 696d 6573 2c20 2831 2d73  fun(@times, (1-s
-00007e40: 292c 2050 3029 202b 2062 7378 6675 6e28  ), P0) + bsxfun(
-00007e50: 4074 696d 6573 2c20 732c 2050 3129 3b0a  @times, s, P1);.
-00007e60: 2020 2020 2020 2020 2020 2020 2320 2020              #   
-00007e70: 2020 7576 203d 2063 2e70 726f 6a65 6374    uv = c.project
-00007e80: 2850 2c20 2773 6574 6f70 7427 2c20 6f70  (P, 'setopt', op
-00007e90: 7429 3b0a 2020 2020 2020 2020 2020 2020  t);.            
-00007ea0: 7365 6c66 2e5f 6178 2e70 6c6f 7428 7576  self._ax.plot(uv
-00007eb0: 5b30 2c3a 5d2c 2075 765b 312c 3a5d 2c20  [0,:], uv[1,:], 
-00007ec0: 2a66 6d74 2c20 2a2a 6b77 6172 6773 290a  *fmt, **kwargs).
-00007ed0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-00007ee0: 2023 2063 2e68 6f6c 6428 686f 6c64 6f6e   # c.hold(holdon
-00007ef0: 293b 2023 2074 7572 6e20 686f 6c64 206f  ); # turn hold o
-00007f00: 6666 2069 6620 6974 2077 6173 2069 6e69  ff if it was ini
-00007f10: 7469 616c 6c79 206f 6666 0a0a 2020 2020  tially off..    
-00007f20: 2020 2020 706c 742e 6472 6177 2829 0a0a      plt.draw()..
-00007f30: 2020 2020 6465 6620 6469 7370 2873 656c      def disp(sel
-00007f40: 662c 2069 6d2c 202a 2a6b 7761 7267 7329  f, im, **kwargs)
-00007f50: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-00007f60: 2020 2020 2020 4469 7370 6c61 7920 696d        Display im
-00007f70: 6167 6520 6f6e 2076 6972 7475 616c 2069  age on virtual i
-00007f80: 6d61 6765 2070 6c61 6e65 2028 6261 7365  mage plane (base
-00007f90: 206d 6574 686f 6429 0a0a 2020 2020 2020   method)..      
-00007fa0: 2020 3a70 6172 616d 2069 6d3a 2069 6d61    :param im: ima
-00007fb0: 6765 2074 6f20 6469 7370 6c61 790a 2020  ge to display.  
-00007fc0: 2020 2020 2020 3a74 7970 6520 696d 3a20        :type im: 
-00007fd0: 3a63 6c61 7373 3a60 496d 6167 6560 2069  :class:`Image` i
-00007fe0: 6e73 7461 6e63 650a 2020 2020 2020 2020  nstance.        
-00007ff0: 3a70 6172 616d 206b 7761 7267 733a 206f  :param kwargs: o
-00008000: 7074 696f 6e73 2074 6f20 3a66 756e 633a  ptions to :func:
-00008010: 607e 6d61 6368 696e 6576 6973 696f 6e74  `~machinevisiont
-00008020: 6f6f 6c62 6f78 2e62 6173 652e 696d 6167  oolbox.base.imag
-00008030: 6569 6f2e 6964 6973 7028 2960 0a0a 2020  eio.idisp()`..  
-00008040: 2020 2020 2020 416e 2069 6d61 6765 2069        An image i
-00008050: 7320 6469 7370 6c61 7965 6420 6f6e 2063  s displayed on c
-00008060: 616d 6572 6127 7320 7468 6520 7669 7274  amera's the virt
-00008070: 7561 6c20 696d 6167 6520 706c 616e 652e  ual image plane.
-00008080: 2020 0a20 2020 2020 2020 200a 2020 2020    .        .    
-00008090: 2020 2020 2e2e 206e 6f74 653a 2054 6865      .. note: The
-000080a0: 2064 696d 656e 7369 6f6e 7320 6f66 2074   dimensions of t
-000080b0: 6865 2069 6d61 6765 2070 6c61 6e65 2073  he image plane s
-000080c0: 686f 756c 6420 6d61 7463 6820 7468 6520  hould match the 
-000080d0: 6469 6d65 6e73 696f 6e73 206f 6620 7468  dimensions of th
-000080e0: 6520 696d 6167 652e 0a0a 2020 2020 2020  e image...      
-000080f0: 2020 3a73 6565 616c 736f 3a20 3a66 756e    :seealso: :fun
-00008100: 633a 606d 6163 6869 6e65 7669 7369 6f6e  c:`machinevision
-00008110: 746f 6f6c 626f 782e 6261 7365 2e69 6469  toolbox.base.idi
-00008120: 7370 2829 600a 2020 2020 2020 2020 2222  sp()`.        ""
-00008130: 220a 2020 2020 2020 2020 7365 6c66 2e69  ".        self.i
-00008140: 6d61 6765 7369 7a65 203d 2028 696d 2e73  magesize = (im.s
-00008150: 6861 7065 5b31 5d2c 2069 6d2e 7368 6170  hape[1], im.shap
-00008160: 655b 305d 290a 2020 2020 2020 2020 7365  e[0]).        se
-00008170: 6c66 2e5f 696e 6974 5f69 6d61 6765 706c  lf._init_imagepl
-00008180: 616e 6528 290a 2020 2020 2020 2020 696d  ane().        im
-00008190: 2e64 6973 7028 6178 3d73 656c 662e 5f61  .disp(ax=self._a
-000081a0: 782c 2074 6974 6c65 3d46 616c 7365 2c20  x, title=False, 
-000081b0: 2a2a 6b77 6172 6773 290a 0a20 2020 2020  **kwargs)..     
-000081c0: 2020 2070 6c74 2e61 7574 6f73 6361 6c65     plt.autoscale
-000081d0: 2846 616c 7365 290a 0a20 2020 2064 6566  (False)..    def
-000081e0: 2070 6c6f 7428 7365 6c66 3d4e 6f6e 652c   plot(self=None,
-000081f0: 2070 6f73 653d 4e6f 6e65 2c20 7363 616c   pose=None, scal
-00008200: 653d 312c 2073 6861 7065 3d27 6361 6d65  e=1, shape='came
-00008210: 7261 272c 206c 6162 656c 3d54 7275 652c  ra', label=True,
-00008220: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008230: 2020 2020 2061 6c70 6861 3d31 2c20 736f       alpha=1, so
-00008240: 6c69 643d 4661 6c73 652c 2063 6f6c 6f72  lid=False, color
-00008250: 3d27 7227 2c20 7072 6f6a 6563 7469 6f6e  ='r', projection
-00008260: 3d27 6f72 7468 6f27 2c20 6672 616d 653d  ='ortho', frame=
-00008270: 4661 6c73 652c 0a20 2020 2020 2020 2020  False,.         
-00008280: 2020 2020 2020 2020 2020 2061 783d 4e6f             ax=No
-00008290: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
-000082a0: 0a20 2020 2020 2020 2050 6c6f 7420 3344  .        Plot 3D
-000082b0: 2063 616d 6572 6120 6963 6f6e 2069 6e20   camera icon in 
-000082c0: 776f 726c 6420 7669 6577 2028 6261 7365  world view (base
-000082d0: 206d 6574 686f 6429 0a0a 2020 2020 2020   method)..      
-000082e0: 2020 3a70 6172 616d 2070 6f73 653a 2063    :param pose: c
-000082f0: 616d 6572 6120 706f 7365 0a20 2020 2020  amera pose.     
-00008300: 2020 203a 7479 7065 2070 6f73 653a 203a     :type pose: :
-00008310: 636c 6173 733a 607e 7370 6174 6961 6c6d  class:`~spatialm
-00008320: 6174 682e 2e70 6f73 6533 642e 5345 3360  ath..pose3d.SE3`
-00008330: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-00008340: 7363 616c 653a 2073 6361 6c65 2066 6163  scale: scale fac
-00008350: 746f 722c 2064 6566 6175 6c74 7320 746f  tor, defaults to
-00008360: 2031 0a20 2020 2020 2020 203a 7479 7065   1.        :type
-00008370: 2073 6361 6c65 3a20 666c 6f61 740a 2020   scale: float.  
-00008380: 2020 2020 2020 3a70 6172 616d 2073 6861        :param sha
-00008390: 7065 3a20 6963 6f6e 2073 6861 7065 3a20  pe: icon shape: 
-000083a0: 2766 7275 7374 756d 2720 5b64 6566 6175  'frustum' [defau
-000083b0: 6c74 5d2c 2027 6361 6d65 7261 270a 2020  lt], 'camera'.  
-000083c0: 2020 2020 2020 3a74 7970 6520 7368 6170        :type shap
-000083d0: 653a 2073 7472 2c20 6f70 7469 6f6e 616c  e: str, optional
-000083e0: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-000083f0: 6c61 6265 6c3a 2073 686f 7720 6361 6d65  label: show came
-00008400: 7261 206e 616d 652c 2064 6566 6175 6c74  ra name, default
-00008410: 7320 746f 2054 7275 650a 2020 2020 2020  s to True.      
-00008420: 2020 3a74 7970 6520 6c61 6265 6c3a 2062    :type label: b
-00008430: 6f6f 6c2c 206f 7074 696f 6e61 6c0a 2020  ool, optional.  
-00008440: 2020 2020 2020 3a70 6172 616d 2061 6c70        :param alp
-00008450: 6861 3a20 7472 616e 7370 6172 656e 6379  ha: transparency
-00008460: 206f 6620 6963 6f6e 2c20 6465 6661 756c   of icon, defaul
-00008470: 7473 2074 6f20 310a 2020 2020 2020 2020  ts to 1.        
-00008480: 3a74 7970 6520 616c 7068 613a 2066 6c6f  :type alpha: flo
-00008490: 6174 2c20 6f70 7469 6f6e 616c 0a20 2020  at, optional.   
-000084a0: 2020 2020 203a 7061 7261 6d20 736f 6c69       :param soli
-000084b0: 643a 2069 636f 6e20 636f 6d70 7269 7365  d: icon comprise
-000084c0: 7320 736f 6c69 6420 6661 6365 732c 2064  s solid faces, d
-000084d0: 6566 6175 6c74 7320 746f 2046 616c 7365  efaults to False
-000084e0: 0a20 2020 2020 2020 203a 7479 7065 2073  .        :type s
-000084f0: 6f6c 6964 3a20 626f 6f6c 2c20 6f70 7469  olid: bool, opti
-00008500: 6f6e 616c 0a20 2020 2020 2020 203a 7061  onal.        :pa
-00008510: 7261 6d20 636f 6c6f 723a 2069 636f 6e20  ram color: icon 
-00008520: 636f 6c6f 722c 2064 6566 6175 6c74 7320  color, defaults 
-00008530: 746f 2027 7227 0a20 2020 2020 2020 203a  to 'r'.        :
-00008540: 7479 7065 2063 6f6c 6f72 3a20 7374 722c  type color: str,
-00008550: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
-00008560: 2020 3a70 6172 616d 2070 726f 6a65 6374    :param project
-00008570: 696f 6e3a 2070 726f 6a65 6374 696f 6e20  ion: projection 
-00008580: 6d6f 6465 6c20 666f 7220 6e65 7720 6178  model for new ax
-00008590: 6573 2c20 6465 6661 756c 7473 2074 6f20  es, defaults to 
-000085a0: 276f 7274 686f 270a 2020 2020 2020 2020  'ortho'.        
-000085b0: 3a74 7970 6520 7072 6f6a 6563 7469 6f6e  :type projection
-000085c0: 3a20 7374 722c 206f 7074 696f 6e61 6c0a  : str, optional.
-000085d0: 2020 2020 2020 2020 3a70 6172 616d 2061          :param a
-000085e0: 783a 2061 7865 7320 746f 2064 7261 7720  x: axes to draw 
-000085f0: 696e 2c20 6465 6661 756c 7473 2074 6f20  in, defaults to 
-00008600: 6375 7272 656e 7420 3344 2061 7865 730a  current 3D axes.
-00008610: 2020 2020 2020 2020 3a74 7970 6520 6178          :type ax
-00008620: 3a20 3a63 6c61 7373 3a60 7e6d 6174 706c  : :class:`~matpl
-00008630: 6f74 6c69 622e 4178 6573 3344 602c 206f  otlib.Axes3D`, o
-00008640: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
-00008650: 3a72 6574 7572 6e3a 2061 7865 7320 6472  :return: axes dr
-00008660: 6177 6e20 696e 746f 0a20 2020 2020 2020  awn into.       
-00008670: 203a 7274 7970 653a 203a 636c 6173 733a   :rtype: :class:
-00008680: 607e 6d61 7470 6c6f 746c 6962 2e41 7865  `~matplotlib.Axe
-00008690: 7333 4460 0a0a 2020 2020 2020 2020 506c  s3D`..        Pl
-000086a0: 6f74 2061 2033 4420 6963 6f6e 2072 6570  ot a 3D icon rep
-000086b0: 7265 7365 6e74 696e 6720 7468 6520 706f  resenting the po
-000086c0: 7365 206f 6620 6120 6361 6d65 7261 2069  se of a camera i
-000086d0: 6e74 6f20 6120 3344 204d 6174 706c 6f74  nto a 3D Matplot
-000086e0: 6c69 620a 2020 2020 2020 2020 706c 6f74  lib.        plot
-000086f0: 2e20 2054 776f 2069 636f 6e73 2061 7265  .  Two icons are
-00008700: 2073 7570 706f 7274 6564 3a20 7468 6520   supported: the 
-00008710: 7472 6164 6974 696f 6e61 6c20 6672 7573  traditional frus
-00008720: 7475 6d2c 2061 6e64 2061 0a20 2020 2020  tum, and a.     
-00008730: 2020 2073 696d 706c 6973 7469 6320 6361     simplistic ca
-00008740: 6d65 7261 2063 6f6d 7072 6973 696e 6720  mera comprising 
-00008750: 6120 626f 7820 616e 6420 6379 6c69 6e64  a box and cylind
-00008760: 6572 2e0a 0a20 2020 2020 2020 203a 6e6f  er...        :no
-00008770: 7465 3a20 4966 2060 6070 6f73 6560 6020  te: If ``pose`` 
-00008780: 6973 206e 6f74 2067 6976 656e 2069 7420  is not given it 
-00008790: 6465 6661 756c 7473 2074 6f20 7468 6520  defaults to the 
-000087a0: 706f 7365 206f 6620 7468 650a 2020 2020  pose of the.    
-000087b0: 2020 2020 2020 2020 696e 7374 616e 6365          instance
-000087c0: 2e0a 2020 2020 2020 2020 2222 220a 0a20  ..        """.. 
-000087d0: 2020 2020 2020 2023 2069 6620 2866 6967         # if (fig
-000087e0: 2069 7320 4e6f 6e65 2920 616e 6420 2861   is None) and (a
-000087f0: 7820 6973 204e 6f6e 6529 3a0a 2020 2020  x is None):.    
-00008800: 2020 2020 2320 2020 2020 2320 6372 6561      #     # crea
-00008810: 7465 206f 7572 206f 776e 2068 616e 646c  te our own handl
-00008820: 6520 666f 7220 7468 6520 6669 6775 7265  e for the figure
-00008830: 2f70 6c6f 740a 2020 2020 2020 2020 2320  /plot.        # 
-00008840: 2020 2020 7072 696e 7428 2763 7265 6174      print('creat
-00008850: 696e 6720 6e65 7720 6669 6775 7265 2061  ing new figure a
-00008860: 6e64 2061 7865 7320 666f 7220 6361 6d65  nd axes for came
-00008870: 7261 2729 0a20 2020 2020 2020 2023 2020  ra').        #  
-00008880: 2020 2066 6967 203d 2070 6c74 2e66 6967     fig = plt.fig
-00008890: 7572 6528 290a 2020 2020 2020 2020 2320  ure().        # 
-000088a0: 2020 2020 6178 203d 2066 6967 2e67 6361      ax = fig.gca
-000088b0: 2870 726f 6a65 6374 696f 6e3d 2733 6427  (projection='3d'
-000088c0: 290a 2020 2020 2020 2020 2320 2020 2020  ).        #     
-000088d0: 2320 6178 2e73 6574 5f61 7370 6563 7428  # ax.set_aspect(
-000088e0: 2765 7175 616c 2729 0a0a 2020 2020 2020  'equal')..      
-000088f0: 2020 2222 225b 7375 6d6d 6172 795d 0a20    """[summary]. 
-00008900: 2020 2020 2020 2066 6163 6520 6f72 6465         face orde
-00008910: 7220 2d78 2c20 2b79 2c20 2b78 2c20 2d79  r -x, +y, +x, -y
-00008920: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00008930: 2020 2020 2023 2067 6574 2061 7865 7320       # get axes 
-00008940: 746f 2064 7261 7720 696e 0a20 2020 2020  to draw in.     
-00008950: 2020 2061 7820 3d20 736d 6261 7365 2e61     ax = smbase.a
-00008960: 7865 735f 6c6f 6769 6328 6178 2c20 332c  xes_logic(ax, 3,
-00008970: 2070 726f 6a65 6374 696f 6e3d 7072 6f6a   projection=proj
-00008980: 6563 7469 6f6e 290a 0a20 2020 2020 2020  ection)..       
-00008990: 2069 6620 706f 7365 2069 7320 4e6f 6e65   if pose is None
-000089a0: 3a0a 2020 2020 2020 2020 2020 2020 706f  :.            po
-000089b0: 7365 203d 2073 656c 662e 706f 7365 0a0a  se = self.pose..
-000089c0: 2020 2020 2020 2020 2320 6472 6177 2063          # draw c
-000089d0: 616d 6572 612d 6c69 6b65 206f 626a 6563  amera-like objec
-000089e0: 743a 0a20 2020 2020 2020 2069 6620 7368  t:.        if sh
-000089f0: 6170 6520 3d3d 2027 6672 7573 7475 6d27  ape == 'frustum'
-00008a00: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
-00008a10: 544f 444f 206d 616b 6520 7468 6973 206b  TODO make this k
-00008a20: 7761 7267 7320 6f72 206f 7074 696f 6e61  wargs or optiona
-00008a30: 6c20 696e 7075 7473 0a20 2020 2020 2020  l inputs.       
-00008a40: 2020 2020 2023 2073 6964 6520 636f 6c6f       # side colo
-00008a50: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
-00008a60: 2320 202b 7820 7265 640a 2020 2020 2020  #  +x red.      
-00008a70: 2020 2020 2020 2320 202d 7920 7265 640a        #  -y red.
-00008a80: 2020 2020 2020 2020 2020 2020 2320 202b              #  +
-00008a90: 7920 6772 6565 6e0a 2020 2020 2020 2020  y green.        
-00008aa0: 2020 2020 2320 202d 7920 7965 6c6c 6f77      #  -y yellow
-00008ab0: 0a20 2020 2020 2020 2020 2020 206c 656e  .            len
-00008ac0: 6774 6820 3d20 7363 616c 650a 2020 2020  gth = scale.    
-00008ad0: 2020 2020 2020 2020 7769 6474 6862 203d          widthb =
-00008ae0: 2073 6361 6c65 2f31 300a 2020 2020 2020   scale/10.      
-00008af0: 2020 2020 2020 7769 6474 6874 203d 2073        widtht = s
-00008b00: 6361 6c65 0a20 2020 2020 2020 2020 2020  cale.           
-00008b10: 2077 6964 7468 6220 2f3d 2032 0a20 2020   widthb /= 2.   
-00008b20: 2020 2020 2020 2020 2077 6964 7468 7420           widtht 
-00008b30: 2f3d 2032 0a20 2020 2020 2020 2020 2020  /= 2.           
-00008b40: 2062 3020 3d20 6e70 2e61 7272 6179 285b   b0 = np.array([
-00008b50: 2d77 6964 7468 622c 202d 7769 6474 6862  -widthb, -widthb
-00008b60: 2c20 302c 2031 5d29 0a20 2020 2020 2020  , 0, 1]).       
-00008b70: 2020 2020 2062 3120 3d20 6e70 2e61 7272       b1 = np.arr
-00008b80: 6179 285b 2d77 6964 7468 622c 2077 6964  ay([-widthb, wid
-00008b90: 7468 622c 2030 2c20 315d 290a 2020 2020  thb, 0, 1]).    
-00008ba0: 2020 2020 2020 2020 6232 203d 206e 702e          b2 = np.
-00008bb0: 6172 7261 7928 5b77 6964 7468 622c 2077  array([widthb, w
-00008bc0: 6964 7468 622c 2030 2c20 315d 290a 2020  idthb, 0, 1]).  
-00008bd0: 2020 2020 2020 2020 2020 6233 203d 206e            b3 = n
-00008be0: 702e 6172 7261 7928 5b77 6964 7468 622c  p.array([widthb,
-00008bf0: 202d 7769 6474 6862 2c20 302c 2031 5d29   -widthb, 0, 1])
-00008c00: 0a20 2020 2020 2020 2020 2020 2074 3020  .            t0 
-00008c10: 3d20 6e70 2e61 7272 6179 285b 2d77 6964  = np.array([-wid
-00008c20: 7468 742c 202d 7769 6474 6874 2c20 6c65  tht, -widtht, le
-00008c30: 6e67 7468 2c20 315d 290a 2020 2020 2020  ngth, 1]).      
-00008c40: 2020 2020 2020 7431 203d 206e 702e 6172        t1 = np.ar
-00008c50: 7261 7928 5b2d 7769 6474 6874 2c20 7769  ray([-widtht, wi
-00008c60: 6474 6874 2c20 6c65 6e67 7468 2c20 315d  dtht, length, 1]
-00008c70: 290a 2020 2020 2020 2020 2020 2020 7432  ).            t2
-00008c80: 203d 206e 702e 6172 7261 7928 5b77 6964   = np.array([wid
-00008c90: 7468 742c 2077 6964 7468 742c 206c 656e  tht, widtht, len
-00008ca0: 6774 682c 2031 5d29 0a20 2020 2020 2020  gth, 1]).       
-00008cb0: 2020 2020 2074 3320 3d20 6e70 2e61 7272       t3 = np.arr
-00008cc0: 6179 285b 7769 6474 6874 2c20 2d77 6964  ay([widtht, -wid
-00008cd0: 7468 742c 206c 656e 6774 682c 2031 5d29  tht, length, 1])
-00008ce0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00008cf0: 626f 7474 6f6d 2f6e 6172 726f 7720 656e  bottom/narrow en
-00008d00: 640a 2020 2020 2020 2020 2020 2020 5420  d.            T 
-00008d10: 3d20 706f 7365 2e41 0a20 2020 2020 2020  = pose.A.       
-00008d20: 2020 2020 2062 3020 3d20 2854 2040 2062       b0 = (T @ b
-00008d30: 3029 5b3a 2d31 5d0a 2020 2020 2020 2020  0)[:-1].        
-00008d40: 2020 2020 6231 203d 2028 5420 4020 6231      b1 = (T @ b1
-00008d50: 295b 3a2d 315d 0a20 2020 2020 2020 2020  )[:-1].         
-00008d60: 2020 2062 3220 3d20 2854 2040 2062 3229     b2 = (T @ b2)
-00008d70: 5b3a 2d31 5d0a 2020 2020 2020 2020 2020  [:-1].          
-00008d80: 2020 6233 203d 2028 5420 4020 6233 295b    b3 = (T @ b3)[
-00008d90: 3a2d 315d 0a0a 2020 2020 2020 2020 2020  :-1]..          
-00008da0: 2020 2320 7769 6465 2f74 6f70 2065 6e64    # wide/top end
-00008db0: 0a20 2020 2020 2020 2020 2020 2074 3020  .            t0 
-00008dc0: 3d20 2854 2040 2074 3029 5b3a 2d31 5d0a  = (T @ t0)[:-1].
-00008dd0: 2020 2020 2020 2020 2020 2020 7431 203d              t1 =
-00008de0: 2028 5420 4020 7431 295b 3a2d 315d 0a20   (T @ t1)[:-1]. 
-00008df0: 2020 2020 2020 2020 2020 2074 3220 3d20             t2 = 
-00008e00: 2854 2040 2074 3229 5b3a 2d31 5d0a 2020  (T @ t2)[:-1].  
-00008e10: 2020 2020 2020 2020 2020 7433 203d 2028            t3 = (
-00008e20: 5420 4020 7433 295b 3a2d 315d 0a0a 2020  T @ t3)[:-1]..  
-00008e30: 2020 2020 2020 2020 2020 2320 4561 6368            # Each
-00008e40: 2073 6574 206f 6620 666f 7572 2070 6f69   set of four poi
-00008e50: 6e74 7320 6973 2061 2073 696e 676c 6520  nts is a single 
-00008e60: 7369 6465 206f 6620 7468 6520 4672 7573  side of the Frus
-00008e70: 7472 756d 0a20 2020 2020 2020 2020 2020  trum.           
-00008e80: 2023 2070 6f69 6e74 7320 3d20 6e70 2e61   # points = np.a
-00008e90: 7272 6179 285b 5b62 302c 2062 312c 2074  rray([[b0, b1, t
-00008ea0: 312c 2074 305d 2c20 5b62 312c 2062 322c  1, t0], [b1, b2,
-00008eb0: 2074 322c 2074 315d 2c20 5b0a 2020 2020   t2, t1], [.    
-00008ec0: 2020 2020 2020 2020 2320 2020 2020 2020          #       
-00008ed0: 2020 2020 2020 2020 2020 2020 6232 2c20              b2, 
-00008ee0: 6233 2c20 7433 2c20 7432 5d2c 205b 6233  b3, t3, t2], [b3
-00008ef0: 2c20 6230 2c20 7430 2c20 7433 5d5d 290a  , b0, t0, t3]]).
-00008f00: 2020 2020 2020 2020 2020 2020 706f 696e              poin
-00008f10: 7473 203d 205b 0a20 2020 2020 2020 2020  ts = [.         
-00008f20: 2020 2020 2020 206e 702e 6172 7261 7928         np.array(
-00008f30: 5b62 302c 2062 312c 2074 312c 2074 305d  [b0, b1, t1, t0]
-00008f40: 292c 2020 2320 2d78 2066 6163 650a 2020  ),  # -x face.  
-00008f50: 2020 2020 2020 2020 2020 2020 2020 6e70                np
-00008f60: 2e61 7272 6179 285b 6231 2c20 6232 2c20  .array([b1, b2, 
-00008f70: 7432 2c20 7431 5d29 2c20 2023 202b 7920  t2, t1]),  # +y 
-00008f80: 6661 6365 0a20 2020 2020 2020 2020 2020  face.           
-00008f90: 2020 2020 206e 702e 6172 7261 7928 5b62       np.array([b
-00008fa0: 322c 2062 332c 2074 332c 2074 325d 292c  2, b3, t3, t2]),
-00008fb0: 2020 2320 2b78 2066 6163 650a 2020 2020    # +x face.    
-00008fc0: 2020 2020 2020 2020 2020 2020 6e70 2e61              np.a
-00008fd0: 7272 6179 285b 6233 2c20 6230 2c20 7430  rray([b3, b0, t0
-00008fe0: 2c20 7433 5d29 2020 2023 202d 7920 6661  , t3])   # -y fa
-00008ff0: 6365 0a20 2020 2020 2020 2020 2020 205d  ce.            ]
-00009000: 0a20 2020 2020 2020 2020 2020 2070 6f6c  .            pol
-00009010: 7920 3d20 506f 6c79 3344 436f 6c6c 6563  y = Poly3DCollec
-00009020: 7469 6f6e 2870 6f69 6e74 732c 0a20 2020  tion(points,.   
-00009030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009050: 2066 6163 6563 6f6c 6f72 733d 5b27 7227   facecolors=['r'
-00009060: 2c20 2767 272c 2027 7227 2c20 2779 275d  , 'g', 'r', 'y']
-00009070: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00009080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009090: 2020 2020 2020 616c 7068 613d 616c 7068        alpha=alph
-000090a0: 6129 0a20 2020 2020 2020 2020 2020 2061  a).            a
-000090b0: 782e 6164 645f 636f 6c6c 6563 7469 6f6e  x.add_collection
-000090c0: 3364 2870 6f6c 7929 0a0a 2020 2020 2020  3d(poly)..      
-000090d0: 2020 656c 6966 2073 6861 7065 203d 3d20    elif shape == 
-000090e0: 2763 616d 6572 6127 3a0a 0a20 2020 2020  'camera':..     
-000090f0: 2020 2020 2020 2023 2074 6865 2062 6f78         # the box
-00009100: 2069 7320 6365 6e74 7265 6420 6174 2074   is centred at t
-00009110: 6865 206f 7269 6769 6e20 616e 6420 6974  he origin and it
-00009120: 7320 6365 6e74 6572 6c69 6e65 2070 6172  s centerline par
-00009130: 616c 6c65 6c20 746f 2074 6865 0a20 2020  allel to the.   
-00009140: 2020 2020 2020 2020 2023 207a 2d61 7869           # z-axi
-00009150: 732e 2020 4974 7320 7a2d 6578 7465 6e74  s.  Its z-extent
-00009160: 2069 7320 2d62 682f 3220 746f 2062 682f   is -bh/2 to bh/
-00009170: 322e 0a20 2020 2020 2020 2020 2020 2057  2..            W
-00009180: 203d 2030 2e35 2020 2020 2020 2023 2077   = 0.5       # w
-00009190: 6964 7468 2026 2068 6569 6768 7420 6f66  idth & height of
-000091a0: 2074 6865 2062 6f78 0a20 2020 2020 2020   the box.       
-000091b0: 2020 2020 204c 203d 2031 2e32 2020 2020       L = 1.2    
-000091c0: 2020 2023 206c 656e 6774 6820 6f66 2074     # length of t
-000091d0: 6865 2062 6f78 0a20 2020 2020 2020 2020  he box.         
-000091e0: 2020 2063 7220 3d20 302e 3220 2020 2020     cr = 0.2     
-000091f0: 2020 2320 6379 6c69 6e64 6572 2072 6164    # cylinder rad
-00009200: 6975 730a 2020 2020 2020 2020 2020 2020  ius.            
-00009210: 6368 203d 2030 2e34 2020 2020 2020 2023  ch = 0.4       #
-00009220: 2063 796c 696e 6465 7220 6865 6967 6874   cylinder height
-00009230: 0a20 2020 2020 2020 2020 2020 2063 6e20  .            cn 
-00009240: 3d20 3132 2020 2020 2020 2020 2320 6e75  = 12        # nu
-00009250: 6d62 6572 206f 6620 6661 6365 7473 206f  mber of facets o
-00009260: 6620 6379 6c69 6e64 6572 0a20 2020 2020  f cylinder.     
-00009270: 2020 2020 2020 2061 203d 2033 2020 2020         a = 3    
-00009280: 2020 2020 2020 2320 6c65 6e67 7468 206f        # length o
-00009290: 6620 6178 6973 206c 696e 6520 7365 676d  f axis line segm
-000092a0: 656e 7473 0a0a 2020 2020 2020 2020 2020  ents..          
-000092b0: 2020 2320 6472 6177 2074 6865 2062 6f78    # draw the box
-000092c0: 2070 6172 7420 6f66 2074 6865 2063 616d   part of the cam
-000092d0: 6572 610a 2020 2020 2020 2020 2020 2020  era.            
-000092e0: 736d 6261 7365 2e70 6c6f 745f 6375 626f  smbase.plot_cubo
-000092f0: 6964 2873 6964 6573 3d6e 702e 725f 5b57  id(sides=np.r_[W
-00009300: 2c20 572c 204c 5d20 2a20 7363 616c 652c  , W, L] * scale,
-00009310: 2070 6f73 653d 706f 7365 2c20 6669 6c6c   pose=pose, fill
-00009320: 6564 3d73 6f6c 6964 2c20 636f 6c6f 723d  ed=solid, color=
-00009330: 636f 6c6f 722c 2061 6c70 6861 3d30 2e35  color, alpha=0.5
-00009340: 202a 2061 6c70 6861 2069 6620 736f 6c69   * alpha if soli
-00009350: 6420 656c 7365 2061 6c70 6861 2c20 6178  d else alpha, ax
-00009360: 3d61 7829 0a0a 2020 2020 2020 2020 2020  =ax)..          
-00009370: 2020 2320 6472 6177 2074 6865 206c 656e    # draw the len
-00009380: 730a 2020 2020 2020 2020 2020 2020 736d  s.            sm
-00009390: 6261 7365 2e70 6c6f 745f 6379 6c69 6e64  base.plot_cylind
-000093a0: 6572 2872 6164 6975 733d 6372 202a 2073  er(radius=cr * s
-000093b0: 6361 6c65 2c20 6865 6967 6874 3d6e 702e  cale, height=np.
-000093c0: 725f 5b4c 202f 2032 2c20 4c20 2f20 3220  r_[L / 2, L / 2 
-000093d0: 2b20 6368 5d20 2a20 7363 616c 652c 2072  + ch] * scale, r
-000093e0: 6573 6f6c 7574 696f 6e3d 636e 2c20 706f  esolution=cn, po
-000093f0: 7365 3d70 6f73 652c 2066 696c 6c65 643d  se=pose, filled=
-00009400: 736f 6c69 642c 2063 6f6c 6f72 3d63 6f6c  solid, color=col
-00009410: 6f72 2c20 616c 7068 613d 302e 3520 2a20  or, alpha=0.5 * 
-00009420: 616c 7068 612c 2061 783d 6178 290a 0a20  alpha, ax=ax).. 
-00009430: 2020 2020 2020 2020 2020 2069 6620 6c61             if la
-00009440: 6265 6c3a 0a20 2020 2020 2020 2020 2020  bel:.           
-00009450: 2020 2020 2061 782e 7365 745f 786c 6162       ax.set_xlab
-00009460: 656c 2827 5827 290a 2020 2020 2020 2020  el('X').        
-00009470: 2020 2020 2020 2020 6178 2e73 6574 5f79          ax.set_y
-00009480: 6c61 6265 6c28 2759 2729 0a20 2020 2020  label('Y').     
-00009490: 2020 2020 2020 2020 2020 2061 782e 7365             ax.se
-000094a0: 745f 7a6c 6162 656c 2827 5a27 290a 0a20  t_zlabel('Z').. 
-000094b0: 2020 2020 2020 2069 6620 6672 616d 6520         if frame 
-000094c0: 6973 2054 7275 653a 0a20 2020 2020 2020  is True:.       
-000094d0: 2020 2020 2073 656c 662e 706f 7365 2e70       self.pose.p
-000094e0: 6c6f 7428 6c65 6e67 7468 3d73 6361 6c65  lot(length=scale
-000094f0: 2a31 2e35 2c20 7374 796c 653d 276c 696e  *1.5, style='lin
-00009500: 6527 2c20 636f 6c6f 723d 636f 6c6f 722c  e', color=color,
-00009510: 2066 6c6f 3d28 302e 3037 2c20 302c 202d   flo=(0.07, 0, -
-00009520: 302e 3031 2929 0a20 2020 2020 2020 2065  0.01)).        e
-00009530: 6c69 6620 6672 616d 6520 6973 206e 6f74  lif frame is not
-00009540: 2046 616c 7365 3a0a 2020 2020 2020 2020   False:.        
-00009550: 2020 2020 7365 6c66 2e70 6f73 652e 706c      self.pose.pl
-00009560: 6f74 282a 2a66 7261 6d65 290a 0a20 2020  ot(**frame)..   
-00009570: 2020 2020 2072 6574 7572 6e20 6178 0a0a       return ax..
-00009580: 2020 2020 6465 6620 5f61 6464 5f6e 6f69      def _add_noi
-00009590: 7365 5f64 6973 746f 7274 696f 6e28 7365  se_distortion(se
-000095a0: 6c66 2c20 7576 293a 0a20 2020 2020 2020  lf, uv):.       
-000095b0: 2022 2222 0a20 2020 2020 2020 2041 6464   """.        Add
-000095c0: 206e 6f69 7365 2074 6f20 7069 7865 6c20   noise to pixel 
-000095d0: 636f 6f72 6469 6e61 7465 730a 0a20 2020  coordinates..   
-000095e0: 2020 2020 203a 7061 7261 6d20 7576 3a20       :param uv: 
-000095f0: 696d 6167 6520 706c 616e 6520 706f 696e  image plane poin
-00009600: 7420 636f 6f72 6469 6e61 7465 730a 2020  t coordinates.  
-00009610: 2020 2020 2020 3a74 7970 6520 7576 3a20        :type uv: 
-00009620: 6e64 6172 7261 7928 322c 4e29 0a20 2020  ndarray(2,N).   
-00009630: 2020 2020 203a 7265 7475 726e 3a20 706f       :return: po
-00009640: 696e 7420 636f 6f72 6469 6e61 7465 7320  int coordinates 
-00009650: 7769 7468 2061 6464 6974 6976 6520 6e6f  with additive no
-00009660: 6973 650a 2020 2020 2020 2020 3a72 7479  ise.        :rty
-00009670: 7065 3a20 6e64 6172 7261 7928 322c 4e29  pe: ndarray(2,N)
-00009680: 0a0a 2020 2020 2020 2020 4d6f 6465 6c20  ..        Model 
-00009690: 6e6f 6973 6520 696e 2074 6865 2069 6d61  noise in the ima
-000096a0: 6765 2070 726f 6365 7373 2062 7920 6164  ge process by ad
-000096b0: 6469 6e67 207a 6572 6f2d 6d65 616e 2047  ding zero-mean G
-000096c0: 6175 7373 6961 6e20 6e6f 6973 650a 2020  aussian noise.  
-000096d0: 2020 2020 2020 746f 2074 6865 2063 6f6f        to the coo
-000096e0: 7264 696e 6174 6573 206f 6620 7072 6f6a  rdinates of proj
-000096f0: 6563 7465 6420 776f 726c 6420 706f 696e  ected world poin
-00009700: 7473 2e20 2054 6865 206e 6f69 7365 2068  ts.  The noise h
-00009710: 6173 2061 0a20 2020 2020 2020 2073 7461  as a.        sta
-00009720: 6e64 6172 6420 6465 7669 6174 696f 6e20  ndard deviation 
-00009730: 7370 6563 6966 6965 6420 6279 2074 6865  specified by the
-00009740: 2063 616d 6572 6120 636f 6e73 7472 7563   camera construc
-00009750: 746f 722e 0a0a 2020 2020 2020 2020 3a73  tor...        :s
-00009760: 6565 616c 736f 3a20 3a6d 6574 683a 606e  eealso: :meth:`n
-00009770: 6f69 7365 600a 2020 2020 2020 2020 2222  oise`.        ""
-00009780: 220a 2020 2020 2020 2020 2320 6469 7374  ".        # dist
-00009790: 6f72 7420 7468 6520 7069 7865 6c73 0a20  ort the pixels. 
-000097a0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-000097b0: 2320 6164 6420 4761 7573 7369 616e 206e  # add Gaussian n
-000097c0: 6f69 7365 2077 6974 6820 7370 6563 6966  oise with specif
-000097d0: 6965 6420 7374 616e 6461 7264 2064 6576  ied standard dev
-000097e0: 6961 7469 6f6e 0a20 2020 2020 2020 2069  iation.        i
-000097f0: 6620 7365 6c66 2e6e 6f69 7365 2069 7320  f self.noise is 
-00009800: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00009810: 2020 2020 2020 7576 202b 3d20 7365 6c66        uv += self
-00009820: 2e5f 7261 6e64 6f6d 2e6e 6f72 6d61 6c28  ._random.normal(
-00009830: 302e 302c 2073 656c 662e 6e6f 6973 652c  0.0, self.noise,
-00009840: 2073 697a 653d 7576 2e73 6861 7065 290a   size=uv.shape).
-00009850: 2020 2020 2020 2020 7265 7475 726e 2075          return u
-00009860: 7620 0a0a 636c 6173 7320 4365 6e74 7261  v ..class Centra
-00009870: 6c43 616d 6572 6128 4361 6d65 7261 4261  lCamera(CameraBa
-00009880: 7365 293a 0a20 2020 2022 2222 0a20 2020  se):.    """.   
-00009890: 2043 7265 6174 6520 6365 6e74 7261 6c20   Create central 
-000098a0: 6361 6d65 7261 2070 726f 6a65 6374 696f  camera projectio
-000098b0: 6e20 6d6f 6465 6c0a 0a20 2020 202e 2e20  n model..    .. 
-000098c0: 696e 6865 7269 7461 6e63 652d 6469 6167  inheritance-diag
-000098d0: 7261 6d3a 3a20 6d61 6368 696e 6576 6973  ram:: machinevis
-000098e0: 696f 6e74 6f6f 6c62 6f78 2e43 616d 6572  iontoolbox.Camer
-000098f0: 612e 4365 6e74 7261 6c43 616d 6572 610a  a.CentralCamera.
-00009900: 2020 2020 2020 2020 3a74 6f70 2d63 6c61          :top-cla
-00009910: 7373 6573 3a20 6d61 6368 696e 6576 6973  sses: machinevis
-00009920: 696f 6e74 6f6f 6c62 6f78 2e43 616d 6572  iontoolbox.Camer
-00009930: 612e 4361 6d65 7261 0a20 2020 2020 2020  a.Camera.       
-00009940: 203a 7061 7274 733a 2031 0a0a 2020 2020   :parts: 1..    
-00009950: 3a70 6172 616d 2066 3a20 666f 6361 6c20  :param f: focal 
-00009960: 6c65 6e67 7468 2c20 6465 6661 756c 7473  length, defaults
-00009970: 2074 6f20 386d 6d0a 2020 2020 3a74 7970   to 8mm.    :typ
-00009980: 6520 663a 2066 6c6f 6174 2c20 6f70 7469  e f: float, opti
-00009990: 6f6e 616c 0a20 2020 203a 7061 7261 6d20  onal.    :param 
-000099a0: 6469 7374 6f72 7469 6f6e 3a20 6361 6d65  distortion: came
-000099b0: 7261 2064 6973 746f 7274 696f 6e20 7061  ra distortion pa
-000099c0: 7261 6d65 7465 7273 2c20 6465 6661 756c  rameters, defaul
-000099d0: 7473 2074 6f20 4e6f 6e65 0a20 2020 203a  ts to None.    :
-000099e0: 7479 7065 2064 6973 746f 7274 696f 6e3a  type distortion:
-000099f0: 2061 7272 6179 5f6c 696b 6528 3529 2c20   array_like(5), 
-00009a00: 6f70 7469 6f6e 616c 0a20 2020 203a 7061  optional.    :pa
-00009a10: 7261 6d20 6b77 6172 6773 3a20 6172 6775  ram kwargs: argu
-00009a20: 6d65 6e74 7320 7061 7373 6564 2074 6f20  ments passed to 
-00009a30: 3a63 6c61 7373 3a60 4361 6d65 7261 4261  :class:`CameraBa
-00009a40: 7365 6020 636f 6e73 7472 7563 746f 720a  se` constructor.
-00009a50: 0a0a 2020 2020 4120 6361 6d65 7261 206f  ..    A camera o
-00009a60: 626a 6563 7420 636f 6e74 6169 6e73 206d  bject contains m
-00009a70: 6574 686f 6473 2066 6f72 2070 726f 6a65  ethods for proje
-00009a80: 6374 696e 6720 3344 2070 6f69 6e74 7320  cting 3D points 
-00009a90: 616e 6420 6c69 6e65 730a 2020 2020 746f  and lines.    to
-00009aa0: 2074 6865 2069 6d61 6765 2070 6c61 6e65   the image plane
-00009ab0: 2c20 6173 2077 656c 6c20 6173 2073 7570  , as well as sup
-00009ac0: 706f 7274 696e 6720 6120 7669 7274 7561  porting a virtua
-00009ad0: 6c20 696d 6167 6520 706c 616e 6520 6f6e  l image plane on
-00009ae0: 746f 0a20 2020 2077 6869 6368 2033 4420  to.    which 3D 
-00009af0: 706f 696e 7473 2061 6e64 206c 696e 6573  points and lines
-00009b00: 2063 616e 2062 6520 6472 6177 6e2e 0a0a   can be drawn...
-00009b10: 2020 2020 3a72 6566 6572 656e 6365 733a      :references:
-00009b20: 200a 2020 2020 2020 2020 2d20 526f 626f   .        - Robo
-00009b30: 7469 6373 2c20 5669 7369 6f6e 2026 2043  tics, Vision & C
-00009b40: 6f6e 7472 6f6c 2066 6f72 2050 7974 686f  ontrol for Pytho
-00009b50: 6e2c 2053 6563 7469 6f6e 2031 332e 312c  n, Section 13.1,
-00009b60: 2050 2e20 436f 726b 652c 2053 7072 696e   P. Corke, Sprin
-00009b70: 6765 7220 3230 3233 2e0a 0a20 2020 203a  ger 2023...    :
-00009b80: 7365 6561 6c73 6f3a 203a 636c 6173 733a  seealso: :class:
-00009b90: 6043 616d 6572 6142 6173 6560 203a 636c  `CameraBase` :cl
-00009ba0: 6173 733a 6046 6973 6845 7965 4361 6d65  ass:`FishEyeCame
-00009bb0: 7261 6020 3a63 6c61 7373 3a60 5370 6865  ra` :class:`Sphe
-00009bc0: 7269 6361 6c43 616d 6572 6160 0a20 2020  ricalCamera`.   
-00009bd0: 2022 2222 0a0a 2020 2020 6465 6620 5f5f   """..    def __
-00009be0: 696e 6974 5f5f 2873 656c 662c 0a20 2020  init__(self,.   
-00009bf0: 2020 2020 2020 2020 2020 2020 2020 663d                f=
-00009c00: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
-00009c10: 2020 2020 6469 7374 6f72 7469 6f6e 3d4e      distortion=N
-00009c20: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
-00009c30: 2020 2020 2020 2a2a 6b77 6172 6773 293a        **kwargs):
-00009c40: 0a0a 2020 2020 2020 2020 7375 7065 7228  ..        super(
-00009c50: 292e 5f5f 696e 6974 5f5f 2863 616d 7479  ).__init__(camty
-00009c60: 7065 3d27 7065 7273 7065 6374 6976 6527  pe='perspective'
-00009c70: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
-00009c80: 2020 2020 2320 544f 444f 2073 6f6d 6520      # TODO some 
-00009c90: 6f66 2074 6869 7320 6c6f 6769 6320 746f  of this logic to
-00009ca0: 2066 2061 6e64 2070 7020 7365 7474 6572   f and pp setter
-00009cb0: 730a 2020 2020 2020 2020 7365 6c66 2e66  s.        self.f
-00009cc0: 203d 2066 0a0a 2020 2020 2020 2020 7365   = f..        se
-00009cd0: 6c66 2e5f 6469 7374 6f72 7469 6f6e 203d  lf._distortion =
-00009ce0: 2064 6973 746f 7274 696f 6e0a 0a20 2020   distortion..   
-00009cf0: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
-00009d00: 2020 6465 6620 4465 6661 756c 7428 636c    def Default(cl
-00009d10: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-00009d20: 2020 2020 2020 7222 2222 0a20 2020 2020        r""".     
-00009d30: 2020 2053 6574 2064 6566 6175 6c74 2063     Set default c
-00009d40: 656e 7472 616c 2063 616d 6572 6120 7061  entral camera pa
-00009d50: 7261 6d65 7465 7273 0a0a 2020 2020 2020  rameters..      
-00009d60: 2020 3a72 6574 7572 6e3a 2063 656e 7472    :return: centr
-00009d70: 616c 2063 616d 6572 6120 6d6f 6465 6c0a  al camera model.
-00009d80: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-00009d90: 3a63 6c61 7373 3a60 4365 6e74 7261 6c43  :class:`CentralC
-00009da0: 616d 6572 6160 2069 6e73 7461 6e63 650a  amera` instance.
-00009db0: 0a20 2020 2020 2020 2049 6e69 7469 616c  .        Initial
-00009dc0: 697a 6520 6120 6365 6e74 7261 6c20 6361  ize a central ca
-00009dd0: 6d65 7261 2077 6974 683a 2066 6f63 616c  mera with: focal
-00009de0: 206c 656e 6774 6820 6f66 2038 6d6d 2c20   length of 8mm, 
-00009df0: 3a6d 6174 683a 6031 305c 6d75 5c6d 626f  :math:`10\mu\mbo
-00009e00: 787b 6d7d 6020 7069 7865 6c73 2c0a 2020  x{m}` pixels,.  
-00009e10: 2020 2020 2020 696d 6167 6520 7369 7a65        image size
-00009e20: 206f 6620 3a6d 6174 683a 6031 3030 3020   of :math:`1000 
-00009e30: 5c74 696d 6573 2031 3030 3060 2077 6974  \times 1000` wit
-00009e40: 6820 7072 696e 6369 7061 6c20 706f 696e  h principal poin
-00009e50: 7420 6174 2028 3530 302c 2035 3030 292e  t at (500, 500).
-00009e60: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-00009e70: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
-00009e80: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
-00009e90: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00009ea0: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
-00009eb0: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
-00009ec0: 7420 4365 6e74 7261 6c43 616d 6572 610a  t CentralCamera.
-00009ed0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00009ee0: 6361 6d65 7261 203d 2043 656e 7472 616c  camera = Central
-00009ef0: 4361 6d65 7261 2e44 6566 6175 6c74 286e  Camera.Default(n
-00009f00: 616d 653d 2763 616d 6572 6131 2729 0a20  ame='camera1'). 
-00009f10: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-00009f20: 616d 6572 610a 0a20 2020 2020 2020 203a  amera..        :
-00009f30: 7265 6665 7265 6e63 6573 3a20 0a20 2020  references: .   
-00009f40: 2020 2020 2020 2020 202d 2052 6f62 6f74           - Robot
-00009f50: 6963 732c 2056 6973 696f 6e20 2620 436f  ics, Vision & Co
-00009f60: 6e74 726f 6c20 666f 7220 5079 7468 6f6e  ntrol for Python
-00009f70: 2c20 5365 6374 696f 6e20 3133 2e31 2c20  , Section 13.1, 
-00009f80: 502e 2043 6f72 6b65 2c20 5370 7269 6e67  P. Corke, Spring
-00009f90: 6572 2032 3032 332e 0a0a 2020 2020 2020  er 2023...      
-00009fa0: 2020 3a73 6565 616c 736f 3a20 3a63 6c61    :seealso: :cla
-00009fb0: 7373 3a60 4365 6e74 7261 6c43 616d 6572  ss:`CentralCamer
-00009fc0: 6160 0a20 2020 2020 2020 2022 2222 0a20  a`.        """. 
-00009fd0: 2020 2020 2020 2064 6566 6175 6c74 203d         default =
-00009fe0: 207b 0a20 2020 2020 2020 2020 2020 2027   {.            '
-00009ff0: 6627 3a20 302e 3030 382c 200a 2020 2020  f': 0.008, .    
-0000a000: 2020 2020 2020 2020 2772 686f 273a 2031          'rho': 1
-0000a010: 3065 2d36 2c0a 2020 2020 2020 2020 2020  0e-6,.          
-0000a020: 2020 2769 6d61 6765 7369 7a65 273a 2031    'imagesize': 1
-0000a030: 3030 302c 200a 2020 2020 2020 2020 2020  000, .          
-0000a040: 2020 2770 7027 3a20 2835 3030 2c35 3030    'pp': (500,500
-0000a050: 292c 0a20 2020 2020 2020 2020 2020 2027  ),.            '
-0000a060: 6e61 6d65 273a 2027 6465 6661 756c 7420  name': 'default 
-0000a070: 7065 7273 7065 6374 6976 6520 6361 6d65  perspective came
-0000a080: 7261 270a 2020 2020 2020 2020 7d0a 0a20  ra'.        }.. 
-0000a090: 2020 2020 2020 2072 6574 7572 6e20 4365         return Ce
-0000a0a0: 6e74 7261 6c43 616d 6572 6128 2a2a 7b2a  ntralCamera(**{*
-0000a0b0: 2a64 6566 6175 6c74 2c20 2a2a 6b77 6172  *default, **kwar
-0000a0c0: 6773 7d29 0a20 2020 2020 2020 200a 2020  gs}).        .  
-0000a0d0: 2020 6465 6620 5f5f 7374 725f 5f28 7365    def __str__(se
-0000a0e0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0000a0f0: 0a20 2020 2020 2020 2053 7472 696e 6720  .        String 
-0000a100: 7265 7072 6573 656e 7461 7469 6f6e 206f  representation o
-0000a110: 6620 6365 6e74 7261 6c20 6361 6d65 7261  f central camera
-0000a120: 2070 6172 616d 6574 6572 730a 0a20 2020   parameters..   
-0000a130: 2020 2020 203a 7265 7475 726e 3a20 7374       :return: st
-0000a140: 7269 6e67 2072 6570 7265 7365 6e74 6174  ring representat
-0000a150: 696f 6e0a 2020 2020 2020 2020 3a72 7479  ion.        :rty
-0000a160: 7065 3a20 7374 720a 0a20 2020 2020 2020  pe: str..       
-0000a170: 204d 756c 7469 2d6c 696e 6520 7374 7269   Multi-line stri
-0000a180: 6e67 2072 6570 7265 7365 6e74 6174 696f  ng representatio
-0000a190: 6e20 6f66 2063 616d 6572 6120 696e 7472  n of camera intr
-0000a1a0: 696e 7369 6320 616e 6420 6578 7472 696e  insic and extrin
-0000a1b0: 7369 630a 2020 2020 2020 2020 7061 7261  sic.        para
-0000a1c0: 6d65 7465 7273 2e0a 2020 2020 2020 2020  meters..        
-0000a1d0: 2222 220a 2020 2020 2020 2020 7320 3d20  """.        s = 
-0000a1e0: 7375 7065 7228 292e 5f5f 7374 725f 5f28  super().__str__(
-0000a1f0: 290a 2020 2020 2020 2020 7320 2b3d 2073  ).        s += s
-0000a200: 656c 662e 666d 742e 666f 726d 6174 2827  elf.fmt.format('
-0000a210: 7072 696e 6369 7061 6c20 7074 272c 2073  principal pt', s
-0000a220: 656c 662e 7070 290a 2020 2020 2020 2020  elf.pp).        
-0000a230: 7320 2b3d 2073 656c 662e 666d 742e 666f  s += self.fmt.fo
-0000a240: 726d 6174 2827 666f 6361 6c20 6c65 6e67  rmat('focal leng
-0000a250: 7468 272c 2073 656c 662e 6629 0a20 2020  th', self.f).   
-0000a260: 2020 2020 2072 6574 7572 6e20 730a 0a0a       return s...
-0000a270: 2020 2020 6465 6620 7072 6f6a 6563 745f      def project_
-0000a280: 706f 696e 7428 7365 6c66 2c20 502c 2070  point(self, P, p
-0000a290: 6f73 653d 4e6f 6e65 2c20 6f62 6a70 6f73  ose=None, objpos
-0000a2a0: 653d 4e6f 6e65 2c20 6265 6869 6e64 3d54  e=None, behind=T
-0000a2b0: 7275 652c 2076 6973 6962 696c 6974 793d  rue, visibility=
-0000a2c0: 4661 6c73 652c 2072 6574 696e 616c 3d46  False, retinal=F
-0000a2d0: 616c 7365 2c20 2a2a 6b77 6172 6773 293a  alse, **kwargs):
-0000a2e0: 0a20 2020 2020 2020 2072 2222 220a 2020  .        r""".  
-0000a2f0: 2020 2020 2020 5072 6f6a 6563 7420 3344        Project 3D
-0000a300: 2070 6f69 6e74 7320 746f 2069 6d61 6765   points to image
-0000a310: 2070 6c61 6e65 0a0a 2020 2020 2020 2020   plane..        
-0000a320: 3a70 6172 616d 2050 3a20 3344 2077 6f72  :param P: 3D wor
-0000a330: 6c64 2070 6f69 6e74 206f 7220 706f 696e  ld point or poin
-0000a340: 7473 2069 6e20 4575 636c 6964 6561 6e20  ts in Euclidean 
-0000a350: 6f72 2068 6f6d 6f67 656e 656f 7573 2066  or homogeneous f
-0000a360: 6f72 6d0a 2020 2020 2020 2020 3a74 7970  orm.        :typ
-0000a370: 6520 503a 2061 7272 6179 5f6c 696b 6528  e P: array_like(
-0000a380: 3329 2c20 6172 7261 795f 6c69 6b65 2833  3), array_like(3
-0000a390: 2c6e 292c 2061 7272 6179 5f6c 696b 6528  ,n), array_like(
-0000a3a0: 3429 2c20 6172 7261 795f 6c69 6b65 2834  4), array_like(4
-0000a3b0: 2c6e 290a 2020 2020 2020 2020 3a70 6172  ,n).        :par
-0000a3c0: 616d 2070 6f73 653a 2063 616d 6572 6120  am pose: camera 
-0000a3d0: 706f 7365 2077 6974 6820 7265 7370 6563  pose with respec
-0000a3e0: 7420 746f 2074 6865 2077 6f72 6c64 2066  t to the world f
-0000a3f0: 7261 6d65 2c20 6465 6661 756c 7473 2074  rame, defaults t
-0000a400: 6f0a 2020 2020 2020 2020 2020 2020 6361  o.            ca
-0000a410: 6d65 7261 2773 2060 6070 6f73 6560 6020  mera's ``pose`` 
-0000a420: 6174 7472 6962 7574 650a 2020 2020 2020  attribute.      
-0000a430: 2020 3a74 7970 6520 706f 7365 3a20 3a63    :type pose: :c
-0000a440: 6c61 7373 3a60 7e73 7061 7469 616c 6d61  lass:`~spatialma
-0000a450: 7468 2e2e 706f 7365 3364 2e53 4533 602c  th..pose3d.SE3`,
-0000a460: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
-0000a470: 2020 3a70 6172 616d 206f 626a 706f 7365    :param objpose
-0000a480: 3a20 2033 4420 706f 696e 7420 7265 6665  :  3D point refe
-0000a490: 7265 6e63 6520 6672 616d 652c 2064 6566  rence frame, def
-0000a4a0: 6175 6c74 7320 746f 2077 6f72 6c64 2066  aults to world f
-0000a4b0: 7261 6d65 0a20 2020 2020 2020 203a 7479  rame.        :ty
-0000a4c0: 7065 206f 626a 706f 7365 3a20 3a63 6c61  pe objpose: :cla
-0000a4d0: 7373 3a60 7e73 7061 7469 616c 6d61 7468  ss:`~spatialmath
-0000a4e0: 2e2e 706f 7365 3364 2e53 4533 602c 206f  ..pose3d.SE3`, o
-0000a4f0: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
-0000a500: 3a70 6172 616d 2062 6568 696e 643a 2070  :param behind: p
-0000a510: 6f69 6e74 7320 6265 6869 6e64 2074 6865  oints behind the
-0000a520: 2063 616d 6572 6120 696e 6469 6361 7465   camera indicate
-0000a530: 6420 6279 204e 614e 2c20 6465 6661 756c  d by NaN, defaul
-0000a540: 7473 2074 6f20 5472 7565 0a20 2020 2020  ts to True.     
-0000a550: 2020 203a 7479 7065 2062 6568 696e 643a     :type behind:
-0000a560: 2062 6f6f 6c2c 206f 7074 696f 6e61 6c0a   bool, optional.
-0000a570: 2020 2020 2020 2020 3a70 6172 616d 2076          :param v
-0000a580: 6973 6962 696c 6974 793a 2072 6574 7572  isibility: retur
-0000a590: 6e20 7669 7369 6269 6c69 7479 2061 7272  n visibility arr
-0000a5a0: 6179 2c20 6465 6661 756c 7473 2074 6f20  ay, defaults to 
-0000a5b0: 4661 6c73 650a 2020 2020 2020 2020 3a74  False.        :t
-0000a5c0: 7970 6520 7669 7369 6269 6c69 7479 3a20  ype visibility: 
-0000a5d0: 626f 6f6c 0a20 2020 2020 2020 203a 7061  bool.        :pa
-0000a5e0: 7261 6d20 7265 7469 6e61 6c3a 2074 7261  ram retinal: tra
-0000a5f0: 6e73 666f 726d 2074 6f20 7265 7469 6e61  nsform to retina
-0000a600: 6c20 636f 6f72 6469 6e61 7465 732c 2064  l coordinates, d
-0000a610: 6566 6175 6c74 7320 746f 2046 616c 7365  efaults to False
-0000a620: 0a20 2020 2020 2020 203a 7479 7065 2072  .        :type r
-0000a630: 6574 696e 616c 3a20 626f 6f6c 2c20 6f70  etinal: bool, op
-0000a640: 7469 6f6e 616c 0a20 2020 2020 2020 203a  tional.        :
-0000a650: 7265 7475 726e 3a20 696d 6167 6520 706c  return: image pl
-0000a660: 616e 6520 706f 696e 7473 2c20 6f70 7469  ane points, opti
-0000a670: 6f6e 616c 2076 6973 6962 696c 6974 7920  onal visibility 
-0000a680: 7665 6374 6f72 0a20 2020 2020 2020 203a  vector.        :
-0000a690: 7274 7970 653a 206e 6461 7272 6179 2832  rtype: ndarray(2
-0000a6a0: 2c6e 292c 206e 6461 7272 6179 286e 290a  ,n), ndarray(n).
-0000a6b0: 0a20 2020 2020 2020 2050 726f 6a65 6374  .        Project
-0000a6c0: 2061 2033 4420 706f 696e 7420 746f 2074   a 3D point to t
-0000a6d0: 6865 2069 6d61 6765 2070 6c61 6e65 0a0a  he image plane..
-0000a6e0: 2020 2020 2020 2020 2e2e 206d 6174 683a          .. math:
-0000a6f0: 3a0a 0a20 2020 2020 2020 2020 2020 205c  :..            \
-0000a700: 6876 6563 7b70 7d20 3d20 5c6d 6174 7b43  hvec{p} = \mat{C
-0000a710: 7d20 5c68 7665 637b 507d 0a0a 2020 2020  } \hvec{P}..    
-0000a720: 2020 2020 7768 6572 6520 3a6d 6174 683a      where :math:
-0000a730: 605c 6d61 747b 437d 6020 6973 2074 6865  `\mat{C}` is the
-0000a740: 2063 616d 6572 6120 6361 6c69 6272 6174   camera calibrat
-0000a750: 696f 6e20 6d61 7472 6978 2061 6e64 0a20  ion matrix and. 
-0000a760: 2020 2020 2020 203a 6d61 7468 3a60 5c68         :math:`\h
-0000a770: 7665 637b 707d 6020 616e 6420 3a6d 6174  vec{p}` and :mat
-0000a780: 683a 605c 6876 6563 7b50 7d60 2061 7265  h:`\hvec{P}` are
-0000a790: 2074 6865 2069 6d61 6765 2070 6c61 6e65   the image plane
-0000a7a0: 2061 6e64 2077 6f72 6c64 0a20 2020 2020   and world.     
-0000a7b0: 2020 2066 7261 6d65 2063 6f6f 7264 696e     frame coordin
-0000a7c0: 6174 6573 2072 6573 7065 6374 6976 656c  ates respectivel
-0000a7d0: 792c 2069 6e20 686f 6d6f 6765 6e65 6f75  y, in homogeneou
-0000a7e0: 7320 666f 726d 2e20 0a20 2020 2020 2020  s form. .       
-0000a7f0: 200a 2020 2020 2020 2020 576f 726c 6420   .        World 
-0000a800: 706f 696e 7473 2061 7265 2067 6976 656e  points are given
-0000a810: 2061 7320 6120 3144 2061 7272 6179 206f   as a 1D array o
-0000a820: 7220 7468 6520 636f 6c75 6d6e 7320 6f66  r the columns of
-0000a830: 2061 2032 4420 6172 7261 7920 6f66 0a20   a 2D array of. 
-0000a840: 2020 2020 2020 2045 7563 6c69 6465 616e         Euclidean
-0000a850: 206f 7220 686f 6d6f 6765 6e65 6f75 7320   or homogeneous 
-0000a860: 636f 6f72 6469 6e61 7465 732e 2054 6865  coordinates. The
-0000a870: 2063 6f6d 7075 7465 6420 696d 6167 6520   computed image 
-0000a880: 706c 616e 650a 2020 2020 2020 2020 636f  plane.        co
-0000a890: 6f72 6469 6e61 7465 7320 6172 6520 4575  ordinates are Eu
-0000a8a0: 636c 6964 6561 6e20 6f72 2068 6f6d 6f67  clidean or homog
-0000a8b0: 656e 656f 7573 2061 6e64 2067 6976 656e  eneous and given
-0000a8c0: 2061 7320 6120 3144 2061 7272 6179 206f   as a 1D array o
-0000a8d0: 7220 7468 650a 2020 2020 2020 2020 636f  r the.        co
-0000a8e0: 7272 6573 706f 6e64 696e 6720 636f 6c75  rresponding colu
-0000a8f0: 6d6e 7320 6f66 2061 2032 4420 6172 7261  mns of a 2D arra
-0000a900: 792e 0a0a 2020 2020 2020 2020 4966 2060  y...        If `
-0000a910: 6070 6f73 6560 6020 6973 2073 7065 6369  `pose`` is speci
-0000a920: 6669 6564 2069 7420 6973 2075 7365 6420  fied it is used 
-0000a930: 666f 7220 7468 6520 6361 6d65 7261 2066  for the camera f
-0000a940: 7261 6d65 2070 6f73 652c 206f 7468 6572  rame pose, other
-0000a950: 7769 7365 0a20 2020 2020 2020 2074 6865  wise.        the
-0000a960: 2061 7474 7269 6275 7465 2060 6070 6f73   attribute ``pos
-0000a970: 6560 6020 6973 2075 7365 642e 2020 5468  e`` is used.  Th
-0000a980: 6520 6f62 6a65 6374 2773 2060 6070 6f73  e object's ``pos
-0000a990: 6560 6020 6174 7472 6962 7574 6520 6973  e`` attribute is
-0000a9a0: 206e 6f74 0a20 2020 2020 2020 2075 7064   not.        upd
-0000a9b0: 6174 6564 2069 6620 6060 706f 7365 6060  ated if ``pose``
-0000a9c0: 2069 7320 7370 6563 6966 6965 642e 0a0a   is specified...
-0000a9d0: 2020 2020 2020 2020 4120 7369 6e67 6c65          A single
-0000a9e0: 2070 6f69 6e74 2063 616e 2062 6520 7370   point can be sp
-0000a9f0: 6563 6966 6965 6420 6173 2061 2033 2d76  ecified as a 3-v
-0000aa00: 6563 746f 722c 206d 756c 7469 706c 6520  ector, multiple 
-0000aa10: 706f 696e 7473 2061 7320 616e 0a20 2020  points as an.   
-0000aa20: 2020 2020 2061 7272 6179 2077 6974 6820       array with 
-0000aa30: 7468 7265 6520 726f 7773 2061 6e64 2065  three rows and e
-0000aa40: 6163 6820 636f 6c75 6d6e 2069 7320 7468  ach column is th
-0000aa50: 6520 3344 2070 6f69 6e74 2063 6f6f 7264  e 3D point coord
-0000aa60: 696e 6174 6520 2858 2c20 592c 0a20 2020  inate (X, Y,.   
-0000aa70: 2020 2020 205a 292e 0a0a 2020 2020 2020       Z)...      
-0000aa80: 2020 5468 6520 706f 696e 7473 2060 6050    The points ``P
-0000aa90: 6060 2061 7265 2062 7920 6465 6661 756c  `` are by defaul
-0000aaa0: 7420 7769 7468 2072 6573 7065 6374 2074  t with respect t
-0000aab0: 6f20 7468 6520 776f 726c 6420 6672 616d  o the world fram
-0000aac0: 652c 2062 7574 200a 2020 2020 2020 2020  e, but .        
-0000aad0: 7468 6579 2063 616e 2062 6520 7472 616e  they can be tran
-0000aae0: 7366 6f72 6d65 6420 6279 2073 7065 6369  sformed by speci
-0000aaf0: 6679 696e 6720 6060 6f62 6a70 6f73 6560  fying ``objpose`
-0000ab00: 602e 0a20 2020 2020 2020 200a 2020 2020  `..        .    
-0000ab10: 2020 2020 4966 2077 6f72 6c64 2070 6f69      If world poi
-0000ab20: 6e74 7320 6172 6520 6265 6869 6e64 2074  nts are behind t
-0000ab30: 6865 2063 616d 6572 6120 616e 6420 6060  he camera and ``
-0000ab40: 6265 6869 6e64 6060 2069 7320 5472 7565  behind`` is True
-0000ab50: 2074 6865 6e20 7468 650a 2020 2020 2020   then the.      
-0000ab60: 2020 696d 6167 6520 706c 616e 6520 636f    image plane co
-0000ab70: 6f72 6469 6e61 7465 7320 6172 6520 7365  ordinates are se
-0000ab80: 7420 746f 204e 614e 2e0a 2020 2020 2020  t to NaN..      
-0000ab90: 2020 0a20 2020 2020 2020 2069 6620 6060    .        if ``
-0000aba0: 7669 7369 6269 6c69 7479 6060 2069 7320  visibility`` is 
-0000abb0: 5472 7565 2074 6865 6e20 6561 6368 2070  True then each p
-0000abc0: 726f 6a65 6374 6564 2070 6f69 6e74 2069  rojected point i
-0000abd0: 7320 6368 6563 6b65 6420 746f 2065 6e73  s checked to ens
-0000abe0: 7572 650a 2020 2020 2020 2020 6974 206c  ure.        it l
-0000abf0: 6965 7320 696e 2074 6865 2062 6f75 6e64  ies in the bound
-0000ac00: 7320 6f66 2074 6865 2069 6d61 6765 2070  s of the image p
-0000ac10: 6c61 6e65 2e20 2049 6e20 7468 6973 2063  lane.  In this c
-0000ac20: 6173 6520 7468 6572 6520 6172 6520 7477  ase there are tw
-0000ac30: 6f0a 2020 2020 2020 2020 7265 7475 726e  o.        return
-0000ac40: 2076 616c 7565 733a 2074 6865 2069 6d61   values: the ima
-0000ac50: 6765 2070 6c61 6e65 2063 6f6f 7264 696e  ge plane coordin
-0000ac60: 6174 6573 2061 6e64 2061 6e20 6172 7261  ates and an arra
-0000ac70: 7920 6f66 2062 6f6f 6c65 616e 730a 2020  y of booleans.  
-0000ac80: 2020 2020 2020 696e 6469 6361 7469 6e67        indicating
-0000ac90: 2069 6620 7468 6520 636f 7272 6573 706f   if the correspo
-0000aca0: 6e64 696e 6720 706f 696e 7420 6973 2076  nding point is v
-0000acb0: 6973 6962 6c65 2e0a 0a20 2020 2020 2020  isible...       
-0000acc0: 2049 6620 6060 7265 7469 6e61 6c60 6020   If ``retinal`` 
-0000acd0: 6973 2054 7275 6520 7468 656e 2070 726f  is True then pro
-0000ace0: 6a65 6374 2070 6f69 6e74 7320 696e 2072  ject points in r
-0000acf0: 6574 696e 616c 2063 6f6f 7264 696e 6174  etinal coordinat
-0000ad00: 6573 2c20 0a20 2020 2020 2020 2069 6e20  es, .        in 
-0000ad10: 756e 6974 7320 6f66 206d 6574 7265 7320  units of metres 
-0000ad20: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
-0000ad30: 7468 6520 7072 696e 6369 7061 6c20 706f  the principal po
-0000ad40: 696e 742e 0a0a 2020 2020 2020 2020 4578  int...        Ex
-0000ad50: 616d 706c 653a 0a0a 2020 2020 2020 2020  ample:..        
-0000ad60: 2e2e 2072 756e 626c 6f63 6b3a 3a20 7079  .. runblock:: py
-0000ad70: 636f 6e0a 0a20 2020 2020 2020 2020 2020  con..           
-0000ad80: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
-0000ad90: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
-0000ada0: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
-0000adb0: 6572 610a 2020 2020 2020 2020 2020 2020  era.            
-0000adc0: 3e3e 3e20 6361 6d65 7261 203d 2043 656e  >>> camera = Cen
-0000add0: 7472 616c 4361 6d65 7261 2e44 6566 6175  tralCamera.Defau
-0000ade0: 6c74 2829 0a20 2020 2020 2020 2020 2020  lt().           
-0000adf0: 203e 3e3e 2063 616d 6572 612e 7072 6f6a   >>> camera.proj
-0000ae00: 6563 745f 706f 696e 7428 2830 2e33 2c20  ect_point((0.3, 
-0000ae10: 302e 342c 2032 2929 0a0a 2020 2020 2020  0.4, 2))..      
-0000ae20: 2020 3a72 6566 6572 656e 6365 733a 200a    :references: .
-0000ae30: 2020 2020 2020 2020 2020 2020 2d20 526f              - Ro
-0000ae40: 626f 7469 6373 2c20 5669 7369 6f6e 2026  botics, Vision &
-0000ae50: 2043 6f6e 7472 6f6c 2066 6f72 2050 7974   Control for Pyt
-0000ae60: 686f 6e2c 2053 6563 7469 6f6e 2031 332e  hon, Section 13.
-0000ae70: 312c 2050 2e20 436f 726b 652c 2053 7072  1, P. Corke, Spr
-0000ae80: 696e 6765 7220 3230 3233 2e0a 0a20 2020  inger 2023...   
-0000ae90: 2020 2020 203a 7365 6561 6c73 6f3a 203a       :seealso: :
-0000aea0: 6d65 7468 3a60 4360 203a 6d65 7468 3a60  meth:`C` :meth:`
-0000aeb0: 7072 6f6a 6563 745f 706f 696e 7460 203a  project_point` :
-0000aec0: 6d65 7468 3a60 7072 6f6a 6563 745f 6c69  meth:`project_li
-0000aed0: 6e65 6020 3a6d 6574 683a 6070 726f 6a65  ne` :meth:`proje
-0000aee0: 6374 5f71 7561 6472 6963 600a 2020 2020  ct_quadric`.    
-0000aef0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000af00: 6966 2070 6f73 6520 6973 204e 6f6e 653a  if pose is None:
-0000af10: 0a20 2020 2020 2020 2020 2020 2070 6f73  .            pos
-0000af20: 6520 3d20 7365 6c66 2e70 6f73 650a 0a20  e = self.pose.. 
-0000af30: 2020 2020 2020 2043 203d 2073 656c 662e         C = self.
-0000af40: 4328 706f 7365 2c20 7265 7469 6e61 6c3d  C(pose, retinal=
-0000af50: 7265 7469 6e61 6c29 0a0a 2020 2020 2020  retinal)..      
-0000af60: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-0000af70: 502c 206e 702e 6e64 6172 7261 7929 3a0a  P, np.ndarray):.
-0000af80: 2020 2020 2020 2020 2020 2020 6966 2050              if P
-0000af90: 2e6e 6469 6d20 3d3d 2031 3a0a 2020 2020  .ndim == 1:.    
-0000afa0: 2020 2020 2020 2020 2020 2020 5020 3d20              P = 
-0000afb0: 502e 7265 7368 6170 6528 282d 312c 2031  P.reshape((-1, 1
-0000afc0: 2929 2020 2320 6d61 6b65 2069 7420 6120  ))  # make it a 
-0000afd0: 636f 6c75 6d6e 0a20 2020 2020 2020 2065  column.        e
-0000afe0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000aff0: 2050 203d 2062 6173 652e 6765 7476 6563   P = base.getvec
-0000b000: 746f 7228 502c 206f 7574 3d27 636f 6c27  tor(P, out='col'
-0000b010: 290a 0a20 2020 2020 2020 2069 6620 502e  )..        if P.
-0000b020: 7368 6170 655b 305d 203d 3d20 333a 0a20  shape[0] == 3:. 
-0000b030: 2020 2020 2020 2020 2020 2050 203d 2062             P = b
-0000b040: 6173 652e 6532 6828 5029 2020 2320 6d61  ase.e2h(P)  # ma
-0000b050: 6b65 2069 7420 686f 6d6f 6765 6e65 6f75  ke it homogeneou
-0000b060: 730a 2020 2020 2020 2020 2020 2020 6575  s.            eu
-0000b070: 636c 6964 6561 6e20 3d20 5472 7565 0a20  clidean = True. 
-0000b080: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000b090: 2020 2020 2020 2020 2065 7563 6c69 6465           euclide
-0000b0a0: 616e 203d 2046 616c 7365 0a0a 2020 2020  an = False..    
-0000b0b0: 2020 2020 2320 7072 6f6a 6563 7420 3344      # project 3D
-0000b0c0: 2070 6f69 6e74 730a 0a20 2020 2020 2020   points..       
-0000b0d0: 2069 6620 6f62 6a70 6f73 6520 6973 206e   if objpose is n
-0000b0e0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-0000b0f0: 2020 2020 2050 203d 206f 626a 706f 7365       P = objpose
-0000b100: 2e41 2040 2050 0a0a 2020 2020 2020 2020  .A @ P..        
-0000b110: 7820 3d20 4320 4020 500a 0a20 2020 2020  x = C @ P..     
-0000b120: 2020 2069 6620 6265 6869 6e64 3a0a 2020     if behind:.  
-0000b130: 2020 2020 2020 2020 2020 785b 322c 2078            x[2, x
-0000b140: 5b32 2c20 3a5d 203c 2030 5d20 3d20 6e70  [2, :] < 0] = np
-0000b150: 2e6e 616e 2020 2320 706f 696e 7473 2062  .nan  # points b
-0000b160: 6568 696e 6420 7468 6520 6361 6d65 7261  ehind the camera
-0000b170: 2061 7265 2073 6574 2074 6f20 4e61 4e0a   are set to NaN.
-0000b180: 0a20 2020 2020 2020 2069 6620 6575 636c  .        if eucl
-0000b190: 6964 6561 6e3a 0a20 2020 2020 2020 2020  idean:.         
-0000b1a0: 2020 2023 2045 7563 6c69 6465 616e 2070     # Euclidean p
-0000b1b0: 6f69 6e74 7320 6769 7665 6e2c 2072 6574  oints given, ret
-0000b1c0: 7572 6e20 4575 636c 6964 6561 6e20 706f  urn Euclidean po
-0000b1d0: 696e 7473 0a20 2020 2020 2020 2020 2020  ints.           
-0000b1e0: 2078 203d 2062 6173 652e 6832 6528 7829   x = base.h2e(x)
-0000b1f0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000b200: 6164 6420 4761 7573 7369 616e 206e 6f69  add Gaussian noi
-0000b210: 7365 2061 6e64 2064 6973 746f 7274 696f  se and distortio
-0000b220: 6e0a 2020 2020 2020 2020 2020 2020 6966  n.            if
-0000b230: 2073 656c 662e 5f64 6973 746f 7274 696f   self._distortio
-0000b240: 6e3a 0a20 2020 2020 2020 2020 2020 2020  n:.             
-0000b250: 2020 2078 203d 2073 656c 662e 5f64 6973     x = self._dis
-0000b260: 746f 7274 2878 290a 2020 2020 2020 2020  tort(x).        
-0000b270: 2020 2020 7820 3d20 7365 6c66 2e5f 6164      x = self._ad
-0000b280: 645f 6e6f 6973 655f 6469 7374 6f72 7469  d_noise_distorti
-0000b290: 6f6e 2878 290a 0a20 2020 2020 2020 2020  on(x)..         
-0000b2a0: 2020 2023 2020 646f 2076 6973 6962 696c     #  do visibil
-0000b2b0: 6974 7920 6368 6563 6b20 6966 2072 6571  ity check if req
-0000b2c0: 7569 7265 640a 2020 2020 2020 2020 2020  uired.          
-0000b2d0: 2020 6966 2076 6973 6962 696c 6974 793a    if visibility:
-0000b2e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b2f0: 2076 6973 6962 6c65 203d 207e 6e70 2e69   visible = ~np.i
-0000b300: 736e 616e 2878 5b30 2c3a 5d29 205c 0a20  snan(x[0,:]) \. 
-0000b310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b320: 2020 2026 2028 785b 302c 203a 5d20 3e3d     & (x[0, :] >=
-0000b330: 2030 2920 5c0a 2020 2020 2020 2020 2020   0) \.          
-0000b340: 2020 2020 2020 2020 2020 2620 2878 5b31            & (x[1
-0000b350: 2c20 3a5d 203e 3d20 3029 205c 0a20 2020  , :] >= 0) \.   
-0000b360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b370: 2026 2028 785b 302c 203a 5d20 3c20 7365   & (x[0, :] < se
-0000b380: 6c66 2e6e 7529 205c 0a20 2020 2020 2020  lf.nu) \.       
-0000b390: 2020 2020 2020 2020 2020 2020 2026 2028               & (
-0000b3a0: 785b 312c 203a 5d20 3c20 7365 6c66 2e6e  x[1, :] < self.n
-0000b3b0: 7629 0a20 2020 2020 2020 2020 2020 2020  v).             
-0000b3c0: 2020 200a 2020 2020 2020 2020 2020 2020     .            
-0000b3d0: 2020 2020 7265 7475 726e 2078 2c20 7669      return x, vi
-0000b3e0: 7369 626c 650a 2020 2020 2020 2020 2020  sible.          
-0000b3f0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000b400: 2020 2020 2020 2020 7265 7475 726e 2078          return x
-0000b410: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0000b420: 2020 2020 2020 2020 2020 2023 2068 6f6d             # hom
-0000b430: 6f67 656e 656f 7573 2070 6f69 6e74 7320  ogeneous points 
-0000b440: 6769 7665 6e2c 2072 6574 7572 6e20 686f  given, return ho
-0000b450: 6d6f 6765 6e65 6f75 7320 706f 696e 7473  mogeneous points
-0000b460: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000b470: 7572 6e20 780a 0a20 2020 2064 6566 2070  urn x..    def p
-0000b480: 726f 6a65 6374 5f6c 696e 6528 7365 6c66  roject_line(self
-0000b490: 2c20 6c69 6e65 7329 3a0a 2020 2020 2020  , lines):.      
-0000b4a0: 2020 7222 2222 0a20 2020 2020 2020 2050    r""".        P
-0000b4b0: 726f 6a65 6374 2033 4420 6c69 6e65 7320  roject 3D lines 
-0000b4c0: 746f 2069 6d61 6765 2070 6c61 6e65 0a0a  to image plane..
-0000b4d0: 2020 2020 2020 2020 3a70 6172 616d 206c          :param l
-0000b4e0: 696e 6573 3a20 506c 7563 6b65 7220 6c69  ines: Plucker li
-0000b4f0: 6e65 206f 7220 6c69 6e65 730a 2020 2020  ne or lines.    
-0000b500: 2020 2020 3a74 7970 6520 6c69 6e65 733a      :type lines:
-0000b510: 203a 636c 6173 733a 607e 7370 6174 6961   :class:`~spatia
-0000b520: 6c6d 6174 682e 2e67 656f 6d33 642e 4c69  lmath..geom3d.Li
-0000b530: 6e65 3360 2069 6e73 7461 6e63 6520 7769  ne3` instance wi
-0000b540: 7468 204e 2076 616c 7565 730a 2020 2020  th N values.    
-0000b550: 2020 2020 3a72 6574 7572 6e3a 2032 4420      :return: 2D 
-0000b560: 686f 6d6f 6765 6e65 6f75 7320 6c69 6e65  homogeneous line
-0000b570: 732c 206f 6e65 2070 6572 2063 6f6c 756d  s, one per colum
-0000b580: 6e0a 2020 2020 2020 2020 3a72 7479 7065  n.        :rtype
-0000b590: 3a20 6e64 6172 7261 7928 332c 4e29 0a0a  : ndarray(3,N)..
-0000b5a0: 2020 2020 2020 2020 5468 6520 3a63 6c61          The :cla
-0000b5b0: 7373 3a60 7e73 7061 7469 616c 6d61 7468  ss:`~spatialmath
-0000b5c0: 2e2e 6765 6f6d 3364 2e4c 696e 6533 6020  ..geom3d.Line3` 
-0000b5d0: 6f62 6a65 6374 2063 616e 2063 6f6e 7461  object can conta
-0000b5e0: 696e 206d 756c 7469 706c 6520 6c69 6e65  in multiple line
-0000b5f0: 732e 2020 5468 6520 7265 7375 6c74 2061  s.  The result a
-0000b600: 7272 6179 2068 6173 206f 6e65 0a20 2020  rray has one.   
-0000b610: 2020 2020 2063 6f6c 756d 6e20 7065 7220       column per 
-0000b620: 6c69 6e65 2c20 616e 6420 6561 6368 2063  line, and each c
-0000b630: 6f6c 756d 6e20 6973 2061 2076 6563 746f  olumn is a vecto
-0000b640: 7220 6465 7363 7269 6269 6e67 2074 6865  r describing the
-0000b650: 2069 6d61 6765 2070 6c61 6e65 0a20 2020   image plane.   
-0000b660: 2020 2020 206c 696e 6520 696e 2068 6f6d       line in hom
-0000b670: 6f67 656e 656f 7573 2066 6f72 6d20 3a6d  ogeneous form :m
-0000b680: 6174 683a 605c 656c 6c5f 3020 7520 2b20  ath:`\ell_0 u + 
-0000b690: 5c65 6c6c 5f31 2076 202b 205c 656c 6c5f  \ell_1 v + \ell_
-0000b6a0: 3220 3d20 3060 2e0a 0a20 2020 2020 2020  2 = 0`...       
-0000b6b0: 2054 6865 2070 726f 6a65 6374 696f 6e20   The projection 
-0000b6c0: 6973 0a0a 2020 2020 2020 2020 2e2e 206d  is..        .. m
-0000b6d0: 6174 683a 3a0a 0a20 2020 2020 2020 2020  ath::..         
-0000b6e0: 2020 205c 656c 6c20 3d20 5c76 6578 7b5c     \ell = \vex{\
-0000b6f0: 6d61 747b 437d 205c 736b 7b5c 7665 637b  mat{C} \sk{\vec{
-0000b700: 4c7d 7d20 5c6d 6174 7b43 7d5e 7b5c 746f  L}} \mat{C}^{\to
-0000b710: 707d 7d0a 0a20 2020 2020 2020 2077 6865  p}}..        whe
-0000b720: 7265 203a 6d61 7468 3a60 5c6d 6174 7b43  re :math:`\mat{C
-0000b730: 7d60 2069 7320 7468 6520 6361 6d65 7261  }` is the camera
-0000b740: 2063 616c 6962 7261 7469 6f6e 206d 6174   calibration mat
-0000b750: 7269 7820 616e 6420 3a6d 6174 683a 605c  rix and :math:`\
-0000b760: 736b 7b5c 7665 637b 4c7d 7d60 0a20 2020  sk{\vec{L}}`.   
-0000b770: 2020 2020 2069 7320 7468 6520 736b 6577       is the skew
-0000b780: 206d 6174 7269 7820 7265 7072 6573 656e   matrix represen
-0000b790: 7461 7469 6f6e 206f 6620 7468 6520 506c  tation of the Pl
-0000b7a0: 7563 6b65 7220 6c69 6e65 2e0a 0a20 2020  ucker line...   
-0000b7b0: 2020 2020 2045 7861 6d70 6c65 3a0a 0a20       Example:.. 
-0000b7c0: 2020 2020 2020 202e 2e20 7275 6e62 6c6f         .. runblo
-0000b7d0: 636b 3a3a 2070 7963 6f6e 0a0a 2020 2020  ck:: pycon..    
-0000b7e0: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-0000b7f0: 206d 6163 6869 6e65 7669 7369 6f6e 746f   machinevisionto
-0000b800: 6f6c 626f 7820 696d 706f 7274 2043 656e  olbox import Cen
-0000b810: 7472 616c 4361 6d65 7261 0a20 2020 2020  tralCamera.     
-0000b820: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
-0000b830: 7370 6174 6961 6c6d 6174 6820 696d 706f  spatialmath impo
-0000b840: 7274 204c 696e 6533 0a20 2020 2020 2020  rt Line3.       
-0000b850: 2020 2020 203e 3e3e 206c 696e 6520 3d20       >>> line = 
-0000b860: 4c69 6e65 332e 4a6f 696e 2828 2d33 2c20  Line3.Join((-3, 
-0000b870: 2d34 2c20 3529 2c20 2835 2c20 322c 2036  -4, 5), (5, 2, 6
-0000b880: 2929 0a20 2020 2020 2020 2020 2020 203e  )).            >
-0000b890: 3e3e 206c 696e 650a 2020 2020 2020 2020  >> line.        
-0000b8a0: 2020 2020 3e3e 3e20 6361 6d65 7261 203d      >>> camera =
-0000b8b0: 2043 656e 7472 616c 4361 6d65 7261 2829   CentralCamera()
-0000b8c0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-0000b8d0: 2063 616d 6572 612e 7072 6f6a 6563 745f   camera.project_
-0000b8e0: 6c69 6e65 286c 696e 6529 0a0a 2020 2020  line(line)..    
-0000b8f0: 2020 2020 3a72 6566 6572 656e 6365 733a      :references:
-0000b900: 200a 2020 2020 2020 2020 2020 2020 2d20   .            - 
-0000b910: 526f 626f 7469 6373 2c20 5669 7369 6f6e  Robotics, Vision
-0000b920: 2026 2043 6f6e 7472 6f6c 2066 6f72 2050   & Control for P
-0000b930: 7974 686f 6e2c 2053 6563 7469 6f6e 2031  ython, Section 1
-0000b940: 332e 372e 312c 2050 2e20 436f 726b 652c  3.7.1, P. Corke,
-0000b950: 2053 7072 696e 6765 7220 3230 3233 2e0a   Springer 2023..
-0000b960: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
-0000b970: 6f3a 203a 6d65 7468 3a60 4360 203a 636c  o: :meth:`C` :cl
-0000b980: 6173 733a 607e 7370 6174 6961 6c6d 6174  ass:`~spatialmat
-0000b990: 682e 2e67 656f 6d33 642e 4c69 6e65 3360  h..geom3d.Line3`
-0000b9a0: 203a 6d65 7468 3a60 7072 6f6a 6563 745f   :meth:`project_
-0000b9b0: 706f 696e 7460 203a 6d65 7468 3a60 7072  point` :meth:`pr
-0000b9c0: 6f6a 6563 745f 7175 6164 7269 6360 0a20  oject_quadric`. 
-0000b9d0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000b9e0: 2020 2069 6620 6e6f 7420 6973 696e 7374     if not isinst
-0000b9f0: 616e 6365 286c 696e 6573 2c20 4c69 6e65  ance(lines, Line
-0000ba00: 3329 3a0a 2020 2020 2020 2020 2020 2020  3):.            
-0000ba10: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-0000ba20: 2827 6578 7065 6374 696e 6720 4c69 6e65  ('expecting Line
-0000ba30: 3320 6c69 6e65 7327 290a 2020 2020 2020  3 lines').      
-0000ba40: 2020 2320 7072 6f6a 6563 7420 506c 7563    # project Pluc
-0000ba50: 6b65 7220 6c69 6e65 730a 0a20 2020 2020  ker lines..     
-0000ba60: 2020 206c 696e 6573 3264 203d 205b 5d0a     lines2d = [].
-0000ba70: 2020 2020 2020 2020 4320 3d20 7365 6c66          C = self
-0000ba80: 2e43 2829 0a20 2020 2020 2020 2066 6f72  .C().        for
-0000ba90: 206c 696e 6520 696e 206c 696e 6573 3a0a   line in lines:.
-0000baa0: 2020 2020 2020 2020 2020 2020 6c20 3d20              l = 
-0000bab0: 6261 7365 2e76 6578 2843 2020 4020 6c69  base.vex(C  @ li
-0000bac0: 6e65 2e73 6b65 7728 2920 4020 432e 5429  ne.skew() @ C.T)
-0000bad0: 0a20 2020 2020 2020 2020 2020 2078 203d  .            x =
-0000bae0: 206c 202f 206e 702e 6d61 7828 6e70 2e61   l / np.max(np.a
-0000baf0: 6273 286c 2929 2020 2320 6e6f 726d 616c  bs(l))  # normal
-0000bb00: 697a 6520 6279 206c 6172 6765 7374 2065  ize by largest e
-0000bb10: 6c65 6d65 6e74 0a20 2020 2020 2020 2020  lement.         
-0000bb20: 2020 206c 696e 6573 3264 2e61 7070 656e     lines2d.appen
-0000bb30: 6428 7829 0a20 2020 2020 2020 2072 6574  d(x).        ret
-0000bb40: 7572 6e20 6e70 2e63 6f6c 756d 6e5f 7374  urn np.column_st
-0000bb50: 6163 6b28 6c69 6e65 7332 6429 0a0a 2020  ack(lines2d)..  
-0000bb60: 2020 6465 6620 7072 6f6a 6563 745f 7175    def project_qu
-0000bb70: 6164 7269 6328 7365 6c66 2c20 5129 3a0a  adric(self, Q):.
-0000bb80: 2020 2020 2020 2020 7222 2222 0a20 2020          r""".   
-0000bb90: 2020 2020 2050 726f 6a65 6374 2033 4420       Project 3D 
-0000bba0: 7175 6164 7269 6320 746f 2069 6d61 6765  quadric to image
-0000bbb0: 2070 6c61 6e65 0a0a 2020 2020 2020 2020   plane..        
-0000bbc0: 3a70 6172 616d 2051 3a20 7175 6164 7269  :param Q: quadri
-0000bbd0: 6320 6d61 7472 6978 0a20 2020 2020 2020  c matrix.       
-0000bbe0: 203a 7479 7065 2051 3a20 6e64 6172 7261   :type Q: ndarra
-0000bbf0: 7928 342c 3429 0a20 2020 2020 2020 203a  y(4,4).        :
-0000bc00: 7265 7475 726e 3a20 696d 6167 6520 706c  return: image pl
-0000bc10: 616e 6520 636f 6e69 630a 2020 2020 2020  ane conic.      
-0000bc20: 2020 3a72 7479 7065 3a20 6e64 6172 7261    :rtype: ndarra
-0000bc30: 7928 332c 3329 0a0a 2020 2020 2020 2020  y(3,3)..        
-0000bc40: 5175 6164 7269 6373 2c20 7368 6f72 7420  Quadrics, short 
-0000bc50: 666f 7220 7175 6164 7261 7469 6320 7375  for quadratic su
-0000bc60: 7266 6163 6573 2c20 6172 6520 6120 7269  rfaces, are a ri
-0000bc70: 6368 2066 616d 696c 7920 6f66 0a20 2020  ch family of.   
-0000bc80: 2020 2020 2033 2d64 696d 656e 7369 6f6e       3-dimension
-0000bc90: 616c 2073 7572 6661 6365 732e 2054 6865  al surfaces. The
-0000bca0: 7265 2061 7265 2031 3720 7374 616e 6461  re are 17 standa
-0000bcb0: 7264 2074 7970 6573 2069 6e63 6c75 6469  rd types includi
-0000bcc0: 6e67 2073 7068 6572 6573 2c0a 2020 2020  ng spheres,.    
-0000bcd0: 2020 2020 656c 6c69 7073 6f69 6473 2c20      ellipsoids, 
-0000bce0: 6879 7065 722d 2062 6f6c 6f69 6473 2c20  hyper- boloids, 
-0000bcf0: 7061 7261 626f 6c6f 6964 732c 2063 796c  paraboloids, cyl
-0000bd00: 696e 6465 7273 2061 6e64 2063 6f6e 6573  inders and cones
-0000bd10: 2061 6c6c 0a20 2020 2020 2020 2064 6573   all.        des
-0000bd20: 6372 6962 6564 2062 7920 706f 696e 7473  cribed by points
-0000bd30: 203a 6d61 7468 3a60 5c76 6563 7b78 7d20   :math:`\vec{x} 
-0000bd40: 5c69 6e20 5c6d 6174 6862 627b 507d 5e33  \in \mathbb{P}^3
-0000bd50: 6020 7375 6368 2074 6861 740a 2020 2020  ` such that.    
-0000bd60: 2020 2020 0a20 2020 2020 2020 202e 2e20      .        .. 
-0000bd70: 6d61 7468 3a3a 0a20 2020 2020 2020 200a  math::.        .
-0000bd80: 2020 2020 2020 2020 2020 2020 5c68 7665              \hve
-0000bd90: 637b 787d 5e7b 5c74 6f70 7d20 5c6d 6174  c{x}^{\top} \mat
-0000bda0: 7b51 7d20 5c68 7665 637b 787d 203d 2030  {Q} \hvec{x} = 0
-0000bdb0: 0a0a 2020 2020 2020 2020 5468 6520 6f75  ..        The ou
-0000bdc0: 746c 696e 6520 6f66 2074 6865 2071 7561  tline of the qua
-0000bdd0: 6472 6963 2069 7320 7072 6f6a 6563 7465  dric is projecte
-0000bde0: 6420 746f 2061 2063 6f6e 6963 2073 6563  d to a conic sec
-0000bdf0: 7469 6f6e 206f 6e20 7468 6520 696d 6167  tion on the imag
-0000be00: 650a 2020 2020 2020 2020 706c 616e 650a  e.        plane.
-0000be10: 0a20 2020 2020 2020 202e 2e20 6d61 7468  .        .. math
-0000be20: 3a3a 0a0a 2020 2020 2020 2020 2020 2020  ::..            
-0000be30: 635e 2a20 3d20 5c6d 6174 7b43 7d20 5c6d  c^* = \mat{C} \m
-0000be40: 6174 7b51 7d5e 2a20 5c6d 6174 7b43 7d5e  at{Q}^* \mat{C}^
-0000be50: 7b5c 746f 707d 0a0a 2020 2020 2020 2020  {\top}..        
-0000be60: 7768 6572 6520 3a6d 6174 683a 6028 5c6d  where :math:`(\m
-0000be70: 6174 7b58 7d29 5e2a 203d 2064 6574 285c  at{X})^* = det(\
-0000be80: 6d61 747b 587d 2920 5c6d 6174 7b58 7d5e  mat{X}) \mat{X}^
-0000be90: 7b2d 317d 6020 6973 2074 6865 2061 646a  {-1}` is the adj
-0000bea0: 7567 6174 650a 2020 2020 2020 2020 6f70  ugate.        op
-0000beb0: 6572 6174 6f72 2e0a 0a20 2020 2020 2020  erator...       
-0000bec0: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
-0000bed0: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
-0000bee0: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
-0000bef0: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
-0000bf00: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
-0000bf10: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
-0000bf20: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
-0000bf30: 2020 203e 3e3e 2066 726f 6d20 7370 6174     >>> from spat
-0000bf40: 6961 6c6d 6174 6820 696d 706f 7274 2053  ialmath import S
-0000bf50: 4533 0a20 2020 2020 2020 2020 2020 203e  E3.            >
-0000bf60: 3e3e 2054 5f63 616d 203d 2053 4533 2e54  >> T_cam = SE3.T
-0000bf70: 7261 6e73 2830 2e32 2c20 302e 312c 202d  rans(0.2, 0.1, -
-0000bf80: 3529 202a 2053 4533 2e52 7828 302e 3229  5) * SE3.Rx(0.2)
-0000bf90: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-0000bfa0: 2051 203d 206e 702e 6469 6167 285b 312c   Q = np.diag([1,
-0000bfb0: 2031 2c20 312c 202d 315d 2920 2023 2075   1, 1, -1])  # u
-0000bfc0: 6e69 7420 7370 6865 7265 2061 7420 6f72  nit sphere at or
-0000bfd0: 6967 696e 0a20 2020 2020 2020 2020 2020  igin.           
-0000bfe0: 203e 3e3e 2063 616d 6572 6120 3d20 4365   >>> camera = Ce
-0000bff0: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
-0000c000: 756c 7428 663d 302e 3031 352c 2070 6f73  ult(f=0.015, pos
-0000c010: 653d 545f 6361 6d29 3b0a 2020 2020 2020  e=T_cam);.      
-0000c020: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
-0000c030: 2e70 726f 6a65 6374 5f71 7561 6472 6963  .project_quadric
-0000c040: 2851 290a 0a20 2020 2020 2020 203a 7265  (Q)..        :re
-0000c050: 6665 7265 6e63 6573 3a0a 2020 2020 2020  ferences:.      
-0000c060: 2020 2020 2020 2d20 526f 626f 7469 6373        - Robotics
-0000c070: 2c20 5669 7369 6f6e 2026 2043 6f6e 7472  , Vision & Contr
-0000c080: 6f6c 2066 6f72 2050 7974 686f 6e2c 2053  ol for Python, S
-0000c090: 6563 7469 6f6e 2031 332e 372e 312c 2050  ection 13.7.1, P
-0000c0a0: 2e20 436f 726b 652c 2053 7072 696e 6765  . Corke, Springe
-0000c0b0: 7220 3230 3233 2e0a 0a20 2020 2020 2020  r 2023...       
-0000c0c0: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
-0000c0d0: 3a60 4360 203a 6d65 7468 3a60 7072 6f6a  :`C` :meth:`proj
-0000c0e0: 6563 745f 706f 696e 7460 203a 6d65 7468  ect_point` :meth
-0000c0f0: 3a60 7072 6f6a 6563 745f 6c69 6e65 600a  :`project_line`.
-0000c100: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0000c110: 2020 2020 6966 206e 6f74 2073 6d62 6173      if not smbas
-0000c120: 652e 6973 6d61 7472 6978 2851 2c20 2834  e.ismatrix(Q, (4
-0000c130: 2c34 2929 3a0a 2020 2020 2020 2020 2020  ,4)):.          
-0000c140: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-0000c150: 6f72 2827 6578 7065 6374 696e 6720 3478  or('expecting 4x
-0000c160: 3420 636f 6e69 6320 6d61 7472 6978 2729  4 conic matrix')
-0000c170: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0000c180: 2073 656c 662e 4328 2920 4020 5120 4020   self.C() @ Q @ 
-0000c190: 7365 6c66 2e43 2829 2e54 0a0a 2020 2020  self.C().T..    
-0000c1a0: 6465 6620 6570 696c 696e 6528 7365 6c66  def epiline(self
-0000c1b0: 2c20 702c 2063 616d 6572 6132 293a 0a20  , p, camera2):. 
-0000c1c0: 2020 2020 2020 2072 2222 220a 2020 2020         r""".    
-0000c1d0: 2020 2020 436f 6d70 7574 6520 6570 6970      Compute epip
-0000c1e0: 6f6c 6172 206c 696e 650a 0a20 2020 2020  olar line..     
-0000c1f0: 2020 203a 7061 7261 6d20 703a 2069 6d61     :param p: ima
-0000c200: 6765 2070 6c61 6e65 2070 6f69 6e74 206f  ge plane point o
-0000c210: 7220 706f 696e 7473 0a20 2020 2020 2020  r points.       
-0000c220: 203a 7479 7065 2070 3a20 6172 7261 795f   :type p: array_
-0000c230: 6c69 6b65 2832 2920 6f72 206e 6461 7272  like(2) or ndarr
-0000c240: 6179 2832 2c4e 290a 2020 2020 2020 2020  ay(2,N).        
-0000c250: 3a70 6172 616d 2063 616d 6572 6132 3a20  :param camera2: 
-0000c260: 7365 636f 6e64 2063 616d 6572 610a 2020  second camera.  
-0000c270: 2020 2020 2020 3a74 7970 6520 6361 6d65        :type came
-0000c280: 7261 323a 203a 636c 6173 733a 6043 656e  ra2: :class:`Cen
-0000c290: 7472 616c 4361 6d65 7261 6020 696e 7374  tralCamera` inst
-0000c2a0: 616e 6365 0a20 2020 2020 2020 203a 7265  ance.        :re
-0000c2b0: 7475 726e 3a20 6570 6970 6f6c 6172 206c  turn: epipolar l
-0000c2c0: 696e 6520 6f72 206c 696e 6573 2069 6e20  ine or lines in 
-0000c2d0: 686f 6d6f 6765 6e65 6f75 7320 666f 726d  homogeneous form
-0000c2e0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-0000c2f0: 206e 6461 7272 6179 2833 292c 206e 6461   ndarray(3), nda
-0000c300: 7272 6179 2833 2c4e 290a 2020 2020 0a20  rray(3,N).    . 
-0000c310: 2020 2020 2020 2043 6f6d 7075 7465 2074         Compute t
-0000c320: 6865 2065 7069 706f 6c61 7220 6c69 6e65  he epipolar line
-0000c330: 2069 6e20 6060 6361 6d65 7261 3260 6020   in ``camera2`` 
-0000c340: 696e 6475 6365 6420 6279 2074 6865 2069  induced by the i
-0000c350: 6d61 6765 2070 6c61 6e65 0a20 2020 2020  mage plane.     
-0000c360: 2020 2070 6f69 6e74 7320 6060 7060 6020     points ``p`` 
-0000c370: 696e 2074 6865 2063 7572 7265 6e74 2063  in the current c
-0000c380: 616d 6572 612e 2020 4561 6368 206c 696e  amera.  Each lin
-0000c390: 6520 6973 2067 6976 656e 2062 790a 0a20  e is given by.. 
-0000c3a0: 2020 2020 2020 202e 2e20 6d61 7468 3a3a         .. math::
-0000c3b0: 0a0a 2020 2020 2020 2020 2020 2020 5c65  ..            \e
-0000c3c0: 6c6c 203d 205c 6d61 747b 467d 207b 7d5e  ll = \mat{F} {}^
-0000c3d0: 3120 5c68 7665 637b 707d 0a0a 2020 2020  1 \hvec{p}..    
-0000c3e0: 2020 2020 7768 6963 6820 6973 2069 6e20      which is in 
-0000c3f0: 686f 6d6f 6765 6e65 6f75 7320 666f 726d  homogeneous form
-0000c400: 203a 6d61 7468 3a60 5c65 6c6c 5f30 2075   :math:`\ell_0 u
-0000c410: 202b 205c 656c 6c5f 3120 7620 2b20 5c65   + \ell_1 v + \e
-0000c420: 6c6c 5f32 203d 2030 600a 2020 2020 2020  ll_2 = 0`.      
-0000c430: 2020 616e 6420 7468 6520 636f 6e6a 7567    and the conjug
-0000c440: 6174 6520 706f 696e 7420 3a6d 6174 683a  ate point :math:
-0000c450: 607b 7d5e 3220 5c76 6563 7b70 7d60 206c  `{}^2 \vec{p}` l
-0000c460: 6965 7320 6f6e 2074 6869 7320 6c69 6e65  ies on this line
-0000c470: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
-0000c480: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
-0000c490: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
-0000c4a0: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
-0000c4b0: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
-0000c4c0: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
-0000c4d0: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
-0000c4e0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-0000c4f0: 2066 726f 6d20 7370 6174 6961 6c6d 6174   from spatialmat
-0000c500: 6820 696d 706f 7274 2053 4533 0a20 2020  h import SE3.   
-0000c510: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-0000c520: 6572 6131 203d 2043 656e 7472 616c 4361  era1 = CentralCa
-0000c530: 6d65 7261 2e44 6566 6175 6c74 286e 616d  mera.Default(nam
-0000c540: 653d 2763 616d 6572 6131 2729 0a20 2020  e='camera1').   
-0000c550: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-0000c560: 6572 6132 203d 2043 656e 7472 616c 4361  era2 = CentralCa
-0000c570: 6d65 7261 2e44 6566 6175 6c74 2870 6f73  mera.Default(pos
-0000c580: 653d 5345 3328 302e 312c 2030 2e30 352c  e=SE3(0.1, 0.05,
-0000c590: 2030 292c 206e 616d 653d 2763 616d 6572   0), name='camer
-0000c5a0: 6132 2729 0a20 2020 2020 2020 2020 2020  a2').           
-0000c5b0: 203e 3e3e 2050 203d 205b 2d30 2e32 2c20   >>> P = [-0.2, 
-0000c5c0: 302e 332c 2035 5d20 2023 2077 6f72 6c64  0.3, 5]  # world
-0000c5d0: 2070 6f69 6e74 0a20 2020 2020 2020 2020   point.         
-0000c5e0: 2020 203e 3e3e 2070 3120 3d20 6361 6d65     >>> p1 = came
-0000c5f0: 7261 312e 7072 6f6a 6563 745f 706f 696e  ra1.project_poin
-0000c600: 7428 5029 2020 2320 7072 6f6a 6563 7420  t(P)  # project 
-0000c610: 746f 2066 6972 7374 2063 616d 6572 610a  to first camera.
-0000c620: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-0000c630: 6361 6d65 7261 312e 6570 696c 696e 6528  camera1.epiline(
-0000c640: 7031 2c20 6361 6d65 7261 3229 2020 2023  p1, camera2)   #
-0000c650: 2065 7069 706f 6c61 7220 6c69 6e65 2069   epipolar line i
-0000c660: 6e20 7365 636f 6e64 2063 616d 6572 610a  n second camera.
-0000c670: 0a20 2020 2020 2020 203a 7265 6665 7265  .        :refere
-0000c680: 6e63 6573 3a0a 2020 2020 2020 2020 2020  nces:.          
-0000c690: 2020 2d20 526f 626f 7469 6373 2c20 5669    - Robotics, Vi
-0000c6a0: 7369 6f6e 2026 2043 6f6e 7472 6f6c 2066  sion & Control f
-0000c6b0: 6f72 2050 7974 686f 6e2c 2053 6563 7469  or Python, Secti
-0000c6c0: 6f6e 2031 342e 322e 312c 2050 2e20 436f  on 14.2.1, P. Co
-0000c6d0: 726b 652c 2053 7072 696e 6765 7220 3230  rke, Springer 20
-0000c6e0: 3233 2e0a 0a20 2020 2020 2020 203a 7365  23...        :se
-0000c6f0: 6561 6c73 6f3a 203a 6d65 7468 3a60 706c  ealso: :meth:`pl
-0000c700: 6f74 5f65 7069 6c69 6e65 6020 3a6d 6574  ot_epiline` :met
-0000c710: 683a 6043 656e 7472 616c 4361 6d65 7261  h:`CentralCamera
-0000c720: 2e46 600a 2020 2020 2020 2020 2222 220a  .F`.        """.
-0000c730: 2020 2020 2020 2020 2320 7020 6973 2033          # p is 3
-0000c740: 2078 204e 2c20 7265 7375 6c74 2069 7320   x N, result is 
-0000c750: 3320 7820 4e0a 2020 2020 2020 2020 7265  3 x N.        re
-0000c760: 7475 726e 2073 656c 662e 4628 6361 6d65  turn self.F(came
-0000c770: 7261 3229 2040 2062 6173 652e 6532 6828  ra2) @ base.e2h(
-0000c780: 7029 0a0a 2020 2020 6465 6620 706c 6f74  p)..    def plot
-0000c790: 5f65 7069 6c69 6e65 2873 656c 662c 2046  _epiline(self, F
-0000c7a0: 2c20 702c 202a 666d 742c 202a 2a6b 7761  , p, *fmt, **kwa
-0000c7b0: 7267 7329 3a0a 2020 2020 2020 2020 7222  rgs):.        r"
-0000c7c0: 2222 0a20 2020 2020 2020 2050 6c6f 7420  "".        Plot 
-0000c7d0: 6570 6970 6f6c 6172 206c 696e 650a 0a20  epipolar line.. 
-0000c7e0: 2020 2020 2020 203a 7061 7261 6d20 463a         :param F:
-0000c7f0: 2066 756e 6461 6d65 6e74 616c 206d 6174   fundamental mat
-0000c800: 7269 780a 2020 2020 2020 2020 3a74 7970  rix.        :typ
-0000c810: 6520 463a 206e 6461 7272 6179 2833 2c33  e F: ndarray(3,3
-0000c820: 290a 2020 2020 2020 2020 3a70 6172 616d  ).        :param
-0000c830: 2070 3a20 696d 6167 6520 706c 616e 6520   p: image plane 
-0000c840: 706f 696e 7420 6f72 2070 6f69 6e74 730a  point or points.
-0000c850: 2020 2020 2020 2020 3a74 7970 6520 703a          :type p:
-0000c860: 2061 7272 6179 5f6c 696b 6528 3229 206f   array_like(2) o
-0000c870: 7220 6e64 6172 7261 7928 322c 4e29 0a20  r ndarray(2,N). 
-0000c880: 2020 2020 2020 203a 7061 7261 6d20 666d         :param fm
-0000c890: 743a 206c 696e 6520 7374 796c 6520 6172  t: line style ar
-0000c8a0: 6775 6d65 6e74 2070 6173 7365 6420 746f  gument passed to
-0000c8b0: 2060 6070 6c6f 7460 600a 2020 2020 2020   ``plot``.      
-0000c8c0: 2020 3a70 6172 616d 206b 7761 7267 733a    :param kwargs:
-0000c8d0: 2061 6464 6974 696f 6e61 6c20 6c69 6e65   additional line
-0000c8e0: 2073 7479 6c65 2061 7267 756d 656e 7473   style arguments
-0000c8f0: 2070 6173 7365 6420 746f 2060 6070 6c6f   passed to ``plo
-0000c900: 7460 600a 2020 2020 0a20 2020 2020 2020  t``.    .       
-0000c910: 2050 6c6f 7420 7468 6520 6570 6970 6f6c   Plot the epipol
-0000c920: 6172 206c 696e 6520 696e 6475 6365 6420  ar line induced 
-0000c930: 6279 2074 6865 2069 6d61 6765 2070 6c61  by the image pla
-0000c940: 6e65 2070 6f69 6e74 7320 6060 7060 6020  ne points ``p`` 
-0000c950: 696e 2074 6865 0a20 2020 2020 2020 2063  in the.        c
-0000c960: 616d 6572 6127 7320 7669 7274 7561 6c20  amera's virtual 
-0000c970: 696d 6167 6520 706c 616e 652e 2020 4561  image plane.  Ea
-0000c980: 6368 206c 696e 6520 6973 2067 6976 656e  ch line is given
-0000c990: 2062 790a 0a20 2020 2020 2020 202e 2e20   by..        .. 
-0000c9a0: 6d61 7468 3a3a 0a0a 2020 2020 2020 2020  math::..        
-0000c9b0: 2020 2020 5c65 6c6c 203d 205c 6d61 747b      \ell = \mat{
-0000c9c0: 467d 207b 7d5e 3120 5c68 7665 637b 707d  F} {}^1 \hvec{p}
-0000c9d0: 0a0a 2020 2020 2020 2020 7768 6963 6820  ..        which 
-0000c9e0: 6973 2069 6e20 686f 6d6f 6765 6e65 6f75  is in homogeneou
-0000c9f0: 7320 666f 726d 203a 6d61 7468 3a60 5c65  s form :math:`\e
-0000ca00: 6c6c 5f30 2075 202b 205c 656c 6c5f 3120  ll_0 u + \ell_1 
-0000ca10: 7620 2b20 5c65 6c6c 5f32 203d 2030 600a  v + \ell_2 = 0`.
-0000ca20: 2020 2020 2020 2020 616e 6420 7468 6520          and the 
-0000ca30: 636f 6e6a 7567 6174 6520 706f 696e 7420  conjugate point 
-0000ca40: 3a6d 6174 683a 607b 7d5e 3220 5c76 6563  :math:`{}^2 \vec
-0000ca50: 7b70 7d60 206c 6965 7320 6f6e 2074 6869  {p}` lies on thi
-0000ca60: 7320 6c69 6e65 2e0a 0a20 2020 2020 2020  s line...       
-0000ca70: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
-0000ca80: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
-0000ca90: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
-0000caa0: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
-0000cab0: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
-0000cac0: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
-0000cad0: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
-0000cae0: 2020 203e 3e3e 2066 726f 6d20 7370 6174     >>> from spat
-0000caf0: 6961 6c6d 6174 6820 696d 706f 7274 2053  ialmath import S
-0000cb00: 4533 0a20 2020 2020 2020 2020 2020 203e  E3.            >
-0000cb10: 3e3e 2063 616d 6572 6131 203d 2043 656e  >> camera1 = Cen
-0000cb20: 7472 616c 4361 6d65 7261 2e44 6566 6175  tralCamera.Defau
-0000cb30: 6c74 286e 616d 653d 2763 616d 6572 6131  lt(name='camera1
-0000cb40: 2729 0a20 2020 2020 2020 2020 2020 203e  ').            >
-0000cb50: 3e3e 2063 616d 6572 6132 203d 2043 656e  >> camera2 = Cen
-0000cb60: 7472 616c 4361 6d65 7261 2e44 6566 6175  tralCamera.Defau
-0000cb70: 6c74 2870 6f73 653d 5345 3328 302e 312c  lt(pose=SE3(0.1,
-0000cb80: 2030 2e30 352c 2030 292c 206e 616d 653d   0.05, 0), name=
-0000cb90: 2763 616d 6572 6132 2729 0a20 2020 2020  'camera2').     
-0000cba0: 2020 2020 2020 203e 3e3e 2050 203d 205b         >>> P = [
-0000cbb0: 2d30 2e32 2c20 302e 332c 2035 5d20 2023  -0.2, 0.3, 5]  #
-0000cbc0: 2077 6f72 6c64 2070 6f69 6e74 0a20 2020   world point.   
-0000cbd0: 2020 2020 2020 2020 203e 3e3e 2070 3120           >>> p1 
-0000cbe0: 3d20 6361 6d65 7261 312e 7072 6f6a 6563  = camera1.projec
-0000cbf0: 745f 706f 696e 7428 5029 2020 2320 7072  t_point(P)  # pr
-0000cc00: 6f6a 6563 7420 746f 2066 6972 7374 2063  oject to first c
-0000cc10: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
-0000cc20: 2020 3e3e 3e20 6361 6d65 7261 322e 706c    >>> camera2.pl
-0000cc30: 6f74 5f70 6f69 6e74 2850 2c20 276b 6427  ot_point(P, 'kd'
-0000cc40: 2920 2320 7072 6f6a 6563 7420 616e 6420  ) # project and 
-0000cc50: 6469 7370 6c61 7920 696e 2073 6563 6f6e  display in secon
-0000cc60: 6420 6361 6d65 7261 0a20 2020 2020 2020  d camera.       
-0000cc70: 2020 2020 203e 3e3e 2063 616d 6572 6132       >>> camera2
-0000cc80: 2e70 6c6f 745f 6570 696c 696e 6528 6361  .plot_epiline(ca
-0000cc90: 6d65 7261 312e 4628 6361 6d65 7261 3229  mera1.F(camera2)
-0000cca0: 2c20 7031 2920 2320 706c 6f74 2065 7069  , p1) # plot epi
-0000ccb0: 706f 6c61 7220 6c69 6e65 2069 6e20 7365  polar line in se
-0000ccc0: 636f 6e64 2063 616d 6572 610a 0a20 2020  cond camera..   
-0000ccd0: 2020 2020 203a 7265 6665 7265 6e63 6573       :references
-0000cce0: 3a0a 2020 2020 2020 2020 2020 2020 2d20  :.            - 
-0000ccf0: 526f 626f 7469 6373 2c20 5669 7369 6f6e  Robotics, Vision
-0000cd00: 2026 2043 6f6e 7472 6f6c 2066 6f72 2050   & Control for P
-0000cd10: 7974 686f 6e2c 2053 6563 7469 6f6e 2031  ython, Section 1
-0000cd20: 342e 322e 312c 2050 2e20 436f 726b 652c  4.2.1, P. Corke,
-0000cd30: 2053 7072 696e 6765 7220 3230 3233 2e0a   Springer 2023..
-0000cd40: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
-0000cd50: 6f3a 203a 6d65 7468 3a60 706c 6f74 5f70  o: :meth:`plot_p
-0000cd60: 6f69 6e74 6020 3a6d 6574 683a 6065 7069  oint` :meth:`epi
-0000cd70: 6c69 6e65 6020 3a6d 6574 683a 6043 656e  line` :meth:`Cen
-0000cd80: 7472 616c 4361 6d65 7261 2e46 600a 2020  tralCamera.F`.  
-0000cd90: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000cda0: 2020 2320 7020 6973 2033 2078 204e 2c20    # p is 3 x N, 
-0000cdb0: 7265 7375 6c74 2069 7320 3320 7820 4e0a  result is 3 x N.
-0000cdc0: 2020 2020 2020 2020 7365 6c66 2e70 6c6f          self.plo
-0000cdd0: 745f 6c69 6e65 3228 4620 4020 6261 7365  t_line2(F @ base
-0000cde0: 2e65 3268 2870 292c 202a 666d 742c 202a  .e2h(p), *fmt, *
-0000cdf0: 2a6b 7761 7267 7329 0a0a 2020 2020 6465  *kwargs)..    de
-0000ce00: 6620 706c 6f74 5f6c 696e 6533 2873 656c  f plot_line3(sel
-0000ce10: 662c 204c 2c20 2a2a 6b77 6172 6773 293a  f, L, **kwargs):
-0000ce20: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0000ce30: 2020 2020 2050 6c6f 7420 3344 206c 696e       Plot 3D lin
-0000ce40: 6520 6f6e 2076 6972 7475 616c 2069 6d61  e on virtual ima
-0000ce50: 6765 2070 6c61 6e65 2028 6261 7365 206d  ge plane (base m
-0000ce60: 6574 686f 6429 0a0a 2020 2020 2020 2020  ethod)..        
-0000ce70: 3a70 6172 616d 204c 3a20 3344 206c 696e  :param L: 3D lin
-0000ce80: 6520 696e 2050 6c75 636b 6572 2063 6f6f  e in Plucker coo
-0000ce90: 7264 696e 6174 6573 0a20 2020 2020 2020  rdinates.       
-0000cea0: 203a 7479 7065 204c 3a20 3a63 6c61 7373   :type L: :class
-0000ceb0: 3a60 7e73 7061 7469 616c 6d61 7468 2e2e  :`~spatialmath..
-0000cec0: 6765 6f6d 3364 2e4c 696e 6533 600a 2020  geom3d.Line3`.  
-0000ced0: 2020 2020 2020 3a70 6172 616d 206b 7761        :param kwa
-0000cee0: 7267 733a 2061 7267 756d 656e 7473 2070  rgs: arguments p
-0000cef0: 6173 7365 6420 746f 2060 6070 6c6f 7460  assed to ``plot`
-0000cf00: 600a 0a20 2020 2020 2020 2054 6865 2050  `..        The P
-0000cf10: 6c75 636b 6572 206c 696e 6520 6973 2070  lucker line is p
-0000cf20: 726f 6a65 6374 6564 2074 6f20 7468 6520  rojected to the 
-0000cf30: 6361 6d65 7261 2773 2076 6972 7475 616c  camera's virtual
-0000cf40: 2069 6d61 6765 2070 6c61 6e65 2061 6e64   image plane and
-0000cf50: 0a20 2020 2020 2020 2070 6c6f 7474 6564  .        plotted
-0000cf60: 2e0a 0a20 2020 2020 2020 203a 6e6f 7465  ...        :note
-0000cf70: 3a0a 2020 2020 2020 2020 2020 2020 2d20  :.            - 
-0000cf80: 5375 6363 6573 7369 7665 2063 616c 6c73  Successive calls
-0000cf90: 2061 6464 2069 7465 6d73 2074 6f20 7468   add items to th
-0000cfa0: 6520 7669 7274 7561 6c20 696d 6167 6520  e virtual image 
-0000cfb0: 706c 616e 652e 0a20 2020 2020 2020 2020  plane..         
-0000cfc0: 2020 202d 2054 6869 7320 6d65 7468 6f64     - This method
-0000cfd0: 2069 7320 636f 6d6d 6f6e 2074 6f20 616c   is common to al
-0000cfe0: 6c20 6060 4361 6d65 7261 4261 7365 6060  l ``CameraBase``
-0000cff0: 2073 7562 636c 6173 7365 732c 2062 7574   subclasses, but
-0000d000: 2069 740a 2020 2020 2020 2020 2020 2020   it.            
-0000d010: 2020 696e 766f 6b65 7320 6120 6361 6d65    invokes a came
-0000d020: 7261 2d73 7065 6369 6669 6320 7072 6f6a  ra-specific proj
-0000d030: 6563 7469 6f6e 206d 6574 686f 642e 0a20  ection method.. 
-0000d040: 2020 2020 2020 2020 2020 2020 200a 2020               .  
-0000d050: 2020 2020 2020 3a73 6565 616c 736f 3a20        :seealso: 
-0000d060: 3a6d 6574 683a 6070 6c6f 745f 706f 696e  :meth:`plot_poin
-0000d070: 7460 203a 6d65 7468 3a60 706c 6f74 5f6c  t` :meth:`plot_l
-0000d080: 696e 6532 6020 3a6d 6574 683a 6070 6c6f  ine2` :meth:`plo
-0000d090: 745f 7769 7265 6672 616d 6560 203a 6d65  t_wireframe` :me
-0000d0a0: 7468 3a60 636c 6660 0a20 2020 2020 2020  th:`clf`.       
-0000d0b0: 2022 2222 0a0a 2020 2020 2020 2020 6c20   """..        l 
-0000d0c0: 3d20 7365 6c66 2e70 726f 6a65 6374 5f6c  = self.project_l
-0000d0d0: 696e 6528 4c29 0a20 2020 2020 2020 2066  ine(L).        f
-0000d0e0: 6f72 2068 6c20 696e 206c 2e54 3a0a 2020  or hl in l.T:.  
-0000d0f0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
-0000d100: 6c6f 745f 6c69 6e65 3228 686c 2c20 2a2a  lot_line2(hl, **
-0000d110: 6b77 6172 6773 290a 0a20 2020 2064 6566  kwargs)..    def
-0000d120: 2072 6179 2873 656c 662c 2070 6f69 6e74   ray(self, point
-0000d130: 732c 2070 6f73 653d 4e6f 6e65 293a 0a20  s, pose=None):. 
-0000d140: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000d150: 2020 2050 726f 6a65 6374 2069 6d61 6765     Project image
-0000d160: 2070 6c61 6e65 2070 6f69 6e74 7320 746f   plane points to
-0000d170: 2061 2072 6179 0a0a 2020 2020 2020 2020   a ray..        
-0000d180: 3a70 6172 616d 2070 6f69 6e74 733a 2069  :param points: i
-0000d190: 6d61 6765 2070 6c61 6e65 2070 6f69 6e74  mage plane point
-0000d1a0: 730a 2020 2020 2020 2020 3a74 7970 6520  s.        :type 
-0000d1b0: 706f 696e 7473 3a20 6e64 6172 7261 7928  points: ndarray(
-0000d1c0: 322c 4e29 0a20 2020 2020 2020 203a 7061  2,N).        :pa
-0000d1d0: 7261 6d20 706f 7365 3a20 6361 6d65 7261  ram pose: camera
-0000d1e0: 2070 6f73 652c 2064 6566 6175 6c74 7320   pose, defaults 
-0000d1f0: 746f 204e 6f6e 650a 2020 2020 2020 2020  to None.        
-0000d200: 3a74 7970 6520 706f 7365 3a20 3a63 6c61  :type pose: :cla
-0000d210: 7373 3a60 7e73 7061 7469 616c 6d61 7468  ss:`~spatialmath
-0000d220: 2e2e 706f 7365 3364 2e53 4533 602c 206f  ..pose3d.SE3`, o
-0000d230: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
-0000d240: 3a72 6574 7572 6e3a 2063 6f72 7265 7370  :return: corresp
-0000d250: 6f6e 6469 6e67 2050 6c75 636b 6572 206c  onding Plucker l
-0000d260: 696e 6573 0a20 2020 2020 2020 203a 7274  ines.        :rt
-0000d270: 7970 653a 203a 636c 6173 733a 607e 7370  ype: :class:`~sp
-0000d280: 6174 6961 6c6d 6174 682e 2e67 656f 6d33  atialmath..geom3
-0000d290: 642e 4c69 6e65 3360 0a0a 2020 2020 2020  d.Line3`..      
-0000d2a0: 2020 466f 7220 6561 6368 2069 6d61 6765    For each image
-0000d2b0: 2070 6c61 6e65 2070 6f69 6e74 2063 6f6d   plane point com
-0000d2c0: 7075 7465 2074 6865 2065 7175 6174 696f  pute the equatio
-0000d2d0: 6e20 6f66 2061 2050 6c75 636b 6572 206c  n of a Plucker l
-0000d2e0: 696e 650a 2020 2020 2020 2020 7468 6174  ine.        that
-0000d2f0: 2072 6570 7265 7365 6e74 7320 7468 6520   represents the 
-0000d300: 3344 2072 6179 2066 726f 6d20 7468 6520  3D ray from the 
-0000d310: 6361 6d65 7261 206f 7269 6769 6e20 7468  camera origin th
-0000d320: 726f 7567 6820 7468 6520 696d 6167 650a  rough the image.
-0000d330: 2020 2020 2020 2020 706c 616e 6520 706f          plane po
-0000d340: 696e 742e 0a0a 2020 2020 2020 2020 4578  int...        Ex
-0000d350: 616d 706c 653a 0a0a 2020 2020 2020 2020  ample:..        
-0000d360: 2e2e 2072 756e 626c 6f63 6b3a 3a20 7079  .. runblock:: py
-0000d370: 636f 6e0a 0a20 2020 2020 2020 2020 2020  con..           
-0000d380: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
-0000d390: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
-0000d3a0: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
-0000d3b0: 6572 610a 2020 2020 2020 2020 2020 2020  era.            
-0000d3c0: 3e3e 3e20 6361 6d65 7261 203d 2043 656e  >>> camera = Cen
-0000d3d0: 7472 616c 4361 6d65 7261 2e44 6566 6175  tralCamera.Defau
-0000d3e0: 6c74 2829 0a20 2020 2020 2020 2020 2020  lt().           
-0000d3f0: 203e 3e3e 206c 696e 6520 3d20 6361 6d65   >>> line = came
-0000d400: 7261 2e72 6179 2828 3130 302c 2032 3030  ra.ray((100, 200
-0000d410: 2929 0a20 2020 2020 2020 2020 2020 203e  )).            >
-0000d420: 3e3e 206c 696e 650a 0a20 2020 2020 2020  >> line..       
-0000d430: 203a 7265 6665 7265 6e63 653a 0a20 2020   :reference:.   
-0000d440: 2020 2020 2020 2020 202d 2022 4d75 6c74           - "Mult
-0000d450: 6976 6965 7720 4765 6f6d 6574 7279 222c  iview Geometry",
-0000d460: 2048 6172 746c 6579 2026 205a 6973 7365   Hartley & Zisse
-0000d470: 726d 616e 2c20 702e 3136 320a 2020 2020  rman, p.162.    
-0000d480: 2020 2020 2020 2020 2d20 526f 626f 7469          - Roboti
-0000d490: 6373 2c20 5669 7369 6f6e 2026 2043 6f6e  cs, Vision & Con
-0000d4a0: 7472 6f6c 2066 6f72 2050 7974 686f 6e2c  trol for Python,
-0000d4b0: 2053 6563 7469 6f6e 2031 342e 332c 2050   Section 14.3, P
-0000d4c0: 2e20 436f 726b 652c 2053 7072 696e 6765  . Corke, Springe
-0000d4d0: 7220 3230 3233 2e0a 0a20 2020 2020 2020  r 2023...       
-0000d4e0: 203a 7365 6561 6c73 6f3a 203a 636c 6173   :seealso: :clas
-0000d4f0: 733a 607e 7370 6174 6961 6c6d 6174 682e  s:`~spatialmath.
-0000d500: 2e67 656f 6d33 642e 4c69 6e65 3360 0a20  .geom3d.Line3`. 
-0000d510: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000d520: 2020 2023 2064 6566 696e 6520 506c 7563     # define Pluc
-0000d530: 6b65 7220 6c69 6e65 2069 6e20 7465 726d  ker line in term
-0000d540: 7320 6f66 2070 6f69 6e74 2028 6365 6e74  s of point (cent
-0000d550: 7265 206f 6620 6361 6d65 7261 2920 616e  re of camera) an
-0000d560: 6420 6469 7265 6374 696f 6e0a 2020 2020  d direction.    
-0000d570: 2020 2020 4320 3d20 7365 6c66 2e43 2870      C = self.C(p
-0000d580: 6f73 653d 706f 7365 290a 2020 2020 2020  ose=pose).      
-0000d590: 2020 4d69 203d 206e 702e 6c69 6e61 6c67    Mi = np.linalg
-0000d5a0: 2e69 6e76 2843 5b3a 332c 203a 335d 290a  .inv(C[:3, :3]).
-0000d5b0: 2020 2020 2020 2020 7620 3d20 435b 3a2c          v = C[:,
-0000d5c0: 2033 5d0a 2020 2020 2020 2020 6c69 6e65   3].        line
-0000d5d0: 7320 3d20 5b5d 0a20 2020 2020 2020 2066  s = [].        f
-0000d5e0: 6f72 2070 6f69 6e74 2069 6e20 6261 7365  or point in base
-0000d5f0: 2e67 6574 6d61 7472 6978 2870 6f69 6e74  .getmatrix(point
-0000d600: 732c 2028 322c 204e 6f6e 6529 292e 543a  s, (2, None)).T:
-0000d610: 0a20 2020 2020 2020 2020 2020 206c 696e  .            lin
-0000d620: 6573 2e61 7070 656e 6428 4c69 6e65 332e  es.append(Line3.
-0000d630: 506f 696e 7444 6972 282d 4d69 2040 2076  PointDir(-Mi @ v
-0000d640: 2c20 4d69 2040 2073 6d62 6173 652e 6532  , Mi @ smbase.e2
-0000d650: 6828 706f 696e 7429 2929 0a20 2020 2020  h(point))).     
-0000d660: 2020 2072 6574 7572 6e20 4c69 6e65 3328     return Line3(
-0000d670: 6c69 6e65 7329 0a0a 2020 2020 4070 726f  lines)..    @pro
-0000d680: 7065 7274 790a 2020 2020 6465 6620 6365  perty.    def ce
-0000d690: 6e74 7265 2873 656c 6629 3a0a 2020 2020  ntre(self):.    
-0000d6a0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000d6b0: 506f 7369 7469 6f6e 206f 6620 6361 6d65  Position of came
-0000d6c0: 7261 2066 7261 6d65 0a0a 2020 2020 2020  ra frame..      
-0000d6d0: 2020 3a72 6574 7572 6e3a 2045 7563 6c69    :return: Eucli
-0000d6e0: 6465 616e 2063 6f6f 7264 696e 6174 6520  dean coordinate 
-0000d6f0: 6f66 2074 6865 2063 616d 6572 6120 6672  of the camera fr
-0000d700: 616d 6527 7320 6f72 6967 696e 0a20 2020  ame's origin.   
-0000d710: 2020 2020 203a 7274 7970 653a 206e 6461       :rtype: nda
-0000d720: 7272 6179 2833 290a 0a20 2020 2020 2020  rray(3)..       
-0000d730: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
-0000d740: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
-0000d750: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
-0000d760: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
-0000d770: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
-0000d780: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
-0000d790: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
-0000d7a0: 2020 203e 3e3e 2066 726f 6d20 7370 6174     >>> from spat
-0000d7b0: 6961 6c6d 6174 6820 696d 706f 7274 2053  ialmath import S
-0000d7c0: 4533 0a20 2020 2020 2020 2020 2020 203e  E3.            >
-0000d7d0: 3e3e 2063 616d 6572 6131 203d 2043 656e  >> camera1 = Cen
-0000d7e0: 7472 616c 4361 6d65 7261 2e44 6566 6175  tralCamera.Defau
-0000d7f0: 6c74 286e 616d 653d 2763 616d 6572 6131  lt(name='camera1
-0000d800: 272c 2070 6f73 653d 5345 332e 5472 616e  ', pose=SE3.Tran
-0000d810: 7328 312c 322c 3329 290a 2020 2020 2020  s(1,2,3)).      
-0000d820: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
-0000d830: 310a 2020 2020 2020 2020 2020 2020 3e3e  1.            >>
-0000d840: 3e20 6361 6d65 7261 312e 6365 6e74 7265  > camera1.centre
-0000d850: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0000d860: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0000d870: 2e70 6f73 652e 740a 0a20 2020 2040 7072  .pose.t..    @pr
-0000d880: 6f70 6572 7479 0a20 2020 2064 6566 2063  operty.    def c
-0000d890: 656e 7465 7228 7365 6c66 293a 0a20 2020  enter(self):.   
-0000d8a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0000d8b0: 2050 6f73 6974 696f 6e20 6f66 2063 616d   Position of cam
-0000d8c0: 6572 6120 6672 616d 650a 0a20 2020 2020  era frame..     
-0000d8d0: 2020 203a 7265 7475 726e 3a20 4575 636c     :return: Eucl
-0000d8e0: 6964 6561 6e20 636f 6f72 6469 6e61 7465  idean coordinate
-0000d8f0: 206f 6620 7468 6520 6361 6d65 7261 2066   of the camera f
-0000d900: 7261 6d65 2773 206f 7269 6769 6e0a 2020  rame's origin.  
-0000d910: 2020 2020 2020 3a72 7479 7065 3a20 6e64        :rtype: nd
-0000d920: 6172 7261 7928 3329 0a0a 2020 2020 2020  array(3)..      
-0000d930: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
-0000d940: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-0000d950: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
-0000d960: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
-0000d970: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-0000d980: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
-0000d990: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-0000d9a0: 2020 2020 3e3e 3e20 6672 6f6d 2073 7061      >>> from spa
-0000d9b0: 7469 616c 6d61 7468 2069 6d70 6f72 7420  tialmath import 
-0000d9c0: 5345 330a 2020 2020 2020 2020 2020 2020  SE3.            
-0000d9d0: 3e3e 3e20 6361 6d65 7261 3120 3d20 4365  >>> camera1 = Ce
-0000d9e0: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
-0000d9f0: 756c 7428 6e61 6d65 3d27 6361 6d65 7261  ult(name='camera
-0000da00: 3127 2c20 706f 7365 3d53 4533 2e54 7261  1', pose=SE3.Tra
-0000da10: 6e73 2831 2c32 2c33 2929 0a20 2020 2020  ns(1,2,3)).     
-0000da20: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
-0000da30: 6131 0a20 2020 2020 2020 2020 2020 203e  a1.            >
-0000da40: 3e3e 2063 616d 6572 6131 2e63 656e 7465  >> camera1.cente
-0000da50: 720a 2020 2020 2020 2020 2222 220a 2020  r.        """.  
-0000da60: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-0000da70: 662e 706f 7365 2e74 0a0a 2020 2020 6465  f.pose.t..    de
-0000da80: 6620 666f 7628 7365 6c66 293a 0a20 2020  f fov(self):.   
-0000da90: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0000daa0: 2043 616d 6572 6120 6669 656c 642d 6f66   Camera field-of
-0000dab0: 2d76 6965 7720 616e 676c 6573 0a0a 2020  -view angles..  
-0000dac0: 2020 2020 2020 3a72 6574 7572 6e3a 2066        :return: f
-0000dad0: 6965 6c64 206f 6620 7669 6577 2061 6e67  ield of view ang
-0000dae0: 6c65 7320 696e 2072 6164 6961 6e73 0a20  les in radians. 
-0000daf0: 2020 2020 2020 203a 7274 7970 653a 206e         :rtype: n
-0000db00: 6461 7272 6179 2832 290a 2020 2020 2020  darray(2).      
-0000db10: 2020 0a20 2020 2020 2020 2043 6f6d 7075    .        Compu
-0000db20: 7465 7320 7468 6520 6669 656c 6420 6f66  tes the field of
-0000db30: 2076 6965 7720 616e 676c 6573 2028 3278   view angles (2x
-0000db40: 3129 2069 6e20 7261 6469 616e 7320 666f  1) in radians fo
-0000db50: 7220 7468 6520 6361 6d65 7261 0a20 2020  r the camera.   
-0000db60: 2020 2020 2068 6f72 697a 6f6e 7461 6c20       horizontal 
-0000db70: 616e 6420 7665 7274 6963 616c 2064 6972  and vertical dir
-0000db80: 6563 7469 6f6e 732e 0a0a 2020 2020 2020  ections...      
-0000db90: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
-0000dba0: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-0000dbb0: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
-0000dbc0: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
-0000dbd0: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-0000dbe0: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
-0000dbf0: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-0000dc00: 2020 2020 3e3e 3e20 6361 6d65 7261 3120      >>> camera1 
-0000dc10: 3d20 4365 6e74 7261 6c43 616d 6572 612e  = CentralCamera.
-0000dc20: 4465 6661 756c 7428 6e61 6d65 3d27 6361  Default(name='ca
-0000dc30: 6d65 7261 3127 290a 2020 2020 2020 2020  mera1').        
-0000dc40: 2020 2020 3e3e 3e20 6361 6d65 7261 312e      >>> camera1.
-0000dc50: 666f 7628 290a 0a20 2020 2020 2020 203a  fov()..        :
-0000dc60: 7265 6665 7265 6e63 6573 3a0a 2020 2020  references:.    
-0000dc70: 2020 2020 2020 2020 2d20 526f 626f 7469          - Roboti
-0000dc80: 6373 2c20 5669 7369 6f6e 2026 2043 6f6e  cs, Vision & Con
-0000dc90: 7472 6f6c 2066 6f72 2050 7974 686f 6e2c  trol for Python,
-0000dca0: 2053 6563 7469 6f6e 2031 332e 312e 342c   Section 13.1.4,
-0000dcb0: 2050 2e20 436f 726b 652c 200a 2020 2020   P. Corke, .    
-0000dcc0: 2020 2020 2020 2020 2020 5370 7269 6e67            Spring
-0000dcd0: 6572 2032 3032 332e 0a20 2020 2020 2020  er 2023..       
-0000dce0: 2022 2222 0a20 2020 2020 2020 2074 7279   """.        try
-0000dcf0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000dd00: 7475 726e 2032 202a 206e 702e 6172 6374  turn 2 * np.arct
-0000dd10: 616e 286e 702e 725f 5b73 656c 662e 696d  an(np.r_[self.im
-0000dd20: 6167 6573 697a 655d 202f 2032 202a 206e  agesize] / 2 * n
-0000dd30: 702e 725f 5b73 656c 662e 7268 6f5d 202f  p.r_[self.rho] /
-0000dd40: 2073 656c 662e 6629 0a20 2020 2020 2020   self.f).       
-0000dd50: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
-0000dd60: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-0000dd70: 4572 726f 7228 2769 6d61 6765 7369 7a65  Error('imagesize
-0000dd80: 206f 7220 7268 6f20 7072 6f70 6572 7469   or rho properti
-0000dd90: 6573 206e 6f74 2073 6574 2729 0a0a 2020  es not set')..  
-0000dda0: 2020 6465 6620 6469 7374 6f72 7428 7365    def distort(se
-0000ddb0: 6c66 2c20 706f 696e 7473 293a 0a20 2020  lf, points):.   
-0000ddc0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0000ddd0: 2043 6f6d 7075 7465 2064 6973 746f 7274   Compute distort
-0000dde0: 6564 2063 6f6f 7264 696e 6174 650a 0a20  ed coordinate.. 
-0000ddf0: 2020 2020 2020 203a 7061 7261 6d20 706f         :param po
-0000de00: 696e 7473 3a20 696d 6167 6520 706c 616e  ints: image plan
-0000de10: 6520 706f 696e 7473 0a20 2020 2020 2020  e points.       
-0000de20: 203a 7479 7065 2070 6f69 6e74 733a 206e   :type points: n
-0000de30: 6461 7272 6179 2832 2c6e 290a 2020 2020  darray(2,n).    
-0000de40: 2020 2020 3a72 6574 7572 6e73 3a20 6469      :returns: di
-0000de50: 7374 6f72 7465 6420 696d 6167 6520 706c  storted image pl
-0000de60: 616e 6520 636f 6f72 6469 6e61 7465 730a  ane coordinates.
-0000de70: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-0000de80: 6e64 6172 7261 7928 322c 6e29 0a20 2020  ndarray(2,n).   
-0000de90: 2020 2020 200a 2020 2020 2020 2020 436f       .        Co
-0000dea0: 6d70 7574 6520 7468 6520 696d 6167 6520  mpute the image 
-0000deb0: 706c 616e 6520 636f 6f72 6469 6e61 7465  plane coordinate
-0000dec0: 7320 6166 7465 7220 6c65 6e73 2064 6973  s after lens dis
-0000ded0: 746f 7274 696f 6e20 6861 7320 6265 656e  tortion has been
-0000dee0: 0a20 2020 2020 2020 2061 7070 6c69 6564  .        applied
-0000def0: 2e20 2054 6865 206c 656e 7320 6469 7374  .  The lens dist
-0000df00: 6f72 7469 6f6e 206d 6f64 656c 2069 7320  ortion model is 
-0000df10: 696e 6974 6961 6c69 7a65 6420 6174 2063  initialized at c
-0000df20: 6f6e 7374 7275 6374 6f72 2074 696d 652e  onstructor time.
-0000df30: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0000df40: 2020 2020 2069 6620 7365 6c66 2e5f 6469       if self._di
-0000df50: 7374 6f72 7469 6f6e 2069 7320 4e6f 6e65  stortion is None
-0000df60: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000df70: 7475 726e 2070 6f69 6e74 730a 0a20 2020  turn points..   
-0000df80: 2020 2020 2023 2063 6f6e 7665 7274 2074       # convert t
-0000df90: 6f20 6e6f 726d 616c 697a 6564 2069 6d61  o normalized ima
-0000dfa0: 6765 2063 6f6f 7264 696e 6174 6573 0a20  ge coordinates. 
-0000dfb0: 2020 2020 2020 2058 203d 206e 702e 6c69         X = np.li
-0000dfc0: 6e61 6c67 2e69 6e76 2873 656c 662e 4b29  nalg.inv(self.K)
-0000dfd0: 202a 2073 6d62 6173 652e 6532 6828 706f   * smbase.e2h(po
-0000dfe0: 696e 7473 290a 0a20 2020 2020 2020 2023  ints)..        #
-0000dff0: 2075 6e70 6163 6b20 636f 6f72 6469 6e61   unpack coordina
-0000e000: 7465 730a 2020 2020 2020 2020 7520 3d20  tes.        u = 
-0000e010: 585b 302c 203a 5d0a 2020 2020 2020 2020  X[0, :].        
-0000e020: 7620 3d20 585b 312c 203a 5d0a 0a20 2020  v = X[1, :]..   
-0000e030: 2020 2020 2023 2075 6e70 6163 6b20 6469       # unpack di
-0000e040: 7374 6f72 7469 6f6e 2076 6563 746f 720a  stortion vector.
-0000e050: 2020 2020 2020 2020 6b20 3d20 7365 6c66          k = self
-0000e060: 2e5f 6469 7374 6f72 7469 6f6e 5b3a 335d  ._distortion[:3]
-0000e070: 0a20 2020 2020 2020 2070 203d 2073 656c  .        p = sel
-0000e080: 662e 5f64 6973 746f 7274 696f 6e5b 333a  f._distortion[3:
-0000e090: 5d0a 0a20 2020 2020 2020 2072 203d 206e  ]..        r = n
-0000e0a0: 702e 7371 7274 2875 202a 2a20 3220 2b20  p.sqrt(u ** 2 + 
-0000e0b0: 7620 2a2a 2032 2920 2320 6469 7374 616e  v ** 2) # distan
-0000e0c0: 6365 2066 726f 6d20 7072 696e 6369 7061  ce from principa
-0000e0d0: 6c20 706f 696e 740a 2020 2020 2020 2020  l point.        
-0000e0e0: 0a20 2020 2020 2020 2023 2063 6f6d 7075  .        # compu
-0000e0f0: 7465 2074 6865 2073 6869 6674 2064 7565  te the shift due
-0000e100: 2074 6f20 6469 7374 6f72 7469 6f6e 0a20   to distortion. 
-0000e110: 2020 2020 2020 2064 656c 7461 5f75 203d         delta_u =
-0000e120: 2075 202a 2028 6b5b 305d 202a 2072 202a   u * (k[0] * r *
-0000e130: 2a20 3220 2b20 6b5b 315d 202a 2072 202a  * 2 + k[1] * r *
-0000e140: 2a20 3420 2b20 6b5b 325d 202a 2072 202a  * 4 + k[2] * r *
-0000e150: 2a20 3629 202b 205c 0a20 2020 2020 2020  * 6) + \.       
-0000e160: 2020 2020 2032 202a 2070 5b30 5d20 2a20       2 * p[0] * 
-0000e170: 7520 2a20 7620 2b20 705b 315d 202a 2028  u * v + p[1] * (
-0000e180: 7220 2a2a 2032 202b 2032 202a 2075 202a  r ** 2 + 2 * u *
-0000e190: 2a20 3229 0a20 2020 2020 2020 2064 656c  * 2).        del
-0000e1a0: 7461 5f76 203d 2076 2020 2a20 286b 5b30  ta_v = v  * (k[0
-0000e1b0: 5d20 2a20 7220 2a2a 2032 202b 206b 5b31  ] * r ** 2 + k[1
-0000e1c0: 5d20 2a20 7220 2a2a 2034 202b 206b 5b32  ] * r ** 4 + k[2
-0000e1d0: 5d20 2a20 7220 2a2a 2036 2920 2b20 5c0a  ] * r ** 6) + \.
-0000e1e0: 2020 2020 2020 2020 2020 2020 705b 305d              p[0]
-0000e1f0: 202a 2028 7220 2a2a 2032 202b 2032 202a   * (r ** 2 + 2 *
-0000e200: 2076 202a 2a20 3229 202b 2032 2020 2a70   v ** 2) + 2  *p
-0000e210: 5b31 5d20 2a20 7520 2a20 760a 2020 2020  [1] * u * v.    
-0000e220: 2020 2020 0a20 2020 2020 2020 2023 2064      .        # d
-0000e230: 6973 746f 7274 6564 2063 6f6f 7264 696e  istorted coordin
-0000e240: 6174 6573 0a20 2020 2020 2020 2075 6420  ates.        ud 
-0000e250: 3d20 7520 2b20 6465 6c74 615f 750a 2020  = u + delta_u.  
-0000e260: 2020 2020 2020 7664 203d 2076 202b 2064        vd = v + d
-0000e270: 656c 7461 5f76 0a20 2020 2020 2020 200a  elta_v.        .
-0000e280: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0000e290: 656c 662e 4b20 2a20 736d 6261 7365 2e65  elf.K * smbase.e
-0000e2a0: 3268 2820 6e70 2e72 5f5b 7564 2c20 7664  2h( np.r_[ud, vd
-0000e2b0: 5d20 2920 2320 636f 6e76 6572 7420 746f  ] ) # convert to
-0000e2c0: 2070 6978 656c 2063 6f6f 7264 730a 0a20   pixel coords.. 
-0000e2d0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-0000e2e0: 2064 6566 2066 7528 7365 6c66 293a 0a20   def fu(self):. 
-0000e2f0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000e300: 2020 2047 6574 2066 6f63 616c 206c 656e     Get focal len
-0000e310: 6774 6820 696e 2068 6f72 697a 6f6e 7461  gth in horizonta
-0000e320: 6c20 6469 7265 6374 696f 6e0a 0a20 2020  l direction..   
-0000e330: 2020 2020 203a 7265 7475 726e 3a20 666f       :return: fo
-0000e340: 6361 6c20 6c65 6e67 7468 2069 6e20 686f  cal length in ho
-0000e350: 7269 7a6f 6e74 616c 2064 6972 6563 7469  rizontal directi
-0000e360: 6f6e 0a20 2020 2020 2020 203a 7274 7970  on.        :rtyp
-0000e370: 653a 2066 6c6f 6174 0a0a 2020 2020 2020  e: float..      
-0000e380: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
-0000e390: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-0000e3a0: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
-0000e3b0: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
-0000e3c0: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-0000e3d0: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
-0000e3e0: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-0000e3f0: 2020 2020 3e3e 3e20 6361 6d65 7261 203d      >>> camera =
-0000e400: 2043 656e 7472 616c 4361 6d65 7261 2e44   CentralCamera.D
-0000e410: 6566 6175 6c74 286e 616d 653d 2763 616d  efault(name='cam
-0000e420: 6572 6131 2729 0a20 2020 2020 2020 2020  era1').         
-0000e430: 2020 203e 3e3e 2063 616d 6572 612e 6675     >>> camera.fu
-0000e440: 0a0a 2020 2020 2020 2020 3a73 6565 616c  ..        :seeal
-0000e450: 736f 3a20 3a6d 6574 683a 6066 7660 203a  so: :meth:`fv` :
-0000e460: 6d65 7468 3a60 6660 0a20 2020 2020 2020  meth:`f`.       
-0000e470: 2022 2222 0a20 2020 2020 2020 2072 6574   """.        ret
-0000e480: 7572 6e20 7365 6c66 2e5f 6675 0a0a 2020  urn self._fu..  
-0000e490: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-0000e4a0: 6465 6620 6676 2873 656c 6629 3a0a 2020  def fv(self):.  
-0000e4b0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000e4c0: 2020 4765 7420 666f 6361 6c20 6c65 6e67    Get focal leng
-0000e4d0: 7468 2069 6e20 7665 7274 6963 616c 2064  th in vertical d
-0000e4e0: 6972 6563 7469 6f6e 0a0a 2020 2020 2020  irection..      
-0000e4f0: 2020 3a72 6574 7572 6e3a 2066 6f63 616c    :return: focal
-0000e500: 206c 656e 6774 6820 696e 2076 6572 7469   length in verti
-0000e510: 6361 6c20 6469 7265 6374 696f 6e0a 2020  cal direction.  
-0000e520: 2020 2020 2020 3a72 7479 7065 3a20 666c        :rtype: fl
-0000e530: 6f61 740a 0a20 2020 2020 2020 2045 7861  oat..        Exa
-0000e540: 6d70 6c65 3a0a 0a20 2020 2020 2020 202e  mple:..        .
-0000e550: 2e20 7275 6e62 6c6f 636b 3a3a 2070 7963  . runblock:: pyc
-0000e560: 6f6e 0a0a 2020 2020 2020 2020 2020 2020  on..            
-0000e570: 3e3e 3e20 6672 6f6d 206d 6163 6869 6e65  >>> from machine
-0000e580: 7669 7369 6f6e 746f 6f6c 626f 7820 696d  visiontoolbox im
-0000e590: 706f 7274 2043 656e 7472 616c 4361 6d65  port CentralCame
-0000e5a0: 7261 0a20 2020 2020 2020 2020 2020 203e  ra.            >
-0000e5b0: 3e3e 2063 616d 6572 6120 3d20 4365 6e74  >> camera = Cent
-0000e5c0: 7261 6c43 616d 6572 612e 4465 6661 756c  ralCamera.Defaul
-0000e5d0: 7428 6e61 6d65 3d27 6361 6d65 7261 3127  t(name='camera1'
-0000e5e0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
-0000e5f0: 3e20 6361 6d65 7261 2e66 760a 0a20 2020  > camera.fv..   
-0000e600: 2020 2020 203a 7365 6561 6c73 6f3a 203a       :seealso: :
-0000e610: 6d65 7468 3a60 6675 6020 3a6d 6574 683a  meth:`fu` :meth:
-0000e620: 6066 600a 2020 2020 2020 2020 2222 220a  `f`.        """.
-0000e630: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0000e640: 656c 662e 5f66 760a 0a20 2020 2040 7072  elf._fv..    @pr
-0000e650: 6f70 6572 7479 0a20 2020 2064 6566 2066  operty.    def f
-0000e660: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000e670: 2222 220a 2020 2020 2020 2020 5365 742f  """.        Set/
-0000e680: 6765 7420 666f 6361 6c20 6c65 6e67 7468  get focal length
-0000e690: 0a0a 2020 2020 2020 2020 3a72 6574 7572  ..        :retur
-0000e6a0: 6e3a 2066 6f63 616c 206c 656e 6774 6820  n: focal length 
-0000e6b0: 696e 2068 6f72 697a 6f6e 7461 6c20 616e  in horizontal an
-0000e6c0: 6420 7665 7274 6963 616c 2064 6972 6563  d vertical direc
-0000e6d0: 7469 6f6e 730a 2020 2020 2020 2020 3a72  tions.        :r
-0000e6e0: 7479 7065 3a20 6e64 6172 7261 7928 3229  type: ndarray(2)
-0000e6f0: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
-0000e700: 2066 6f63 616c 206c 656e 6774 6820 696e   focal length in
-0000e710: 2068 6f72 697a 6f6e 7461 6c20 616e 6420   horizontal and 
-0000e720: 7665 7274 6963 616c 2064 6972 6563 7469  vertical directi
-0000e730: 6f6e 732e 2020 0a0a 2020 2020 2020 2020  ons.  ..        
-0000e740: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
-0000e750: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
-0000e760: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
-0000e770: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
-0000e780: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
-0000e790: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
-0000e7a0: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
-0000e7b0: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
-0000e7c0: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
-0000e7d0: 6175 6c74 286e 616d 653d 2763 616d 6572  ault(name='camer
-0000e7e0: 6131 2729 0a20 2020 2020 2020 2020 2020  a1').           
-0000e7f0: 203e 3e3e 2063 616d 6572 612e 660a 2020   >>> camera.f.  
-0000e800: 2020 2020 2020 2020 2020 3e3e 3e20 6361            >>> ca
-0000e810: 6d65 7261 2e66 203d 2030 2e30 3135 0a20  mera.f = 0.015. 
-0000e820: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-0000e830: 616d 6572 612e 660a 2020 2020 2020 2020  amera.f.        
-0000e840: 2020 2020 3e3e 3e20 6361 6d65 7261 2e66      >>> camera.f
-0000e850: 203d 205b 302e 3031 352c 2030 2e30 3230   = [0.015, 0.020
-0000e860: 5d0a 2020 2020 2020 2020 2020 2020 3e3e  ].            >>
-0000e870: 3e20 6361 6d65 7261 2e66 0a0a 2020 2020  > camera.f..    
-0000e880: 2020 2020 3a6e 6f74 653a 2054 6865 7365      :note: These
-0000e890: 2061 7265 206e 6f72 6d61 6c6c 7920 6964   are normally id
-0000e8a0: 656e 7469 6361 6c20 6275 7420 7769 6c6c  entical but will
-0000e8b0: 2064 6966 6665 7220 6966 2074 6865 2073   differ if the s
-0000e8c0: 656e 736f 720a 2020 2020 2020 2020 2020  ensor.          
-0000e8d0: 2020 6861 7320 6e6f 6e2d 7371 7561 7265    has non-square
-0000e8e0: 2070 6978 656c 7320 6f72 2074 6865 2066   pixels or the f
-0000e8f0: 7261 6d65 2067 7261 6262 6572 2069 7320  rame grabber is 
-0000e900: 6368 616e 6769 6e67 2074 6865 2061 7370  changing the asp
-0000e910: 6563 7420 0a20 2020 2020 2020 2020 2020  ect .           
-0000e920: 2072 6174 696f 206f 6620 7468 6520 696d   ratio of the im
-0000e930: 6167 652e 0a0a 2020 2020 2020 2020 3a73  age...        :s
-0000e940: 6565 616c 736f 3a20 3a6d 6574 683a 6066  eealso: :meth:`f
-0000e950: 7560 203a 6d65 7468 3a60 6676 600a 2020  u` :meth:`fv`.  
-0000e960: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000e970: 2020 7265 7475 726e 206e 702e 725f 5b73    return np.r_[s
-0000e980: 656c 662e 5f66 752c 2073 656c 662e 5f66  elf._fu, self._f
-0000e990: 765d 0a0a 2020 2020 4066 2e73 6574 7465  v]..    @f.sette
-0000e9a0: 720a 2020 2020 6465 6620 6628 7365 6c66  r.    def f(self
-0000e9b0: 2c20 6629 3a0a 2020 2020 2020 2020 2222  , f):.        ""
-0000e9c0: 225b 7375 6d6d 6172 795d 0a0a 2020 2020  "[summary]..    
-0000e9d0: 2020 2020 3a70 6172 616d 2066 3a20 666f      :param f: fo
-0000e9e0: 6361 6c20 6c65 6e67 7468 0a20 2020 2020  cal length.     
-0000e9f0: 2020 203a 7479 7065 2066 3a20 7363 616c     :type f: scal
-0000ea00: 6172 206f 7220 6172 7261 795f 6c69 6b65  ar or array_like
-0000ea10: 2832 290a 2020 2020 2020 2020 3a72 6169  (2).        :rai
-0000ea20: 7365 7320 5661 6c75 6545 7272 6f72 3a20  ses ValueError: 
-0000ea30: 696e 636f 7272 6563 7420 6c65 6e67 7468  incorrect length
-0000ea40: 206f 6620 6060 6660 600a 2020 2020 2020   of ``f``.      
-0000ea50: 2020 2222 220a 2020 2020 2020 2020 6620    """.        f 
-0000ea60: 3d20 6261 7365 2e67 6574 7665 6374 6f72  = base.getvector
-0000ea70: 2866 290a 0a20 2020 2020 2020 2069 6620  (f)..        if 
-0000ea80: 6c65 6e28 6629 203d 3d20 313a 0a20 2020  len(f) == 1:.   
-0000ea90: 2020 2020 2020 2020 2073 656c 662e 5f66           self._f
-0000eaa0: 7520 3d20 665b 305d 0a20 2020 2020 2020  u = f[0].       
-0000eab0: 2020 2020 2073 656c 662e 5f66 7620 3d20       self._fv = 
-0000eac0: 665b 305d 0a20 2020 2020 2020 2065 6c69  f[0].        eli
-0000ead0: 6620 6c65 6e28 6629 203d 3d20 323a 0a20  f len(f) == 2:. 
-0000eae0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000eaf0: 5f66 7520 3d20 665b 305d 0a20 2020 2020  _fu = f[0].     
-0000eb00: 2020 2020 2020 2073 656c 662e 5f66 7620         self._fv 
-0000eb10: 3d20 665b 315d 0a20 2020 2020 2020 2065  = f[1].        e
-0000eb20: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000eb30: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000eb40: 7228 662c 2027 6620 6d75 7374 2062 6520  r(f, 'f must be 
-0000eb50: 6120 312d 206f 7220 322d 656c 656d 656e  a 1- or 2-elemen
-0000eb60: 7420 7665 6374 6f72 2729 0a0a 2020 2020  t vector')..    
-0000eb70: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-0000eb80: 6620 6670 6978 2873 656c 6629 3a0a 2020  f fpix(self):.  
-0000eb90: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000eba0: 2020 4765 7420 666f 6361 6c20 6c65 6e67    Get focal leng
-0000ebb0: 7468 2069 6e20 7069 7865 6c73 0a0a 2020  th in pixels..  
-0000ebc0: 2020 2020 2020 3a72 6574 7572 6e3a 2066        :return: f
-0000ebd0: 6f63 616c 206c 656e 6774 6820 696e 2068  ocal length in h
-0000ebe0: 6f72 697a 6f6e 7461 6c20 616e 6420 7665  orizontal and ve
-0000ebf0: 7274 6963 616c 2064 6972 6563 7469 6f6e  rtical direction
-0000ec00: 7320 696e 2070 6978 656c 730a 2020 2020  s in pixels.    
-0000ec10: 2020 2020 3a72 7479 7065 3a20 6e64 6172      :rtype: ndar
-0000ec20: 7261 7928 3229 0a0a 2020 2020 2020 2020  ray(2)..        
-0000ec30: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
-0000ec40: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
-0000ec50: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
-0000ec60: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
-0000ec70: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
-0000ec80: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
-0000ec90: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
-0000eca0: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
-0000ecb0: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
-0000ecc0: 6175 6c74 286e 616d 653d 2763 616d 6572  ault(name='camer
-0000ecd0: 6131 2729 0a20 2020 2020 2020 2020 2020  a1').           
-0000ece0: 203e 3e3e 2063 616d 6572 612e 6670 6978   >>> camera.fpix
-0000ecf0: 0a0a 2020 2020 2020 2020 3a73 6565 616c  ..        :seeal
-0000ed00: 736f 3a20 3a6d 6574 683a 6066 600a 2020  so: :meth:`f`.  
-0000ed10: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000ed20: 2020 7265 7475 726e 206e 702e 725f 5b73    return np.r_[s
-0000ed30: 656c 662e 5f66 7520 2f20 7365 6c66 2e5f  elf._fu / self._
-0000ed40: 7268 6f75 2c20 7365 6c66 2e5f 6676 202f  rhou, self._fv /
-0000ed50: 2073 656c 662e 5f72 686f 765d 0a0a 2020   self._rhov]..  
-0000ed60: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-0000ed70: 6465 6620 4b28 7365 6c66 293a 0a20 2020  def K(self):.   
-0000ed80: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0000ed90: 2049 6e74 7269 6e73 6963 206d 6174 7269   Intrinsic matri
-0000eda0: 7820 6f66 2063 616d 6572 610a 0a20 2020  x of camera..   
-0000edb0: 2020 2020 203a 7265 7475 726e 3a20 696e       :return: in
-0000edc0: 7472 696e 7369 6320 6d61 7472 6978 0a20  trinsic matrix. 
-0000edd0: 2020 2020 2020 203a 7274 7970 653a 206e         :rtype: n
-0000ede0: 6461 7272 6179 2833 2c33 290a 0a20 2020  darray(3,3)..   
-0000edf0: 2020 2020 2052 6574 7572 6e20 7468 6520       Return the 
-0000ee00: 6361 6d65 7261 2069 6e74 7269 6e73 6963  camera intrinsic
-0000ee10: 206d 6174 7269 782e 0a0a 2020 2020 2020   matrix...      
-0000ee20: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
-0000ee30: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-0000ee40: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
-0000ee50: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
-0000ee60: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-0000ee70: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
-0000ee80: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-0000ee90: 2020 2020 3e3e 3e20 6361 6d65 7261 203d      >>> camera =
-0000eea0: 2043 656e 7472 616c 4361 6d65 7261 2e44   CentralCamera.D
-0000eeb0: 6566 6175 6c74 286e 616d 653d 2763 616d  efault(name='cam
-0000eec0: 6572 6131 2729 0a20 2020 2020 2020 2020  era1').         
-0000eed0: 2020 203e 3e3e 2063 616d 6572 612e 4b0a     >>> camera.K.
-0000eee0: 0a20 2020 2020 2020 203a 7265 6665 7265  .        :refere
-0000eef0: 6e63 6573 3a20 0a20 2020 2020 2020 2020  nces: .         
-0000ef00: 2020 202d 2052 6f62 6f74 6963 732c 2056     - Robotics, V
-0000ef10: 6973 696f 6e20 2620 436f 6e74 726f 6c20  ision & Control 
-0000ef20: 666f 7220 5079 7468 6f6e 2c20 5365 6374  for Python, Sect
-0000ef30: 696f 6e20 3133 2e31 2c20 502e 2043 6f72  ion 13.1, P. Cor
-0000ef40: 6b65 2c20 5370 7269 6e67 6572 2032 3032  ke, Springer 202
-0000ef50: 332e 0a0a 2020 2020 2020 2020 3a73 6565  3...        :see
-0000ef60: 616c 736f 3a20 3a6d 6574 683a 6043 6020  also: :meth:`C` 
-0000ef70: 3a6d 6574 683a 6070 7060 203a 6d65 7468  :meth:`pp` :meth
-0000ef80: 3a60 7268 6f60 0a20 2020 2020 2020 2022  :`rho`.        "
-0000ef90: 2222 0a20 2020 2020 2020 2023 2066 6d74  "".        # fmt
-0000efa0: 3a20 6f66 660a 2020 2020 2020 2020 4b20  : off.        K 
-0000efb0: 3d20 6e70 2e61 7272 6179 285b 5b73 656c  = np.array([[sel
-0000efc0: 662e 6675 202f 2073 656c 662e 7268 6f75  f.fu / self.rhou
-0000efd0: 2c20 302c 2020 2020 2020 2020 2020 2020  , 0,            
-0000efe0: 2020 2020 2020 2073 656c 662e 7530 5d2c         self.u0],
-0000eff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f000: 2020 2020 2020 205b 2030 2c20 2020 2020         [ 0,     
-0000f010: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000f020: 662e 6676 202f 2073 656c 662e 7268 6f76  f.fv / self.rhov
-0000f030: 2c20 7365 6c66 2e76 305d 2c0a 2020 2020  , self.v0],.    
-0000f040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f050: 2020 5b20 302c 2020 2020 2020 2020 2020    [ 0,          
-0000f060: 2020 2020 2020 2020 302c 2020 2020 2020          0,      
-0000f070: 2020 2020 2020 2020 2020 2020 2020 315d                1]
-0000f080: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f090: 2020 2020 2020 205d 2c20 6474 7970 653d         ], dtype=
-0000f0a0: 6e70 2e66 6c6f 6174 3634 290a 2020 2020  np.float64).    
-0000f0b0: 2020 2020 2320 666d 743a 206f 6e0a 2020      # fmt: on.  
-0000f0c0: 2020 2020 2020 7265 7475 726e 204b 0a0a        return K..
-0000f0d0: 2020 2020 2320 3d3d 3d3d 3d3d 3d3d 3d3d      # ==========
-0000f0e0: 3d3d 3d3d 3d3d 3d3d 3d20 6361 6d65 7261  ========= camera
-0000f0f0: 2063 616c 6962 7261 7469 6f6e 203d 3d3d   calibration ===
-0000f100: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f110: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2023 0a20  ============ #. 
-0000f120: 2020 2064 6566 2043 2873 656c 662c 2070     def C(self, p
-0000f130: 6f73 653d 4e6f 6e65 2c20 7265 7469 6e61  ose=None, retina
-0000f140: 6c3d 4661 6c73 6529 3a0a 2020 2020 2020  l=False):.      
-0000f150: 2020 2222 220a 2020 2020 2020 2020 4361    """.        Ca
-0000f160: 6d65 7261 2070 726f 6a65 6374 696f 6e20  mera projection 
-0000f170: 6d61 7472 6978 0a0a 2020 2020 2020 2020  matrix..        
-0000f180: 3a70 6172 616d 2054 3a20 6361 6d65 7261  :param T: camera
-0000f190: 2070 6f73 6520 7769 7468 2072 6573 7065   pose with respe
-0000f1a0: 6374 2074 6f20 776f 726c 6420 6672 616d  ct to world fram
-0000f1b0: 652c 2064 6566 6175 6c74 7320 746f 2070  e, defaults to p
-0000f1c0: 6f73 6520 6672 6f6d 2063 616d 6572 6120  ose from camera 
-0000f1d0: 6f62 6a65 6374 0a20 2020 2020 2020 203a  object.        :
-0000f1e0: 7479 7065 2054 3a20 3a63 6c61 7373 3a60  type T: :class:`
-0000f1f0: 7e73 7061 7469 616c 6d61 7468 2e2e 706f  ~spatialmath..po
-0000f200: 7365 3364 2e53 4533 602c 206f 7074 696f  se3d.SE3`, optio
-0000f210: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
-0000f220: 616d 2072 6574 696e 616c 3a20 7472 616e  am retinal: tran
-0000f230: 7366 6f72 6d20 746f 2072 6574 696e 616c  sform to retinal
-0000f240: 2063 6f6f 7264 696e 6174 6573 2c20 6465   coordinates, de
-0000f250: 6661 756c 7420 4661 6c73 650a 2020 2020  fault False.    
-0000f260: 2020 2020 3a74 7970 6520 7265 7469 6e61      :type retina
-0000f270: 6c3a 2062 6f6f 6c2c 206f 7074 696f 6e61  l: bool, optiona
-0000f280: 6c0a 2020 2020 2020 2020 3a72 6574 7572  l.        :retur
-0000f290: 6e3a 2063 616d 6572 6120 7072 6f6a 6563  n: camera projec
-0000f2a0: 7469 6f6e 2f63 616c 6962 7261 7469 6f6e  tion/calibration
-0000f2b0: 206d 6174 7269 780a 2020 2020 2020 2020   matrix.        
-0000f2c0: 3a72 7479 7065 3a20 6e64 6172 7261 7928  :rtype: ndarray(
-0000f2d0: 332c 3429 0a0a 2020 2020 2020 2020 5265  3,4)..        Re
-0000f2e0: 7475 726e 2074 6865 2063 616d 6572 6120  turn the camera 
-0000f2f0: 6d61 7472 6978 2077 6869 6368 2070 726f  matrix which pro
-0000f300: 6a65 6374 7320 3344 2070 6f69 6e74 7320  jects 3D points 
-0000f310: 746f 2074 6865 2069 6d61 6765 2070 6c61  to the image pla
-0000f320: 6e65 2e0a 2020 2020 2020 2020 4974 2069  ne..        It i
-0000f330: 7320 6120 6675 6e63 7469 6f6e 206f 6620  s a function of 
-0000f340: 7468 6520 6361 6d65 7261 2773 2069 6e74  the camera's int
-0000f350: 7269 6e73 6963 2061 6e64 2065 7874 7269  rinsic and extri
-0000f360: 6e73 6963 2070 6172 616d 6574 6572 732e  nsic parameters.
-0000f370: 0a0a 2020 2020 2020 2020 4966 2060 6072  ..        If ``r
-0000f380: 6574 696e 616c 6060 2069 7320 5472 7565  etinal`` is True
-0000f390: 2074 6865 6e20 7072 6f6a 6563 7420 706f   then project po
-0000f3a0: 696e 7473 2069 6e20 7265 7469 6e61 6c20  ints in retinal 
-0000f3b0: 636f 6f72 6469 6e61 7465 732c 200a 2020  coordinates, .  
-0000f3c0: 2020 2020 2020 696e 2075 6e69 7473 206f        in units o
-0000f3d0: 6620 6d65 7472 6573 2077 6974 6820 7265  f metres with re
-0000f3e0: 7370 6563 7420 746f 2074 6865 2070 7269  spect to the pri
-0000f3f0: 6e63 6970 616c 2070 6f69 6e74 2e0a 0a20  ncipal point... 
-0000f400: 2020 2020 2020 2045 7861 6d70 6c65 3a0a         Example:.
-0000f410: 0a20 2020 2020 2020 202e 2e20 7275 6e62  .        .. runb
-0000f420: 6c6f 636b 3a3a 2070 7963 6f6e 0a0a 2020  lock:: pycon..  
-0000f430: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
-0000f440: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
-0000f450: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
-0000f460: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
-0000f470: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-0000f480: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
-0000f490: 6572 612e 4465 6661 756c 7428 6e61 6d65  era.Default(name
-0000f4a0: 3d27 6361 6d65 7261 3127 290a 2020 2020  ='camera1').    
-0000f4b0: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-0000f4c0: 7261 2e43 2829 0a20 2020 2020 2020 2020  ra.C().         
-0000f4d0: 2020 203e 3e3e 2063 616d 6572 612e 4328     >>> camera.C(
-0000f4e0: 5345 332e 5472 616e 7328 302e 312c 2030  SE3.Trans(0.1, 0
-0000f4f0: 2c20 3029 290a 2020 2020 2020 2020 2020  , 0)).          
-0000f500: 2020 3e3e 3e20 6361 6d65 7261 2e6d 6f76    >>> camera.mov
-0000f510: 6528 5345 3328 302e 312c 2030 2c20 3029  e(SE3(0.1, 0, 0)
-0000f520: 292e 4328 290a 0a20 2020 2020 2020 203a  ).C()..        :
-0000f530: 7265 6665 7265 6e63 6573 3a20 0a20 2020  references: .   
-0000f540: 2020 2020 2020 2020 202d 2052 6f62 6f74           - Robot
-0000f550: 6963 732c 2056 6973 696f 6e20 2620 436f  ics, Vision & Co
-0000f560: 6e74 726f 6c20 666f 7220 5079 7468 6f6e  ntrol for Python
-0000f570: 2c20 5365 6374 696f 6e20 3133 2e31 2c20  , Section 13.1, 
-0000f580: 502e 2043 6f72 6b65 2c20 5370 7269 6e67  P. Corke, Spring
-0000f590: 6572 2032 3032 332e 0a0a 2020 2020 2020  er 2023...      
-0000f5a0: 2020 3a73 6565 616c 736f 3a20 3a6d 6574    :seealso: :met
-0000f5b0: 683a 6070 726f 6a65 6374 5f70 6f69 6e74  h:`project_point
-0000f5c0: 6020 3a6d 6574 683a 604b 6020 3a6d 6574  ` :meth:`K` :met
-0000f5d0: 683a 6064 6563 6f6d 706f 7365 4360 0a20  h:`decomposeC`. 
-0000f5e0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000f5f0: 2020 2050 3020 3d20 6e70 2e65 7965 2833     P0 = np.eye(3
-0000f600: 2c20 3429 0a20 2020 2020 2020 2069 6620  , 4).        if 
-0000f610: 706f 7365 2069 7320 4e6f 6e65 3a0a 2020  pose is None:.  
-0000f620: 2020 2020 2020 2020 2020 706f 7365 203d            pose =
-0000f630: 2073 656c 662e 706f 7365 0a20 2020 2020   self.pose.     
-0000f640: 2020 2069 6620 7265 7469 6e61 6c3a 0a20     if retinal:. 
-0000f650: 2020 2020 2020 2020 2020 204b 203d 206e             K = n
-0000f660: 702e 6469 6167 285b 7365 6c66 2e66 752c  p.diag([self.fu,
-0000f670: 2073 656c 662e 6676 2c20 315d 290a 2020   self.fv, 1]).  
-0000f680: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000f690: 2020 2020 2020 2020 4b20 3d20 7365 6c66          K = self
-0000f6a0: 2e4b 0a20 2020 2020 2020 2072 6574 7572  .K.        retur
-0000f6b0: 6e20 4b20 4020 5030 2040 2070 6f73 652e  n K @ P0 @ pose.
-0000f6c0: 696e 7628 292e 410a 0a20 2020 2040 7374  inv().A..    @st
-0000f6d0: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
-0000f6e0: 6566 2070 6f69 6e74 7332 4328 502c 2070  ef points2C(P, p
-0000f6f0: 293a 0a20 2020 2020 2020 2072 2222 220a  ):.        r""".
-0000f700: 2020 2020 2020 2020 4573 7469 6d61 7465          Estimate
-0000f710: 2063 616d 6572 6120 6d61 7472 6978 2066   camera matrix f
-0000f720: 726f 6d20 6461 7461 2070 6f69 6e74 730a  rom data points.
-0000f730: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-0000f740: 503a 2063 616c 6962 7261 7469 6f6e 2070  P: calibration p
-0000f750: 6f69 6e74 7320 696e 2077 6f72 6c64 2063  oints in world c
-0000f760: 6f6f 7264 696e 6174 6520 6672 616d 650a  oordinate frame.
-0000f770: 2020 2020 2020 2020 3a74 7970 6520 503a          :type P:
-0000f780: 206e 6461 7272 6179 2833 2c4e 290a 2020   ndarray(3,N).  
-0000f790: 2020 2020 2020 3a70 6172 616d 2070 3a20        :param p: 
-0000f7a0: 6361 6c69 6272 6174 696f 6e20 706f 696e  calibration poin
-0000f7b0: 7473 2069 6e20 696d 6167 6520 706c 616e  ts in image plan
-0000f7c0: 650a 2020 2020 2020 2020 3a74 7970 6520  e.        :type 
-0000f7d0: 703a 206e 6461 7272 6179 2832 2c4e 290a  p: ndarray(2,N).
-0000f7e0: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
-0000f7f0: 2063 616d 6572 6120 6361 6c69 6272 6174   camera calibrat
-0000f800: 696f 6e20 6d61 7472 6978 2061 6e64 2072  ion matrix and r
-0000f810: 6573 6964 7561 6c0a 2020 2020 2020 2020  esidual.        
-0000f820: 3a72 7479 7065 3a20 6e64 6172 7261 7928  :rtype: ndarray(
-0000f830: 332c 3429 2c20 666c 6f61 740a 0a20 2020  3,4), float..   
-0000f840: 2020 2020 2045 7374 696d 6174 6520 7468       Estimate th
-0000f850: 6520 6361 6d65 7261 206d 6174 7269 7820  e camera matrix 
-0000f860: 3a6d 6174 683a 605c 6d61 747b 437d 6020  :math:`\mat{C}` 
-0000f870: 6465 7465 726d 696e 6564 2062 7920 6c65  determined by le
-0000f880: 6173 740a 2020 2020 2020 2020 7371 7561  ast.        squa
-0000f890: 7265 7320 6672 6f6d 2063 6f72 7265 7370  res from corresp
-0000f8a0: 6f6e 6469 6e67 2077 6f72 6c64 2060 6050  onding world ``P
-0000f8b0: 6060 2061 6e64 2069 6d61 6765 2d70 6c61  `` and image-pla
-0000f8c0: 6e65 2060 6070 6060 2070 6f69 6e74 732e  ne ``p`` points.
-0000f8d0: 0a20 2020 2020 2020 2043 6f72 7265 7370  .        Corresp
-0000f8e0: 6f6e 6469 6e67 2070 6f69 6e74 7320 6172  onding points ar
-0000f8f0: 6520 7265 7072 6573 656e 7465 6420 6279  e represented by
-0000f900: 2063 6f72 7265 7370 6f6e 6469 6e67 2063   corresponding c
-0000f910: 6f6c 756d 6e73 206f 6620 6060 5060 600a  olumns of ``P``.
-0000f920: 2020 2020 2020 2020 616e 6420 6060 7060          and ``p`
-0000f930: 602e 2020 416c 736f 2072 6574 7572 6e73  `.  Also returns
-0000f940: 2074 6865 2072 6573 6964 7561 6c20 7768   the residual wh
-0000f950: 6963 6820 6973 3a0a 0a20 2020 2020 2020  ich is:..       
-0000f960: 202e 2e20 6d61 7468 3a3a 0a0a 2020 2020   .. math::..    
-0000f970: 2020 2020 2020 2020 5c6d 6178 207c 205c          \max | \
-0000f980: 6d61 747b 437d 5c6d 6174 7b50 7d20 2d20  mat{C}\mat{P} - 
-0000f990: 5c6d 6174 7b70 7d20 7c0a 0a20 2020 2020  \mat{p} |..     
-0000f9a0: 2020 2045 7861 6d70 6c65 3a0a 0a20 2020     Example:..   
-0000f9b0: 2020 2020 202e 2e20 7275 6e62 6c6f 636b       .. runblock
-0000f9c0: 3a3a 2070 7963 6f6e 0a0a 2020 2020 2020  :: pycon..      
-0000f9d0: 2020 2020 2020 3e3e 3e20 6672 6f6d 206d        >>> from m
-0000f9e0: 6163 6869 6e65 7669 7369 6f6e 746f 6f6c  achinevisiontool
-0000f9f0: 626f 7820 696d 706f 7274 2043 656e 7472  box import Centr
-0000fa00: 616c 4361 6d65 7261 2c20 6d6b 6375 6265  alCamera, mkcube
-0000fa10: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-0000fa20: 2050 203d 206d 6b63 7562 6528 302e 3229   P = mkcube(0.2)
-0000fa30: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-0000fa40: 2063 616d 6572 615f 756e 6b6e 6f77 6e20   camera_unknown 
-0000fa50: 3d20 4365 6e74 7261 6c43 616d 6572 6128  = CentralCamera(
-0000fa60: 663d 302e 3031 352c 2072 686f 3d31 3065  f=0.015, rho=10e
-0000fa70: 2d36 2c20 696d 6167 6573 697a 653d 5b31  -6, imagesize=[1
-0000fa80: 3238 302c 2031 3032 345d 2c20 6e6f 6973  280, 1024], nois
-0000fa90: 653d 302e 3035 2c20 7365 6564 3d30 290a  e=0.05, seed=0).
-0000faa0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-0000fab0: 545f 756e 6b6e 6f77 6e20 3d20 5345 332e  T_unknown = SE3.
-0000fac0: 5472 616e 7328 302e 312c 2030 2e32 2c20  Trans(0.1, 0.2, 
-0000fad0: 312e 3529 202a 2053 4533 2e52 5059 2830  1.5) * SE3.RPY(0
-0000fae0: 2e31 2c20 302e 322c 2030 2e33 290a 2020  .1, 0.2, 0.3).  
-0000faf0: 2020 2020 2020 2020 2020 3e3e 3e20 7020            >>> p 
-0000fb00: 3d20 6361 6d65 7261 5f75 6e6b 6e6f 776e  = camera_unknown
-0000fb10: 2e70 726f 6a65 6374 5f70 6f69 6e74 2850  .project_point(P
-0000fb20: 2c20 6f62 6a70 6f73 653d 545f 756e 6b6e  , objpose=T_unkn
-0000fb30: 6f77 6e29 0a20 2020 2020 2020 2020 2020  own).           
-0000fb40: 203e 3e3e 2043 2c20 7265 7369 6420 3d20   >>> C, resid = 
-0000fb50: 4365 6e74 7261 6c43 616d 6572 612e 706f  CentralCamera.po
-0000fb60: 696e 7473 3243 2850 2c20 7029 0a20 2020  ints2C(P, p).   
-0000fb70: 2020 2020 2020 2020 203e 3e3e 2043 0a20           >>> C. 
-0000fb80: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-0000fb90: 616d 6572 615f 756e 6b6e 6f77 6e2e 4328  amera_unknown.C(
-0000fba0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
-0000fbb0: 3e20 7265 7369 640a 0a20 2020 2020 2020  > resid..       
-0000fbc0: 203a 6e6f 7465 3a20 5468 6973 206d 6574   :note: This met
-0000fbd0: 686f 6420 6173 7375 6d65 7320 6e6f 206c  hod assumes no l
-0000fbe0: 656e 7320 6469 7374 6f72 7469 6f6e 2061  ens distortion a
-0000fbf0: 6666 6563 7469 6e67 2074 6865 2069 6d61  ffecting the ima
-0000fc00: 6765 2070 6c61 6e65 0a20 2020 2020 2020  ge plane.       
-0000fc10: 2020 2020 2063 6f6f 7264 696e 6174 6573       coordinates
-0000fc20: 2e0a 0a20 2020 2020 2020 203a 7265 6665  ...        :refe
-0000fc30: 7265 6e63 6573 3a0a 2020 2020 2020 2020  rences:.        
-0000fc40: 2020 2020 2d20 526f 626f 7469 6373 2c20      - Robotics, 
-0000fc50: 5669 7369 6f6e 2026 2043 6f6e 7472 6f6c  Vision & Control
-0000fc60: 2066 6f72 2050 7974 686f 6e2c 2053 6563   for Python, Sec
-0000fc70: 7469 6f6e 2031 332e 322e 312c 2050 2e20  tion 13.2.1, P. 
-0000fc80: 436f 726b 652c 200a 2020 2020 2020 2020  Corke, .        
-0000fc90: 2020 2020 2020 5370 7269 6e67 6572 2032        Springer 2
-0000fca0: 3032 332e 0a0a 2020 2020 2020 2020 3a73  023...        :s
-0000fcb0: 6565 616c 736f 3a20 3a6d 6574 683a 6043  eealso: :meth:`C
-0000fcc0: 6020 3a6d 6574 683a 6069 6d61 6765 7332  ` :meth:`images2
-0000fcd0: 4360 203a 6d65 7468 3a60 6465 636f 6d70  C` :meth:`decomp
-0000fce0: 6f73 6543 600a 2020 2020 2020 2020 2222  oseC`.        ""
-0000fcf0: 220a 2020 2020 2020 2020 7a34 203d 206e  ".        z4 = n
-0000fd00: 702e 7a65 726f 7328 2834 2c29 290a 0a20  p.zeros((4,)).. 
-0000fd10: 2020 2020 2020 2041 203d 206e 702e 656d         A = np.em
-0000fd20: 7074 7928 7368 6170 653d 2830 2c31 3129  pty(shape=(0,11)
-0000fd30: 290a 2020 2020 2020 2020 6220 3d20 6e70  ).        b = np
-0000fd40: 2e65 6d70 7479 2873 6861 7065 3d28 302c  .empty(shape=(0,
-0000fd50: 2929 0a20 2020 2020 2020 2066 6f72 2075  )).        for u
-0000fd60: 762c 2058 2069 6e20 7a69 7028 702e 542c  v, X in zip(p.T,
-0000fd70: 2050 2e54 293a 0a20 2020 2020 2020 2020   P.T):.         
-0000fd80: 2020 2075 2c20 7620 3d20 7576 0a20 2020     u, v = uv.   
-0000fd90: 2020 2020 2020 2020 2023 2066 6d74 3a20           # fmt: 
-0000fda0: 6f66 660a 2020 2020 2020 2020 2020 2020  off.            
-0000fdb0: 726f 7720 3d20 6e70 2e61 7272 6179 285b  row = np.array([
-0000fdc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fdd0: 2020 2020 206e 702e 725f 5b20 582c 2031       np.r_[ X, 1
-0000fde0: 2c20 7a34 2c20 2d75 202a 2058 5d2c 0a20  , z4, -u * X],. 
-0000fdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fe00: 2020 206e 702e 725f 5b7a 342c 2058 2c20     np.r_[z4, X, 
-0000fe10: 2031 2c20 2d76 202a 2058 5d0a 2020 2020   1, -v * X].    
-0000fe20: 2020 2020 2020 2020 2020 2020 5d29 0a20              ]). 
-0000fe30: 2020 2020 2020 2020 2020 2023 2066 6d74             # fmt
-0000fe40: 3a20 6f6e 0a20 2020 2020 2020 2020 2020  : on.           
-0000fe50: 2041 203d 206e 702e 7673 7461 636b 2828   A = np.vstack((
-0000fe60: 412c 2072 6f77 2929 0a20 2020 2020 2020  A, row)).       
-0000fe70: 2020 2020 2062 203d 206e 702e 725f 5b62       b = np.r_[b
-0000fe80: 2c20 7576 5d0a 0a20 2020 2020 2020 2023  , uv]..        #
-0000fe90: 2073 6f6c 7665 2041 7820 3d20 6220 7768   solve Ax = b wh
-0000fea0: 6572 6520 6320 6973 2031 3120 656c 656d  ere c is 11 elem
-0000feb0: 656e 7473 206f 6620 6361 6d65 7261 206d  ents of camera m
-0000fec0: 6174 7269 780a 2020 2020 2020 2020 632c  atrix.        c,
-0000fed0: 202a 5f20 3d20 7363 6970 792e 6c69 6e61   *_ = scipy.lina
-0000fee0: 6c67 2e6c 7374 7371 2841 2c20 6229 0a0a  lg.lstsq(A, b)..
-0000fef0: 2020 2020 2020 2020 2320 636f 6d70 7574          # comput
-0000ff00: 6520 616e 6420 7072 696e 7420 7468 6520  e and print the 
-0000ff10: 7265 7369 6475 616c 0a20 2020 2020 2020  residual.       
-0000ff20: 2072 203d 206e 702e 6d61 7828 6e70 2e61   r = np.max(np.a
-0000ff30: 6273 2828 4120 4020 6320 2d20 6229 2929  bs((A @ c - b)))
-0000ff40: 0a0a 2020 2020 2020 2020 6320 3d20 6e70  ..        c = np
-0000ff50: 2e72 5f5b 632c 2031 5d20 2020 2320 6170  .r_[c, 1]   # ap
-0000ff60: 7065 6e64 2061 2031 0a20 2020 2020 2020  pend a 1.       
-0000ff70: 2043 203d 2063 2e72 6573 6861 7065 2828   C = c.reshape((
-0000ff80: 332c 3429 2920 2023 206d 616b 6520 6120  3,4))  # make a 
-0000ff90: 3378 3420 6d61 7472 6978 0a0a 2020 2020  3x4 matrix..    
-0000ffa0: 2020 2020 7265 7475 726e 2043 2c20 720a      return C, r.
-0000ffb0: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-0000ffc0: 640a 2020 2020 6465 6620 696d 6167 6573  d.    def images
-0000ffd0: 3243 2873 656c 662c 2069 6d61 6765 732c  2C(self, images,
-0000ffe0: 2067 7269 6473 6861 7065 3d28 372c 3629   gridshape=(7,6)
-0000fff0: 2c20 7371 7561 7265 7369 7a65 3d30 2e30  , squaresize=0.0
-00010000: 3235 293a 0a20 2020 2020 2020 2022 2222  25):.        """
-00010010: 0a20 2020 2020 2020 2043 616c 6962 7261  .        Calibra
-00010020: 7465 2063 616d 6572 6120 6672 6f6d 2063  te camera from c
-00010030: 6865 636b 6572 626f 6172 6420 696d 6167  heckerboard imag
-00010040: 6573 0a0a 2020 2020 2020 2020 3a70 6172  es..        :par
-00010050: 616d 2069 6d61 6765 733a 2061 6e20 6974  am images: an it
-00010060: 6572 6174 6f72 2074 6861 7420 7265 7475  erator that retu
-00010070: 726e 7320 3a63 6c61 7373 3a60 7e6d 6163  rns :class:`~mac
-00010080: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
-00010090: 782e 496d 6167 6543 6f72 652e 496d 6167  x.ImageCore.Imag
-000100a0: 6560 206f 626a 6563 7473 0a20 2020 2020  e` objects.     
-000100b0: 2020 203a 7479 7065 2069 6d61 6765 733a     :type images:
-000100c0: 203a 636c 6173 733a 607e 6d61 6368 696e   :class:`~machin
-000100d0: 6576 6973 696f 6e74 6f6f 6c62 6f78 2e53  evisiontoolbox.S
-000100e0: 6f75 7263 6573 2e49 6d61 6765 536f 7572  ources.ImageSour
-000100f0: 6365 600a 2020 2020 2020 2020 3a70 6172  ce`.        :par
-00010100: 616d 2067 7269 6473 6861 7065 3a20 6e75  am gridshape: nu
-00010110: 6d62 6572 206f 6620 6772 6964 2073 7175  mber of grid squ
-00010120: 6172 6573 2069 6e20 6561 6368 2064 696d  ares in each dim
-00010130: 656e 7369 6f6e 2c20 6465 6661 756c 7473  ension, defaults
-00010140: 2074 6f20 2837 2c36 290a 2020 2020 2020   to (7,6).      
-00010150: 2020 3a74 7970 6520 6772 6964 7368 6170    :type gridshap
-00010160: 653a 2074 7570 6c65 2c20 6f70 7469 6f6e  e: tuple, option
-00010170: 616c 0a20 2020 2020 2020 203a 7061 7261  al.        :para
-00010180: 6d20 7371 7561 7265 7369 7a65 3a20 7369  m squaresize: si
-00010190: 7a65 206f 6620 7468 6520 6772 6964 2073  ze of the grid s
-000101a0: 7175 6172 6573 2069 6e20 756e 6974 7320  quares in units 
-000101b0: 6f66 206c 656e 6774 682c 2064 6566 6175  of length, defau
-000101c0: 6c74 7320 746f 2030 2e30 3235 0a20 2020  lts to 0.025.   
-000101d0: 2020 2020 203a 7479 7065 2073 7175 6172       :type squar
-000101e0: 6573 697a 653a 2066 6c6f 6174 2c20 6f70  esize: float, op
-000101f0: 7469 6f6e 616c 0a20 2020 2020 2020 203a  tional.        :
-00010200: 7265 7475 726e 3a20 6361 6d65 7261 2063  return: camera c
-00010210: 616c 6962 7261 7469 6f6e 206d 6174 7269  alibration matri
-00010220: 782c 2064 6973 746f 7274 696f 6e20 7061  x, distortion pa
-00010230: 7261 6d65 7465 7273 2c20 696d 6167 6520  rameters, image 
-00010240: 6672 616d 6573 0a20 2020 2020 2020 203a  frames.        :
-00010250: 7274 7970 653a 206e 6461 7272 6179 2833  rtype: ndarray(3
-00010260: 2c34 292c 206e 6461 7272 6179 2835 292c  ,4), ndarray(5),
-00010270: 206c 6973 7420 6f66 206e 616d 6564 2074   list of named t
-00010280: 7570 6c65 730a 0a20 2020 2020 2020 2054  uples..        T
-00010290: 6865 2064 6973 746f 7274 696f 6e20 636f  he distortion co
-000102a0: 6566 6669 6369 656e 7473 2061 7265 2069  efficients are i
-000102b0: 6e20 7468 6520 6f72 6465 7220 3a6d 6174  n the order :mat
-000102c0: 683a 6028 6b5f 312c 206b 5f32 2c20 705f  h:`(k_1, k_2, p_
-000102d0: 312c 2070 5f32 2c20 6b5f 3329 600a 2020  1, p_2, k_3)`.  
-000102e0: 2020 2020 2020 7768 6572 6520 3a6d 6174        where :mat
-000102f0: 683a 606b 5f69 6020 6172 6520 7261 6469  h:`k_i` are radi
-00010300: 616c 2064 6973 746f 7274 696f 6e20 636f  al distortion co
-00010310: 6566 6669 6369 656e 7473 2061 6e64 203a  efficients and :
-00010320: 6d61 7468 3a60 705f 6960 2061 7265 0a20  math:`p_i` are. 
-00010330: 2020 2020 2020 2074 616e 6765 6e74 6961         tangentia
-00010340: 6c20 6469 7374 6f72 7469 6f6e 2063 6f65  l distortion coe
-00010350: 6666 6963 6965 6e74 732e 0a0a 2020 2020  fficients...    
-00010360: 2020 2020 496d 6167 6520 6672 616d 6573      Image frames
-00010370: 2074 6861 7420 7765 7265 2073 7563 6365   that were succe
-00010380: 7373 6675 6c6c 7920 7072 6f63 6573 7365  ssfully processe
-00010390: 6420 6172 6520 7265 7475 726e 6564 2061  d are returned a
-000103a0: 7320 6120 6c69 7374 206f 660a 2020 2020  s a list of.    
-000103b0: 2020 2020 6e61 6d65 6420 7475 706c 6573      named tuples
-000103c0: 2060 6043 616c 6962 7261 7469 6f6e 4672   ``CalibrationFr
-000103d0: 616d 6560 6020 7769 7468 2065 6c65 6d65  ame`` with eleme
-000103e0: 6e74 733a 0a0a 2020 2020 2020 2020 3d3d  nts:..        ==
-000103f0: 3d3d 3d3d 3d20 203d 3d3d 3d3d 3d3d 3d3d  =====  =========
-00010400: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2020 3d3d  ============  ==
-00010410: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000340: 0a0a 0a63 6c61 7373 2043 616d 6572 6142  ...class CameraB
+00000350: 6173 6528 4142 4329 3a0a 0a20 2020 2023  ase(ABC):..    #
+00000360: 206c 6973 7420 6f66 2061 7474 7269 6275   list of attribu
+00000370: 7465 730a 2020 2020 5f6e 616d 6520 3d20  tes.    _name = 
+00000380: 4e6f 6e65 2020 2320 6361 6d65 7261 2020  None  # camera  
+00000390: 6e61 6d65 2028 7374 7269 6e67 290a 2020  name (string).  
+000003a0: 2020 5f63 616d 7479 7065 203d 204e 6f6e    _camtype = Non
+000003b0: 6520 2023 2063 616d 6572 6120 7479 7065  e  # camera type
+000003c0: 2028 7374 7269 6e67 290a 0a20 2020 205f   (string)..    _
+000003d0: 696d 6167 6573 697a 6520 3d20 4e6f 6e65  imagesize = None
+000003e0: 2020 2320 6e75 6d62 6572 206f 6620 7069    # number of pi
+000003f0: 7865 6c73 2028 686f 7269 7a6f 6e74 616c  xels (horizontal
+00000400: 2c20 7665 7274 6963 616c 290a 2020 2020  , vertical).    
+00000410: 5f70 7020 3d20 4e6f 6e65 2020 2320 7072  _pp = None  # pr
+00000420: 696e 6369 7061 6c20 706f 696e 7420 2868  incipal point (h
+00000430: 6f72 697a 6f6e 7461 6c2c 2076 6572 7469  orizontal, verti
+00000440: 6361 6c29 0a20 2020 205f 7268 6f75 203d  cal).    _rhou =
+00000450: 204e 6f6e 6520 2023 2070 6978 656c 2069   None  # pixel i
+00000460: 6d61 6765 7369 7a65 2028 7369 6e67 6c65  magesize (single
+00000470: 2070 6978 656c 2920 686f 7269 7a6f 6e74   pixel) horizont
+00000480: 616c 0a20 2020 205f 7268 6f76 203d 204e  al.    _rhov = N
+00000490: 6f6e 6520 2023 2070 6978 656c 2069 6d61  one  # pixel ima
+000004a0: 6765 7369 7a65 2028 7369 6e67 6c65 2070  gesize (single p
+000004b0: 6978 656c 2920 7665 7274 6963 616c 0a20  ixel) vertical. 
+000004c0: 2020 205f 696d 6167 6520 3d20 4e6f 6e65     _image = None
+000004d0: 2020 2320 696d 6167 6520 2854 4f44 4f20    # image (TODO 
+000004e0: 696d 6167 6520 636c 6173 733f 292c 2066  image class?), f
+000004f0: 6f72 206e 6f77 2c20 6a75 7374 206e 756d  or now, just num
+00000500: 7079 2061 7272 6179 0a0a 2020 2020 5f54  py array..    _T
+00000510: 203d 205b 5d20 2023 2063 616d 6572 6120   = []  # camera 
+00000520: 706f 7365 2028 686f 6d6f 6765 6e65 6f75  pose (homogeneou
+00000530: 7320 7472 616e 7366 6f72 6d2c 2053 4533  s transform, SE3
+00000540: 2063 6c61 7373 290a 0a20 2020 205f 6178   class)..    _ax
+00000550: 203d 205b 5d20 2023 2066 6f72 2070 6c6f   = []  # for plo
+00000560: 7474 696e 672c 2061 7865 7320 6861 6e64  tting, axes hand
+00000570: 6c65 0a0a 2020 2020 6465 6620 5f5f 696e  le..    def __in
+00000580: 6974 5f5f 280a 2020 2020 2020 2020 7365  it__(.        se
+00000590: 6c66 2c0a 2020 2020 2020 2020 6e61 6d65  lf,.        name
+000005a0: 3d4e 6f6e 652c 0a20 2020 2020 2020 2063  =None,.        c
+000005b0: 616d 7479 7065 3d22 6365 6e74 7261 6c22  amtype="central"
+000005c0: 2c0a 2020 2020 2020 2020 7268 6f3d 312c  ,.        rho=1,
+000005d0: 0a20 2020 2020 2020 2069 6d61 6765 7369  .        imagesi
+000005e0: 7a65 3d4e 6f6e 652c 0a20 2020 2020 2020  ze=None,.       
+000005f0: 2073 656e 736f 7273 697a 653d 4e6f 6e65   sensorsize=None
+00000600: 2c0a 2020 2020 2020 2020 7070 3d4e 6f6e  ,.        pp=Non
+00000610: 652c 0a20 2020 2020 2020 206e 6f69 7365  e,.        noise
+00000620: 3d4e 6f6e 652c 0a20 2020 2020 2020 2070  =None,.        p
+00000630: 6f73 653d 4e6f 6e65 2c0a 2020 2020 2020  ose=None,.      
+00000640: 2020 6c69 6d69 7473 3d4e 6f6e 652c 0a20    limits=None,. 
+00000650: 2020 2020 2020 206c 6162 656c 733d 4e6f         labels=No
+00000660: 6e65 2c0a 2020 2020 2020 2020 7365 6564  ne,.        seed
+00000670: 3d4e 6f6e 652c 0a20 2020 2029 3a0a 2020  =None,.    ):.  
+00000680: 2020 2020 2020 2222 2241 6273 7472 6163        """Abstrac
+00000690: 7420 6361 6d65 7261 2062 6173 6520 636c  t camera base cl
+000006a0: 6173 730a 0a20 2020 2020 2020 203a 7061  ass..        :pa
+000006b0: 7261 6d20 6e61 6d65 3a20 6361 6d65 7261  ram name: camera
+000006c0: 2069 6e73 7461 6e63 6520 6e61 6d65 2c20   instance name, 
+000006d0: 6465 6661 756c 7473 2074 6f20 4e6f 6e65  defaults to None
+000006e0: 0a20 2020 2020 2020 203a 7479 7065 206e  .        :type n
+000006f0: 616d 653a 2073 7472 2c20 6f70 7469 6f6e  ame: str, option
+00000700: 616c 0a20 2020 2020 2020 203a 7061 7261  al.        :para
+00000710: 6d20 6361 6d74 7970 653a 2063 616d 6572  m camtype: camer
+00000720: 6120 7072 6f6a 6563 7469 6f6e 2074 7970  a projection typ
+00000730: 652c 2064 6566 6175 6c74 7320 746f 2027  e, defaults to '
+00000740: 6365 6e74 7261 6c27 0a20 2020 2020 2020  central'.       
+00000750: 203a 7479 7065 2063 616d 7479 7065 3a20   :type camtype: 
+00000760: 7374 722c 206f 7074 696f 6e61 6c0a 2020  str, optional.  
+00000770: 2020 2020 2020 3a70 6172 616d 2072 686f        :param rho
+00000780: 3a20 7069 7865 6c20 7369 7a65 2c20 6465  : pixel size, de
+00000790: 6661 756c 7473 2074 6f20 310a 2020 2020  faults to 1.    
+000007a0: 2020 2020 3a74 7970 6520 7268 6f3a 2073      :type rho: s
+000007b0: 6361 6c61 7220 6f72 2061 7272 6179 5f6c  calar or array_l
+000007c0: 696b 6528 3229 2c20 6f70 7469 6f6e 616c  ike(2), optional
+000007d0: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+000007e0: 696d 6167 6573 697a 653a 2069 6d61 6765  imagesize: image
+000007f0: 2064 696d 656e 7369 6f6e 2069 6e20 7069   dimension in pi
+00000800: 7865 6c73 2c20 6465 6661 756c 7473 2074  xels, defaults t
+00000810: 6f20 4e6f 6e65 0a20 2020 2020 2020 203a  o None.        :
+00000820: 7479 7065 2069 6d61 6765 7369 7a65 3a20  type imagesize: 
+00000830: 696e 7420 6f72 2061 7272 6179 5f6c 696b  int or array_lik
+00000840: 6528 3229 2c20 6f70 7469 6f6e 616c 0a20  e(2), optional. 
+00000850: 2020 2020 2020 203a 7061 7261 6d20 7365         :param se
+00000860: 6e73 6f72 7369 7a65 3a20 696d 6167 6520  nsorsize: image 
+00000870: 7365 6e73 6f72 2073 697a 652c 2064 6566  sensor size, def
+00000880: 6175 6c74 7320 746f 204e 6f6e 650a 2020  aults to None.  
+00000890: 2020 2020 2020 3a74 7970 6520 7365 6e73        :type sens
+000008a0: 6f72 7369 7a65 3a20 6172 7261 795f 6c69  orsize: array_li
+000008b0: 6b65 2832 292c 206f 7074 696f 6e61 6c0a  ke(2), optional.
+000008c0: 2020 2020 2020 2020 3a70 6172 616d 2070          :param p
+000008d0: 703a 2070 7269 6e63 6970 616c 2070 6f69  p: principal poi
+000008e0: 6e74 2070 6f73 6974 696f 6e2c 2064 6566  nt position, def
+000008f0: 6175 6c74 7320 746f 204e 6f6e 650a 2020  aults to None.  
+00000900: 2020 2020 2020 3a74 7970 6520 7070 3a20        :type pp: 
+00000910: 6172 7261 795f 6c69 6b65 2832 292c 206f  array_like(2), o
+00000920: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
+00000930: 3a70 6172 616d 206e 6f69 7365 3a20 7374  :param noise: st
+00000940: 616e 6461 7264 2064 6576 6961 7469 6f6e  andard deviation
+00000950: 206f 6620 696d 6167 6520 706c 616e 6520   of image plane 
+00000960: 7072 6f6a 6563 7469 6f6e 206e 6f69 7365  projection noise
+00000970: 2c20 6465 6661 756c 7473 2074 6f20 4e6f  , defaults to No
+00000980: 6e65 0a20 2020 2020 2020 203a 7479 7065  ne.        :type
+00000990: 206e 6f69 7365 3a20 666c 6f61 742c 206f   noise: float, o
+000009a0: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
+000009b0: 3a70 6172 616d 2070 6f73 653a 2063 616d  :param pose: cam
+000009c0: 6572 6120 706f 7365 2c20 6465 6661 756c  era pose, defaul
+000009d0: 7473 2074 6f20 4e6f 6e65 0a20 2020 2020  ts to None.     
+000009e0: 2020 203a 7479 7065 2070 6f73 653a 203a     :type pose: :
+000009f0: 636c 6173 733a 607e 7370 6174 6961 6c6d  class:`~spatialm
+00000a00: 6174 682e 2e70 6f73 6533 642e 5345 3360  ath..pose3d.SE3`
+00000a10: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
+00000a20: 2020 203a 7061 7261 6d20 6c69 6d69 7473     :param limits
+00000a30: 3a20 626f 756e 6473 206f 6620 7669 7274  : bounds of virt
+00000a40: 7561 6c20 696d 6167 6520 706c 616e 6520  ual image plane 
+00000a50: 5b75 6d69 6e2c 2075 6d61 782c 2076 6d69  [umin, umax, vmi
+00000a60: 6e2c 2076 6d61 785d 2c20 6465 6661 756c  n, vmax], defaul
+00000a70: 7473 2074 6f20 4e6f 6e65 0a20 2020 2020  ts to None.     
+00000a80: 2020 203a 7479 7065 206c 696d 6974 733a     :type limits:
+00000a90: 2061 7272 6179 5f6c 696b 6528 3429 2c20   array_like(4), 
+00000aa0: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
+00000ab0: 203a 7061 7261 6d20 6c61 6265 6c73 3a20   :param labels: 
+00000ac0: 6178 6973 206c 6162 656c 7320 666f 7220  axis labels for 
+00000ad0: 7669 7274 7561 6c20 696d 6167 6520 706c  virtual image pl
+00000ae0: 616e 652c 2064 6566 6175 6c74 7320 746f  ane, defaults to
+00000af0: 2060 6028 2775 272c 2027 7627 2960 600a   ``('u', 'v')``.
+00000b00: 2020 2020 2020 2020 3a74 7970 6520 6c61          :type la
+00000b10: 6265 6c73 3a20 322d 7475 706c 6520 6f66  bels: 2-tuple of
+00000b20: 2073 7472 2c20 6f70 7469 6f6e 616c 0a20   str, optional. 
+00000b30: 2020 2020 2020 203a 7061 7261 6d20 7365         :param se
+00000b40: 6564 3a20 7261 6e64 6f6d 206e 756d 6265  ed: random numbe
+00000b50: 7220 7365 6564 2066 6f72 2070 726f 6a65  r seed for proje
+00000b60: 6374 696f 6e20 6e6f 6973 652c 2064 6566  ction noise, def
+00000b70: 6175 6c74 7320 746f 204e 6f6e 650a 2020  aults to None.  
+00000b80: 2020 2020 2020 3a74 7970 6520 7365 6564        :type seed
+00000b90: 3a20 696e 742c 206f 7074 696f 6e61 6c0a  : int, optional.
+00000ba0: 2020 2020 2020 2020 3a72 6169 7365 7320          :raises 
+00000bb0: 5479 7065 4572 726f 723a 206e 616d 6520  TypeError: name 
+00000bc0: 6d75 7374 2062 6520 6120 7374 7269 6e67  must be a string
+00000bd0: 0a20 2020 2020 2020 203a 7261 6973 6573  .        :raises
+00000be0: 2054 7970 6545 7272 6f72 3a20 6361 6d74   TypeError: camt
+00000bf0: 7970 6520 6d75 7374 2062 6520 6120 7374  ype must be a st
+00000c00: 7269 6e67 0a20 2020 2020 2020 203a 7261  ring.        :ra
+00000c10: 6973 6573 2056 616c 7565 4572 726f 723a  ises ValueError:
+00000c20: 2072 686f 206d 7573 7420 6265 2061 2031   rho must be a 1
+00000c30: 2d20 6f72 2032 2d65 6c65 6d65 6e74 2076  - or 2-element v
+00000c40: 6563 746f 720a 0a20 2020 2020 2020 2054  ector..        T
+00000c50: 6869 7320 6162 7374 7261 6374 2063 6c61  his abstract cla
+00000c60: 7373 2069 7320 7468 6520 6261 7365 2066  ss is the base f
+00000c70: 6f72 2061 6c6c 2063 616d 6572 6120 7072  or all camera pr
+00000c80: 6f6a 6563 7469 6f6e 206d 6f64 656c 0a20  ojection model. 
+00000c90: 2020 2020 2020 2063 6c61 7373 6573 2e20         classes. 
+00000ca0: 2041 6c6c 2062 6173 6563 6c61 7373 2063   All baseclass c
+00000cb0: 6f6e 7374 7275 6374 6f72 7320 7375 7070  onstructors supp
+00000cc0: 6f72 7420 7468 6573 6520 6f70 7469 6f6e  ort these option
+00000cd0: 732e 0a20 2020 2020 2020 2022 2222 0a20  s..        """. 
+00000ce0: 2020 2020 2020 2069 6620 6e61 6d65 2069         if name i
+00000cf0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00000d00: 2020 2020 7365 6c66 2e5f 6e61 6d65 203d      self._name =
+00000d10: 2063 616d 7479 7065 0a20 2020 2020 2020   camtype.       
+00000d20: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00000d30: 2020 2069 6620 6e6f 7420 6973 696e 7374     if not isinst
+00000d40: 616e 6365 286e 616d 652c 2073 7472 293a  ance(name, str):
+00000d50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00000d60: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
+00000d70: 286e 616d 652c 2022 6e61 6d65 206d 7573  (name, "name mus
+00000d80: 7420 6265 2061 2073 7472 696e 6722 290a  t be a string").
+00000d90: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00000da0: 2e5f 6e61 6d65 203d 206e 616d 650a 0a20  ._name = name.. 
+00000db0: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
+00000dc0: 696e 7374 616e 6365 2863 616d 7479 7065  instance(camtype
+00000dd0: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
+00000de0: 2020 2020 7261 6973 6520 5479 7065 4572      raise TypeEr
+00000df0: 726f 7228 6361 6d74 7970 652c 2022 6361  ror(camtype, "ca
+00000e00: 6d74 7970 6520 6d75 7374 2062 6520 6120  mtype must be a 
+00000e10: 7374 7269 6e67 2229 0a20 2020 2020 2020  string").       
+00000e20: 2073 656c 662e 5f63 616d 7479 7065 203d   self._camtype =
+00000e30: 2063 616d 7479 7065 0a0a 2020 2020 2020   camtype..      
+00000e40: 2020 6966 2069 6d61 6765 7369 7a65 2069    if imagesize i
+00000e50: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00000e60: 2020 2020 6966 2070 7020 6973 204e 6f6e      if pp is Non
+00000e70: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00000e80: 2020 2073 656c 662e 7070 203d 2028 302c     self.pp = (0,
+00000e90: 2030 290a 2020 2020 2020 2020 2020 2020   0).            
+00000ea0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00000eb0: 2020 2020 2020 7365 6c66 2e70 7020 3d20        self.pp = 
+00000ec0: 7070 0a20 2020 2020 2020 2065 6c73 653a  pp.        else:
+00000ed0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00000ee0: 662e 696d 6167 6573 697a 6520 3d20 696d  f.imagesize = im
+00000ef0: 6167 6573 697a 650a 2020 2020 2020 2020  agesize.        
+00000f00: 2020 2020 6966 2070 7020 6973 204e 6f6e      if pp is Non
+00000f10: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00000f20: 2020 2073 656c 662e 7070 203d 205b 7820     self.pp = [x 
+00000f30: 2f20 3220 666f 7220 7820 696e 2073 656c  / 2 for x in sel
+00000f40: 662e 696d 6167 6573 697a 655d 0a20 2020  f.imagesize].   
+00000f50: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00000f60: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00000f70: 656c 662e 7070 203d 2070 700a 0a20 2020  elf.pp = pp..   
+00000f80: 2020 2020 2069 6620 7365 6e73 6f72 7369       if sensorsi
+00000f90: 7a65 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ze is not None:.
+00000fa0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00000fb0: 2e5f 7268 6f75 203d 2073 656e 736f 7273  ._rhou = sensors
+00000fc0: 697a 655b 305d 202f 2073 656c 662e 696d  ize[0] / self.im
+00000fd0: 6167 6573 697a 655b 315d 0a20 2020 2020  agesize[1].     
+00000fe0: 2020 2020 2020 2073 656c 662e 5f72 686f         self._rho
+00000ff0: 7620 3d20 7365 6e73 6f72 7369 7a65 5b31  v = sensorsize[1
+00001000: 5d20 2f20 7365 6c66 2e69 6d61 6765 7369  ] / self.imagesi
+00001010: 7a65 5b30 5d0a 2020 2020 2020 2020 656c  ze[0].        el
+00001020: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00001030: 7268 6f20 3d20 6261 7365 2e67 6574 7665  rho = base.getve
+00001040: 6374 6f72 2872 686f 290a 2020 2020 2020  ctor(rho).      
+00001050: 2020 2020 2020 6966 206c 656e 2872 686f        if len(rho
+00001060: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
+00001070: 2020 2020 2020 2020 7365 6c66 2e5f 7268          self._rh
+00001080: 6f75 203d 2072 686f 5b30 5d0a 2020 2020  ou = rho[0].    
+00001090: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000010a0: 2e5f 7268 6f76 203d 2072 686f 5b30 5d0a  ._rhov = rho[0].
+000010b0: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+000010c0: 206c 656e 2872 686f 2920 3d3d 2032 3a0a   len(rho) == 2:.
+000010d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000010e0: 7365 6c66 2e5f 7268 6f75 203d 2072 686f  self._rhou = rho
+000010f0: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
+00001100: 2020 2020 7365 6c66 2e5f 7268 6f76 203d      self._rhov =
+00001110: 2072 686f 5b31 5d0a 2020 2020 2020 2020   rho[1].        
+00001120: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00001130: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00001140: 5661 6c75 6545 7272 6f72 2872 686f 2c20  ValueError(rho, 
+00001150: 2272 686f 206d 7573 7420 6265 2061 2031  "rho must be a 1
+00001160: 2d20 6f72 2032 2d65 6c65 6d65 6e74 2076  - or 2-element v
+00001170: 6563 746f 7222 290a 0a20 2020 2020 2020  ector")..       
+00001180: 2069 6620 6e6f 6973 6520 6973 206e 6f74   if noise is not
+00001190: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+000011a0: 2020 2073 656c 662e 5f6e 6f69 7365 203d     self._noise =
+000011b0: 206e 6f69 7365 0a0a 2020 2020 2020 2020   noise..        
+000011c0: 7365 6c66 2e5f 7261 6e64 6f6d 203d 206e  self._random = n
+000011d0: 702e 7261 6e64 6f6d 2e64 6566 6175 6c74  p.random.default
+000011e0: 5f72 6e67 2873 6565 6429 0a0a 2020 2020  _rng(seed)..    
+000011f0: 2020 2020 6966 2070 6f73 6520 6973 204e      if pose is N
+00001200: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00001210: 2073 656c 662e 5f70 6f73 6520 3d20 5345   self._pose = SE
+00001220: 3328 290a 2020 2020 2020 2020 656c 7365  3().        else
+00001230: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+00001240: 6c66 2e5f 706f 7365 203d 2053 4533 2870  lf._pose = SE3(p
+00001250: 6f73 6529 0a0a 2020 2020 2020 2020 7365  ose)..        se
+00001260: 6c66 2e70 6f73 6530 203d 2073 656c 662e  lf.pose0 = self.
+00001270: 706f 7365 0a0a 2020 2020 2020 2020 7365  pose..        se
+00001280: 6c66 2e5f 6e6f 6973 6520 3d20 6e6f 6973  lf._noise = nois
+00001290: 650a 0a20 2020 2020 2020 2073 656c 662e  e..        self.
+000012a0: 5f69 6d61 6765 203d 204e 6f6e 650a 0a20  _image = None.. 
+000012b0: 2020 2020 2020 2073 656c 662e 5f61 7820         self._ax 
+000012c0: 3d20 4e6f 6e65 0a0a 2020 2020 2020 2020  = None..        
+000012d0: 7365 6c66 2e5f 6469 7374 6f72 7469 6f6e  self._distortion
+000012e0: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
+000012f0: 7365 6c66 2e6c 6162 656c 7320 3d20 6c61  self.labels = la
+00001300: 6265 6c73 0a20 2020 2020 2020 2073 656c  bels.        sel
+00001310: 662e 6c69 6d69 7473 203d 206c 696d 6974  f.limits = limit
+00001320: 730a 0a20 2020 2064 6566 2072 6573 6574  s..    def reset
+00001330: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00001340: 2222 220a 2020 2020 2020 2020 5265 7365  """.        Rese
+00001350: 7420 6361 6d65 7261 2070 6f73 6520 2862  t camera pose (b
+00001360: 6173 6520 6d65 7468 6f64 290a 0a20 2020  ase method)..   
+00001370: 2020 2020 2052 6573 746f 7265 2063 616d       Restore cam
+00001380: 6572 6120 746f 2061 2063 6f70 7920 6f66  era to a copy of
+00001390: 2074 6865 2070 6f73 6520 6769 7665 6e20   the pose given 
+000013a0: 746f 2074 6865 2063 6f6e 7374 7275 6374  to the construct
+000013b0: 6f72 2e20 2054 6865 2063 6f70 790a 2020  or.  The copy.  
+000013c0: 2020 2020 2020 6d65 616e 7320 7468 6174        means that
+000013d0: 2074 6865 2063 616d 6572 6120 706f 7365   the camera pose
+000013e0: 2063 616e 2062 6520 6d6f 6469 6669 6564   can be modified
+000013f0: 2066 7265 656c 792c 2077 6974 686f 7574   freely, without
+00001400: 2064 6573 7472 6f79 696e 670a 2020 2020   destroying.    
+00001410: 2020 2020 7468 6520 696e 6974 6961 6c20      the initial 
+00001420: 706f 7365 2076 616c 7565 2e0a 2020 2020  pose value..    
+00001430: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00001440: 7365 6c66 2e70 6f73 6520 3d20 7365 6c66  self.pose = self
+00001450: 2e70 6f73 6530 2e63 6f70 7928 290a 0a20  .pose0.copy().. 
+00001460: 2020 2064 6566 205f 5f73 7472 5f5f 2873     def __str__(s
+00001470: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00001480: 220a 2020 2020 2020 2020 5374 7269 6e67  ".        String
+00001490: 2072 6570 7265 7365 6e74 6174 696f 6e20   representation 
+000014a0: 6f66 2063 616d 6572 6120 7061 7261 6d65  of camera parame
+000014b0: 7465 7273 2028 6261 7365 206d 6574 686f  ters (base metho
+000014c0: 6429 0a0a 2020 2020 2020 2020 3a72 6574  d)..        :ret
+000014d0: 7572 6e3a 2073 7472 696e 6720 7265 7072  urn: string repr
+000014e0: 6573 656e 7461 7469 6f6e 0a20 2020 2020  esentation.     
+000014f0: 2020 203a 7274 7970 653a 2073 7472 0a0a     :rtype: str..
+00001500: 2020 2020 2020 2020 4d75 6c74 692d 6c69          Multi-li
+00001510: 6e65 2073 7472 696e 6720 7265 7072 6573  ne string repres
+00001520: 656e 7461 7469 6f6e 206f 6620 6361 6d65  entation of came
+00001530: 7261 2069 6e74 7269 6e73 6963 2061 6e64  ra intrinsic and
+00001540: 2065 7874 7269 6e73 6963 0a20 2020 2020   extrinsic.     
+00001550: 2020 2070 6172 616d 6574 6572 732e 0a20     parameters.. 
+00001560: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00001570: 2020 2023 2054 4f44 4f2c 2069 6d61 6765     # TODO, image
+00001580: 7369 7a65 2073 686f 756c 6420 6265 2069  size should be i
+00001590: 6e74 6567 6572 730a 2020 2020 2020 2020  ntegers.        
+000015a0: 7320 3d20 2222 0a20 2020 2020 2020 2073  s = "".        s
+000015b0: 656c 662e 666d 7420 3d20 227b 3a3e 3135  elf.fmt = "{:>15
+000015c0: 737d 3a20 7b7d 5c6e 220a 2020 2020 2020  s}: {}\n".      
+000015d0: 2020 7320 2b3d 2073 656c 662e 666d 742e    s += self.fmt.
+000015e0: 666f 726d 6174 2822 4e61 6d65 222c 2073  format("Name", s
+000015f0: 656c 662e 6e61 6d65 202b 2022 205b 2220  elf.name + " [" 
+00001600: 2b20 7365 6c66 2e5f 5f63 6c61 7373 5f5f  + self.__class__
+00001610: 2e5f 5f6e 616d 655f 5f20 2b20 225d 2229  .__name__ + "]")
+00001620: 0a20 2020 2020 2020 2073 202b 3d20 7365  .        s += se
+00001630: 6c66 2e66 6d74 2e66 6f72 6d61 7428 2270  lf.fmt.format("p
+00001640: 6978 656c 2073 697a 6522 2c20 2220 7820  ixel size", " x 
+00001650: 222e 6a6f 696e 285b 7374 7228 7829 2066  ".join([str(x) f
+00001660: 6f72 2078 2069 6e20 7365 6c66 2e72 686f  or x in self.rho
+00001670: 5d29 290a 2020 2020 2020 2020 6966 2073  ])).        if s
+00001680: 656c 662e 696d 6167 6573 697a 6520 6973  elf.imagesize is
+00001690: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+000016a0: 2020 2020 2020 2073 202b 3d20 7365 6c66         s += self
+000016b0: 2e66 6d74 2e66 6f72 6d61 7428 0a20 2020  .fmt.format(.   
+000016c0: 2020 2020 2020 2020 2020 2020 2022 696d               "im
+000016d0: 6167 6520 7369 7a65 222c 2022 2078 2022  age size", " x "
+000016e0: 2e6a 6f69 6e28 5b73 7472 2878 2920 666f  .join([str(x) fo
+000016f0: 7220 7820 696e 2073 656c 662e 696d 6167  r x in self.imag
+00001700: 6573 697a 655d 290a 2020 2020 2020 2020  esize]).        
+00001710: 2020 2020 290a 2020 2020 2020 2020 7320      ).        s 
+00001720: 2b3d 2073 656c 662e 666d 742e 666f 726d  += self.fmt.form
+00001730: 6174 2822 706f 7365 222c 2073 656c 662e  at("pose", self.
+00001740: 706f 7365 2e73 7472 6c69 6e65 2866 6d74  pose.strline(fmt
+00001750: 3d22 7b3a 2e33 677d 222c 206f 7269 656e  ="{:.3g}", orien
+00001760: 743d 2272 7079 2f79 787a 2229 290a 2020  t="rpy/yxz")).  
+00001770: 2020 2020 2020 7265 7475 726e 2073 0a0a        return s..
+00001780: 2020 2020 6465 6620 5f5f 7265 7072 5f5f      def __repr__
+00001790: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000017a0: 2222 220a 2020 2020 2020 2020 5265 6164  """.        Read
+000017b0: 6162 6c65 2072 6570 7265 7365 6e74 6174  able representat
+000017c0: 696f 206f 6620 6361 6d65 7261 2070 6172  io of camera par
+000017d0: 616d 6574 6572 7320 2862 6173 6520 6d65  ameters (base me
+000017e0: 7468 6f64 290a 0a20 2020 2020 2020 203a  thod)..        :
+000017f0: 7265 7475 726e 3a20 7374 7269 6e67 2072  return: string r
+00001800: 6570 7265 7365 6e74 6174 696f 6e0a 2020  epresentation.  
+00001810: 2020 2020 2020 3a72 7479 7065 3a20 7374        :rtype: st
+00001820: 720a 0a20 2020 2020 2020 204d 756c 7469  r..        Multi
+00001830: 2d6c 696e 6520 7374 7269 6e67 2072 6570  -line string rep
+00001840: 7265 7365 6e74 6174 696f 6e20 6f66 2063  resentation of c
+00001850: 616d 6572 6120 696e 7472 696e 7369 6320  amera intrinsic 
+00001860: 616e 6420 6578 7472 696e 7369 630a 2020  and extrinsic.  
+00001870: 2020 2020 2020 7061 7261 6d65 7465 7273        parameters
+00001880: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+00001890: 2020 2020 2020 7265 7475 726e 2073 7472        return str
+000018a0: 2873 656c 6629 0a0a 2020 2020 4061 6273  (self)..    @abs
+000018b0: 7472 6163 746d 6574 686f 640a 2020 2020  tractmethod.    
+000018c0: 6465 6620 7072 6f6a 6563 745f 706f 696e  def project_poin
+000018d0: 7428 7365 6c66 2c20 502c 202a 2a6b 7761  t(self, P, **kwa
+000018e0: 7267 7329 3a0a 2020 2020 2020 2020 7061  rgs):.        pa
+000018f0: 7373 0a0a 2020 2020 6465 6620 7072 6f6a  ss..    def proj
+00001900: 6563 745f 6c69 6e65 2873 656c 662c 202a  ect_line(self, *
+00001910: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
+00001920: 0a20 2020 2020 2020 2072 6169 7365 204e  .        raise N
+00001930: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
+00001940: 6f72 2822 6e6f 7420 696d 706c 656d 656e  or("not implemen
+00001950: 7465 6420 666f 7220 7468 6973 2063 616d  ted for this cam
+00001960: 6572 6120 6d6f 6465 6c22 290a 0a20 2020  era model")..   
+00001970: 2064 6566 2070 726f 6a65 6374 5f63 6f6e   def project_con
+00001980: 6963 2873 656c 662c 202a 6172 6773 2c20  ic(self, *args, 
+00001990: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+000019a0: 2020 2072 6169 7365 204e 6f74 496d 706c     raise NotImpl
+000019b0: 656d 656e 7465 6445 7272 6f72 2822 6e6f  ementedError("no
+000019c0: 7420 696d 706c 656d 656e 7465 6420 666f  t implemented fo
+000019d0: 7220 7468 6973 2063 616d 6572 6120 6d6f  r this camera mo
+000019e0: 6465 6c22 290a 0a20 2020 2040 7072 6f70  del")..    @prop
+000019f0: 6572 7479 0a20 2020 2064 6566 206e 616d  erty.    def nam
+00001a00: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
+00001a10: 2022 2222 0a20 2020 2020 2020 2053 6574   """.        Set
+00001a20: 2f67 6574 2063 616d 6572 6120 6e61 6d65  /get camera name
+00001a30: 2028 6261 7365 206d 6574 686f 6429 0a0a   (base method)..
+00001a40: 2020 2020 2020 2020 4120 6361 6d65 7261          A camera
+00001a50: 2068 6173 2061 2073 7472 696e 672d 7661   has a string-va
+00001a60: 6c75 6564 206e 616d 6520 7468 6174 2063  lued name that c
+00001a70: 616e 2062 6520 7265 6164 2061 6e64 2077  an be read and w
+00001a80: 7269 7474 656e 2e0a 0a20 2020 2020 2020  ritten...       
+00001a90: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
+00001aa0: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
+00001ab0: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
+00001ac0: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
+00001ad0: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
+00001ae0: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
+00001af0: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
+00001b00: 2020 203e 3e3e 2063 616d 6572 6120 3d20     >>> camera = 
+00001b10: 4365 6e74 7261 6c43 616d 6572 6128 293b  CentralCamera();
+00001b20: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00001b30: 2063 616d 6572 612e 6e61 6d65 0a20 2020   camera.name.   
+00001b40: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00001b50: 6572 612e 6e61 6d65 203d 2022 666f 6f22  era.name = "foo"
+00001b60: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00001b70: 2063 616d 6572 612e 6e61 6d65 0a20 2020   camera.name.   
+00001b80: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00001b90: 2072 6574 7572 6e20 7365 6c66 2e5f 6e61   return self._na
+00001ba0: 6d65 0a0a 2020 2020 406e 616d 652e 7365  me..    @name.se
+00001bb0: 7474 6572 0a20 2020 2064 6566 206e 616d  tter.    def nam
+00001bc0: 6528 7365 6c66 2c20 6e65 776e 616d 6529  e(self, newname)
+00001bd0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00001be0: 2020 2020 2020 5365 7420 6361 6d65 7261        Set camera
+00001bf0: 206e 616d 650a 0a20 2020 2020 2020 203a   name..        :
+00001c00: 7061 7261 6d20 6e65 776e 616d 653a 2063  param newname: c
+00001c10: 616d 6572 6120 6e61 6d65 0a20 2020 2020  amera name.     
+00001c20: 2020 203a 7479 7065 206e 6577 6e61 6d65     :type newname
+00001c30: 3a20 7374 720a 2020 2020 2020 2020 2222  : str.        ""
+00001c40: 220a 2020 2020 2020 2020 6966 2069 7369  ".        if isi
+00001c50: 6e73 7461 6e63 6528 6e65 776e 616d 652c  nstance(newname,
+00001c60: 2073 7472 293a 0a20 2020 2020 2020 2020   str):.         
+00001c70: 2020 2073 656c 662e 5f6e 616d 6520 3d20     self._name = 
+00001c80: 6e65 776e 616d 650a 2020 2020 2020 2020  newname.        
+00001c90: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00001ca0: 2020 7261 6973 6520 5479 7065 4572 726f    raise TypeErro
+00001cb0: 7228 6e65 776e 616d 652c 2022 6e61 6d65  r(newname, "name
+00001cc0: 206d 7573 7420 6265 2061 2073 7472 696e   must be a strin
+00001cd0: 6722 290a 0a20 2020 2040 7072 6f70 6572  g")..    @proper
+00001ce0: 7479 0a20 2020 2064 6566 2063 616d 7479  ty.    def camty
+00001cf0: 7065 2873 656c 6629 3a0a 2020 2020 2020  pe(self):.      
+00001d00: 2020 2222 220a 2020 2020 2020 2020 5365    """.        Se
+00001d10: 742f 6765 7420 6361 6d65 7261 2074 7970  t/get camera typ
+00001d20: 6520 2862 6173 6520 6d65 7468 6f64 290a  e (base method).
+00001d30: 0a20 2020 2020 2020 2041 2063 616d 6572  .        A camer
+00001d40: 6120 6861 7320 6120 7374 7269 6e67 2d76  a has a string-v
+00001d50: 616c 7565 6420 7479 7065 2074 6861 7420  alued type that 
+00001d60: 6361 6e20 6265 2072 6561 6420 616e 6420  can be read and 
+00001d70: 7772 6974 7465 6e2e 2020 5468 6973 0a20  written.  This. 
+00001d80: 2020 2020 2020 2069 7320 756e 6971 7565         is unique
+00001d90: 2074 6f20 7468 6520 6361 6d65 7261 2073   to the camera s
+00001da0: 7562 636c 6173 7320 616e 6420 7072 6f6a  ubclass and proj
+00001db0: 6563 7469 6f6e 206d 6f64 656c 2e0a 0a20  ection model... 
+00001dc0: 2020 2020 2020 2045 7861 6d70 6c65 3a0a         Example:.
+00001dd0: 0a20 2020 2020 2020 202e 2e20 7275 6e62  .        .. runb
+00001de0: 6c6f 636b 3a3a 2070 7963 6f6e 0a0a 2020  lock:: pycon..  
+00001df0: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
+00001e00: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
+00001e10: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
+00001e20: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
+00001e30: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00001e40: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
+00001e50: 6572 6128 293b 0a20 2020 2020 2020 2020  era();.         
+00001e60: 2020 203e 3e3e 2063 616d 6572 612e 6361     >>> camera.ca
+00001e70: 6d74 7970 650a 2020 2020 2020 2020 2020  mtype.          
+00001e80: 2020 3e3e 3e20 6361 6d65 7261 2e63 616d    >>> camera.cam
+00001e90: 7479 7065 203d 2022 666f 6f22 0a20 2020  type = "foo".   
+00001ea0: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00001eb0: 6572 612e 6361 6d74 7970 650a 2020 2020  era.camtype.    
+00001ec0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00001ed0: 7265 7475 726e 2073 656c 662e 5f63 616d  return self._cam
+00001ee0: 7479 7065 0a0a 2020 2020 4063 616d 7479  type..    @camty
+00001ef0: 7065 2e73 6574 7465 720a 2020 2020 6465  pe.setter.    de
+00001f00: 6620 6361 6d74 7970 6528 7365 6c66 2c20  f camtype(self, 
+00001f10: 6e65 7763 616d 7479 7065 293a 0a20 2020  newcamtype):.   
+00001f20: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00001f30: 2053 6574 2063 616d 6572 6120 7479 7065   Set camera type
+00001f40: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+00001f50: 206e 6577 6361 6d74 7970 653a 2063 616d   newcamtype: cam
+00001f60: 6572 6120 7072 6f6a 6563 7469 6f6e 2074  era projection t
+00001f70: 7970 650a 2020 2020 2020 2020 3a74 7970  ype.        :typ
+00001f80: 6520 6e65 7763 616d 7479 7065 3a20 7374  e newcamtype: st
+00001f90: 720a 2020 2020 2020 2020 2222 220a 2020  r.        """.  
+00001fa0: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00001fb0: 6e63 6528 6e65 7763 616d 7479 7065 2c20  nce(newcamtype, 
+00001fc0: 7374 7229 3a0a 2020 2020 2020 2020 2020  str):.          
+00001fd0: 2020 7365 6c66 2e5f 6361 6d74 7970 6520    self._camtype 
+00001fe0: 3d20 6e65 7763 616d 7479 7065 0a20 2020  = newcamtype.   
+00001ff0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00002000: 2020 2020 2020 2072 6169 7365 2054 7970         raise Typ
+00002010: 6545 7272 6f72 286e 6577 6361 6d74 7970  eError(newcamtyp
+00002020: 652c 2022 6361 6d74 7970 6520 6d75 7374  e, "camtype must
+00002030: 2062 6520 6120 7374 7269 6e67 2229 0a0a   be a string")..
+00002040: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+00002050: 2020 6465 6620 696d 6167 6573 697a 6528    def imagesize(
+00002060: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+00002070: 2222 0a20 2020 2020 2020 2053 6574 2f67  "".        Set/g
+00002080: 6574 2073 697a 6520 6f66 2076 6972 7475  et size of virtu
+00002090: 616c 2069 6d61 6765 2070 6c61 6e65 2028  al image plane (
+000020a0: 6261 7365 206d 6574 686f 6429 0a0a 2020  base method)..  
+000020b0: 2020 2020 2020 5468 6520 6469 6d65 6e73        The dimens
+000020c0: 696f 6e73 206f 6620 7468 6520 7669 7274  ions of the virt
+000020d0: 7561 6c20 696d 6167 6520 706c 616e 6520  ual image plane 
+000020e0: 6973 2061 2032 2d74 7570 6c65 2c20 7769  is a 2-tuple, wi
+000020f0: 6474 6820 616e 640a 2020 2020 2020 2020  dth and.        
+00002100: 6865 6967 6874 2c20 7468 6174 2063 616e  height, that can
+00002110: 2062 6520 7265 6164 206f 7220 7772 6974   be read or writ
+00002120: 7465 6e2e 2020 466f 7220 7772 6974 696e  ten.  For writin
+00002130: 6720 7468 6520 7369 7a65 206d 7573 7420  g the size must 
+00002140: 6265 2061 6e0a 2020 2020 2020 2020 6974  be an.        it
+00002150: 6572 6162 6c65 206f 6620 6c65 6e67 7468  erable of length
+00002160: 2032 2e0a 0a20 2020 2020 2020 2045 7861   2...        Exa
+00002170: 6d70 6c65 3a0a 0a20 2020 2020 2020 202e  mple:..        .
+00002180: 2e20 7275 6e62 6c6f 636b 3a3a 2070 7963  . runblock:: pyc
+00002190: 6f6e 0a0a 2020 2020 2020 2020 2020 2020  on..            
+000021a0: 3e3e 3e20 6672 6f6d 206d 6163 6869 6e65  >>> from machine
+000021b0: 7669 7369 6f6e 746f 6f6c 626f 7820 696d  visiontoolbox im
+000021c0: 706f 7274 2043 656e 7472 616c 4361 6d65  port CentralCame
+000021d0: 7261 0a20 2020 2020 2020 2020 2020 203e  ra.            >
+000021e0: 3e3e 2063 616d 6572 6120 3d20 4365 6e74  >> camera = Cent
+000021f0: 7261 6c43 616d 6572 612e 4465 6661 756c  ralCamera.Defaul
+00002200: 7428 293b 0a20 2020 2020 2020 2020 2020  t();.           
+00002210: 203e 3e3e 2063 616d 6572 612e 696d 6167   >>> camera.imag
+00002220: 6573 697a 650a 2020 2020 2020 2020 2020  esize.          
+00002230: 2020 3e3e 3e20 6361 6d65 7261 2e69 6d61    >>> camera.ima
+00002240: 6765 7369 7a65 203d 2028 3530 302c 2035  gesize = (500, 5
+00002250: 3030 290a 2020 2020 2020 2020 2020 2020  00).            
+00002260: 3e3e 3e20 6361 6d65 7261 2e69 6d61 6765  >>> camera.image
+00002270: 7369 7a65 0a0a 2020 2020 2020 2020 3a6e  size..        :n
+00002280: 6f74 653a 2049 6620 7468 6520 7072 696e  ote: If the prin
+00002290: 6369 7061 6c20 706f 696e 7420 6973 206e  cipal point is n
+000022a0: 6f74 2073 6574 2c20 7468 656e 2073 6574  ot set, then set
+000022b0: 7469 6e67 2069 6d61 6765 7369 7a65 0a20  ting imagesize. 
+000022c0: 2020 2020 2020 2020 2020 2073 6574 7320             sets 
+000022d0: 7468 6520 7072 696e 6369 7061 6c20 706f  the principal po
+000022e0: 696e 7420 746f 2074 6865 2063 656e 7472  int to the centr
+000022f0: 6520 6f66 2074 6865 2069 6d61 6765 2070  e of the image p
+00002300: 6c61 6e65 2e0a 0a20 2020 2020 2020 203a  lane...        :
+00002310: 7365 6561 6c73 6f3a 203a 6d65 7468 3a60  seealso: :meth:`
+00002320: 7769 6474 6860 203a 6d65 7468 3a60 6865  width` :meth:`he
+00002330: 6967 6874 6020 3a6d 6574 683a 606e 7560  ight` :meth:`nu`
+00002340: 203a 6d65 7468 3a60 6e76 600a 2020 2020   :meth:`nv`.    
+00002350: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00002360: 7265 7475 726e 2073 656c 662e 5f69 6d61  return self._ima
+00002370: 6765 7369 7a65 0a0a 2020 2020 4069 6d61  gesize..    @ima
+00002380: 6765 7369 7a65 2e73 6574 7465 720a 2020  gesize.setter.  
+00002390: 2020 6465 6620 696d 6167 6573 697a 6528    def imagesize(
+000023a0: 7365 6c66 2c20 6e70 6978 293a 0a20 2020  self, npix):.   
+000023b0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000023c0: 2053 6574 2069 6d61 6765 2070 6c61 6e65   Set image plane
+000023d0: 2073 697a 650a 0a20 2020 2020 2020 203a   size..        :
+000023e0: 7061 7261 6d20 6e70 6978 3a20 5b64 6573  param npix: [des
+000023f0: 6372 6970 7469 6f6e 5d0a 2020 2020 2020  cription].      
+00002400: 2020 3a74 7970 6520 6e70 6978 3a20 6172    :type npix: ar
+00002410: 7261 795f 6c69 6b65 2832 290a 2020 2020  ray_like(2).    
+00002420: 2020 2020 3a72 6169 7365 7320 5661 6c75      :raises Valu
+00002430: 6545 7272 6f72 3a20 6261 6420 7661 6c75  eError: bad valu
+00002440: 650a 0a20 2020 2020 2020 2053 6574 7320  e..        Sets 
+00002450: 7468 6520 7369 7a65 206f 6620 7468 6520  the size of the 
+00002460: 7669 7274 7561 6c20 696d 6167 6520 706c  virtual image pl
+00002470: 616e 652e 0a0a 2020 2020 2020 2020 3a6e  ane...        :n
+00002480: 6f74 653a 2049 6620 7468 6520 7072 696e  ote: If the prin
+00002490: 6369 706c 6520 706f 696e 7420 6973 206e  ciple point is n
+000024a0: 6f74 2073 6574 2c20 7468 656e 2069 740a  ot set, then it.
+000024b0: 2020 2020 2020 2020 2020 2020 6973 2073              is s
+000024c0: 6574 2074 6f20 7468 6520 6365 6e74 7265  et to the centre
+000024d0: 206f 6620 7468 6520 696d 6167 6520 706c   of the image pl
+000024e0: 616e 652e 0a0a 2020 2020 2020 2020 3a73  ane...        :s
+000024f0: 6565 616c 736f 3a20 3a6d 6574 683a 6077  eealso: :meth:`w
+00002500: 6964 7468 6020 3a6d 6574 683a 6068 6569  idth` :meth:`hei
+00002510: 6768 7460 203a 6d65 7468 3a60 6e75 6020  ght` :meth:`nu` 
+00002520: 3a6d 6574 683a 606e 7660 0a20 2020 2020  :meth:`nv`.     
+00002530: 2020 2022 2222 0a20 2020 2020 2020 206e     """.        n
+00002540: 7069 7820 3d20 6261 7365 2e67 6574 7665  pix = base.getve
+00002550: 6374 6f72 286e 7069 782c 2064 7479 7065  ctor(npix, dtype
+00002560: 3d22 696e 7422 290a 2020 2020 2020 2020  ="int").        
+00002570: 6966 206c 656e 286e 7069 7829 203d 3d20  if len(npix) == 
+00002580: 313a 0a20 2020 2020 2020 2020 2020 2073  1:.            s
+00002590: 656c 662e 5f69 6d61 6765 7369 7a65 203d  elf._imagesize =
+000025a0: 206e 702e 725f 5b6e 7069 785b 305d 2c20   np.r_[npix[0], 
+000025b0: 6e70 6978 5b30 5d5d 0a20 2020 2020 2020  npix[0]].       
+000025c0: 2065 6c69 6620 6c65 6e28 6e70 6978 2920   elif len(npix) 
+000025d0: 696e 2028 322c 2033 293a 0a20 2020 2020  in (2, 3):.     
+000025e0: 2020 2020 2020 2023 2069 676e 6f72 6520         # ignore 
+000025f0: 636f 6c6f 7220 6469 6d65 6e73 696f 6e20  color dimension 
+00002600: 696e 2063 6173 6520 6974 2069 7320 6769  in case it is gi
+00002610: 7665 6e0a 2020 2020 2020 2020 2020 2020  ven.            
+00002620: 7365 6c66 2e5f 696d 6167 6573 697a 6520  self._imagesize 
+00002630: 3d20 6e70 6978 5b3a 325d 0a20 2020 2020  = npix[:2].     
+00002640: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00002650: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00002660: 4572 726f 7228 6e70 6978 2c20 2269 6d61  Error(npix, "ima
+00002670: 6765 7369 7a65 206d 7573 7420 6265 2061  gesize must be a
+00002680: 2031 2d20 6f72 2032 2d65 6c65 6d65 6e74   1- or 2-element
+00002690: 2076 6563 746f 7222 290a 2020 2020 2020   vector").      
+000026a0: 2020 6966 2073 656c 662e 5f70 7020 6973    if self._pp is
+000026b0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+000026c0: 2020 2073 656c 662e 5f70 7020 3d20 7365     self._pp = se
+000026d0: 6c66 2e5f 696d 6167 6573 697a 6520 2f20  lf._imagesize / 
+000026e0: 320a 0a20 2020 2040 7072 6f70 6572 7479  2..    @property
+000026f0: 0a20 2020 2064 6566 206e 7528 7365 6c66  .    def nu(self
+00002700: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00002710: 2020 2020 2020 2047 6574 2069 6d61 6765         Get image
+00002720: 2070 6c61 6e65 2077 6964 7468 2028 6261   plane width (ba
+00002730: 7365 206d 6574 686f 6429 0a0a 2020 2020  se method)..    
+00002740: 2020 2020 3a72 6574 7572 6e3a 2077 6964      :return: wid
+00002750: 7468 0a20 2020 2020 2020 203a 7274 7970  th.        :rtyp
+00002760: 653a 2069 6e74 0a0a 2020 2020 2020 2020  e: int..        
+00002770: 4e75 6d62 6572 206f 6620 7069 7865 6c73  Number of pixels
+00002780: 2069 6e20 7468 6520 752d 6469 7265 6374   in the u-direct
+00002790: 696f 6e20 2877 6964 7468 290a 0a20 2020  ion (width)..   
+000027a0: 2020 2020 2045 7861 6d70 6c65 3a0a 0a20       Example:.. 
+000027b0: 2020 2020 2020 202e 2e20 7275 6e62 6c6f         .. runblo
+000027c0: 636b 3a3a 2070 7963 6f6e 0a0a 2020 2020  ck:: pycon..    
+000027d0: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
+000027e0: 206d 6163 6869 6e65 7669 7369 6f6e 746f   machinevisionto
+000027f0: 6f6c 626f 7820 696d 706f 7274 2043 656e  olbox import Cen
+00002800: 7472 616c 4361 6d65 7261 0a20 2020 2020  tralCamera.     
+00002810: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+00002820: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
+00002830: 612e 4465 6661 756c 7428 293b 0a20 2020  a.Default();.   
+00002840: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00002850: 6572 612e 6e75 0a0a 2020 2020 2020 2020  era.nu..        
+00002860: 3a73 6565 616c 736f 3a20 3a6d 6574 683a  :seealso: :meth:
+00002870: 606e 7660 203a 6d65 7468 3a60 7769 6474  `nv` :meth:`widt
+00002880: 6860 203a 6d65 7468 3a60 696d 6167 6573  h` :meth:`images
+00002890: 697a 6560 0a20 2020 2020 2020 2022 2222  ize`.        """
+000028a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000028b0: 7365 6c66 2e5f 696d 6167 6573 697a 655b  self._imagesize[
+000028c0: 305d 0a0a 2020 2020 4070 726f 7065 7274  0]..    @propert
+000028d0: 790a 2020 2020 6465 6620 6e76 2873 656c  y.    def nv(sel
+000028e0: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
+000028f0: 2020 2020 2020 2020 4765 7420 696d 6167          Get imag
+00002900: 6520 706c 616e 6520 6865 6967 6874 2028  e plane height (
+00002910: 6261 7365 206d 6574 686f 6429 0a0a 2020  base method)..  
+00002920: 2020 2020 2020 3a72 6574 7572 6e3a 2068        :return: h
+00002930: 6569 6768 740a 2020 2020 2020 2020 3a72  eight.        :r
+00002940: 7479 7065 3a20 696e 740a 0a20 2020 2020  type: int..     
+00002950: 2020 204e 756d 6265 7220 6f66 2070 6978     Number of pix
+00002960: 656c 7320 696e 2074 6865 2076 2d64 6972  els in the v-dir
+00002970: 6563 7469 6f6e 2028 6865 6967 6874 290a  ection (height).
+00002980: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+00002990: 3a0a 0a20 2020 2020 2020 202e 2e20 7275  :..        .. ru
+000029a0: 6e62 6c6f 636b 3a3a 2070 7963 6f6e 0a0a  nblock:: pycon..
+000029b0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+000029c0: 6672 6f6d 206d 6163 6869 6e65 7669 7369  from machinevisi
+000029d0: 6f6e 746f 6f6c 626f 7820 696d 706f 7274  ontoolbox import
+000029e0: 2043 656e 7472 616c 4361 6d65 7261 0a20   CentralCamera. 
+000029f0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
+00002a00: 616d 6572 6120 3d20 4365 6e74 7261 6c43  amera = CentralC
+00002a10: 616d 6572 612e 4465 6661 756c 7428 293b  amera.Default();
+00002a20: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00002a30: 2063 616d 6572 612e 6e76 0a0a 2020 2020   camera.nv..    
+00002a40: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
+00002a50: 6574 683a 606e 7560 203a 6d65 7468 3a60  eth:`nu` :meth:`
+00002a60: 6865 6967 6874 6020 203a 6d65 7468 3a60  height`  :meth:`
+00002a70: 696d 6167 6573 697a 6560 0a20 2020 2020  imagesize`.     
+00002a80: 2020 2022 2222 0a20 2020 2020 2020 2072     """.        r
+00002a90: 6574 7572 6e20 7365 6c66 2e5f 696d 6167  eturn self._imag
+00002aa0: 6573 697a 655b 315d 0a0a 2020 2020 4070  esize[1]..    @p
+00002ab0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+00002ac0: 7769 6474 6828 7365 6c66 293a 0a20 2020  width(self):.   
+00002ad0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00002ae0: 2047 6574 2069 6d61 6765 2070 6c61 6e65   Get image plane
+00002af0: 2077 6964 7468 2028 6261 7365 206d 6574   width (base met
+00002b00: 686f 6429 0a0a 2020 2020 2020 2020 3a72  hod)..        :r
+00002b10: 6574 7572 6e3a 2077 6964 7468 0a20 2020  eturn: width.   
+00002b20: 2020 2020 203a 7274 7970 653a 2069 6e74       :rtype: int
+00002b30: 0a0a 2020 2020 2020 2020 496d 6167 6520  ..        Image 
+00002b40: 706c 616e 6520 6865 6967 6874 2c20 6e75  plane height, nu
+00002b50: 6d62 6572 206f 6620 7069 7865 6c73 2069  mber of pixels i
+00002b60: 6e20 7468 6520 762d 6469 7265 6374 696f  n the v-directio
+00002b70: 6e0a 0a20 2020 2020 2020 2045 7861 6d70  n..        Examp
+00002b80: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
+00002b90: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
+00002ba0: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
+00002bb0: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
+00002bc0: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
+00002bd0: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
+00002be0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00002bf0: 2063 616d 6572 6120 3d20 4365 6e74 7261   camera = Centra
+00002c00: 6c43 616d 6572 612e 4465 6661 756c 7428  lCamera.Default(
+00002c10: 293b 0a20 2020 2020 2020 2020 2020 203e  );.            >
+00002c20: 3e3e 2063 616d 6572 612e 7769 6474 680a  >> camera.width.
+00002c30: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
+00002c40: 6f3a 203a 6d65 7468 3a60 6e75 6020 3a6d  o: :meth:`nu` :m
+00002c50: 6574 683a 6068 6569 6768 7460 0a20 2020  eth:`height`.   
+00002c60: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00002c70: 2072 6574 7572 6e20 7365 6c66 2e5f 696d   return self._im
+00002c80: 6167 6573 697a 655b 305d 0a0a 2020 2020  agesize[0]..    
+00002c90: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00002ca0: 6620 6865 6967 6874 2873 656c 6629 3a0a  f height(self):.
+00002cb0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00002cc0: 2020 2020 4765 7420 696d 6167 6520 706c      Get image pl
+00002cd0: 616e 6520 6865 6967 6874 2028 6261 7365  ane height (base
+00002ce0: 206d 6574 686f 6429 0a0a 2020 2020 2020   method)..      
+00002cf0: 2020 3a72 6574 7572 6e3a 2068 6569 6768    :return: heigh
+00002d00: 740a 2020 2020 2020 2020 3a72 7479 7065  t.        :rtype
+00002d10: 3a20 696e 740a 0a20 2020 2020 2020 2049  : int..        I
+00002d20: 6d61 6765 2070 6c61 6e65 2077 6964 7468  mage plane width
+00002d30: 2c20 6e75 6d62 6572 206f 6620 7069 7865  , number of pixe
+00002d40: 6c73 2069 6e20 7468 6520 752d 6469 7265  ls in the u-dire
+00002d50: 6374 696f 6e0a 0a20 2020 2020 2020 2045  ction..        E
+00002d60: 7861 6d70 6c65 3a0a 0a20 2020 2020 2020  xample:..       
+00002d70: 202e 2e20 7275 6e62 6c6f 636b 3a3a 2070   .. runblock:: p
+00002d80: 7963 6f6e 0a0a 2020 2020 2020 2020 2020  ycon..          
+00002d90: 2020 3e3e 3e20 6672 6f6d 206d 6163 6869    >>> from machi
+00002da0: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
+00002db0: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
+00002dc0: 6d65 7261 0a20 2020 2020 2020 2020 2020  mera.           
+00002dd0: 203e 3e3e 2063 616d 6572 6120 3d20 4365   >>> camera = Ce
+00002de0: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
+00002df0: 756c 7428 293b 0a20 2020 2020 2020 2020  ult();.         
+00002e00: 2020 203e 3e3e 2063 616d 6572 612e 6865     >>> camera.he
+00002e10: 6967 6874 0a0a 2020 2020 2020 2020 3a73  ight..        :s
+00002e20: 6565 616c 736f 3a20 3a6d 6574 683a 606e  eealso: :meth:`n
+00002e30: 7660 203a 6d65 7468 3a60 7769 6474 6860  v` :meth:`width`
+00002e40: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00002e50: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00002e60: 2e5f 696d 6167 6573 697a 655b 315d 0a0a  ._imagesize[1]..
+00002e70: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+00002e80: 2020 6465 6620 7070 2873 656c 6629 3a0a    def pp(self):.
+00002e90: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00002ea0: 2020 2020 5365 742f 6765 7420 7072 696e      Set/get prin
+00002eb0: 6369 7061 6c20 706f 696e 7420 636f 6f72  cipal point coor
+00002ec0: 6469 6e61 7465 2028 6261 7365 206d 6574  dinate (base met
+00002ed0: 686f 6429 0a0a 2020 2020 2020 2020 5468  hod)..        Th
+00002ee0: 6520 7072 696e 6369 7061 6c20 706f 696e  e principal poin
+00002ef0: 7420 6973 2074 6865 2063 6f6f 7264 696e  t is the coordin
+00002f00: 6174 6520 6f66 2074 6865 2070 6f69 6e74  ate of the point
+00002f10: 2077 6865 7265 0a20 2020 2020 2020 2074   where.        t
+00002f20: 6865 206f 7074 6963 616c 2061 7869 7320  he optical axis 
+00002f30: 7069 6572 6365 7320 7468 6520 696d 6167  pierces the imag
+00002f40: 6520 706c 616e 652e 2020 4974 2069 7320  e plane.  It is 
+00002f50: 6120 322d 7475 706c 6520 7768 6963 6820  a 2-tuple which 
+00002f60: 6361 6e0a 2020 2020 2020 2020 6265 2072  can.        be r
+00002f70: 6561 6420 6f72 2077 7269 7474 656e 2e20  ead or written. 
+00002f80: 2046 6f72 2077 7269 7469 6e67 2074 6865   For writing the
+00002f90: 2073 697a 6520 6d75 7374 2062 6520 616e   size must be an
+00002fa0: 0a20 2020 2020 2020 2069 7465 7261 626c  .        iterabl
+00002fb0: 6520 6f66 206c 656e 6774 6820 322e 0a0a  e of length 2...
+00002fc0: 2020 2020 2020 2020 4578 616d 706c 653a          Example:
+00002fd0: 0a0a 2020 2020 2020 2020 2e2e 2072 756e  ..        .. run
+00002fe0: 626c 6f63 6b3a 3a20 7079 636f 6e0a 0a20  block:: pycon.. 
+00002ff0: 2020 2020 2020 2020 2020 203e 3e3e 2066             >>> f
+00003000: 726f 6d20 6d61 6368 696e 6576 6973 696f  rom machinevisio
+00003010: 6e74 6f6f 6c62 6f78 2069 6d70 6f72 7420  ntoolbox import 
+00003020: 4365 6e74 7261 6c43 616d 6572 610a 2020  CentralCamera.  
+00003030: 2020 2020 2020 2020 2020 3e3e 3e20 6361            >>> ca
+00003040: 6d65 7261 203d 2043 656e 7472 616c 4361  mera = CentralCa
+00003050: 6d65 7261 2e44 6566 6175 6c74 2829 3b0a  mera.Default();.
+00003060: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00003070: 6361 6d65 7261 2e70 700a 0a20 2020 2020  camera.pp..     
+00003080: 2020 203a 7365 6561 6c73 6f3a 203a 6d65     :seealso: :me
+00003090: 7468 3a60 7530 6020 3a6d 6574 683a 6076  th:`u0` :meth:`v
+000030a0: 3060 0a20 2020 2020 2020 2022 2222 0a20  0`.        """. 
+000030b0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+000030c0: 6c66 2e5f 7070 0a0a 2020 2020 4070 702e  lf._pp..    @pp.
+000030d0: 7365 7474 6572 0a20 2020 2064 6566 2070  setter.    def p
+000030e0: 7028 7365 6c66 2c20 7070 293a 0a20 2020  p(self, pp):.   
+000030f0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00003100: 2053 6574 2070 7269 6e63 6970 616c 2070   Set principal p
+00003110: 6f69 6e74 2063 6f6f 7264 696e 6174 650a  oint coordinate.
+00003120: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+00003130: 7070 3a20 7072 696e 6369 7061 6c20 706f  pp: principal po
+00003140: 696e 740a 2020 2020 2020 2020 3a74 7970  int.        :typ
+00003150: 6520 7070 3a20 6172 7261 795f 6c69 6b65  e pp: array_like
+00003160: 2832 290a 0a20 2020 2020 2020 203a 7365  (2)..        :se
+00003170: 6561 6c73 6f3a 203a 6d65 7468 3a60 7070  ealso: :meth:`pp
+00003180: 6020 3a6d 6574 683a 6075 3060 203a 6d65  ` :meth:`u0` :me
+00003190: 7468 3a60 7630 600a 2020 2020 2020 2020  th:`v0`.        
+000031a0: 2222 220a 2020 2020 2020 2020 7070 203d  """.        pp =
+000031b0: 2062 6173 652e 6765 7476 6563 746f 7228   base.getvector(
+000031c0: 7070 290a 2020 2020 2020 2020 6966 206c  pp).        if l
+000031d0: 656e 2870 7029 203d 3d20 313a 0a20 2020  en(pp) == 1:.   
+000031e0: 2020 2020 2020 2020 2073 656c 662e 5f70           self._p
+000031f0: 7020 3d20 6e70 2e72 5f5b 7070 5b30 5d2c  p = np.r_[pp[0],
+00003200: 2070 705b 305d 5d0a 2020 2020 2020 2020   pp[0]].        
+00003210: 656c 6966 206c 656e 2870 7029 203d 3d20  elif len(pp) == 
+00003220: 323a 0a20 2020 2020 2020 2020 2020 2073  2:.            s
+00003230: 656c 662e 5f70 7020 3d20 7070 0a20 2020  elf._pp = pp.   
+00003240: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00003250: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+00003260: 7565 4572 726f 7228 7070 2c20 2270 7020  ueError(pp, "pp 
+00003270: 6d75 7374 2062 6520 6120 312d 206f 7220  must be a 1- or 
+00003280: 322d 656c 656d 656e 7420 7665 6374 6f72  2-element vector
+00003290: 2229 0a0a 2020 2020 4070 726f 7065 7274  ")..    @propert
+000032a0: 790a 2020 2020 6465 6620 7530 2873 656c  y.    def u0(sel
+000032b0: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
+000032c0: 2020 2020 2020 2020 4765 7420 7072 696e          Get prin
+000032d0: 6369 7061 6c20 706f 696e 743a 2068 6f72  cipal point: hor
+000032e0: 697a 6f6e 7461 6c20 636f 6f72 6469 6e61  izontal coordina
+000032f0: 7465 2028 6261 7365 206d 6574 686f 6429  te (base method)
+00003300: 0a0a 2020 2020 2020 2020 3a72 6574 7572  ..        :retur
+00003310: 6e3a 2068 6f72 697a 6f6e 7461 6c20 636f  n: horizontal co
+00003320: 6d70 6f6e 656e 7420 6f66 2070 7269 6e63  mponent of princ
+00003330: 6970 616c 2070 6f69 6e74 0a20 2020 2020  ipal point.     
+00003340: 2020 203a 7274 7970 653a 2066 6c6f 6174     :rtype: float
+00003350: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
+00003360: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
+00003370: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
+00003380: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00003390: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
+000033a0: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
+000033b0: 7420 4365 6e74 7261 6c43 616d 6572 610a  t CentralCamera.
+000033c0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+000033d0: 6361 6d65 7261 203d 2043 656e 7472 616c  camera = Central
+000033e0: 4361 6d65 7261 2829 3b0a 2020 2020 2020  Camera();.      
+000033f0: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
+00003400: 2e75 300a 0a20 2020 2020 2020 203a 7365  .u0..        :se
+00003410: 6561 6c73 6f3a 203a 6d65 7468 3a60 7630  ealso: :meth:`v0
+00003420: 6020 3a6d 6574 683a 6070 7060 0a20 2020  ` :meth:`pp`.   
+00003430: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00003440: 2072 6574 7572 6e20 7365 6c66 2e5f 7070   return self._pp
+00003450: 5b30 5d0a 0a20 2020 2040 7072 6f70 6572  [0]..    @proper
+00003460: 7479 0a20 2020 2064 6566 2076 3028 7365  ty.    def v0(se
+00003470: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
+00003480: 0a20 2020 2020 2020 2047 6574 2070 7269  .        Get pri
+00003490: 6e63 6970 616c 2070 6f69 6e74 3a20 7665  ncipal point: ve
+000034a0: 7274 6963 616c 2063 6f6f 7264 696e 6174  rtical coordinat
+000034b0: 6520 2862 6173 6520 6d65 7468 6f64 290a  e (base method).
+000034c0: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
+000034d0: 3a20 7665 7274 6963 616c 2063 6f6d 706f  : vertical compo
+000034e0: 6e65 6e74 206f 6620 7072 696e 6369 7061  nent of principa
+000034f0: 6c20 706f 696e 740a 2020 2020 2020 2020  l point.        
+00003500: 3a72 7479 7065 3a20 666c 6f61 740a 0a20  :rtype: float.. 
+00003510: 2020 2020 2020 2045 7861 6d70 6c65 3a0a         Example:.
+00003520: 0a20 2020 2020 2020 202e 2e20 7275 6e62  .        .. runb
+00003530: 6c6f 636b 3a3a 2070 7963 6f6e 0a0a 2020  lock:: pycon..  
+00003540: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
+00003550: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
+00003560: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
+00003570: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
+00003580: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00003590: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
+000035a0: 6572 6128 293b 0a20 2020 2020 2020 2020  era();.         
+000035b0: 2020 203e 3e3e 2063 616d 6572 612e 7630     >>> camera.v0
+000035c0: 0a0a 2020 2020 2020 2020 3a73 6565 616c  ..        :seeal
+000035d0: 736f 3a20 3a6d 6574 683a 6075 3060 203a  so: :meth:`u0` :
+000035e0: 6d65 7468 3a60 7070 600a 2020 2020 2020  meth:`pp`.      
+000035f0: 2020 2222 220a 2020 2020 2020 2020 7265    """.        re
+00003600: 7475 726e 2073 656c 662e 5f70 705b 315d  turn self._pp[1]
+00003610: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00003620: 2020 2020 6465 6620 7268 6f75 2873 656c      def rhou(sel
+00003630: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
+00003640: 2020 2020 2020 2020 4765 7420 7069 7865          Get pixe
+00003650: 6c20 7769 6474 6820 2862 6173 6520 6d65  l width (base me
+00003660: 7468 6f64 290a 0a20 2020 2020 2020 203a  thod)..        :
+00003670: 7265 7475 726e 3a20 686f 7269 7a6f 6e74  return: horizont
+00003680: 616c 2070 6978 656c 2073 697a 650a 2020  al pixel size.  
+00003690: 2020 2020 2020 3a72 7479 7065 3a20 666c        :rtype: fl
+000036a0: 6f61 740a 0a20 2020 2020 2020 2045 7861  oat..        Exa
+000036b0: 6d70 6c65 3a0a 0a20 2020 2020 2020 202e  mple:..        .
+000036c0: 2e20 7275 6e62 6c6f 636b 3a3a 2070 7963  . runblock:: pyc
+000036d0: 6f6e 0a0a 2020 2020 2020 2020 2020 2020  on..            
+000036e0: 3e3e 3e20 6672 6f6d 206d 6163 6869 6e65  >>> from machine
+000036f0: 7669 7369 6f6e 746f 6f6c 626f 7820 696d  visiontoolbox im
+00003700: 706f 7274 2043 656e 7472 616c 4361 6d65  port CentralCame
+00003710: 7261 0a20 2020 2020 2020 2020 2020 203e  ra.            >
+00003720: 3e3e 2063 616d 6572 6120 3d20 4365 6e74  >> camera = Cent
+00003730: 7261 6c43 616d 6572 612e 4465 6661 756c  ralCamera.Defaul
+00003740: 7428 293b 0a20 2020 2020 2020 2020 2020  t();.           
+00003750: 203e 3e3e 2063 616d 6572 612e 7268 6f75   >>> camera.rhou
+00003760: 0a0a 2020 2020 2020 2020 3a73 6565 616c  ..        :seeal
+00003770: 736f 3a20 3a6d 6574 683a 6072 686f 7660  so: :meth:`rhov`
+00003780: 203a 6d65 7468 3a60 7268 6f60 0a20 2020   :meth:`rho`.   
+00003790: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000037a0: 2072 6574 7572 6e20 7365 6c66 2e5f 7268   return self._rh
+000037b0: 6f75 0a0a 2020 2020 2320 7468 6973 2069  ou..    # this i
+000037c0: 7320 6765 6e65 7261 6c6c 7920 7468 6520  s generally the 
+000037d0: 6365 6e74 7265 206f 6620 7468 6520 696d  centre of the im
+000037e0: 6167 652c 2068 6173 2073 7065 6369 616c  age, has special
+000037f0: 206d 6561 6e69 6e67 2066 6f72 0a20 2020   meaning for.   
+00003800: 2023 2070 6572 7370 6563 7469 7665 2063   # perspective c
+00003810: 616d 6572 610a 0a20 2020 2040 7072 6f70  amera..    @prop
+00003820: 6572 7479 0a20 2020 2064 6566 2072 686f  erty.    def rho
+00003830: 7628 7365 6c66 293a 0a20 2020 2020 2020  v(self):.       
+00003840: 2022 2222 0a20 2020 2020 2020 2047 6574   """.        Get
+00003850: 2070 6978 656c 2077 6964 7468 2028 6261   pixel width (ba
+00003860: 7365 206d 6574 686f 6429 0a0a 2020 2020  se method)..    
+00003870: 2020 2020 3a72 6574 7572 6e3a 2076 6572      :return: ver
+00003880: 7469 6361 6c20 7069 7865 6c20 7369 7a65  tical pixel size
+00003890: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+000038a0: 2066 6c6f 6174 0a0a 2020 2020 2020 2020   float..        
+000038b0: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
+000038c0: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+000038d0: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
+000038e0: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
+000038f0: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+00003900: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
+00003910: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
+00003920: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
+00003930: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
+00003940: 6175 6c74 2829 3b0a 2020 2020 2020 2020  ault();.        
+00003950: 2020 2020 3e3e 3e20 6361 6d65 7261 2e72      >>> camera.r
+00003960: 686f 760a 0a20 2020 2020 2020 203a 7365  hov..        :se
+00003970: 6561 6c73 6f3a 203a 6d65 7468 3a60 7268  ealso: :meth:`rh
+00003980: 6f76 6020 3a6d 6574 683a 6072 686f 600a  ov` :meth:`rho`.
+00003990: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000039a0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+000039b0: 5f72 686f 760a 0a20 2020 2040 7072 6f70  _rhov..    @prop
+000039c0: 6572 7479 0a20 2020 2064 6566 2072 686f  erty.    def rho
+000039d0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000039e0: 2222 220a 2020 2020 2020 2020 4765 7420  """.        Get 
+000039f0: 7069 7865 6c20 6469 6d65 6e73 696f 6e73  pixel dimensions
+00003a00: 2028 6261 7365 206d 6574 686f 6429 0a0a   (base method)..
+00003a10: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
+00003a20: 2068 6f72 697a 6f6e 7461 6c20 7069 7865   horizontal pixe
+00003a30: 6c20 7369 7a65 0a20 2020 2020 2020 203a  l size.        :
+00003a40: 7274 7970 653a 206e 6461 7272 6179 2832  rtype: ndarray(2
+00003a50: 290a 0a20 2020 2020 2020 2045 7861 6d70  )..        Examp
+00003a60: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
+00003a70: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
+00003a80: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
+00003a90: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
+00003aa0: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
+00003ab0: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
+00003ac0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00003ad0: 2063 616d 6572 6120 3d20 4365 6e74 7261   camera = Centra
+00003ae0: 6c43 616d 6572 6128 293b 0a20 2020 2020  lCamera();.     
+00003af0: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+00003b00: 612e 7268 6f76 0a0a 2020 2020 2020 2020  a.rhov..        
+00003b10: 3a73 6565 616c 736f 3a20 3a6d 6574 683a  :seealso: :meth:
+00003b20: 6072 686f 7560 203a 6d65 7468 3a60 7268  `rhou` :meth:`rh
+00003b30: 6f76 600a 2020 2020 2020 2020 2222 220a  ov`.        """.
+00003b40: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00003b50: 6e70 2e61 7272 6179 285b 7365 6c66 2e5f  np.array([self._
+00003b60: 7268 6f75 2c20 7365 6c66 2e5f 7268 6f76  rhou, self._rhov
+00003b70: 5d29 0a0a 2020 2020 2320 4070 726f 7065  ])..    # @prope
+00003b80: 7274 790a 2020 2020 2320 6465 6620 696d  rty.    # def im
+00003b90: 6167 6528 7365 6c66 293a 0a20 2020 2023  age(self):.    #
+00003ba0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00003bb0: 2e5f 696d 6167 650a 0a20 2020 2023 2040  ._image..    # @
+00003bc0: 696d 6167 652e 7365 7474 6572 0a20 2020  image.setter.   
+00003bd0: 2023 2064 6566 2069 6d61 6765 2873 656c   # def image(sel
+00003be0: 662c 206e 6577 696d 6167 6529 3a0a 2020  f, newimage):.  
+00003bf0: 2020 2320 2020 2020 2222 220a 0a20 2020    #     """..   
+00003c00: 2023 2020 2020 203a 7061 7261 6d20 6e65   #     :param ne
+00003c10: 7769 6d61 6765 3a20 5b64 6573 6372 6970  wimage: [descrip
+00003c20: 7469 6f6e 5d0a 2020 2020 2320 2020 2020  tion].    #     
+00003c30: 3a74 7970 6520 6e65 7769 6d61 6765 3a20  :type newimage: 
+00003c40: 5b74 7970 655d 0a20 2020 2023 2020 2020  [type].    #    
+00003c50: 2022 2222 0a20 2020 2023 2020 2020 2073   """.    #     s
+00003c60: 656c 662e 5f69 6d61 6765 203d 2049 6d61  elf._image = Ima
+00003c70: 6765 286e 6577 696d 6167 6529 0a0a 2020  ge(newimage)..  
+00003c80: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00003c90: 6465 6620 706f 7365 2873 656c 6629 3a0a  def pose(self):.
+00003ca0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00003cb0: 2020 2020 5365 742f 6765 7420 6361 6d65      Set/get came
+00003cc0: 7261 2070 6f73 6520 2862 6173 6520 6d65  ra pose (base me
+00003cd0: 7468 6f64 290a 0a20 2020 2020 2020 2054  thod)..        T
+00003ce0: 6865 2063 616d 6572 6120 706f 7365 2077  he camera pose w
+00003cf0: 6974 6820 7265 7370 6563 7420 746f 2074  ith respect to t
+00003d00: 6865 2067 6c6f 6261 6c20 6672 616d 6520  he global frame 
+00003d10: 6361 6e20 6265 2072 6561 6420 6f72 2077  can be read or w
+00003d20: 7269 7474 656e 0a20 2020 2020 2020 2061  ritten.        a
+00003d30: 7320 616e 203a 636c 6173 733a 607e 7370  s an :class:`~sp
+00003d40: 6174 6961 6c6d 6174 682e 2e70 6f73 6533  atialmath..pose3
+00003d50: 642e 5345 3360 2069 6e73 7461 6e63 652e  d.SE3` instance.
+00003d60: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
+00003d70: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
+00003d80: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
+00003d90: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00003da0: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
+00003db0: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
+00003dc0: 7420 4365 6e74 7261 6c43 616d 6572 610a  t CentralCamera.
+00003dd0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00003de0: 6672 6f6d 2073 7061 7469 616c 6d61 7468  from spatialmath
+00003df0: 2069 6d70 6f72 7420 5345 330a 2020 2020   import SE3.    
+00003e00: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
+00003e10: 7261 203d 2043 656e 7472 616c 4361 6d65  ra = CentralCame
+00003e20: 7261 2829 3b0a 2020 2020 2020 2020 2020  ra();.          
+00003e30: 2020 3e3e 3e20 6361 6d65 7261 2e70 6f73    >>> camera.pos
+00003e40: 650a 2020 2020 2020 2020 2020 2020 3e3e  e.            >>
+00003e50: 3e20 6361 6d65 7261 2e70 6f73 6520 3d20  > camera.pose = 
+00003e60: 5345 332e 5472 616e 7328 312c 2032 2c20  SE3.Trans(1, 2, 
+00003e70: 3329 0a20 2020 2020 2020 2020 2020 203e  3).            >
+00003e80: 3e3e 2063 616d 6572 610a 0a20 2020 2020  >> camera..     
+00003e90: 2020 203a 6e6f 7465 3a20 4368 616e 6765     :note: Change
+00003ea0: 7320 7468 6520 706f 7365 206f 6620 7468  s the pose of th
+00003eb0: 6520 6375 7272 656e 7420 6361 6d65 7261  e current camera
+00003ec0: 2069 6e73 7461 6e63 652c 2077 6865 7265   instance, where
+00003ed0: 6173 0a20 2020 2020 2020 2020 2020 203a  as.            :
+00003ee0: 6d65 7468 3a60 6d6f 7665 6020 636c 6f6e  meth:`move` clon
+00003ef0: 6573 2074 6865 2063 616d 6572 6120 696e  es the camera in
+00003f00: 7374 616e 6365 2077 6974 6820 6120 6e65  stance with a ne
+00003f10: 7720 706f 7365 2e0a 0a20 2020 2020 2020  w pose...       
+00003f20: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
+00003f30: 3a60 6d6f 7665 600a 2020 2020 2020 2020  :`move`.        
+00003f40: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00003f50: 726e 2073 656c 662e 5f70 6f73 650a 0a20  rn self._pose.. 
+00003f60: 2020 2040 706f 7365 2e73 6574 7465 720a     @pose.setter.
+00003f70: 2020 2020 6465 6620 706f 7365 2873 656c      def pose(sel
+00003f80: 662c 206e 6577 706f 7365 293a 0a20 2020  f, newpose):.   
+00003f90: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00003fa0: 2053 6574 2063 616d 6572 6120 706f 7365   Set camera pose
+00003fb0: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+00003fc0: 206e 6577 706f 7365 3a20 706f 7365 206f   newpose: pose o
+00003fd0: 6620 6361 6d65 7261 2066 7261 6d65 0a20  f camera frame. 
+00003fe0: 2020 2020 2020 203a 7479 7065 206e 6577         :type new
+00003ff0: 706f 7365 3a20 3a63 6c61 7373 3a60 7e73  pose: :class:`~s
+00004000: 7061 7469 616c 6d61 7468 2e2e 706f 7365  patialmath..pose
+00004010: 3364 2e53 4533 6020 6f72 206e 6461 7272  3d.SE3` or ndarr
+00004020: 6179 2834 2c34 290a 0a20 2020 2020 2020  ay(4,4)..       
+00004030: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
+00004040: 3a60 6d6f 7665 600a 2020 2020 2020 2020  :`move`.        
+00004050: 2222 220a 2020 2020 2020 2020 7365 6c66  """.        self
+00004060: 2e5f 706f 7365 203d 2053 4533 286e 6577  ._pose = SE3(new
+00004070: 706f 7365 290a 0a20 2020 2040 7072 6f70  pose)..    @prop
+00004080: 6572 7479 0a20 2020 2064 6566 206e 6f69  erty.    def noi
+00004090: 7365 2873 656c 6629 3a0a 2020 2020 2020  se(self):.      
+000040a0: 2020 2222 220a 2020 2020 2020 2020 5365    """.        Se
+000040b0: 742f 4765 7420 7072 6f6a 6563 7469 6f6e  t/Get projection
+000040c0: 206e 6f69 7365 2028 6261 7365 206d 6574   noise (base met
+000040d0: 686f 6429 0a0a 2020 2020 2020 2020 3a72  hod)..        :r
+000040e0: 6574 7572 6e3a 2073 7461 6e64 6172 6420  eturn: standard 
+000040f0: 6465 7669 6174 696f 6e20 6f66 206e 6f69  deviation of noi
+00004100: 7365 2061 6464 6564 2074 6f20 7072 6f6a  se added to proj
+00004110: 6563 7465 6420 696d 6167 6520 706c 616e  ected image plan
+00004120: 6520 706f 696e 7473 0a20 2020 2020 2020  e points.       
+00004130: 203a 7274 7970 653a 2066 6c6f 6174 0a0a   :rtype: float..
+00004140: 2020 2020 2020 2020 5468 6520 6e6f 6973          The nois
+00004150: 6520 7061 7261 6d65 7465 7220 6973 2073  e parameter is s
+00004160: 6574 2062 7920 7468 6520 6f62 6a65 6374  et by the object
+00004170: 2063 6f6e 7374 7275 6374 6f72 2e0a 0a20   constructor... 
+00004180: 2020 2020 2020 2045 7861 6d70 6c65 3a0a         Example:.
+00004190: 0a20 2020 2020 2020 202e 2e20 7275 6e62  .        .. runb
+000041a0: 6c6f 636b 3a3a 2070 7963 6f6e 0a0a 2020  lock:: pycon..  
+000041b0: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
+000041c0: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
+000041d0: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
+000041e0: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
+000041f0: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00004200: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
+00004210: 6572 612e 4465 6661 756c 7428 293b 0a20  era.Default();. 
+00004220: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
+00004230: 616d 6572 612e 7072 6f6a 6563 745f 706f  amera.project_po
+00004240: 696e 7428 5b30 2c20 302c 2033 5d29 0a20  int([0, 0, 3]). 
+00004250: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
+00004260: 616d 6572 612e 6e6f 6973 6520 3d20 320a  amera.noise = 2.
+00004270: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00004280: 6361 6d65 7261 2e70 726f 6a65 6374 5f70  camera.project_p
+00004290: 6f69 6e74 285b 302c 2030 2c20 325d 290a  oint([0, 0, 2]).
+000042a0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+000042b0: 6361 6d65 7261 2e70 726f 6a65 6374 5f70  camera.project_p
+000042c0: 6f69 6e74 285b 302c 2030 2c20 325d 290a  oint([0, 0, 2]).
+000042d0: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
+000042e0: 6f3a 203a 6d65 7468 3a60 7072 6f6a 6563  o: :meth:`projec
+000042f0: 7460 0a20 2020 2020 2020 2022 2222 0a20  t`.        """. 
+00004300: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00004310: 6c66 2e5f 6e6f 6973 650a 0a20 2020 2040  lf._noise..    @
+00004320: 6e6f 6973 652e 7365 7474 6572 0a20 2020  noise.setter.   
+00004330: 2064 6566 206e 6f69 7365 2873 656c 662c   def noise(self,
+00004340: 206e 6f69 7365 293a 0a20 2020 2020 2020   noise):.       
+00004350: 2073 656c 662e 5f6e 6f69 7365 203d 206e   self._noise = n
+00004360: 6f69 7365 0a0a 2020 2020 6465 6620 6d6f  oise..    def mo
+00004370: 7665 2873 656c 662c 2054 2c20 6e61 6d65  ve(self, T, name
+00004380: 3d4e 6f6e 652c 2072 656c 6174 6976 653d  =None, relative=
+00004390: 4661 6c73 6529 3a0a 2020 2020 2020 2020  False):.        
+000043a0: 2222 220a 2020 2020 2020 2020 4d6f 7665  """.        Move
+000043b0: 2063 616d 6572 6120 2862 6173 6520 6d65   camera (base me
+000043c0: 7468 6f64 290a 0a20 2020 2020 2020 203a  thod)..        :
+000043d0: 7061 7261 6d20 543a 2070 6f73 6520 6f66  param T: pose of
+000043e0: 2063 616d 6572 6120 6672 616d 650a 2020   camera frame.  
+000043f0: 2020 2020 2020 3a74 7970 6520 543a 203a        :type T: :
+00004400: 636c 6173 733a 607e 7370 6174 6961 6c6d  class:`~spatialm
+00004410: 6174 682e 2e70 6f73 6533 642e 5345 3360  ath..pose3d.SE3`
+00004420: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+00004430: 7265 6c61 7469 7665 3a20 6d6f 7665 2072  relative: move r
+00004440: 656c 6174 6976 6520 746f 2070 6f73 6520  elative to pose 
+00004450: 6f66 206f 7269 6769 6e61 6c20 6361 6d65  of original came
+00004460: 7261 2c20 6465 6661 756c 7473 2074 6f20  ra, defaults to 
+00004470: 4661 6c73 650a 2020 2020 2020 2020 3a74  False.        :t
+00004480: 7970 6520 7265 6c61 7469 7665 3a20 626f  ype relative: bo
+00004490: 6f6c 2c20 6f70 7469 6f6e 616c 0a20 2020  ol, optional.   
+000044a0: 2020 2020 203a 7265 7475 726e 3a20 6e65       :return: ne
+000044b0: 7720 6361 6d65 7261 206f 626a 6563 740a  w camera object.
+000044c0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+000044d0: 3a63 6c61 7373 3a60 4361 6d65 7261 4261  :class:`CameraBa
+000044e0: 7365 6020 7375 6263 6c61 7373 0a0a 2020  se` subclass..  
+000044f0: 2020 2020 2020 5265 7475 726e 7320 6120        Returns a 
+00004500: 636f 7079 206f 6620 7468 6520 6361 6d65  copy of the came
+00004510: 7261 206f 626a 6563 7420 7769 7468 2070  ra object with p
+00004520: 6f73 6520 7365 7420 746f 2060 6054 6060  ose set to ``T``
+00004530: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
+00004540: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
+00004550: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
+00004560: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
+00004570: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
+00004580: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
+00004590: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
+000045a0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+000045b0: 2066 726f 6d20 7370 6174 6961 6c6d 6174   from spatialmat
+000045c0: 6820 696d 706f 7274 2053 4533 0a20 2020  h import SE3.   
+000045d0: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+000045e0: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
+000045f0: 6572 6128 293b 0a20 2020 2020 2020 2020  era();.         
+00004600: 2020 203e 3e3e 2063 616d 6572 612e 6d6f     >>> camera.mo
+00004610: 7665 2853 4533 2e54 7261 6e73 2830 2e31  ve(SE3.Trans(0.1
+00004620: 2c20 302e 322c 2030 2e33 2929 0a20 2020  , 0.2, 0.3)).   
+00004630: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00004640: 6572 610a 0a20 2020 2020 2020 203a 6e6f  era..        :no
+00004650: 7465 3a20 5468 6520 6060 706c 6f74 6060  te: The ``plot``
+00004660: 206d 6574 686f 6420 6f66 2074 6869 7320   method of this 
+00004670: 636c 6f6e 6564 2063 616d 6572 6120 7769  cloned camera wi
+00004680: 6c6c 2063 7265 6174 6520 6120 6e65 770a  ll create a new.
+00004690: 2020 2020 2020 2020 2020 2020 7769 6e64              wind
+000046a0: 6f77 2e0a 0a20 2020 2020 2020 203a 7365  ow...        :se
+000046b0: 6561 6c73 6f3a 203a 6d65 7468 3a60 706f  ealso: :meth:`po
+000046c0: 7365 600a 2020 2020 2020 2020 2222 220a  se`.        """.
+000046d0: 2020 2020 2020 2020 6e65 7763 616d 6572          newcamer
+000046e0: 6120 3d20 636f 7079 2e63 6f70 7928 7365  a = copy.copy(se
+000046f0: 6c66 290a 2020 2020 2020 2020 6966 206e  lf).        if n
+00004700: 616d 6520 6973 206e 6f74 204e 6f6e 653a  ame is not None:
+00004710: 0a20 2020 2020 2020 2020 2020 206e 6577  .            new
+00004720: 6361 6d65 7261 2e6e 616d 6520 3d20 6e61  camera.name = na
+00004730: 6d65 0a20 2020 2020 2020 2065 6c73 653a  me.        else:
+00004740: 0a20 2020 2020 2020 2020 2020 206e 6577  .            new
+00004750: 6361 6d65 7261 2e6e 616d 6520 3d20 7365  camera.name = se
+00004760: 6c66 2e6e 616d 6520 2b20 222d 6d6f 7665  lf.name + "-move
+00004770: 6422 0a20 2020 2020 2020 206e 6577 6361  d".        newca
+00004780: 6d65 7261 2e5f 6178 203d 204e 6f6e 650a  mera._ax = None.
+00004790: 2020 2020 2020 2020 6966 2072 656c 6174          if relat
+000047a0: 6976 653a 0a20 2020 2020 2020 2020 2020  ive:.           
+000047b0: 206e 6577 6361 6d65 7261 2e70 6f73 6520   newcamera.pose 
+000047c0: 3d20 7365 6c66 2e70 6f73 6520 2a20 540a  = self.pose * T.
+000047d0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000047e0: 2020 2020 2020 2020 2020 6e65 7763 616d            newcam
+000047f0: 6572 612e 706f 7365 203d 2054 0a20 2020  era.pose = T.   
+00004800: 2020 2020 2072 6574 7572 6e20 6e65 7763       return newc
+00004810: 616d 6572 610a 0a20 2020 2023 202d 2d2d  amera..    # ---
+00004820: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004830: 2d2d 2d2d 2070 6c6f 7474 696e 6720 2d2d  ---- plotting --
+00004840: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004860: 2d20 230a 0a20 2020 2064 6566 205f 6e65  - #..    def _ne
+00004870: 775f 696d 6167 6570 6c61 6e65 2873 656c  w_imageplane(sel
+00004880: 662c 2066 6967 3d4e 6f6e 652c 2061 783d  f, fig=None, ax=
+00004890: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
+000048a0: 2222 0a20 2020 2020 2020 2043 7265 6174  "".        Creat
+000048b0: 6520 6120 6e65 7720 7669 7274 7561 6c20  e a new virtual 
+000048c0: 696d 6167 6520 706c 616e 6520 6966 2072  image plane if r
+000048d0: 6571 7569 7265 640a 0a20 2020 2020 2020  equired..       
+000048e0: 203a 7061 7261 6d20 6669 673a 204d 6174   :param fig: Mat
+000048f0: 706c 6f74 6c69 6220 6669 6775 7265 206e  plotlib figure n
+00004900: 756d 6265 722c 2064 6566 6175 6c74 7320  umber, defaults 
+00004910: 746f 204e 6f6e 650a 2020 2020 2020 2020  to None.        
+00004920: 3a74 7970 6520 6669 673a 2069 6e74 2c20  :type fig: int, 
+00004930: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
+00004940: 203a 7061 7261 6d20 6178 3a20 4d61 7470   :param ax: Matp
+00004950: 6c6f 746c 6f62 2061 7865 732c 2064 6566  lotlob axes, def
+00004960: 6175 6c74 7320 746f 204e 6f6e 650a 2020  aults to None.  
+00004970: 2020 2020 2020 3a74 7970 6520 6178 3a20        :type ax: 
+00004980: 3a63 6c61 7373 3a60 6d61 7470 6c6f 746c  :class:`matplotl
+00004990: 6962 2e61 7865 7360 2c20 6f70 7469 6f6e  ib.axes`, option
+000049a0: 616c 0a20 2020 2020 2020 203a 7265 7475  al.        :retu
+000049b0: 726e 3a20 7768 6574 6865 7220 7669 7274  rn: whether virt
+000049c0: 7561 6c20 696d 6167 6520 706c 616e 6520  ual image plane 
+000049d0: 6578 6973 7473 0a20 2020 2020 2020 203a  exists.        :
+000049e0: 7274 7970 653a 2062 6f6f 6c0a 0a20 2020  rtype: bool..   
+000049f0: 2020 2020 2049 6620 7468 6973 2063 616d       If this cam
+00004a00: 6572 6120 616c 7265 6164 7920 6861 7320  era already has 
+00004a10: 6120 7669 7274 7561 6c20 696d 6167 6520  a virtual image 
+00004a20: 706c 616e 652c 2072 6574 7572 6e20 5472  plane, return Tr
+00004a30: 7565 2e0a 2020 2020 2020 2020 4f74 6865  ue..        Othe
+00004a40: 7277 6973 652c 2063 7265 6174 6520 616e  rwise, create an
+00004a50: 2061 7865 732c 2061 6e64 206f 7074 696f   axes, and optio
+00004a60: 6e61 6c6c 7920 6120 2066 6967 7572 652c  nally a  figure,
+00004a70: 2061 6e64 2072 6574 7572 6e20 4661 6c73   and return Fals
+00004a80: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
+00004a90: 2020 2020 2020 2069 6620 5f69 736e 6f74         if _isnot
+00004aa0: 6562 6f6f 6b28 293a 0a20 2020 2020 2020  ebook():.       
+00004ab0: 2020 2020 2061 7820 3d20 706c 742e 6763       ax = plt.gc
+00004ac0: 6128 2920 2023 2072 6574 7572 6e20 6375  a()  # return cu
+00004ad0: 7272 656e 7420 6f72 2063 7265 6174 6520  rrent or create 
+00004ae0: 6e65 770a 2020 2020 2020 2020 2020 2020  new.            
+00004af0: 6966 2073 656c 662e 5f61 7820 6973 204e  if self._ax is N
+00004b00: 6f6e 6520 6f72 2073 656c 662e 5f61 7820  one or self._ax 
+00004b10: 6973 206e 6f74 2061 783a 0a20 2020 2020  is not ax:.     
+00004b20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00004b30: 5f61 7820 3d20 6178 0a20 2020 2020 2020  _ax = ax.       
+00004b40: 2020 2020 2020 2020 2073 656c 662e 5f66           self._f
+00004b50: 6967 203d 2070 6c74 2e67 6366 2829 0a20  ig = plt.gcf(). 
+00004b60: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00004b70: 6574 7572 6e20 4661 6c73 650a 2020 2020  eturn False.    
+00004b80: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00004b90: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00004ba0: 7475 726e 2054 7275 650a 0a20 2020 2020  turn True..     
+00004bb0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00004bc0: 2020 2020 2023 2069 6620 6e6f 7420 4a75       # if not Ju
+00004bd0: 7079 7465 722c 2072 6575 7365 2061 6e20  pyter, reuse an 
+00004be0: 6578 6973 7469 6e67 2069 6d61 6765 706c  existing imagepl
+00004bf0: 616e 6520 706c 6f74 0a20 2020 2020 2020  ane plot.       
+00004c00: 2020 2020 2069 6620 7365 6c66 2e5f 6178       if self._ax
+00004c10: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+00004c20: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00004c30: 7475 726e 2054 7275 650a 0a20 2020 2020  turn True..     
+00004c40: 2020 2069 6620 2866 6967 2069 7320 4e6f     if (fig is No
+00004c50: 6e65 2920 616e 6420 2861 7820 6973 204e  ne) and (ax is N
+00004c60: 6f6e 6529 3a0a 2020 2020 2020 2020 2020  one):.          
+00004c70: 2020 2320 6372 6561 7465 206f 7572 206f    # create our o
+00004c80: 776e 2068 616e 646c 6520 666f 7220 7468  wn handle for th
+00004c90: 6520 6669 6775 7265 2f70 6c6f 740a 2020  e figure/plot.  
+00004ca0: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
+00004cb0: 7428 2763 7265 6174 696e 6720 6e65 7720  t('creating new 
+00004cc0: 6669 6775 7265 2061 6e64 2061 7865 7320  figure and axes 
+00004cd0: 666f 7220 6361 6d65 7261 2729 0a20 2020  for camera').   
+00004ce0: 2020 2020 2020 2020 2066 6967 2c20 6178           fig, ax
+00004cf0: 203d 2070 6c74 2e73 7562 706c 6f74 7328   = plt.subplots(
+00004d00: 2920 2023 2054 4f44 4f20 2a61 7267 732c  )  # TODO *args,
+00004d10: 202a 2a6b 7761 7267 733f 0a20 2020 2020   **kwargs?.     
+00004d20: 2020 2023 2054 4f44 4f20 656c 6966 2061     # TODO elif a
+00004d30: 7820 6973 2061 2070 6c6f 7420 6861 6e64  x is a plot hand
+00004d40: 6c65 2c20 656c 7365 2072 6169 7365 2056  le, else raise V
+00004d50: 616c 7565 4572 726f 720a 2020 2020 2020  alueError.      
+00004d60: 2020 7365 6c66 2e5f 6178 203d 2061 780a    self._ax = ax.
+00004d70: 2020 2020 2020 2020 7365 6c66 2e5f 6669          self._fi
+00004d80: 6720 3d20 6669 670a 2020 2020 2020 2020  g = fig.        
+00004d90: 7265 7475 726e 2046 616c 7365 0a0a 2020  return False..  
+00004da0: 2020 6465 6620 5f69 6e69 745f 696d 6167    def _init_imag
+00004db0: 6570 6c61 6e65 2873 656c 662c 2066 6967  eplane(self, fig
+00004dc0: 3d4e 6f6e 652c 2061 783d 4e6f 6e65 293a  =None, ax=None):
+00004dd0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00004de0: 2020 2020 2043 7265 6174 6520 706c 6f74       Create plot
+00004df0: 2077 696e 646f 7720 666f 7220 6361 6d65   window for came
+00004e00: 7261 2069 6d61 6765 2070 6c61 6e65 0a0a  ra image plane..
+00004e10: 2020 2020 2020 2020 3a70 6172 616d 2066          :param f
+00004e20: 6967 3a20 6669 6775 7265 2074 6f20 706c  ig: figure to pl
+00004e30: 6f74 2069 6e74 6f2c 2064 6566 6175 6c74  ot into, default
+00004e40: 7320 746f 204e 6f6e 650a 2020 2020 2020  s to None.      
+00004e50: 2020 3a74 7970 6520 6669 673a 2066 6967    :type fig: fig
+00004e60: 7572 6520 6861 6e64 6c65 2c20 6f70 7469  ure handle, opti
+00004e70: 6f6e 616c 0a20 2020 2020 2020 203a 7061  onal.        :pa
+00004e80: 7261 6d20 6178 3a20 6178 6973 2074 6f20  ram ax: axis to 
+00004e90: 706c 6f74 2069 6e74 6f2c 2064 6566 6175  plot into, defau
+00004ea0: 6c74 7320 746f 204e 6f6e 650a 2020 2020  lts to None.    
+00004eb0: 2020 2020 3a74 7970 6520 6178 3a20 3244      :type ax: 2D
+00004ec0: 2061 7869 7320 6861 6e64 6c65 2c20 6f70   axis handle, op
+00004ed0: 7469 6f6e 616c 0a20 2020 2020 2020 203a  tional.        :
+00004ee0: 7265 7475 726e 3a20 6669 6775 7265 2061  return: figure a
+00004ef0: 6e64 2061 7869 730a 2020 2020 2020 2020  nd axis.        
+00004f00: 3a72 7479 7065 3a20 2866 6967 2c20 6178  :rtype: (fig, ax
+00004f10: 6973 290a 0a20 2020 2020 2020 2043 7265  is)..        Cre
+00004f20: 6174 6573 2061 2032 4420 6178 6973 2074  ates a 2D axis t
+00004f30: 6861 7420 7265 7072 6573 656e 7473 2074  hat represents t
+00004f40: 6865 2069 6d61 6765 2070 6c61 6e65 206f  he image plane o
+00004f50: 6620 7468 6520 7669 7274 7561 6c0a 2020  f the virtual.  
+00004f60: 2020 2020 2020 6361 6d65 7261 2e0a 0a20        camera... 
+00004f70: 2020 2020 2020 203a 7365 6561 6c73 6f3a         :seealso:
+00004f80: 203a 6d65 7468 3a60 706c 6f74 6020 3a6d   :meth:`plot` :m
+00004f90: 6574 683a 606d 6573 6860 0a20 2020 2020  eth:`mesh`.     
+00004fa0: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+00004fb0: 6620 7365 6c66 2e5f 6e65 775f 696d 6167  f self._new_imag
+00004fc0: 6570 6c61 6e65 2866 6967 2c20 6178 293a  eplane(fig, ax):
+00004fd0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00004fe0: 7572 6e20 7365 6c66 2e5f 6178 0a0a 2020  urn self._ax..  
+00004ff0: 2020 2020 2020 6178 203d 2073 656c 662e        ax = self.
+00005000: 5f61 780a 0a20 2020 2020 2020 2069 6620  _ax..        if 
+00005010: 7365 6c66 2e5f 696d 6167 6520 6973 206e  self._image is n
+00005020: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+00005030: 2020 2020 2023 2069 6620 6361 6d65 7261       # if camera
+00005040: 2068 6173 2061 6e20 696d 6167 652c 2064   has an image, d
+00005050: 6973 706c 6179 2073 6169 6420 696d 6167  isplay said imag
+00005060: 650a 2020 2020 2020 2020 2020 2020 6964  e.            id
+00005070: 6973 7028 7365 6c66 2e5f 696d 6167 652c  isp(self._image,
+00005080: 2066 6967 3d66 6967 2c20 6178 3d61 782c   fig=fig, ax=ax,
+00005090: 2074 6974 6c65 3d73 656c 662e 5f6e 616d   title=self._nam
+000050a0: 652c 2064 7261 776f 6e6c 793d 5472 7565  e, drawonly=True
+000050b0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+000050c0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+000050d0: 656c 662e 6c69 6d69 7473 2069 7320 4e6f  elf.limits is No
+000050e0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+000050f0: 2020 2020 6178 2e73 6574 5f78 6c69 6d28      ax.set_xlim(
+00005100: 302c 2073 656c 662e 6e75 290a 2020 2020  0, self.nu).    
+00005110: 2020 2020 2020 2020 2020 2020 6178 2e73              ax.s
+00005120: 6574 5f79 6c69 6d28 302c 2073 656c 662e  et_ylim(0, self.
+00005130: 6e76 290a 2020 2020 2020 2020 2020 2020  nv).            
+00005140: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00005150: 2020 2020 2020 6178 2e73 6574 5f78 6c69        ax.set_xli
+00005160: 6d28 7365 6c66 2e6c 696d 6974 735b 305d  m(self.limits[0]
+00005170: 2c20 7365 6c66 2e6c 696d 6974 735b 315d  , self.limits[1]
+00005180: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00005190: 2020 6178 2e73 6574 5f79 6c69 6d28 7365    ax.set_ylim(se
+000051a0: 6c66 2e6c 696d 6974 735b 325d 2c20 7365  lf.limits[2], se
+000051b0: 6c66 2e6c 696d 6974 735b 335d 290a 2020  lf.limits[3]).  
+000051c0: 2020 2020 2020 2020 2020 6178 2e61 7574            ax.aut
+000051d0: 6f73 6361 6c65 2846 616c 7365 290a 2020  oscale(False).  
+000051e0: 2020 2020 2020 2020 2020 6178 2e73 6574            ax.set
+000051f0: 5f61 7370 6563 7428 2265 7175 616c 2229  _aspect("equal")
+00005200: 0a20 2020 2020 2020 2020 2020 2061 782e  .            ax.
+00005210: 696e 7665 7274 5f79 6178 6973 2829 0a20  invert_yaxis(). 
+00005220: 2020 2020 2020 2020 2020 2061 782e 6772             ax.gr
+00005230: 6964 2854 7275 6529 0a20 2020 2020 2020  id(True).       
+00005240: 2020 2020 2069 6620 7365 6c66 2e6c 6162       if self.lab
+00005250: 656c 7320 6973 204e 6f6e 653a 0a20 2020  els is None:.   
+00005260: 2020 2020 2020 2020 2020 2020 2061 782e               ax.
+00005270: 7365 745f 786c 6162 656c 2822 7520 2870  set_xlabel("u (p
+00005280: 6978 656c 7329 2229 0a20 2020 2020 2020  ixels)").       
+00005290: 2020 2020 2020 2020 2061 782e 7365 745f           ax.set_
+000052a0: 796c 6162 656c 2822 7620 2870 6978 656c  ylabel("v (pixel
+000052b0: 7329 2229 0a20 2020 2020 2020 2020 2020  s)").           
+000052c0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000052d0: 2020 2020 2020 2061 782e 7365 745f 786c         ax.set_xl
+000052e0: 6162 656c 2873 656c 662e 6c61 6265 6c73  abel(self.labels
+000052f0: 5b30 5d29 0a20 2020 2020 2020 2020 2020  [0]).           
+00005300: 2020 2020 2061 782e 7365 745f 796c 6162       ax.set_ylab
+00005310: 656c 2873 656c 662e 6c61 6265 6c73 5b31  el(self.labels[1
+00005320: 5d29 0a20 2020 2020 2020 2020 2020 2061  ]).            a
+00005330: 782e 7365 745f 7469 746c 6528 7365 6c66  x.set_title(self
+00005340: 2e6e 616d 6529 0a20 2020 2020 2020 2020  .name).         
+00005350: 2020 2061 782e 7365 745f 6661 6365 636f     ax.set_faceco
+00005360: 6c6f 7228 226c 6967 6874 7965 6c6c 6f77  lor("lightyellow
+00005370: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
+00005380: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+00005390: 2020 2020 2061 782e 6669 6775 7265 2e63       ax.figure.c
+000053a0: 616e 7661 732e 6d61 6e61 6765 722e 7365  anvas.manager.se
+000053b0: 745f 7769 6e64 6f77 5f74 6974 6c65 280a  t_window_title(.
+000053c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000053d0: 2020 2020 224d 6163 6869 6e65 2056 6973      "Machine Vis
+000053e0: 696f 6e20 546f 6f6c 626f 7820 666f 7220  ion Toolbox for 
+000053f0: 5079 7468 6f6e 220a 2020 2020 2020 2020  Python".        
+00005400: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00005410: 2020 2020 2020 6578 6365 7074 2041 7474        except Att
+00005420: 7269 6275 7465 4572 726f 723a 0a20 2020  ributeError:.   
+00005430: 2020 2020 2020 2020 2020 2020 2023 2063               # c
+00005440: 616e 2068 6170 7065 6e20 6475 7269 6e67  an happen during
+00005450: 2075 6e69 7420 7465 7374 2077 6974 686f   unit test witho
+00005460: 7574 2047 5549 0a20 2020 2020 2020 2020  ut GUI.         
+00005470: 2020 2020 2020 2070 6173 730a 0a20 2020         pass..   
+00005480: 2020 2020 2023 2054 4f44 4f20 6669 6775       # TODO figu
+00005490: 7265 206f 7574 2061 7865 7320 7469 636b  re out axes tick
+000054a0: 732c 2065 7463 0a20 2020 2020 2020 2072  s, etc.        r
+000054b0: 6574 7572 6e20 6178 2020 2320 6c69 6b65  eturn ax  # like
+000054c0: 6c79 2074 6869 7320 7265 7475 726e 2069  ly this return i
+000054d0: 7320 6e6f 7420 6e65 6365 7373 6172 790a  s not necessary.
+000054e0: 0a20 2020 2064 6566 2063 6c66 2873 656c  .    def clf(sel
+000054f0: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
+00005500: 2020 2020 2020 2020 436c 6561 7220 7468          Clear th
+00005510: 6520 7669 7274 7561 6c20 696d 6167 6520  e virtual image 
+00005520: 706c 616e 6520 2862 6173 6520 6d65 7468  plane (base meth
+00005530: 6f64 290a 0a20 2020 2020 2020 2045 7665  od)..        Eve
+00005540: 7279 2063 616d 6572 6120 6f62 6a65 6374  ry camera object
+00005550: 2068 6173 2061 2076 6972 7475 616c 2069   has a virtual i
+00005560: 6d61 6765 2070 6c61 6e65 2064 7261 776e  mage plane drawn
+00005570: 2075 7369 6e67 204d 6174 706c 6f74 6c69   using Matplotli
+00005580: 622e 0a20 2020 2020 2020 2052 656d 6f76  b..        Remov
+00005590: 6520 616c 6c20 706f 696e 7473 2061 6e64  e all points and
+000055a0: 206c 696e 6573 2066 726f 6d20 7468 6520   lines from the 
+000055b0: 696d 6167 6520 706c 616e 652e 0a0a 2020  image plane...  
+000055c0: 2020 2020 2020 3a73 6565 616c 736f 3a20        :seealso: 
+000055d0: 3a6d 6574 683a 6070 6c6f 745f 706f 696e  :meth:`plot_poin
+000055e0: 7460 203a 6d65 7468 3a60 706c 6f74 5f6c  t` :meth:`plot_l
+000055f0: 696e 6560 203a 6d65 7468 3a60 6469 7370  ine` :meth:`disp
+00005600: 600a 2020 2020 2020 2020 2222 220a 2020  `.        """.  
+00005610: 2020 2020 2020 6966 2073 656c 662e 5f61        if self._a
+00005620: 7820 6973 206e 6f74 204e 6f6e 653a 0a20  x is not None:. 
+00005630: 2020 2020 2020 2020 2020 2066 6f72 2061             for a
+00005640: 7274 6973 7420 696e 2073 656c 662e 5f61  rtist in self._a
+00005650: 782e 6765 745f 6368 696c 6472 656e 2829  x.get_children()
+00005660: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005670: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+00005680: 2020 2020 2020 2020 2020 2061 7274 6973             artis
+00005690: 742e 7265 6d6f 7665 2829 0a20 2020 2020  t.remove().     
+000056a0: 2020 2020 2020 2020 2020 2065 7863 6570             excep
+000056b0: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+000056c0: 2020 2020 2020 2070 6173 730a 0a20 2020         pass..   
+000056d0: 2064 6566 2070 6c6f 745f 706f 696e 7428   def plot_point(
+000056e0: 0a20 2020 2020 2020 2073 656c 662c 2050  .        self, P
+000056f0: 2c20 2a66 6d74 2c20 7265 7475 726e 5f61  , *fmt, return_a
+00005700: 7274 6973 743d 4661 6c73 652c 206f 626a  rtist=False, obj
+00005710: 706f 7365 3d4e 6f6e 652c 2070 6f73 653d  pose=None, pose=
+00005720: 4e6f 6e65 2c20 6178 3d4e 6f6e 652c 202a  None, ax=None, *
+00005730: 2a6b 7761 7267 730a 2020 2020 293a 0a20  *kwargs.    ):. 
+00005740: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00005750: 2020 2050 6c6f 7420 706f 696e 7473 206f     Plot points o
+00005760: 6e20 7669 7274 7561 6c20 696d 6167 6520  n virtual image 
+00005770: 706c 616e 6520 2862 6173 6520 6d65 7468  plane (base meth
+00005780: 6f64 290a 0a20 2020 2020 2020 203a 7061  od)..        :pa
+00005790: 7261 6d20 503a 2033 4420 776f 726c 6420  ram P: 3D world 
+000057a0: 706f 696e 7420 6f72 2070 6f69 6e74 732c  point or points,
+000057b0: 206f 7220 3244 2069 6d61 6765 2070 6c61   or 2D image pla
+000057c0: 6e65 2070 6f69 6e74 206f 7220 706f 696e  ne point or poin
+000057d0: 7473 0a20 2020 2020 2020 203a 7479 7065  ts.        :type
+000057e0: 2050 3a20 6e64 6172 7261 7928 332c 292c   P: ndarray(3,),
+000057f0: 206e 6461 7272 6179 2833 2c4e 292c 206f   ndarray(3,N), o
+00005800: 7220 6e64 6172 7261 7928 322c 292c 206e  r ndarray(2,), n
+00005810: 6461 7272 6179 2832 2c4e 290a 2020 2020  darray(2,N).    
+00005820: 2020 2020 3a70 6172 616d 206f 626a 706f      :param objpo
+00005830: 7365 3a20 7472 616e 7366 6f72 6d61 7469  se: transformati
+00005840: 6f6e 2066 6f72 2074 6865 2033 4420 706f  on for the 3D po
+00005850: 696e 7473 2c20 6465 6661 756c 7473 2074  ints, defaults t
+00005860: 6f20 4e6f 6e65 0a20 2020 2020 2020 203a  o None.        :
+00005870: 7479 7065 206f 626a 706f 7365 3a20 3a63  type objpose: :c
+00005880: 6c61 7373 3a60 7e73 7061 7469 616c 6d61  lass:`~spatialma
+00005890: 7468 2e2e 706f 7365 3364 2e53 4533 602c  th..pose3d.SE3`,
+000058a0: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
+000058b0: 2020 3a70 6172 616d 2070 6f73 653a 2070    :param pose: p
+000058c0: 6f73 6520 6f66 2074 6865 2063 616d 6572  ose of the camer
+000058d0: 612c 2064 6566 6175 6c74 7320 746f 204e  a, defaults to N
+000058e0: 6f6e 650a 2020 2020 2020 2020 3a74 7970  one.        :typ
+000058f0: 6520 706f 7365 3a20 3a63 6c61 7373 3a60  e pose: :class:`
+00005900: 7e73 7061 7469 616c 6d61 7468 2e2e 706f  ~spatialmath..po
+00005910: 7365 3364 2e53 4533 602c 206f 7074 696f  se3d.SE3`, optio
+00005920: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
+00005930: 616d 2061 783a 2061 7865 7320 746f 2070  am ax: axes to p
+00005940: 6c6f 7420 696e 746f 0a20 2020 2020 2020  lot into.       
+00005950: 203a 7479 7065 2061 783a 203a 636c 6173   :type ax: :clas
+00005960: 733a 606d 6174 706c 6f74 6c69 622e 6178  s:`matplotlib.ax
+00005970: 6573 600a 2020 2020 2020 2020 3a70 6172  es`.        :par
+00005980: 616d 206b 7761 7267 733a 2061 6464 6974  am kwargs: addit
+00005990: 696f 6e61 6c20 6172 6775 6d65 6e74 7320  ional arguments 
+000059a0: 7061 7373 6564 2074 6f20 3a6f 626a 3a60  passed to :obj:`
+000059b0: 7e6d 6174 706c 6f74 6c69 622e 7079 706c  ~matplotlib.pypl
+000059c0: 6f74 2e70 6c6f 7460 0a20 2020 2020 2020  ot.plot`.       
+000059d0: 203a 7265 7475 726e 3a20 4d61 7470 6c6f   :return: Matplo
+000059e0: 746c 6962 206c 696e 6520 6f62 6a65 6374  tlib line object
+000059f0: 730a 2020 2020 2020 2020 3a72 7479 7065  s.        :rtype
+00005a00: 3a20 6c69 7374 206f 6620 3a63 6c61 7373  : list of :class
+00005a10: 3a60 7e6d 6174 706c 6f74 6c69 622e 6c69  :`~matplotlib.li
+00005a20: 6e65 732e 4c69 6e65 3264 600a 0a20 2020  nes.Line2d`..   
+00005a30: 2020 2020 2033 4420 776f 726c 6420 706f       3D world po
+00005a40: 696e 7473 2061 7265 2066 6972 7374 2070  ints are first p
+00005a50: 726f 6a65 6374 6564 2074 6f20 7468 6520  rojected to the 
+00005a60: 696d 6167 6520 706c 616e 6520 616e 6420  image plane and 
+00005a70: 7468 656e 0a20 2020 2020 2020 2070 6c6f  then.        plo
+00005a80: 7474 6564 206f 6e20 7468 6520 6361 6d65  tted on the came
+00005a90: 7261 2773 2076 6972 7475 616c 2069 6d61  ra's virtual ima
+00005aa0: 6765 2070 6c61 6e65 2e0a 2020 2020 2020  ge plane..      
+00005ab0: 2020 506f 696e 7473 2061 7265 206f 7267    Points are org
+00005ac0: 616e 697a 6564 2061 7320 636f 6c75 6d6e  anized as column
+00005ad0: 7320 6f66 2074 6865 2061 7272 6179 732e  s of the arrays.
+00005ae0: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
+00005af0: 653a 3a0a 0a20 2020 2020 2020 2020 2020  e::..           
+00005b00: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
+00005b10: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
+00005b20: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
+00005b30: 6572 610a 2020 2020 2020 2020 2020 2020  era.            
+00005b40: 3e3e 3e20 6672 6f6d 2073 7061 7469 616c  >>> from spatial
+00005b50: 6d61 7468 2069 6d70 6f72 7420 5345 330a  math import SE3.
+00005b60: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00005b70: 6361 6d65 7261 203d 2043 656e 7472 616c  camera = Central
+00005b80: 4361 6d65 7261 2e44 6566 6175 6c74 2829  Camera.Default()
+00005b90: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00005ba0: 2063 616d 6572 612e 706c 6f74 5f70 6f69   camera.plot_poi
+00005bb0: 6e74 285b 302e 322c 2030 2e33 2c20 325d  nt([0.2, 0.3, 2]
+00005bc0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+00005bd0: 3e20 6361 6d65 7261 2e70 6c6f 745f 706f  > camera.plot_po
+00005be0: 696e 7428 5b30 2e32 2c20 302e 332c 2032  int([0.2, 0.3, 2
+00005bf0: 5d2c 2027 722a 2729 0a20 2020 2020 2020  ], 'r*').       
+00005c00: 2020 2020 203e 3e3e 2063 616d 6572 612e       >>> camera.
+00005c10: 706c 6f74 5f70 6f69 6e74 285b 302e 322c  plot_point([0.2,
+00005c20: 2030 2e33 2c20 325d 2c20 706f 7365 3d53   0.3, 2], pose=S
+00005c30: 4533 2830 2e31 2c20 302c 2030 2929 0a0a  E3(0.1, 0, 0))..
+00005c40: 2020 2020 2020 2020 2e2e 2070 6c6f 743a          .. plot:
+00005c50: 3a0a 0a20 2020 2020 2020 2020 2020 2066  :..            f
+00005c60: 726f 6d20 6d61 6368 696e 6576 6973 696f  rom machinevisio
+00005c70: 6e74 6f6f 6c62 6f78 2069 6d70 6f72 7420  ntoolbox import 
+00005c80: 4365 6e74 7261 6c43 616d 6572 610a 2020  CentralCamera.  
+00005c90: 2020 2020 2020 2020 2020 6672 6f6d 2073            from s
+00005ca0: 7061 7469 616c 6d61 7468 2069 6d70 6f72  patialmath impor
+00005cb0: 7420 5345 330a 2020 2020 2020 2020 2020  t SE3.          
+00005cc0: 2020 6361 6d65 7261 203d 2043 656e 7472    camera = Centr
+00005cd0: 616c 4361 6d65 7261 2e44 6566 6175 6c74  alCamera.Default
+00005ce0: 2829 0a20 2020 2020 2020 2020 2020 2063  ().            c
+00005cf0: 616d 6572 612e 706c 6f74 5f70 6f69 6e74  amera.plot_point
+00005d00: 285b 302e 322c 2030 2e33 2c20 325d 290a  ([0.2, 0.3, 2]).
+00005d10: 2020 2020 2020 2020 2020 2020 6361 6d65              came
+00005d20: 7261 2e70 6c6f 745f 706f 696e 7428 5b30  ra.plot_point([0
+00005d30: 2e32 2c20 302e 332c 2032 5d2c 2027 722a  .2, 0.3, 2], 'r*
+00005d40: 2729 0a20 2020 2020 2020 2020 2020 2063  ').            c
+00005d50: 616d 6572 612e 706c 6f74 5f70 6f69 6e74  amera.plot_point
+00005d60: 285b 302e 322c 2030 2e33 2c20 325d 2c20  ([0.2, 0.3, 2], 
+00005d70: 706f 7365 3d53 4533 2830 2e31 2c20 302c  pose=SE3(0.1, 0,
+00005d80: 2030 2929 0a0a 2020 2020 2020 2020 3a6e   0))..        :n
+00005d90: 6f74 653a 0a20 2020 2020 2020 2020 2020  ote:.           
+00005da0: 202d 2053 7563 6365 7373 6976 6520 6361   - Successive ca
+00005db0: 6c6c 7320 6164 6420 6974 656d 7320 746f  lls add items to
+00005dc0: 2074 6865 2076 6972 7475 616c 2069 6d61   the virtual ima
+00005dd0: 6765 2070 6c61 6e65 2e0a 2020 2020 2020  ge plane..      
+00005de0: 2020 2020 2020 2d20 5468 6973 206d 6574        - This met
+00005df0: 686f 6420 6973 2063 6f6d 6d6f 6e20 746f  hod is common to
+00005e00: 2061 6c6c 2060 6043 616d 6572 6142 6173   all ``CameraBas
+00005e10: 6560 6020 7375 6263 6c61 7373 6573 2c20  e`` subclasses, 
+00005e20: 6275 7420 6974 0a20 2020 2020 2020 2020  but it.         
+00005e30: 2020 2020 2069 6e76 6f6b 6573 2061 2063       invokes a c
+00005e40: 616d 6572 612d 7370 6563 6966 6963 2070  amera-specific p
+00005e50: 726f 6a65 6374 696f 6e20 6d65 7468 6f64  rojection method
+00005e60: 2e0a 0a20 2020 2020 2020 203a 7365 6561  ...        :seea
+00005e70: 6c73 6f3a 203a 6d65 7468 3a60 706c 6f74  lso: :meth:`plot
+00005e80: 5f6c 696e 6532 6020 3a6d 6574 683a 6070  _line2` :meth:`p
+00005e90: 6c6f 745f 6c69 6e65 3360 203a 6d65 7468  lot_line3` :meth
+00005ea0: 3a60 706c 6f74 5f77 6972 6566 7261 6d65  :`plot_wireframe
+00005eb0: 6020 3a6d 6574 683a 6063 6c66 600a 2020  ` :meth:`clf`.  
+00005ec0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00005ed0: 2020 7365 6c66 2e5f 696e 6974 5f69 6d61    self._init_ima
+00005ee0: 6765 706c 616e 6528 6178 290a 0a20 2020  geplane(ax)..   
+00005ef0: 2020 2020 2069 6620 6e6f 7420 6973 696e       if not isin
+00005f00: 7374 616e 6365 2850 2c20 6e70 2e6e 6461  stance(P, np.nda
+00005f10: 7272 6179 293a 0a20 2020 2020 2020 2020  rray):.         
+00005f20: 2020 2050 203d 2062 6173 652e 6765 7476     P = base.getv
+00005f30: 6563 746f 7228 5029 0a0a 2020 2020 2020  ector(P)..      
+00005f40: 2020 6966 2050 2e73 6861 7065 5b30 5d20    if P.shape[0] 
+00005f50: 3d3d 2033 3a0a 2020 2020 2020 2020 2020  == 3:.          
+00005f60: 2020 2320 706c 6f74 2077 6f72 6c64 2070    # plot world p
+00005f70: 6f69 6e74 730a 2020 2020 2020 2020 2020  oints.          
+00005f80: 2020 7020 3d20 7365 6c66 2e70 726f 6a65    p = self.proje
+00005f90: 6374 5f70 6f69 6e74 2850 2c20 706f 7365  ct_point(P, pose
+00005fa0: 3d70 6f73 652c 206f 626a 706f 7365 3d6f  =pose, objpose=o
+00005fb0: 626a 706f 7365 290a 2020 2020 2020 2020  bjpose).        
+00005fc0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00005fd0: 2020 2320 706c 6f74 2069 6d61 6765 2070    # plot image p
+00005fe0: 6c61 6e65 2070 6f69 6e74 730a 2020 2020  lane points.    
+00005ff0: 2020 2020 2020 2020 7020 3d20 500a 0a20          p = P.. 
+00006000: 2020 2020 2020 2069 6620 702e 7368 6170         if p.shap
+00006010: 655b 305d 2021 3d20 323a 0a20 2020 2020  e[0] != 2:.     
+00006020: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+00006030: 7565 4572 726f 7228 2270 206d 7573 7420  ueError("p must 
+00006040: 6861 7665 2062 6520 2832 2c29 2c20 2833  have be (2,), (3
+00006050: 2c29 2c20 2832 2c6e 292c 2028 332c 6e29  ,), (2,n), (3,n)
+00006060: 2229 0a0a 2020 2020 2020 2020 6465 6661  ")..        defa
+00006070: 756c 7473 203d 2064 6963 7428 6d61 726b  ults = dict(mark
+00006080: 6572 7369 7a65 3d36 2c20 636f 6c6f 723d  ersize=6, color=
+00006090: 226b 2229 0a20 2020 2020 2020 2069 6620  "k").        if 
+000060a0: 6c65 6e28 666d 7429 203d 3d20 303a 0a20  len(fmt) == 0:. 
+000060b0: 2020 2020 2020 2020 2020 2066 6d74 203d             fmt =
+000060c0: 205b 226f 225d 0a20 2020 2020 2020 2020   ["o"].         
+000060d0: 2020 206b 7761 7267 7320 3d20 7b2a 2a64     kwargs = {**d
+000060e0: 6566 6175 6c74 732c 202a 2a6b 7761 7267  efaults, **kwarg
+000060f0: 737d 0a0a 2020 2020 2020 2020 6172 7469  s}..        arti
+00006100: 7374 203d 2073 656c 662e 5f61 782e 706c  st = self._ax.pl
+00006110: 6f74 2870 5b30 2c20 3a5d 2c20 705b 312c  ot(p[0, :], p[1,
+00006120: 203a 5d2c 202a 666d 742c 202a 2a6b 7761   :], *fmt, **kwa
+00006130: 7267 7329 0a20 2020 2020 2020 2069 6620  rgs).        if 
+00006140: 706c 742e 6973 696e 7465 7261 6374 6976  plt.isinteractiv
+00006150: 6528 293a 0a20 2020 2020 2020 2020 2020  e():.           
+00006160: 2070 6c74 2e73 686f 7728 626c 6f63 6b3d   plt.show(block=
+00006170: 4661 6c73 6529 0a0a 2020 2020 2020 2020  False)..        
+00006180: 6966 2072 6574 7572 6e5f 6172 7469 7374  if return_artist
+00006190: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000061a0: 7475 726e 2070 2c20 6172 7469 7374 5b30  turn p, artist[0
+000061b0: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
+000061c0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000061d0: 726e 2070 0a0a 2020 2020 6465 6620 706c  rn p..    def pl
+000061e0: 6f74 5f6c 696e 6532 2873 656c 662c 206c  ot_line2(self, l
+000061f0: 2c20 2a61 7267 732c 202a 2a6b 7761 7267  , *args, **kwarg
+00006200: 7329 3a0a 2020 2020 2020 2020 7222 2222  s):.        r"""
+00006210: 0a20 2020 2020 2020 2050 6c6f 7420 3244  .        Plot 2D
+00006220: 206c 696e 6520 6f6e 2076 6972 7475 616c   line on virtual
+00006230: 2069 6d61 6765 2070 6c61 6e65 2028 6261   image plane (ba
+00006240: 7365 206d 6574 686f 6429 0a0a 2020 2020  se method)..    
+00006250: 2020 2020 3a70 6172 616d 206c 3a20 686f      :param l: ho
+00006260: 6d6f 6765 6e65 6f75 7320 6c69 6e65 0a20  mogeneous line. 
+00006270: 2020 2020 2020 203a 7479 7065 206c 3a20         :type l: 
+00006280: 6172 7261 795f 6c69 6b65 2833 290a 2020  array_like(3).  
+00006290: 2020 2020 2020 3a70 6172 616d 206b 7761        :param kwa
+000062a0: 7267 733a 2061 7267 756d 656e 7473 2070  rgs: arguments p
+000062b0: 6173 7365 6420 746f 2060 6070 6c6f 7460  assed to ``plot`
+000062c0: 600a 0a20 2020 2020 2020 2050 6c6f 7420  `..        Plot 
+000062d0: 7468 6520 686f 6d6f 6765 6e65 6f75 7320  the homogeneous 
+000062e0: 6c69 6e65 206f 6e20 7468 6520 6361 6d65  line on the came
+000062f0: 7261 2773 2076 6972 7475 616c 2069 6d61  ra's virtual ima
+00006300: 6765 2070 6c61 6e65 2e20 5468 6520 6c69  ge plane. The li
+00006310: 6e65 0a20 2020 2020 2020 2069 7320 6578  ne.        is ex
+00006320: 7072 6573 7365 6420 696e 2074 6865 2066  pressed in the f
+00006330: 6f72 6d0a 0a20 2020 2020 2020 202e 2e20  orm..        .. 
+00006340: 6d61 7468 3a3a 205c 656c 6c5f 3020 7520  math:: \ell_0 u 
+00006350: 2b20 5c65 6c6c 5f31 2076 202b 205c 656c  + \ell_1 v + \el
+00006360: 6c5f 3220 3d20 300a 0a20 2020 2020 2020  l_2 = 0..       
+00006370: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
+00006380: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
+00006390: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
+000063a0: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
+000063b0: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
+000063c0: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
+000063d0: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
+000063e0: 2020 203e 3e3e 2063 616d 6572 6120 3d20     >>> camera = 
+000063f0: 4365 6e74 7261 6c43 616d 6572 612e 4465  CentralCamera.De
+00006400: 6661 756c 7428 290a 2020 2020 2020 2020  fault().        
+00006410: 2020 2020 3e3e 3e20 6361 6d65 7261 2e70      >>> camera.p
+00006420: 6c6f 745f 6c69 6e65 3228 5b31 2c20 302e  lot_line2([1, 0.
+00006430: 322c 202d 3530 305d 290a 0a20 2020 2020  2, -500])..     
+00006440: 2020 203a 6e6f 7465 3a0a 2020 2020 2020     :note:.      
+00006450: 2020 2020 2020 2d20 5375 6363 6573 7369        - Successi
+00006460: 7665 2063 616c 6c73 2061 6464 2069 7465  ve calls add ite
+00006470: 6d73 2074 6f20 7468 6520 7669 7274 7561  ms to the virtua
+00006480: 6c20 696d 6167 6520 706c 616e 652e 0a20  l image plane.. 
+00006490: 2020 2020 2020 2020 2020 202d 2054 6869             - Thi
+000064a0: 7320 6d65 7468 6f64 2069 7320 636f 6d6d  s method is comm
+000064b0: 6f6e 2074 6f20 616c 6c20 6060 4361 6d65  on to all ``Came
+000064c0: 7261 4261 7365 6060 2073 7562 636c 6173  raBase`` subclas
+000064d0: 7365 732c 2062 7574 2069 740a 2020 2020  ses, but it.    
+000064e0: 2020 2020 2020 2020 2020 696e 766f 6b65            invoke
+000064f0: 7320 6120 6361 6d65 7261 2d73 7065 6369  s a camera-speci
+00006500: 6669 6320 7072 6f6a 6563 7469 6f6e 206d  fic projection m
+00006510: 6574 686f 642e 0a0a 2020 2020 2020 2020  ethod...        
+00006520: 3a73 6565 616c 736f 3a20 3a6d 6574 683a  :seealso: :meth:
+00006530: 6070 6c6f 745f 706f 696e 7460 203a 6d65  `plot_point` :me
+00006540: 7468 3a60 706c 6f74 5f6c 696e 6533 6020  th:`plot_line3` 
+00006550: 3a6d 6574 683a 6063 6c66 600a 2020 2020  :meth:`clf`.    
+00006560: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00006570: 2320 6765 7420 6861 6e64 6c65 2066 6f72  # get handle for
+00006580: 2074 6869 7320 6361 6d65 7261 2069 6d61   this camera ima
+00006590: 6765 2070 6c61 6e65 0a20 2020 2020 2020  ge plane.       
+000065a0: 2073 656c 662e 5f69 6e69 745f 696d 6167   self._init_imag
+000065b0: 6570 6c61 6e65 2829 0a20 2020 2020 2020  eplane().       
+000065c0: 2070 6c74 2e61 7574 6f73 6361 6c65 2846   plt.autoscale(F
+000065d0: 616c 7365 290a 0a20 2020 2020 2020 2062  alse)..        b
+000065e0: 6173 652e 706c 6f74 5f68 6f6d 6c69 6e65  ase.plot_homline
+000065f0: 286c 2c20 2a61 7267 732c 2061 783d 7365  (l, *args, ax=se
+00006600: 6c66 2e5f 6178 2c20 2a2a 6b77 6172 6773  lf._ax, **kwargs
+00006610: 290a 0a20 2020 2023 2064 6566 2070 6c6f  )..    # def plo
+00006620: 745f 6c69 6e65 3328 7365 6c66 2c20 4c2c  t_line3(self, L,
+00006630: 206e 7374 6570 733d 3231 2c20 2a2a 6b77   nsteps=21, **kw
+00006640: 6172 6773 293a 0a20 2020 2023 2020 2020  args):.    #    
+00006650: 2022 2222 0a20 2020 2023 2020 2020 2050   """.    #     P
+00006660: 6c6f 7420 3344 206c 696e 6520 6f6e 2076  lot 3D line on v
+00006670: 6972 7475 616c 2069 6d61 6765 2070 6c61  irtual image pla
+00006680: 6e65 2028 6261 7365 206d 6574 686f 6429  ne (base method)
+00006690: 0a0a 2020 2020 2320 2020 2020 3a70 6172  ..    #     :par
+000066a0: 616d 204c 3a20 3344 206c 696e 6520 6f72  am L: 3D line or
+000066b0: 206c 696e 6573 2069 6e20 506c 7563 6b65   lines in Plucke
+000066c0: 7220 636f 6f72 6469 6e61 7465 730a 2020  r coordinates.  
+000066d0: 2020 2320 2020 2020 3a74 7970 6520 4c3a    #     :type L:
+000066e0: 203a 636c 6173 733a 607e 7370 6174 6961   :class:`~spatia
+000066f0: 6c6d 6174 682e 2e67 656f 6d33 642e 4c69  lmath..geom3d.Li
+00006700: 6e65 3360 0a20 2020 2023 2020 2020 203a  ne3`.    #     :
+00006710: 7061 7261 6d20 6b77 6172 6773 3a20 6172  param kwargs: ar
+00006720: 6775 6d65 6e74 7320 7061 7373 6564 2074  guments passed t
+00006730: 6f20 6060 706c 6f74 6060 0a0a 2020 2020  o ``plot``..    
+00006740: 2320 2020 2020 5468 6520 506c 7563 6b65  #     The Plucke
+00006750: 7220 6c69 6e65 7320 6172 6520 7072 6f6a  r lines are proj
+00006760: 6563 7465 6420 746f 2074 6865 2063 616d  ected to the cam
+00006770: 6572 6127 7320 7669 7274 7561 6c20 696d  era's virtual im
+00006780: 6167 6520 706c 616e 6520 616e 640a 2020  age plane and.  
+00006790: 2020 2320 2020 2020 706c 6f74 7465 642e    #     plotted.
+000067a0: 2020 4561 6368 206c 696e 6520 6973 2061    Each line is a
+000067b0: 7070 726f 7869 6d61 7465 6420 6279 2060  pproximated by `
+000067c0: 606e 7374 6570 7360 6020 706f 696e 7473  `nsteps`` points
+000067d0: 2c20 6561 6368 206f 6620 7768 6963 680a  , each of which.
+000067e0: 2020 2020 2320 2020 2020 6973 2070 726f      #     is pro
+000067f0: 6a65 6374 6564 2c20 616c 6c6f 7769 6e67  jected, allowing
+00006800: 2073 7472 6169 6768 7420 6c69 6e65 7320   straight lines 
+00006810: 746f 2061 7070 6561 7220 6375 7276 6564  to appear curved
+00006820: 2061 6674 6572 2070 726f 6a65 6374 696f   after projectio
+00006830: 6e2e 0a0a 2020 2020 2320 2020 2020 4578  n...    #     Ex
+00006840: 616d 706c 653a 0a0a 2020 2020 2320 2020  ample:..    #   
+00006850: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+00006860: 7079 636f 6e0a 0a20 2020 2023 2020 2020  pycon..    #    
+00006870: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
+00006880: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
+00006890: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
+000068a0: 6c43 616d 6572 612c 206d 6b63 7562 650a  lCamera, mkcube.
+000068b0: 2020 2020 2320 2020 2020 2020 2020 3e3e      #         >>
+000068c0: 3e20 6672 6f6d 2073 7061 7469 616c 6d61  > from spatialma
+000068d0: 7468 2069 6d70 6f72 7420 4c69 6e65 330a  th import Line3.
+000068e0: 2020 2020 2320 2020 2020 2020 2020 3e3e      #         >>
+000068f0: 3e20 6361 6d65 7261 203d 2043 656e 7472  > camera = Centr
+00006900: 616c 4361 6d65 7261 2829 0a20 2020 2023  alCamera().    #
+00006910: 2020 2020 2020 2020 203e 3e3e 206c 696e           >>> lin
+00006920: 6520 3d20 4c69 6e65 332e 4a6f 696e 2828  e = Line3.Join((
+00006930: 2d31 2c20 2d32 2c20 2d33 292c 2028 342c  -1, -2, -3), (4,
+00006940: 2035 2c20 3629 290a 2020 2020 2320 2020   5, 6)).    #   
+00006950: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
+00006960: 2e70 6c6f 745f 6c69 6e65 3328 6c69 6e65  .plot_line3(line
+00006970: 2c20 276b 2d2d 2729 0a0a 2020 2020 2320  , 'k--')..    # 
+00006980: 2020 2020 2e2e 206e 6f74 653a 3a0a 2020      .. note::.  
+00006990: 2020 2320 2020 2020 2020 2020 2d20 5375    #         - Su
+000069a0: 6363 6573 7369 7665 2063 616c 6c73 2061  ccessive calls a
+000069b0: 6464 2069 7465 6d73 2074 6f20 7468 6520  dd items to the 
+000069c0: 7669 7274 7561 6c20 696d 6167 6520 706c  virtual image pl
+000069d0: 616e 652e 0a20 2020 2023 2020 2020 2020  ane..    #      
+000069e0: 2020 202d 2054 6869 7320 6d65 7468 6f64     - This method
+000069f0: 2069 7320 636f 6d6d 6f6e 2074 6f20 616c   is common to al
+00006a00: 6c20 6060 4361 6d65 7261 4261 7365 6060  l ``CameraBase``
+00006a10: 2073 7562 636c 6173 7365 732c 2062 7574   subclasses, but
+00006a20: 2069 740a 2020 2020 2320 2020 2020 2020   it.    #       
+00006a30: 2020 2020 696e 766f 6b65 7320 6120 6361      invokes a ca
+00006a40: 6d65 7261 2d73 7065 6369 6669 6320 7072  mera-specific pr
+00006a50: 6f6a 6563 7469 6f6e 206d 6574 686f 642e  ojection method.
+00006a60: 0a0a 2020 2020 2320 2020 2020 3a73 6565  ..    #     :see
+00006a70: 616c 736f 3a20 3a6d 6574 683a 6070 6c6f  also: :meth:`plo
+00006a80: 745f 706f 696e 7460 203a 6d65 7468 3a60  t_point` :meth:`
+00006a90: 706c 6f74 5f6c 696e 6532 6020 3a6d 6574  plot_line2` :met
+00006aa0: 683a 6070 6c6f 745f 7769 7265 6672 616d  h:`plot_wirefram
+00006ab0: 6560 203a 6d65 7468 3a60 636c 6660 0a20  e` :meth:`clf`. 
+00006ac0: 2020 2023 2020 2020 2022 2222 0a20 2020     #     """.   
+00006ad0: 2023 2020 2020 2023 2064 7261 7720 3344   #     # draw 3D
+00006ae0: 206c 696e 6520 7365 676d 656e 7473 0a20   line segments. 
+00006af0: 2020 2023 2020 2020 2073 203d 206e 702e     #     s = np.
+00006b00: 6c69 6e73 7061 6365 2830 2c20 312c 206e  linspace(0, 1, n
+00006b10: 7374 6570 7329 0a0a 2020 2020 2320 7468  steps)..    # th
+00006b20: 6973 2069 7320 6163 7475 616c 6c79 2070  is is actually p
+00006b30: 7265 7474 7920 7472 6963 6b79 0a20 2020  retty tricky.   
+00006b40: 2023 2020 2d20 686f 7720 746f 2064 6574   #  - how to det
+00006b50: 6572 6d69 6e65 2077 6869 6368 2070 6172  ermine which par
+00006b60: 7420 6f66 2074 6865 2033 4420 6c69 6e65  t of the 3D line
+00006b70: 2069 7320 7669 7369 626c 650a 2020 2020   is visible.    
+00006b80: 2320 202d 2069 6620 6869 6768 6c79 2063  #  - if highly c
+00006b90: 7572 7665 6420 6974 206d 6179 2062 6520  urved it may be 
+00006ba0: 696e 2074 776f 206f 7220 6d6f 7265 2073  in two or more s
+00006bb0: 6567 6d65 6e74 730a 2020 2020 2320 666f  egments.    # fo
+00006bc0: 7220 6c69 6e65 2069 6e20 4c3a 0a20 2020  r line in L:.   
+00006bd0: 2023 2020 2020 206c 203d 2073 656c 662e   #     l = self.
+00006be0: 7072 6f6a 6563 745f 6c69 6e65 286c 696e  project_line(lin
+00006bf0: 6529 0a0a 2020 2020 2320 2020 2020 2320  e)..    #     # 
+00006c00: 7374 7261 6967 6874 2077 6f72 6c64 206c  straight world l
+00006c10: 696e 6573 2061 7265 206e 6f74 2073 7472  ines are not str
+00006c20: 6169 6768 742c 2070 6c6f 7420 7468 656d  aight, plot them
+00006c30: 2070 6965 6365 7769 7365 0a20 2020 2023   piecewise.    #
+00006c40: 2020 2020 2050 203d 2028 3120 2d20 7329       P = (1 - s)
+00006c50: 202a 2050 305b 3a2c 206e 702e 6e65 7761   * P0[:, np.newa
+00006c60: 7869 735d 202b 2073 202a 2050 325b 3a2c  xis] + s * P2[:,
+00006c70: 206e 702e 6e65 7761 7869 735d 0a20 2020   np.newaxis].   
+00006c80: 2023 2020 2020 2075 7620 3d20 7365 6c66   #     uv = self
+00006c90: 2e70 726f 6a65 6374 5f70 6f69 6e74 2850  .project_point(P
+00006ca0: 2c20 706f 7365 3d70 6f73 6529 0a0a 2020  , pose=pose)..  
+00006cb0: 2020 6465 6620 706c 6f74 5f77 6972 6566    def plot_wiref
+00006cc0: 7261 6d65 280a 2020 2020 2020 2020 7365  rame(.        se
+00006cd0: 6c66 2c20 582c 2059 2c20 5a2c 202a 666d  lf, X, Y, Z, *fm
+00006ce0: 742c 206f 626a 706f 7365 3d4e 6f6e 652c  t, objpose=None,
+00006cf0: 2070 6f73 653d 4e6f 6e65 2c20 6e73 7465   pose=None, nste
+00006d00: 7073 3d32 312c 202a 2a6b 7761 7267 730a  ps=21, **kwargs.
+00006d10: 2020 2020 293a 0a20 2020 2020 2020 2022      ):.        "
+00006d20: 2222 0a20 2020 2020 2020 2050 6c6f 7420  "".        Plot 
+00006d30: 3344 2077 6972 6566 7261 6d65 2069 6e20  3D wireframe in 
+00006d40: 7669 7274 7561 6c20 696d 6167 6520 706c  virtual image pl
+00006d50: 616e 6520 2862 6173 6520 6d65 7468 6f64  ane (base method
+00006d60: 290a 0a20 2020 2020 2020 203a 7061 7261  )..        :para
+00006d70: 6d20 583a 2077 6f72 6c64 2058 2063 6f6f  m X: world X coo
+00006d80: 7264 696e 6174 6573 0a20 2020 2020 2020  rdinates.       
+00006d90: 203a 7479 7065 2058 3a20 6e64 6172 7261   :type X: ndarra
+00006da0: 7928 4e2c 4d29 0a20 2020 2020 2020 203a  y(N,M).        :
+00006db0: 7061 7261 6d20 593a 2077 6f72 6c64 2059  param Y: world Y
+00006dc0: 2063 6f6f 7264 696e 6174 6573 0a20 2020   coordinates.   
+00006dd0: 2020 2020 203a 7479 7065 2059 3a20 6e64       :type Y: nd
+00006de0: 6172 7261 7928 4e2c 4d29 0a20 2020 2020  array(N,M).     
+00006df0: 2020 203a 7061 7261 6d20 5a3a 2077 6f72     :param Z: wor
+00006e00: 6c64 205a 2063 6f6f 7264 696e 6174 6573  ld Z coordinates
+00006e10: 0a20 2020 2020 2020 203a 7479 7065 205a  .        :type Z
+00006e20: 3a20 6e64 6172 7261 7928 4e2c 4d29 0a20  : ndarray(N,M). 
+00006e30: 2020 2020 2020 203a 7061 7261 6d20 6f62         :param ob
+00006e40: 6a70 6f73 653a 2074 7261 6e73 666f 726d  jpose: transform
+00006e50: 6174 696f 6e20 666f 7220 7468 6520 7769  ation for the wi
+00006e60: 7265 6672 616d 6520 706f 696e 7473 2c20  reframe points, 
+00006e70: 6465 6661 756c 7473 2074 6f20 4e6f 6e65  defaults to None
+00006e80: 0a20 2020 2020 2020 203a 7479 7065 206f  .        :type o
+00006e90: 626a 706f 7365 3a20 3a63 6c61 7373 3a60  bjpose: :class:`
+00006ea0: 7e73 7061 7469 616c 6d61 7468 2e2e 706f  ~spatialmath..po
+00006eb0: 7365 3364 2e53 4533 602c 206f 7074 696f  se3d.SE3`, optio
+00006ec0: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
+00006ed0: 616d 2070 6f73 653a 2070 6f73 6520 6f66  am pose: pose of
+00006ee0: 2074 6865 2063 616d 6572 612c 2064 6566   the camera, def
+00006ef0: 6175 6c74 7320 746f 204e 6f6e 650a 2020  aults to None.  
+00006f00: 2020 2020 2020 3a74 7970 6520 706f 7365        :type pose
+00006f10: 3a20 3a63 6c61 7373 3a60 7e73 7061 7469  : :class:`~spati
+00006f20: 616c 6d61 7468 2e2e 706f 7365 3364 2e53  almath..pose3d.S
+00006f30: 4533 602c 206f 7074 696f 6e61 6c0a 2020  E3`, optional.  
+00006f40: 2020 2020 2020 3a70 6172 616d 206e 7374        :param nst
+00006f50: 6570 733a 206e 756d 6265 7220 6f66 2070  eps: number of p
+00006f60: 6f69 6e74 7320 666f 7220 6561 6368 2077  oints for each w
+00006f70: 6972 6566 7261 6d65 2073 6567 6d65 6e74  ireframe segment
+00006f80: 2c20 6465 6661 756c 7473 2074 6f20 3231  , defaults to 21
+00006f90: 0a20 2020 2020 2020 203a 7479 7065 206e  .        :type n
+00006fa0: 7374 6570 733a 2069 6e74 2c20 6f70 7469  steps: int, opti
+00006fb0: 6f6e 616c 0a20 2020 2020 2020 203a 7061  onal.        :pa
+00006fc0: 7261 6d20 6b77 6172 6773 3a20 6172 6775  ram kwargs: argu
+00006fd0: 6d65 6e74 7320 7061 7373 6564 2074 6f20  ments passed to 
+00006fe0: 6060 706c 6f74 6060 0a0a 2020 2020 2020  ``plot``..      
+00006ff0: 2020 5468 6520 3344 2077 6972 6566 7261    The 3D wirefra
+00007000: 6d65 2069 7320 7072 6f6a 6563 7465 6420  me is projected 
+00007010: 746f 2074 6865 2063 616d 6572 6127 7320  to the camera's 
+00007020: 7669 7274 7561 6c20 696d 6167 6520 706c  virtual image pl
+00007030: 616e 652e 2020 4561 6368 0a20 2020 2020  ane.  Each.     
+00007040: 2020 2077 6972 6520 6c69 6e6b 2069 6e20     wire link in 
+00007050: 7468 6520 7769 7265 6672 616d 6520 6973  the wireframe is
+00007060: 2061 7070 726f 7869 6d61 7465 6420 6279   approximated by
+00007070: 2060 606e 7374 6570 7360 6020 706f 696e   ``nsteps`` poin
+00007080: 7473 2c20 6561 6368 206f 660a 2020 2020  ts, each of.    
+00007090: 2020 2020 7768 6963 6820 6973 2070 726f      which is pro
+000070a0: 6a65 6374 6564 2c20 616c 6c6f 7769 6e67  jected, allowing
+000070b0: 2073 7472 6169 6768 7420 6564 6765 7320   straight edges 
+000070c0: 746f 2061 7070 6561 7220 6375 7276 6564  to appear curved
+000070d0: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
+000070e0: 6c65 3a3a 0a0a 2020 2020 2020 2020 2020  le::..          
+000070f0: 2020 3e3e 3e20 6672 6f6d 206d 6163 6869    >>> from machi
+00007100: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
+00007110: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
+00007120: 6d65 7261 2c20 6d6b 6375 6265 0a20 2020  mera, mkcube.   
+00007130: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
+00007140: 6d20 7370 6174 6961 6c6d 6174 6820 696d  m spatialmath im
+00007150: 706f 7274 2053 4533 0a20 2020 2020 2020  port SE3.       
+00007160: 2020 2020 203e 3e3e 2063 616d 6572 6120       >>> camera 
+00007170: 3d20 4365 6e74 7261 6c43 616d 6572 612e  = CentralCamera.
+00007180: 4465 6661 756c 7428 290a 2020 2020 2020  Default().      
+00007190: 2020 2020 2020 3e3e 3e20 582c 2059 2c20        >>> X, Y, 
+000071a0: 5a20 3d20 6d6b 6375 6265 2830 2e32 2c20  Z = mkcube(0.2, 
+000071b0: 706f 7365 3d53 4533 2830 2c20 302c 2031  pose=SE3(0, 0, 1
+000071c0: 292c 2065 6467 653d 5472 7565 290a 2020  ), edge=True).  
+000071d0: 2020 2020 2020 2020 2020 3e3e 3e20 6361            >>> ca
+000071e0: 6d65 7261 2e70 6c6f 745f 7769 7265 6672  mera.plot_wirefr
+000071f0: 616d 6528 582c 2059 2c20 5a2c 2027 6b2d  ame(X, Y, Z, 'k-
+00007200: 2d27 290a 0a20 2020 2020 2020 202e 2e20  -')..        .. 
+00007210: 706c 6f74 3a3a 0a0a 2020 2020 2020 2020  plot::..        
+00007220: 2020 2020 6672 6f6d 206d 6163 6869 6e65      from machine
+00007230: 7669 7369 6f6e 746f 6f6c 626f 7820 696d  visiontoolbox im
+00007240: 706f 7274 2043 656e 7472 616c 4361 6d65  port CentralCame
+00007250: 7261 2c20 6d6b 6375 6265 0a20 2020 2020  ra, mkcube.     
+00007260: 2020 2020 2020 2066 726f 6d20 7370 6174         from spat
+00007270: 6961 6c6d 6174 6820 696d 706f 7274 2053  ialmath import S
+00007280: 4533 0a20 2020 2020 2020 2020 2020 2063  E3.            c
+00007290: 616d 6572 6120 3d20 4365 6e74 7261 6c43  amera = CentralC
+000072a0: 616d 6572 612e 4465 6661 756c 7428 290a  amera.Default().
+000072b0: 2020 2020 2020 2020 2020 2020 582c 2059              X, Y
+000072c0: 2c20 5a20 3d20 6d6b 6375 6265 2830 2e32  , Z = mkcube(0.2
+000072d0: 2c20 706f 7365 3d53 4533 2830 2c20 302c  , pose=SE3(0, 0,
+000072e0: 2031 292c 2065 6467 653d 5472 7565 290a   1), edge=True).
+000072f0: 2020 2020 2020 2020 2020 2020 6361 6d65              came
+00007300: 7261 2e70 6c6f 745f 7769 7265 6672 616d  ra.plot_wirefram
+00007310: 6528 582c 2059 2c20 5a2c 2027 6b2d 2d27  e(X, Y, Z, 'k--'
+00007320: 290a 0a20 2020 2020 2020 203a 7365 6561  )..        :seea
+00007330: 6c73 6f3a 203a 6675 6e63 3a60 6d6b 6375  lso: :func:`mkcu
+00007340: 6265 6020 3a6f 626a 3a60 7370 6174 6961  be` :obj:`spatia
+00007350: 6c6d 6174 682e 6261 7365 2e63 796c 696e  lmath.base.cylin
+00007360: 6465 7260 203a 6f62 6a3a 6073 7061 7469  der` :obj:`spati
+00007370: 616c 6d61 7468 2e62 6173 652e 7370 6865  almath.base.sphe
+00007380: 7265 6020 3a6f 626a 3a60 7370 6174 6961  re` :obj:`spatia
+00007390: 6c6d 6174 682e 6261 7365 2e63 7562 6f69  lmath.base.cuboi
+000073a0: 6460 0a20 2020 2020 2020 2022 2222 0a0a  d`.        """..
+000073b0: 2020 2020 2020 2020 2320 7365 6c66 2e5f          # self._
+000073c0: 6178 2e70 6c6f 745f 7375 7266 6163 6528  ax.plot_surface(
+000073d0: 582c 2059 2c20 5a29 0a20 2020 2020 2020  X, Y, Z).       
+000073e0: 2023 2070 6c74 2e73 686f 7728 290a 0a20   # plt.show().. 
+000073f0: 2020 2020 2020 2023 2063 6865 636b 2074         # check t
+00007400: 6861 7420 6d65 7368 206d 6174 7269 6365  hat mesh matrice
+00007410: 7320 636f 6e66 6f72 6d0a 2020 2020 2020  s conform.      
+00007420: 2020 6966 2058 2e73 6861 7065 2021 3d20    if X.shape != 
+00007430: 592e 7368 6170 6520 6f72 2058 2e73 6861  Y.shape or X.sha
+00007440: 7065 2021 3d20 5a2e 7368 6170 653a 0a20  pe != Z.shape:. 
+00007450: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00007460: 2056 616c 7565 4572 726f 7228 226d 6174   ValueError("mat
+00007470: 7269 6365 7320 6d75 7374 2062 6520 7468  rices must be th
+00007480: 6520 7361 6d65 2073 6861 7065 2229 0a0a  e same shape")..
+00007490: 2020 2020 2020 2020 6966 2070 6f73 6520          if pose 
+000074a0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+000074b0: 2020 2020 2070 6f73 6520 3d20 7365 6c66       pose = self
+000074c0: 2e70 6f73 650a 2020 2020 2020 2020 6966  .pose.        if
+000074d0: 206f 626a 706f 7365 2069 7320 6e6f 7420   objpose is not 
+000074e0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+000074f0: 2020 706f 7365 203d 206f 626a 706f 7365    pose = objpose
+00007500: 2e69 6e76 2829 202a 2070 6f73 650a 0a20  .inv() * pose.. 
+00007510: 2020 2020 2020 2023 2067 6574 2068 616e         # get han
+00007520: 646c 6520 666f 7220 7468 6973 2063 616d  dle for this cam
+00007530: 6572 6120 696d 6167 6520 706c 616e 650a  era image plane.
+00007540: 2020 2020 2020 2020 7365 6c66 2e5f 696e          self._in
+00007550: 6974 5f69 6d61 6765 706c 616e 6528 290a  it_imageplane().
+00007560: 2020 2020 2020 2020 706c 742e 6175 746f          plt.auto
+00007570: 7363 616c 6528 4661 6c73 6529 0a0a 2020  scale(False)..  
+00007580: 2020 2020 2020 2320 6472 6177 2033 4420        # draw 3D 
+00007590: 6c69 6e65 2073 6567 6d65 6e74 730a 2020  line segments.  
+000075a0: 2020 2020 2020 7320 3d20 6e70 2e6c 696e        s = np.lin
+000075b0: 7370 6163 6528 302c 2031 2c20 6e73 7465  space(0, 1, nste
+000075c0: 7073 290a 0a20 2020 2020 2020 2023 2063  ps)..        # c
+000075d0: 2e63 6c66 0a20 2020 2020 2020 2023 2068  .clf.        # h
+000075e0: 6f6c 646f 6e20 3d20 632e 686f 6c64 2831  oldon = c.hold(1
+000075f0: 293b 0a0a 2020 2020 2020 2020 666f 7220  );..        for 
+00007600: 6920 696e 2072 616e 6765 2858 2e73 6861  i in range(X.sha
+00007610: 7065 5b30 5d20 2d20 3129 3a20 2023 2069  pe[0] - 1):  # i
+00007620: 3d31 3a6e 756d 726f 7773 2858 292d 310a  =1:numrows(X)-1.
+00007630: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00007640: 6a20 696e 2072 616e 6765 2858 2e73 6861  j in range(X.sha
+00007650: 7065 5b31 5d20 2d20 3129 3a20 2023 206a  pe[1] - 1):  # j
+00007660: 3d31 3a6e 756d 636f 6c73 2858 292d 310a  =1:numcols(X)-1.
+00007670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007680: 5030 203d 206e 702e 725f 5b58 5b69 2c20  P0 = np.r_[X[i, 
+00007690: 6a5d 2c20 595b 692c 206a 5d2c 205a 5b69  j], Y[i, j], Z[i
+000076a0: 2c20 6a5d 5d0a 2020 2020 2020 2020 2020  , j]].          
+000076b0: 2020 2020 2020 5031 203d 206e 702e 725f        P1 = np.r_
+000076c0: 5b58 5b69 202b 2031 2c20 6a5d 2c20 595b  [X[i + 1, j], Y[
+000076d0: 6920 2b20 312c 206a 5d2c 205a 5b69 202b  i + 1, j], Z[i +
+000076e0: 2031 2c20 6a5d 5d0a 2020 2020 2020 2020   1, j]].        
+000076f0: 2020 2020 2020 2020 5032 203d 206e 702e          P2 = np.
+00007700: 725f 5b58 5b69 2c20 6a20 2b20 315d 2c20  r_[X[i, j + 1], 
+00007710: 595b 692c 206a 202b 2031 5d2c 205a 5b69  Y[i, j + 1], Z[i
+00007720: 2c20 6a20 2b20 315d 5d0a 0a20 2020 2020  , j + 1]]..     
+00007730: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00007740: 6c66 2e63 616d 7479 7065 203d 3d20 2270  lf.camtype == "p
+00007750: 6572 7370 6563 7469 7665 223a 0a20 2020  erspective":.   
+00007760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007770: 2023 2073 7472 6169 6768 7420 776f 726c   # straight worl
+00007780: 6420 6c69 6e65 7320 6172 6520 7374 7261  d lines are stra
+00007790: 6967 6874 206f 6e20 7468 6520 696d 6167  ight on the imag
+000077a0: 6520 706c 616e 650a 2020 2020 2020 2020  e plane.        
+000077b0: 2020 2020 2020 2020 2020 2020 7576 203d              uv =
+000077c0: 2073 656c 662e 7072 6f6a 6563 745f 706f   self.project_po
+000077d0: 696e 7428 6e70 2e63 5f5b 5030 2c20 5031  int(np.c_[P0, P1
+000077e0: 5d2c 2070 6f73 653d 706f 7365 290a 2020  ], pose=pose).  
+000077f0: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00007800: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00007810: 2020 2020 2020 2020 2320 7374 7261 6967          # straig
+00007820: 6874 2077 6f72 6c64 206c 696e 6573 2061  ht world lines a
+00007830: 7265 206e 6f74 2073 7472 6169 6768 742c  re not straight,
+00007840: 2070 6c6f 7420 7468 656d 2070 6965 6365   plot them piece
+00007850: 7769 7365 0a20 2020 2020 2020 2020 2020  wise.           
+00007860: 2020 2020 2020 2020 2050 203d 2028 3120           P = (1 
+00007870: 2d20 7329 202a 2050 305b 3a2c 206e 702e  - s) * P0[:, np.
+00007880: 6e65 7761 7869 735d 202b 2073 202a 2050  newaxis] + s * P
+00007890: 315b 3a2c 206e 702e 6e65 7761 7869 735d  1[:, np.newaxis]
+000078a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000078b0: 2020 2020 2075 7620 3d20 7365 6c66 2e70       uv = self.p
+000078c0: 726f 6a65 6374 5f70 6f69 6e74 2850 2c20  roject_point(P, 
+000078d0: 706f 7365 3d70 6f73 6529 0a0a 2020 2020  pose=pose)..    
+000078e0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000078f0: 2e5f 6178 2e70 6c6f 7428 7576 5b30 2c20  ._ax.plot(uv[0, 
+00007900: 3a5d 2c20 7576 5b31 2c20 3a5d 2c20 2a66  :], uv[1, :], *f
+00007910: 6d74 2c20 2a2a 6b77 6172 6773 290a 0a20  mt, **kwargs).. 
+00007920: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00007930: 6620 7365 6c66 2e63 616d 7479 7065 203d  f self.camtype =
+00007940: 3d20 2270 6572 7370 6563 7469 7665 223a  = "perspective":
+00007950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007960: 2020 2020 2023 2073 7472 6169 6768 7420       # straight 
+00007970: 776f 726c 6420 6c69 6e65 7320 6172 6520  world lines are 
+00007980: 7374 7261 6967 6874 206f 6e20 7468 6520  straight on the 
+00007990: 696d 6167 6520 706c 616e 650a 2020 2020  image plane.    
+000079a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000079b0: 7576 203d 2073 656c 662e 7072 6f6a 6563  uv = self.projec
+000079c0: 745f 706f 696e 7428 6e70 2e63 5f5b 5030  t_point(np.c_[P0
+000079d0: 2c20 5032 5d2c 2070 6f73 653d 706f 7365  , P2], pose=pose
+000079e0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000079f0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00007a00: 2020 2020 2020 2020 2020 2020 2320 7374              # st
+00007a10: 7261 6967 6874 2077 6f72 6c64 206c 696e  raight world lin
+00007a20: 6573 2061 7265 206e 6f74 2073 7472 6169  es are not strai
+00007a30: 6768 742c 2070 6c6f 7420 7468 656d 2070  ght, plot them p
+00007a40: 6965 6365 7769 7365 0a20 2020 2020 2020  iecewise.       
+00007a50: 2020 2020 2020 2020 2020 2020 2050 203d               P =
+00007a60: 2028 3120 2d20 7329 202a 2050 305b 3a2c   (1 - s) * P0[:,
+00007a70: 206e 702e 6e65 7761 7869 735d 202b 2073   np.newaxis] + s
+00007a80: 202a 2050 325b 3a2c 206e 702e 6e65 7761   * P2[:, np.newa
+00007a90: 7869 735d 0a20 2020 2020 2020 2020 2020  xis].           
+00007aa0: 2020 2020 2020 2020 2075 7620 3d20 7365           uv = se
+00007ab0: 6c66 2e70 726f 6a65 6374 5f70 6f69 6e74  lf.project_point
+00007ac0: 2850 2c20 706f 7365 3d70 6f73 6529 0a0a  (P, pose=pose)..
+00007ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007ae0: 7365 6c66 2e5f 6178 2e70 6c6f 7428 7576  self._ax.plot(uv
+00007af0: 5b30 2c20 3a5d 2c20 7576 5b31 2c20 3a5d  [0, :], uv[1, :]
+00007b00: 2c20 2a66 6d74 2c20 2a2a 6b77 6172 6773  , *fmt, **kwargs
+00007b10: 290a 0a20 2020 2020 2020 2066 6f72 206a  )..        for j
+00007b20: 2069 6e20 7261 6e67 6528 582e 7368 6170   in range(X.shap
+00007b30: 655b 315d 202d 2031 293a 2020 2320 6a3d  e[1] - 1):  # j=
+00007b40: 313a 6e75 6d63 6f6c 7328 5829 2d31 0a20  1:numcols(X)-1. 
+00007b50: 2020 2020 2020 2020 2020 2050 3020 3d20             P0 = 
+00007b60: 5b58 5b2d 312c 206a 5d2c 2059 5b2d 312c  [X[-1, j], Y[-1,
+00007b70: 206a 5d2c 205a 5b2d 312c 206a 5d5d 0a20   j], Z[-1, j]]. 
+00007b80: 2020 2020 2020 2020 2020 2050 3120 3d20             P1 = 
+00007b90: 5b58 5b2d 312c 206a 202b 2031 5d2c 2059  [X[-1, j + 1], Y
+00007ba0: 5b2d 312c 206a 202b 2031 5d2c 205a 5b2d  [-1, j + 1], Z[-
+00007bb0: 312c 206a 202b 2031 5d5d 0a0a 2020 2020  1, j + 1]]..    
+00007bc0: 2020 2020 2020 2020 2320 6966 2063 2e70          # if c.p
+00007bd0: 6572 7370 6563 7469 7665 0a20 2020 2020  erspective.     
+00007be0: 2020 2020 2020 2023 2073 7472 6169 6768         # straigh
+00007bf0: 7420 776f 726c 6420 6c69 6e65 7320 6172  t world lines ar
+00007c00: 6520 7374 7261 6967 6874 206f 6e20 7468  e straight on th
+00007c10: 6520 696d 6167 6520 706c 616e 650a 2020  e image plane.  
+00007c20: 2020 2020 2020 2020 2020 7576 203d 2073            uv = s
+00007c30: 656c 662e 7072 6f6a 6563 745f 706f 696e  elf.project_poin
+00007c40: 7428 6e70 2e63 5f5b 5030 2c20 5031 5d2c  t(np.c_[P0, P1],
+00007c50: 2070 6f73 653d 706f 7365 290a 2020 2020   pose=pose).    
+00007c60: 2020 2020 2020 2020 2320 656c 7365 0a20          # else. 
+00007c70: 2020 2020 2020 2020 2020 2023 2020 2020             #    
+00007c80: 2023 2073 7472 6169 6768 7420 776f 726c   # straight worl
+00007c90: 6420 6c69 6e65 7320 6172 6520 6e6f 7420  d lines are not 
+00007ca0: 7374 7261 6967 6874 2c20 706c 6f74 2074  straight, plot t
+00007cb0: 6865 6d20 7069 6563 6577 6973 650a 2020  hem piecewise.  
+00007cc0: 2020 2020 2020 2020 2020 2320 2020 2020            #     
+00007cd0: 5020 3d20 6273 7866 756e 2840 7469 6d65  P = bsxfun(@time
+00007ce0: 732c 2028 312d 7329 2c20 5030 2920 2b20  s, (1-s), P0) + 
+00007cf0: 6273 7866 756e 2840 7469 6d65 732c 2073  bsxfun(@times, s
+00007d00: 2c20 5031 293b 0a20 2020 2020 2020 2020  , P1);.         
+00007d10: 2020 2023 2020 2020 2075 7620 3d20 632e     #     uv = c.
+00007d20: 7072 6f6a 6563 7428 502c 2027 7365 746f  project(P, 'seto
+00007d30: 7074 272c 206f 7074 293b 0a20 2020 2020  pt', opt);.     
+00007d40: 2020 2020 2020 2073 656c 662e 5f61 782e         self._ax.
+00007d50: 706c 6f74 2875 765b 302c 203a 5d2c 2075  plot(uv[0, :], u
+00007d60: 765b 312c 203a 5d2c 202a 666d 742c 202a  v[1, :], *fmt, *
+00007d70: 2a6b 7761 7267 7329 0a0a 2020 2020 2020  *kwargs)..      
+00007d80: 2020 2320 632e 686f 6c64 2868 6f6c 646f    # c.hold(holdo
+00007d90: 6e29 3b20 2320 7475 726e 2068 6f6c 6420  n); # turn hold 
+00007da0: 6f66 6620 6966 2069 7420 7761 7320 696e  off if it was in
+00007db0: 6974 6961 6c6c 7920 6f66 660a 0a20 2020  itially off..   
+00007dc0: 2020 2020 2070 6c74 2e64 7261 7728 290a       plt.draw().
+00007dd0: 0a20 2020 2064 6566 2064 6973 7028 7365  .    def disp(se
+00007de0: 6c66 2c20 696d 2c20 2a2a 6b77 6172 6773  lf, im, **kwargs
+00007df0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00007e00: 2020 2020 2020 2044 6973 706c 6179 2069         Display i
+00007e10: 6d61 6765 206f 6e20 7669 7274 7561 6c20  mage on virtual 
+00007e20: 696d 6167 6520 706c 616e 6520 2862 6173  image plane (bas
+00007e30: 6520 6d65 7468 6f64 290a 0a20 2020 2020  e method)..     
+00007e40: 2020 203a 7061 7261 6d20 696d 3a20 696d     :param im: im
+00007e50: 6167 6520 746f 2064 6973 706c 6179 0a20  age to display. 
+00007e60: 2020 2020 2020 203a 7479 7065 2069 6d3a         :type im:
+00007e70: 203a 636c 6173 733a 6049 6d61 6765 6020   :class:`Image` 
+00007e80: 696e 7374 616e 6365 0a20 2020 2020 2020  instance.       
+00007e90: 203a 7061 7261 6d20 6b77 6172 6773 3a20   :param kwargs: 
+00007ea0: 6f70 7469 6f6e 7320 746f 203a 6675 6e63  options to :func
+00007eb0: 3a60 7e6d 6163 6869 6e65 7669 7369 6f6e  :`~machinevision
+00007ec0: 746f 6f6c 626f 782e 6261 7365 2e69 6d61  toolbox.base.ima
+00007ed0: 6765 696f 2e69 6469 7370 2829 600a 0a20  geio.idisp()`.. 
+00007ee0: 2020 2020 2020 2041 6e20 696d 6167 6520         An image 
+00007ef0: 6973 2064 6973 706c 6179 6564 206f 6e20  is displayed on 
+00007f00: 6361 6d65 7261 2773 2074 6865 2076 6972  camera's the vir
+00007f10: 7475 616c 2069 6d61 6765 2070 6c61 6e65  tual image plane
+00007f20: 2e0a 0a20 2020 2020 2020 202e 2e20 6e6f  ...        .. no
+00007f30: 7465 3a20 5468 6520 6469 6d65 6e73 696f  te: The dimensio
+00007f40: 6e73 206f 6620 7468 6520 696d 6167 6520  ns of the image 
+00007f50: 706c 616e 6520 7368 6f75 6c64 206d 6174  plane should mat
+00007f60: 6368 2074 6865 2064 696d 656e 7369 6f6e  ch the dimension
+00007f70: 7320 6f66 2074 6865 2069 6d61 6765 2e0a  s of the image..
+00007f80: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
+00007f90: 6f3a 203a 6675 6e63 3a60 6d61 6368 696e  o: :func:`machin
+00007fa0: 6576 6973 696f 6e74 6f6f 6c62 6f78 2e62  evisiontoolbox.b
+00007fb0: 6173 652e 6964 6973 7028 2960 0a20 2020  ase.idisp()`.   
+00007fc0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00007fd0: 2073 656c 662e 696d 6167 6573 697a 6520   self.imagesize 
+00007fe0: 3d20 2869 6d2e 7368 6170 655b 315d 2c20  = (im.shape[1], 
+00007ff0: 696d 2e73 6861 7065 5b30 5d29 0a20 2020  im.shape[0]).   
+00008000: 2020 2020 2073 656c 662e 5f69 6e69 745f       self._init_
+00008010: 696d 6167 6570 6c61 6e65 2829 0a20 2020  imageplane().   
+00008020: 2020 2020 2069 6d2e 6469 7370 2861 783d       im.disp(ax=
+00008030: 7365 6c66 2e5f 6178 2c20 7469 746c 653d  self._ax, title=
+00008040: 4661 6c73 652c 202a 2a6b 7761 7267 7329  False, **kwargs)
+00008050: 0a0a 2020 2020 2020 2020 706c 742e 6175  ..        plt.au
+00008060: 746f 7363 616c 6528 4661 6c73 6529 0a0a  toscale(False)..
+00008070: 2020 2020 6465 6620 706c 6f74 280a 2020      def plot(.  
+00008080: 2020 2020 2020 7365 6c66 3d4e 6f6e 652c        self=None,
+00008090: 0a20 2020 2020 2020 2070 6f73 653d 4e6f  .        pose=No
+000080a0: 6e65 2c0a 2020 2020 2020 2020 7363 616c  ne,.        scal
+000080b0: 653d 312c 0a20 2020 2020 2020 2073 6861  e=1,.        sha
+000080c0: 7065 3d22 6361 6d65 7261 222c 0a20 2020  pe="camera",.   
+000080d0: 2020 2020 206c 6162 656c 3d54 7275 652c       label=True,
+000080e0: 0a20 2020 2020 2020 2061 6c70 6861 3d31  .        alpha=1
+000080f0: 2c0a 2020 2020 2020 2020 736f 6c69 643d  ,.        solid=
+00008100: 4661 6c73 652c 0a20 2020 2020 2020 2063  False,.        c
+00008110: 6f6c 6f72 3d22 7222 2c0a 2020 2020 2020  olor="r",.      
+00008120: 2020 7072 6f6a 6563 7469 6f6e 3d22 6f72    projection="or
+00008130: 7468 6f22 2c0a 2020 2020 2020 2020 6672  tho",.        fr
+00008140: 616d 653d 4661 6c73 652c 0a20 2020 2020  ame=False,.     
+00008150: 2020 2061 783d 4e6f 6e65 2c0a 2020 2020     ax=None,.    
+00008160: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00008170: 2020 2020 2020 2050 6c6f 7420 3344 2063         Plot 3D c
+00008180: 616d 6572 6120 6963 6f6e 2069 6e20 776f  amera icon in wo
+00008190: 726c 6420 7669 6577 2028 6261 7365 206d  rld view (base m
+000081a0: 6574 686f 6429 0a0a 2020 2020 2020 2020  ethod)..        
+000081b0: 3a70 6172 616d 2070 6f73 653a 2063 616d  :param pose: cam
+000081c0: 6572 6120 706f 7365 0a20 2020 2020 2020  era pose.       
+000081d0: 203a 7479 7065 2070 6f73 653a 203a 636c   :type pose: :cl
+000081e0: 6173 733a 607e 7370 6174 6961 6c6d 6174  ass:`~spatialmat
+000081f0: 682e 2e70 6f73 6533 642e 5345 3360 0a20  h..pose3d.SE3`. 
+00008200: 2020 2020 2020 203a 7061 7261 6d20 7363         :param sc
+00008210: 616c 653a 2073 6361 6c65 2066 6163 746f  ale: scale facto
+00008220: 722c 2064 6566 6175 6c74 7320 746f 2031  r, defaults to 1
+00008230: 0a20 2020 2020 2020 203a 7479 7065 2073  .        :type s
+00008240: 6361 6c65 3a20 666c 6f61 740a 2020 2020  cale: float.    
+00008250: 2020 2020 3a70 6172 616d 2073 6861 7065      :param shape
+00008260: 3a20 6963 6f6e 2073 6861 7065 3a20 2766  : icon shape: 'f
+00008270: 7275 7374 756d 2720 5b64 6566 6175 6c74  rustum' [default
+00008280: 5d2c 2027 6361 6d65 7261 270a 2020 2020  ], 'camera'.    
+00008290: 2020 2020 3a74 7970 6520 7368 6170 653a      :type shape:
+000082a0: 2073 7472 2c20 6f70 7469 6f6e 616c 0a20   str, optional. 
+000082b0: 2020 2020 2020 203a 7061 7261 6d20 6c61         :param la
+000082c0: 6265 6c3a 2073 686f 7720 6361 6d65 7261  bel: show camera
+000082d0: 206e 616d 652c 2064 6566 6175 6c74 7320   name, defaults 
+000082e0: 746f 2054 7275 650a 2020 2020 2020 2020  to True.        
+000082f0: 3a74 7970 6520 6c61 6265 6c3a 2062 6f6f  :type label: boo
+00008300: 6c2c 206f 7074 696f 6e61 6c0a 2020 2020  l, optional.    
+00008310: 2020 2020 3a70 6172 616d 2061 6c70 6861      :param alpha
+00008320: 3a20 7472 616e 7370 6172 656e 6379 206f  : transparency o
+00008330: 6620 6963 6f6e 2c20 6465 6661 756c 7473  f icon, defaults
+00008340: 2074 6f20 310a 2020 2020 2020 2020 3a74   to 1.        :t
+00008350: 7970 6520 616c 7068 613a 2066 6c6f 6174  ype alpha: float
+00008360: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
+00008370: 2020 203a 7061 7261 6d20 736f 6c69 643a     :param solid:
+00008380: 2069 636f 6e20 636f 6d70 7269 7365 7320   icon comprises 
+00008390: 736f 6c69 6420 6661 6365 732c 2064 6566  solid faces, def
+000083a0: 6175 6c74 7320 746f 2046 616c 7365 0a20  aults to False. 
+000083b0: 2020 2020 2020 203a 7479 7065 2073 6f6c         :type sol
+000083c0: 6964 3a20 626f 6f6c 2c20 6f70 7469 6f6e  id: bool, option
+000083d0: 616c 0a20 2020 2020 2020 203a 7061 7261  al.        :para
+000083e0: 6d20 636f 6c6f 723a 2069 636f 6e20 636f  m color: icon co
+000083f0: 6c6f 722c 2064 6566 6175 6c74 7320 746f  lor, defaults to
+00008400: 2027 7227 0a20 2020 2020 2020 203a 7479   'r'.        :ty
+00008410: 7065 2063 6f6c 6f72 3a20 7374 722c 206f  pe color: str, o
+00008420: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
+00008430: 3a70 6172 616d 2070 726f 6a65 6374 696f  :param projectio
+00008440: 6e3a 2070 726f 6a65 6374 696f 6e20 6d6f  n: projection mo
+00008450: 6465 6c20 666f 7220 6e65 7720 6178 6573  del for new axes
+00008460: 2c20 6465 6661 756c 7473 2074 6f20 276f  , defaults to 'o
+00008470: 7274 686f 270a 2020 2020 2020 2020 3a74  rtho'.        :t
+00008480: 7970 6520 7072 6f6a 6563 7469 6f6e 3a20  ype projection: 
+00008490: 7374 722c 206f 7074 696f 6e61 6c0a 2020  str, optional.  
+000084a0: 2020 2020 2020 3a70 6172 616d 2061 783a        :param ax:
+000084b0: 2061 7865 7320 746f 2064 7261 7720 696e   axes to draw in
+000084c0: 2c20 6465 6661 756c 7473 2074 6f20 6375  , defaults to cu
+000084d0: 7272 656e 7420 3344 2061 7865 730a 2020  rrent 3D axes.  
+000084e0: 2020 2020 2020 3a74 7970 6520 6178 3a20        :type ax: 
+000084f0: 3a63 6c61 7373 3a60 7e6d 6174 706c 6f74  :class:`~matplot
+00008500: 6c69 622e 4178 6573 3344 602c 206f 7074  lib.Axes3D`, opt
+00008510: 696f 6e61 6c0a 2020 2020 2020 2020 3a72  ional.        :r
+00008520: 6574 7572 6e3a 2061 7865 7320 6472 6177  eturn: axes draw
+00008530: 6e20 696e 746f 0a20 2020 2020 2020 203a  n into.        :
+00008540: 7274 7970 653a 203a 636c 6173 733a 607e  rtype: :class:`~
+00008550: 6d61 7470 6c6f 746c 6962 2e41 7865 7333  matplotlib.Axes3
+00008560: 4460 0a0a 2020 2020 2020 2020 506c 6f74  D`..        Plot
+00008570: 2061 2033 4420 6963 6f6e 2072 6570 7265   a 3D icon repre
+00008580: 7365 6e74 696e 6720 7468 6520 706f 7365  senting the pose
+00008590: 206f 6620 6120 6361 6d65 7261 2069 6e74   of a camera int
+000085a0: 6f20 6120 3344 204d 6174 706c 6f74 6c69  o a 3D Matplotli
+000085b0: 620a 2020 2020 2020 2020 706c 6f74 2e20  b.        plot. 
+000085c0: 2054 776f 2069 636f 6e73 2061 7265 2073   Two icons are s
+000085d0: 7570 706f 7274 6564 3a20 7468 6520 7472  upported: the tr
+000085e0: 6164 6974 696f 6e61 6c20 6672 7573 7475  aditional frustu
+000085f0: 6d2c 2061 6e64 2061 0a20 2020 2020 2020  m, and a.       
+00008600: 2073 696d 706c 6973 7469 6320 6361 6d65   simplistic came
+00008610: 7261 2063 6f6d 7072 6973 696e 6720 6120  ra comprising a 
+00008620: 626f 7820 616e 6420 6379 6c69 6e64 6572  box and cylinder
+00008630: 2e0a 0a20 2020 2020 2020 203a 6e6f 7465  ...        :note
+00008640: 3a20 4966 2060 6070 6f73 6560 6020 6973  : If ``pose`` is
+00008650: 206e 6f74 2067 6976 656e 2069 7420 6465   not given it de
+00008660: 6661 756c 7473 2074 6f20 7468 6520 706f  faults to the po
+00008670: 7365 206f 6620 7468 650a 2020 2020 2020  se of the.      
+00008680: 2020 2020 2020 696e 7374 616e 6365 2e0a        instance..
+00008690: 2020 2020 2020 2020 2222 220a 0a20 2020          """..   
+000086a0: 2020 2020 2023 2069 6620 2866 6967 2069       # if (fig i
+000086b0: 7320 4e6f 6e65 2920 616e 6420 2861 7820  s None) and (ax 
+000086c0: 6973 204e 6f6e 6529 3a0a 2020 2020 2020  is None):.      
+000086d0: 2020 2320 2020 2020 2320 6372 6561 7465    #     # create
+000086e0: 206f 7572 206f 776e 2068 616e 646c 6520   our own handle 
+000086f0: 666f 7220 7468 6520 6669 6775 7265 2f70  for the figure/p
+00008700: 6c6f 740a 2020 2020 2020 2020 2320 2020  lot.        #   
+00008710: 2020 7072 696e 7428 2763 7265 6174 696e    print('creatin
+00008720: 6720 6e65 7720 6669 6775 7265 2061 6e64  g new figure and
+00008730: 2061 7865 7320 666f 7220 6361 6d65 7261   axes for camera
+00008740: 2729 0a20 2020 2020 2020 2023 2020 2020  ').        #    
+00008750: 2066 6967 203d 2070 6c74 2e66 6967 7572   fig = plt.figur
+00008760: 6528 290a 2020 2020 2020 2020 2320 2020  e().        #   
+00008770: 2020 6178 203d 2066 6967 2e67 6361 2870    ax = fig.gca(p
+00008780: 726f 6a65 6374 696f 6e3d 2733 6427 290a  rojection='3d').
+00008790: 2020 2020 2020 2020 2320 2020 2020 2320          #     # 
+000087a0: 6178 2e73 6574 5f61 7370 6563 7428 2765  ax.set_aspect('e
+000087b0: 7175 616c 2729 0a0a 2020 2020 2020 2020  qual')..        
+000087c0: 2222 225b 7375 6d6d 6172 795d 0a20 2020  """[summary].   
+000087d0: 2020 2020 2066 6163 6520 6f72 6465 7220       face order 
+000087e0: 2d78 2c20 2b79 2c20 2b78 2c20 2d79 0a20  -x, +y, +x, -y. 
+000087f0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00008800: 2020 2023 2067 6574 2061 7865 7320 746f     # get axes to
+00008810: 2064 7261 7720 696e 0a20 2020 2020 2020   draw in.       
+00008820: 2061 7820 3d20 736d 6261 7365 2e61 7865   ax = smbase.axe
+00008830: 735f 6c6f 6769 6328 6178 2c20 332c 2070  s_logic(ax, 3, p
+00008840: 726f 6a65 6374 696f 6e3d 7072 6f6a 6563  rojection=projec
+00008850: 7469 6f6e 290a 0a20 2020 2020 2020 2069  tion)..        i
+00008860: 6620 706f 7365 2069 7320 4e6f 6e65 3a0a  f pose is None:.
+00008870: 2020 2020 2020 2020 2020 2020 706f 7365              pose
+00008880: 203d 2073 656c 662e 706f 7365 0a0a 2020   = self.pose..  
+00008890: 2020 2020 2020 2320 6472 6177 2063 616d        # draw cam
+000088a0: 6572 612d 6c69 6b65 206f 626a 6563 743a  era-like object:
+000088b0: 0a20 2020 2020 2020 2069 6620 7368 6170  .        if shap
+000088c0: 6520 3d3d 2022 6672 7573 7475 6d22 3a0a  e == "frustum":.
+000088d0: 2020 2020 2020 2020 2020 2020 2320 544f              # TO
+000088e0: 444f 206d 616b 6520 7468 6973 206b 7761  DO make this kwa
+000088f0: 7267 7320 6f72 206f 7074 696f 6e61 6c20  rgs or optional 
+00008900: 696e 7075 7473 0a20 2020 2020 2020 2020  inputs.         
+00008910: 2020 2023 2073 6964 6520 636f 6c6f 7273     # side colors
+00008920: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+00008930: 202b 7820 7265 640a 2020 2020 2020 2020   +x red.        
+00008940: 2020 2020 2320 202d 7920 7265 640a 2020      #  -y red.  
+00008950: 2020 2020 2020 2020 2020 2320 202b 7920            #  +y 
+00008960: 6772 6565 6e0a 2020 2020 2020 2020 2020  green.          
+00008970: 2020 2320 202d 7920 7965 6c6c 6f77 0a20    #  -y yellow. 
+00008980: 2020 2020 2020 2020 2020 206c 656e 6774             lengt
+00008990: 6820 3d20 7363 616c 650a 2020 2020 2020  h = scale.      
+000089a0: 2020 2020 2020 7769 6474 6862 203d 2073        widthb = s
+000089b0: 6361 6c65 202f 2031 300a 2020 2020 2020  cale / 10.      
+000089c0: 2020 2020 2020 7769 6474 6874 203d 2073        widtht = s
+000089d0: 6361 6c65 0a20 2020 2020 2020 2020 2020  cale.           
+000089e0: 2077 6964 7468 6220 2f3d 2032 0a20 2020   widthb /= 2.   
+000089f0: 2020 2020 2020 2020 2077 6964 7468 7420           widtht 
+00008a00: 2f3d 2032 0a20 2020 2020 2020 2020 2020  /= 2.           
+00008a10: 2062 3020 3d20 6e70 2e61 7272 6179 285b   b0 = np.array([
+00008a20: 2d77 6964 7468 622c 202d 7769 6474 6862  -widthb, -widthb
+00008a30: 2c20 302c 2031 5d29 0a20 2020 2020 2020  , 0, 1]).       
+00008a40: 2020 2020 2062 3120 3d20 6e70 2e61 7272       b1 = np.arr
+00008a50: 6179 285b 2d77 6964 7468 622c 2077 6964  ay([-widthb, wid
+00008a60: 7468 622c 2030 2c20 315d 290a 2020 2020  thb, 0, 1]).    
+00008a70: 2020 2020 2020 2020 6232 203d 206e 702e          b2 = np.
+00008a80: 6172 7261 7928 5b77 6964 7468 622c 2077  array([widthb, w
+00008a90: 6964 7468 622c 2030 2c20 315d 290a 2020  idthb, 0, 1]).  
+00008aa0: 2020 2020 2020 2020 2020 6233 203d 206e            b3 = n
+00008ab0: 702e 6172 7261 7928 5b77 6964 7468 622c  p.array([widthb,
+00008ac0: 202d 7769 6474 6862 2c20 302c 2031 5d29   -widthb, 0, 1])
+00008ad0: 0a20 2020 2020 2020 2020 2020 2074 3020  .            t0 
+00008ae0: 3d20 6e70 2e61 7272 6179 285b 2d77 6964  = np.array([-wid
+00008af0: 7468 742c 202d 7769 6474 6874 2c20 6c65  tht, -widtht, le
+00008b00: 6e67 7468 2c20 315d 290a 2020 2020 2020  ngth, 1]).      
+00008b10: 2020 2020 2020 7431 203d 206e 702e 6172        t1 = np.ar
+00008b20: 7261 7928 5b2d 7769 6474 6874 2c20 7769  ray([-widtht, wi
+00008b30: 6474 6874 2c20 6c65 6e67 7468 2c20 315d  dtht, length, 1]
+00008b40: 290a 2020 2020 2020 2020 2020 2020 7432  ).            t2
+00008b50: 203d 206e 702e 6172 7261 7928 5b77 6964   = np.array([wid
+00008b60: 7468 742c 2077 6964 7468 742c 206c 656e  tht, widtht, len
+00008b70: 6774 682c 2031 5d29 0a20 2020 2020 2020  gth, 1]).       
+00008b80: 2020 2020 2074 3320 3d20 6e70 2e61 7272       t3 = np.arr
+00008b90: 6179 285b 7769 6474 6874 2c20 2d77 6964  ay([widtht, -wid
+00008ba0: 7468 742c 206c 656e 6774 682c 2031 5d29  tht, length, 1])
+00008bb0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+00008bc0: 626f 7474 6f6d 2f6e 6172 726f 7720 656e  bottom/narrow en
+00008bd0: 640a 2020 2020 2020 2020 2020 2020 5420  d.            T 
+00008be0: 3d20 706f 7365 2e41 0a20 2020 2020 2020  = pose.A.       
+00008bf0: 2020 2020 2062 3020 3d20 2854 2040 2062       b0 = (T @ b
+00008c00: 3029 5b3a 2d31 5d0a 2020 2020 2020 2020  0)[:-1].        
+00008c10: 2020 2020 6231 203d 2028 5420 4020 6231      b1 = (T @ b1
+00008c20: 295b 3a2d 315d 0a20 2020 2020 2020 2020  )[:-1].         
+00008c30: 2020 2062 3220 3d20 2854 2040 2062 3229     b2 = (T @ b2)
+00008c40: 5b3a 2d31 5d0a 2020 2020 2020 2020 2020  [:-1].          
+00008c50: 2020 6233 203d 2028 5420 4020 6233 295b    b3 = (T @ b3)[
+00008c60: 3a2d 315d 0a0a 2020 2020 2020 2020 2020  :-1]..          
+00008c70: 2020 2320 7769 6465 2f74 6f70 2065 6e64    # wide/top end
+00008c80: 0a20 2020 2020 2020 2020 2020 2074 3020  .            t0 
+00008c90: 3d20 2854 2040 2074 3029 5b3a 2d31 5d0a  = (T @ t0)[:-1].
+00008ca0: 2020 2020 2020 2020 2020 2020 7431 203d              t1 =
+00008cb0: 2028 5420 4020 7431 295b 3a2d 315d 0a20   (T @ t1)[:-1]. 
+00008cc0: 2020 2020 2020 2020 2020 2074 3220 3d20             t2 = 
+00008cd0: 2854 2040 2074 3229 5b3a 2d31 5d0a 2020  (T @ t2)[:-1].  
+00008ce0: 2020 2020 2020 2020 2020 7433 203d 2028            t3 = (
+00008cf0: 5420 4020 7433 295b 3a2d 315d 0a0a 2020  T @ t3)[:-1]..  
+00008d00: 2020 2020 2020 2020 2020 2320 4561 6368            # Each
+00008d10: 2073 6574 206f 6620 666f 7572 2070 6f69   set of four poi
+00008d20: 6e74 7320 6973 2061 2073 696e 676c 6520  nts is a single 
+00008d30: 7369 6465 206f 6620 7468 6520 4672 7573  side of the Frus
+00008d40: 7472 756d 0a20 2020 2020 2020 2020 2020  trum.           
+00008d50: 2023 2070 6f69 6e74 7320 3d20 6e70 2e61   # points = np.a
+00008d60: 7272 6179 285b 5b62 302c 2062 312c 2074  rray([[b0, b1, t
+00008d70: 312c 2074 305d 2c20 5b62 312c 2062 322c  1, t0], [b1, b2,
+00008d80: 2074 322c 2074 315d 2c20 5b0a 2020 2020   t2, t1], [.    
+00008d90: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+00008da0: 2020 2020 2020 2020 2020 2020 6232 2c20              b2, 
+00008db0: 6233 2c20 7433 2c20 7432 5d2c 205b 6233  b3, t3, t2], [b3
+00008dc0: 2c20 6230 2c20 7430 2c20 7433 5d5d 290a  , b0, t0, t3]]).
+00008dd0: 2020 2020 2020 2020 2020 2020 706f 696e              poin
+00008de0: 7473 203d 205b 0a20 2020 2020 2020 2020  ts = [.         
+00008df0: 2020 2020 2020 206e 702e 6172 7261 7928         np.array(
+00008e00: 5b62 302c 2062 312c 2074 312c 2074 305d  [b0, b1, t1, t0]
+00008e10: 292c 2020 2320 2d78 2066 6163 650a 2020  ),  # -x face.  
+00008e20: 2020 2020 2020 2020 2020 2020 2020 6e70                np
+00008e30: 2e61 7272 6179 285b 6231 2c20 6232 2c20  .array([b1, b2, 
+00008e40: 7432 2c20 7431 5d29 2c20 2023 202b 7920  t2, t1]),  # +y 
+00008e50: 6661 6365 0a20 2020 2020 2020 2020 2020  face.           
+00008e60: 2020 2020 206e 702e 6172 7261 7928 5b62       np.array([b
+00008e70: 322c 2062 332c 2074 332c 2074 325d 292c  2, b3, t3, t2]),
+00008e80: 2020 2320 2b78 2066 6163 650a 2020 2020    # +x face.    
+00008e90: 2020 2020 2020 2020 2020 2020 6e70 2e61              np.a
+00008ea0: 7272 6179 285b 6233 2c20 6230 2c20 7430  rray([b3, b0, t0
+00008eb0: 2c20 7433 5d29 2c20 2023 202d 7920 6661  , t3]),  # -y fa
+00008ec0: 6365 0a20 2020 2020 2020 2020 2020 205d  ce.            ]
+00008ed0: 0a20 2020 2020 2020 2020 2020 2070 6f6c  .            pol
+00008ee0: 7920 3d20 506f 6c79 3344 436f 6c6c 6563  y = Poly3DCollec
+00008ef0: 7469 6f6e 280a 2020 2020 2020 2020 2020  tion(.          
+00008f00: 2020 2020 2020 706f 696e 7473 2c20 6661        points, fa
+00008f10: 6365 636f 6c6f 7273 3d5b 2272 222c 2022  cecolors=["r", "
+00008f20: 6722 2c20 2272 222c 2022 7922 5d2c 2061  g", "r", "y"], a
+00008f30: 6c70 6861 3d61 6c70 6861 0a20 2020 2020  lpha=alpha.     
+00008f40: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00008f50: 2020 2020 2061 782e 6164 645f 636f 6c6c       ax.add_coll
+00008f60: 6563 7469 6f6e 3364 2870 6f6c 7929 0a0a  ection3d(poly)..
+00008f70: 2020 2020 2020 2020 656c 6966 2073 6861          elif sha
+00008f80: 7065 203d 3d20 2263 616d 6572 6122 3a0a  pe == "camera":.
+00008f90: 0a20 2020 2020 2020 2020 2020 2023 2074  .            # t
+00008fa0: 6865 2062 6f78 2069 7320 6365 6e74 7265  he box is centre
+00008fb0: 6420 6174 2074 6865 206f 7269 6769 6e20  d at the origin 
+00008fc0: 616e 6420 6974 7320 6365 6e74 6572 6c69  and its centerli
+00008fd0: 6e65 2070 6172 616c 6c65 6c20 746f 2074  ne parallel to t
+00008fe0: 6865 0a20 2020 2020 2020 2020 2020 2023  he.            #
+00008ff0: 207a 2d61 7869 732e 2020 4974 7320 7a2d   z-axis.  Its z-
+00009000: 6578 7465 6e74 2069 7320 2d62 682f 3220  extent is -bh/2 
+00009010: 746f 2062 682f 322e 0a20 2020 2020 2020  to bh/2..       
+00009020: 2020 2020 2057 203d 2030 2e35 2020 2320       W = 0.5  # 
+00009030: 7769 6474 6820 2620 6865 6967 6874 206f  width & height o
+00009040: 6620 7468 6520 626f 780a 2020 2020 2020  f the box.      
+00009050: 2020 2020 2020 4c20 3d20 312e 3220 2023        L = 1.2  #
+00009060: 206c 656e 6774 6820 6f66 2074 6865 2062   length of the b
+00009070: 6f78 0a20 2020 2020 2020 2020 2020 2063  ox.            c
+00009080: 7220 3d20 302e 3220 2023 2063 796c 696e  r = 0.2  # cylin
+00009090: 6465 7220 7261 6469 7573 0a20 2020 2020  der radius.     
+000090a0: 2020 2020 2020 2063 6820 3d20 302e 3420         ch = 0.4 
+000090b0: 2023 2063 796c 696e 6465 7220 6865 6967   # cylinder heig
+000090c0: 6874 0a20 2020 2020 2020 2020 2020 2063  ht.            c
+000090d0: 6e20 3d20 3132 2020 2320 6e75 6d62 6572  n = 12  # number
+000090e0: 206f 6620 6661 6365 7473 206f 6620 6379   of facets of cy
+000090f0: 6c69 6e64 6572 0a20 2020 2020 2020 2020  linder.         
+00009100: 2020 2061 203d 2033 2020 2320 6c65 6e67     a = 3  # leng
+00009110: 7468 206f 6620 6178 6973 206c 696e 6520  th of axis line 
+00009120: 7365 676d 656e 7473 0a0a 2020 2020 2020  segments..      
+00009130: 2020 2020 2020 2320 6472 6177 2074 6865        # draw the
+00009140: 2062 6f78 2070 6172 7420 6f66 2074 6865   box part of the
+00009150: 2063 616d 6572 610a 2020 2020 2020 2020   camera.        
+00009160: 2020 2020 736d 6261 7365 2e70 6c6f 745f      smbase.plot_
+00009170: 6375 626f 6964 280a 2020 2020 2020 2020  cuboid(.        
+00009180: 2020 2020 2020 2020 7369 6465 733d 6e70          sides=np
+00009190: 2e72 5f5b 572c 2057 2c20 4c5d 202a 2073  .r_[W, W, L] * s
+000091a0: 6361 6c65 2c0a 2020 2020 2020 2020 2020  cale,.          
+000091b0: 2020 2020 2020 706f 7365 3d70 6f73 652c        pose=pose,
+000091c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000091d0: 2066 696c 6c65 643d 736f 6c69 642c 0a20   filled=solid,. 
+000091e0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000091f0: 6f6c 6f72 3d63 6f6c 6f72 2c0a 2020 2020  olor=color,.    
+00009200: 2020 2020 2020 2020 2020 2020 616c 7068              alph
+00009210: 613d 302e 3520 2a20 616c 7068 6120 6966  a=0.5 * alpha if
+00009220: 2073 6f6c 6964 2065 6c73 6520 616c 7068   solid else alph
+00009230: 612c 0a20 2020 2020 2020 2020 2020 2020  a,.             
+00009240: 2020 2061 783d 6178 2c0a 2020 2020 2020     ax=ax,.      
+00009250: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00009260: 2020 2020 2023 2064 7261 7720 7468 6520       # draw the 
+00009270: 6c65 6e73 0a20 2020 2020 2020 2020 2020  lens.           
+00009280: 2073 6d62 6173 652e 706c 6f74 5f63 796c   smbase.plot_cyl
+00009290: 696e 6465 7228 0a20 2020 2020 2020 2020  inder(.         
+000092a0: 2020 2020 2020 2072 6164 6975 733d 6372         radius=cr
+000092b0: 202a 2073 6361 6c65 2c0a 2020 2020 2020   * scale,.      
+000092c0: 2020 2020 2020 2020 2020 6865 6967 6874            height
+000092d0: 3d6e 702e 725f 5b4c 202f 2032 2c20 4c20  =np.r_[L / 2, L 
+000092e0: 2f20 3220 2b20 6368 5d20 2a20 7363 616c  / 2 + ch] * scal
+000092f0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+00009300: 2020 2072 6573 6f6c 7574 696f 6e3d 636e     resolution=cn
+00009310: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00009320: 2020 706f 7365 3d70 6f73 652c 0a20 2020    pose=pose,.   
+00009330: 2020 2020 2020 2020 2020 2020 2066 696c               fil
+00009340: 6c65 643d 736f 6c69 642c 0a20 2020 2020  led=solid,.     
+00009350: 2020 2020 2020 2020 2020 2063 6f6c 6f72             color
+00009360: 3d63 6f6c 6f72 2c0a 2020 2020 2020 2020  =color,.        
+00009370: 2020 2020 2020 2020 616c 7068 613d 302e          alpha=0.
+00009380: 3520 2a20 616c 7068 612c 0a20 2020 2020  5 * alpha,.     
+00009390: 2020 2020 2020 2020 2020 2061 783d 6178             ax=ax
+000093a0: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
+000093b0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000093c0: 6c61 6265 6c3a 0a20 2020 2020 2020 2020  label:.         
+000093d0: 2020 2020 2020 2061 782e 7365 745f 786c         ax.set_xl
+000093e0: 6162 656c 2822 5822 290a 2020 2020 2020  abel("X").      
+000093f0: 2020 2020 2020 2020 2020 6178 2e73 6574            ax.set
+00009400: 5f79 6c61 6265 6c28 2259 2229 0a20 2020  _ylabel("Y").   
+00009410: 2020 2020 2020 2020 2020 2020 2061 782e               ax.
+00009420: 7365 745f 7a6c 6162 656c 2822 5a22 290a  set_zlabel("Z").
+00009430: 0a20 2020 2020 2020 2069 6620 6672 616d  .        if fram
+00009440: 6520 6973 2054 7275 653a 0a20 2020 2020  e is True:.     
+00009450: 2020 2020 2020 2073 656c 662e 706f 7365         self.pose
+00009460: 2e70 6c6f 7428 0a20 2020 2020 2020 2020  .plot(.         
+00009470: 2020 2020 2020 206c 656e 6774 683d 7363         length=sc
+00009480: 616c 6520 2a20 312e 352c 2073 7479 6c65  ale * 1.5, style
+00009490: 3d22 6c69 6e65 222c 2063 6f6c 6f72 3d63  ="line", color=c
+000094a0: 6f6c 6f72 2c20 666c 6f3d 2830 2e30 372c  olor, flo=(0.07,
+000094b0: 2030 2c20 2d30 2e30 3129 0a20 2020 2020   0, -0.01).     
+000094c0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000094d0: 2065 6c69 6620 6672 616d 6520 6973 206e   elif frame is n
+000094e0: 6f74 2046 616c 7365 3a0a 2020 2020 2020  ot False:.      
+000094f0: 2020 2020 2020 7365 6c66 2e70 6f73 652e        self.pose.
+00009500: 706c 6f74 282a 2a66 7261 6d65 290a 0a20  plot(**frame).. 
+00009510: 2020 2020 2020 2072 6574 7572 6e20 6178         return ax
+00009520: 0a0a 2020 2020 6465 6620 5f61 6464 5f6e  ..    def _add_n
+00009530: 6f69 7365 5f64 6973 746f 7274 696f 6e28  oise_distortion(
+00009540: 7365 6c66 2c20 7576 293a 0a20 2020 2020  self, uv):.     
+00009550: 2020 2022 2222 0a20 2020 2020 2020 2041     """.        A
+00009560: 6464 206e 6f69 7365 2074 6f20 7069 7865  dd noise to pixe
+00009570: 6c20 636f 6f72 6469 6e61 7465 730a 0a20  l coordinates.. 
+00009580: 2020 2020 2020 203a 7061 7261 6d20 7576         :param uv
+00009590: 3a20 696d 6167 6520 706c 616e 6520 706f  : image plane po
+000095a0: 696e 7420 636f 6f72 6469 6e61 7465 730a  int coordinates.
+000095b0: 2020 2020 2020 2020 3a74 7970 6520 7576          :type uv
+000095c0: 3a20 6e64 6172 7261 7928 322c 4e29 0a20  : ndarray(2,N). 
+000095d0: 2020 2020 2020 203a 7265 7475 726e 3a20         :return: 
+000095e0: 706f 696e 7420 636f 6f72 6469 6e61 7465  point coordinate
+000095f0: 7320 7769 7468 2061 6464 6974 6976 6520  s with additive 
+00009600: 6e6f 6973 650a 2020 2020 2020 2020 3a72  noise.        :r
+00009610: 7479 7065 3a20 6e64 6172 7261 7928 322c  type: ndarray(2,
+00009620: 4e29 0a0a 2020 2020 2020 2020 4d6f 6465  N)..        Mode
+00009630: 6c20 6e6f 6973 6520 696e 2074 6865 2069  l noise in the i
+00009640: 6d61 6765 2070 726f 6365 7373 2062 7920  mage process by 
+00009650: 6164 6469 6e67 207a 6572 6f2d 6d65 616e  adding zero-mean
+00009660: 2047 6175 7373 6961 6e20 6e6f 6973 650a   Gaussian noise.
+00009670: 2020 2020 2020 2020 746f 2074 6865 2063          to the c
+00009680: 6f6f 7264 696e 6174 6573 206f 6620 7072  oordinates of pr
+00009690: 6f6a 6563 7465 6420 776f 726c 6420 706f  ojected world po
+000096a0: 696e 7473 2e20 2054 6865 206e 6f69 7365  ints.  The noise
+000096b0: 2068 6173 2061 0a20 2020 2020 2020 2073   has a.        s
+000096c0: 7461 6e64 6172 6420 6465 7669 6174 696f  tandard deviatio
+000096d0: 6e20 7370 6563 6966 6965 6420 6279 2074  n specified by t
+000096e0: 6865 2063 616d 6572 6120 636f 6e73 7472  he camera constr
+000096f0: 7563 746f 722e 0a0a 2020 2020 2020 2020  uctor...        
+00009700: 3a73 6565 616c 736f 3a20 3a6d 6574 683a  :seealso: :meth:
+00009710: 606e 6f69 7365 600a 2020 2020 2020 2020  `noise`.        
+00009720: 2222 220a 2020 2020 2020 2020 2320 6469  """.        # di
+00009730: 7374 6f72 7420 7468 6520 7069 7865 6c73  stort the pixels
+00009740: 0a0a 2020 2020 2020 2020 2320 6164 6420  ..        # add 
+00009750: 4761 7573 7369 616e 206e 6f69 7365 2077  Gaussian noise w
+00009760: 6974 6820 7370 6563 6966 6965 6420 7374  ith specified st
+00009770: 616e 6461 7264 2064 6576 6961 7469 6f6e  andard deviation
+00009780: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00009790: 2e6e 6f69 7365 2069 7320 6e6f 7420 4e6f  .noise is not No
+000097a0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+000097b0: 7576 202b 3d20 7365 6c66 2e5f 7261 6e64  uv += self._rand
+000097c0: 6f6d 2e6e 6f72 6d61 6c28 302e 302c 2073  om.normal(0.0, s
+000097d0: 656c 662e 6e6f 6973 652c 2073 697a 653d  elf.noise, size=
+000097e0: 7576 2e73 6861 7065 290a 2020 2020 2020  uv.shape).      
+000097f0: 2020 7265 7475 726e 2075 760a 0a0a 636c    return uv...cl
+00009800: 6173 7320 4365 6e74 7261 6c43 616d 6572  ass CentralCamer
+00009810: 6128 4361 6d65 7261 4261 7365 293a 0a20  a(CameraBase):. 
+00009820: 2020 2022 2222 0a20 2020 2043 7265 6174     """.    Creat
+00009830: 6520 6365 6e74 7261 6c20 6361 6d65 7261  e central camera
+00009840: 2070 726f 6a65 6374 696f 6e20 6d6f 6465   projection mode
+00009850: 6c0a 0a20 2020 202e 2e20 696e 6865 7269  l..    .. inheri
+00009860: 7461 6e63 652d 6469 6167 7261 6d3a 3a20  tance-diagram:: 
+00009870: 6d61 6368 696e 6576 6973 696f 6e74 6f6f  machinevisiontoo
+00009880: 6c62 6f78 2e43 616d 6572 612e 4365 6e74  lbox.Camera.Cent
+00009890: 7261 6c43 616d 6572 610a 2020 2020 2020  ralCamera.      
+000098a0: 2020 3a74 6f70 2d63 6c61 7373 6573 3a20    :top-classes: 
+000098b0: 6d61 6368 696e 6576 6973 696f 6e74 6f6f  machinevisiontoo
+000098c0: 6c62 6f78 2e43 616d 6572 612e 4361 6d65  lbox.Camera.Came
+000098d0: 7261 0a20 2020 2020 2020 203a 7061 7274  ra.        :part
+000098e0: 733a 2031 0a0a 2020 2020 3a70 6172 616d  s: 1..    :param
+000098f0: 2066 3a20 666f 6361 6c20 6c65 6e67 7468   f: focal length
+00009900: 2c20 6465 6661 756c 7473 2074 6f20 386d  , defaults to 8m
+00009910: 6d0a 2020 2020 3a74 7970 6520 663a 2066  m.    :type f: f
+00009920: 6c6f 6174 2c20 6f70 7469 6f6e 616c 0a20  loat, optional. 
+00009930: 2020 203a 7061 7261 6d20 6469 7374 6f72     :param distor
+00009940: 7469 6f6e 3a20 6361 6d65 7261 2064 6973  tion: camera dis
+00009950: 746f 7274 696f 6e20 7061 7261 6d65 7465  tortion paramete
+00009960: 7273 2c20 6465 6661 756c 7473 2074 6f20  rs, defaults to 
+00009970: 4e6f 6e65 0a20 2020 203a 7479 7065 2064  None.    :type d
+00009980: 6973 746f 7274 696f 6e3a 2061 7272 6179  istortion: array
+00009990: 5f6c 696b 6528 3529 2c20 6f70 7469 6f6e  _like(5), option
+000099a0: 616c 0a20 2020 203a 7061 7261 6d20 6b77  al.    :param kw
+000099b0: 6172 6773 3a20 6172 6775 6d65 6e74 7320  args: arguments 
+000099c0: 7061 7373 6564 2074 6f20 3a63 6c61 7373  passed to :class
+000099d0: 3a60 4361 6d65 7261 4261 7365 6020 636f  :`CameraBase` co
+000099e0: 6e73 7472 7563 746f 720a 0a0a 2020 2020  nstructor...    
+000099f0: 4120 6361 6d65 7261 206f 626a 6563 7420  A camera object 
+00009a00: 636f 6e74 6169 6e73 206d 6574 686f 6473  contains methods
+00009a10: 2066 6f72 2070 726f 6a65 6374 696e 6720   for projecting 
+00009a20: 3344 2070 6f69 6e74 7320 616e 6420 6c69  3D points and li
+00009a30: 6e65 730a 2020 2020 746f 2074 6865 2069  nes.    to the i
+00009a40: 6d61 6765 2070 6c61 6e65 2c20 6173 2077  mage plane, as w
+00009a50: 656c 6c20 6173 2073 7570 706f 7274 696e  ell as supportin
+00009a60: 6720 6120 7669 7274 7561 6c20 696d 6167  g a virtual imag
+00009a70: 6520 706c 616e 6520 6f6e 746f 0a20 2020  e plane onto.   
+00009a80: 2077 6869 6368 2033 4420 706f 696e 7473   which 3D points
+00009a90: 2061 6e64 206c 696e 6573 2063 616e 2062   and lines can b
+00009aa0: 6520 6472 6177 6e2e 0a0a 2020 2020 3a72  e drawn...    :r
+00009ab0: 6566 6572 656e 6365 733a 0a20 2020 2020  eferences:.     
+00009ac0: 2020 202d 2052 6f62 6f74 6963 732c 2056     - Robotics, V
+00009ad0: 6973 696f 6e20 2620 436f 6e74 726f 6c20  ision & Control 
+00009ae0: 666f 7220 5079 7468 6f6e 2c20 5365 6374  for Python, Sect
+00009af0: 696f 6e20 3133 2e31 2c20 502e 2043 6f72  ion 13.1, P. Cor
+00009b00: 6b65 2c20 5370 7269 6e67 6572 2032 3032  ke, Springer 202
+00009b10: 332e 0a0a 2020 2020 3a73 6565 616c 736f  3...    :seealso
+00009b20: 3a20 3a63 6c61 7373 3a60 4361 6d65 7261  : :class:`Camera
+00009b30: 4261 7365 6020 3a63 6c61 7373 3a60 4669  Base` :class:`Fi
+00009b40: 7368 4579 6543 616d 6572 6160 203a 636c  shEyeCamera` :cl
+00009b50: 6173 733a 6053 7068 6572 6963 616c 4361  ass:`SphericalCa
+00009b60: 6d65 7261 600a 2020 2020 2222 220a 0a20  mera`.    """.. 
+00009b70: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+00009b80: 7365 6c66 2c20 663d 312c 2064 6973 746f  self, f=1, disto
+00009b90: 7274 696f 6e3d 4e6f 6e65 2c20 2a2a 6b77  rtion=None, **kw
+00009ba0: 6172 6773 293a 0a0a 2020 2020 2020 2020  args):..        
+00009bb0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+00009bc0: 2863 616d 7479 7065 3d22 7065 7273 7065  (camtype="perspe
+00009bd0: 6374 6976 6522 2c20 2a2a 6b77 6172 6773  ctive", **kwargs
+00009be0: 290a 2020 2020 2020 2020 2320 544f 444f  ).        # TODO
+00009bf0: 2073 6f6d 6520 6f66 2074 6869 7320 6c6f   some of this lo
+00009c00: 6769 6320 746f 2066 2061 6e64 2070 7020  gic to f and pp 
+00009c10: 7365 7474 6572 730a 2020 2020 2020 2020  setters.        
+00009c20: 7365 6c66 2e66 203d 2066 0a0a 2020 2020  self.f = f..    
+00009c30: 2020 2020 7365 6c66 2e5f 6469 7374 6f72      self._distor
+00009c40: 7469 6f6e 203d 2064 6973 746f 7274 696f  tion = distortio
+00009c50: 6e0a 0a20 2020 2040 636c 6173 736d 6574  n..    @classmet
+00009c60: 686f 640a 2020 2020 6465 6620 4465 6661  hod.    def Defa
+00009c70: 756c 7428 636c 732c 202a 2a6b 7761 7267  ult(cls, **kwarg
+00009c80: 7329 3a0a 2020 2020 2020 2020 7222 2222  s):.        r"""
+00009c90: 0a20 2020 2020 2020 2053 6574 2064 6566  .        Set def
+00009ca0: 6175 6c74 2063 656e 7472 616c 2063 616d  ault central cam
+00009cb0: 6572 6120 7061 7261 6d65 7465 7273 0a0a  era parameters..
+00009cc0: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
+00009cd0: 2063 656e 7472 616c 2063 616d 6572 6120   central camera 
+00009ce0: 6d6f 6465 6c0a 2020 2020 2020 2020 3a72  model.        :r
+00009cf0: 7479 7065 3a20 3a63 6c61 7373 3a60 4365  type: :class:`Ce
+00009d00: 6e74 7261 6c43 616d 6572 6160 2069 6e73  ntralCamera` ins
+00009d10: 7461 6e63 650a 0a20 2020 2020 2020 2049  tance..        I
+00009d20: 6e69 7469 616c 697a 6520 6120 6365 6e74  nitialize a cent
+00009d30: 7261 6c20 6361 6d65 7261 2077 6974 683a  ral camera with:
+00009d40: 2066 6f63 616c 206c 656e 6774 6820 6f66   focal length of
+00009d50: 2038 6d6d 2c20 3a6d 6174 683a 6031 305c   8mm, :math:`10\
+00009d60: 6d75 5c6d 626f 787b 6d7d 6020 7069 7865  mu\mbox{m}` pixe
+00009d70: 6c73 2c0a 2020 2020 2020 2020 696d 6167  ls,.        imag
+00009d80: 6520 7369 7a65 206f 6620 3a6d 6174 683a  e size of :math:
+00009d90: 6031 3030 3020 5c74 696d 6573 2031 3030  `1000 \times 100
+00009da0: 3060 2077 6974 6820 7072 696e 6369 7061  0` with principa
+00009db0: 6c20 706f 696e 7420 6174 2028 3530 302c  l point at (500,
+00009dc0: 2035 3030 292e 0a0a 2020 2020 2020 2020   500)...        
+00009dd0: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
+00009de0: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+00009df0: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
+00009e00: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
+00009e10: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+00009e20: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
+00009e30: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
+00009e40: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
+00009e50: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
+00009e60: 6175 6c74 286e 616d 653d 2763 616d 6572  ault(name='camer
+00009e70: 6131 2729 0a20 2020 2020 2020 2020 2020  a1').           
+00009e80: 203e 3e3e 2063 616d 6572 610a 0a20 2020   >>> camera..   
+00009e90: 2020 2020 203a 7265 6665 7265 6e63 6573       :references
+00009ea0: 3a0a 2020 2020 2020 2020 2020 2020 2d20  :.            - 
+00009eb0: 526f 626f 7469 6373 2c20 5669 7369 6f6e  Robotics, Vision
+00009ec0: 2026 2043 6f6e 7472 6f6c 2066 6f72 2050   & Control for P
+00009ed0: 7974 686f 6e2c 2053 6563 7469 6f6e 2031  ython, Section 1
+00009ee0: 332e 312c 2050 2e20 436f 726b 652c 2053  3.1, P. Corke, S
+00009ef0: 7072 696e 6765 7220 3230 3233 2e0a 0a20  pringer 2023... 
+00009f00: 2020 2020 2020 203a 7365 6561 6c73 6f3a         :seealso:
+00009f10: 203a 636c 6173 733a 6043 656e 7472 616c   :class:`Central
+00009f20: 4361 6d65 7261 600a 2020 2020 2020 2020  Camera`.        
+00009f30: 2222 220a 2020 2020 2020 2020 6465 6661  """.        defa
+00009f40: 756c 7420 3d20 7b0a 2020 2020 2020 2020  ult = {.        
+00009f50: 2020 2020 2266 223a 2030 2e30 3038 2c0a      "f": 0.008,.
+00009f60: 2020 2020 2020 2020 2020 2020 2272 686f              "rho
+00009f70: 223a 2031 3065 2d36 2c0a 2020 2020 2020  ": 10e-6,.      
+00009f80: 2020 2020 2020 2269 6d61 6765 7369 7a65        "imagesize
+00009f90: 223a 2031 3030 302c 0a20 2020 2020 2020  ": 1000,.       
+00009fa0: 2020 2020 2022 7070 223a 2028 3530 302c       "pp": (500,
+00009fb0: 2035 3030 292c 0a20 2020 2020 2020 2020   500),.         
+00009fc0: 2020 2022 6e61 6d65 223a 2022 6465 6661     "name": "defa
+00009fd0: 756c 7420 7065 7273 7065 6374 6976 6520  ult perspective 
+00009fe0: 6361 6d65 7261 222c 0a20 2020 2020 2020  camera",.       
+00009ff0: 207d 0a0a 2020 2020 2020 2020 7265 7475   }..        retu
+0000a000: 726e 2043 656e 7472 616c 4361 6d65 7261  rn CentralCamera
+0000a010: 282a 2a7b 2a2a 6465 6661 756c 742c 202a  (**{**default, *
+0000a020: 2a6b 7761 7267 737d 290a 0a20 2020 2064  *kwargs})..    d
+0000a030: 6566 205f 5f73 7472 5f5f 2873 656c 6629  ef __str__(self)
+0000a040: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+0000a050: 2020 2020 2020 5374 7269 6e67 2072 6570        String rep
+0000a060: 7265 7365 6e74 6174 696f 6e20 6f66 2063  resentation of c
+0000a070: 656e 7472 616c 2063 616d 6572 6120 7061  entral camera pa
+0000a080: 7261 6d65 7465 7273 0a0a 2020 2020 2020  rameters..      
+0000a090: 2020 3a72 6574 7572 6e3a 2073 7472 696e    :return: strin
+0000a0a0: 6720 7265 7072 6573 656e 7461 7469 6f6e  g representation
+0000a0b0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+0000a0c0: 2073 7472 0a0a 2020 2020 2020 2020 4d75   str..        Mu
+0000a0d0: 6c74 692d 6c69 6e65 2073 7472 696e 6720  lti-line string 
+0000a0e0: 7265 7072 6573 656e 7461 7469 6f6e 206f  representation o
+0000a0f0: 6620 6361 6d65 7261 2069 6e74 7269 6e73  f camera intrins
+0000a100: 6963 2061 6e64 2065 7874 7269 6e73 6963  ic and extrinsic
+0000a110: 0a20 2020 2020 2020 2070 6172 616d 6574  .        paramet
+0000a120: 6572 732e 0a20 2020 2020 2020 2022 2222  ers..        """
+0000a130: 0a20 2020 2020 2020 2073 203d 2073 7570  .        s = sup
+0000a140: 6572 2829 2e5f 5f73 7472 5f5f 2829 0a20  er().__str__(). 
+0000a150: 2020 2020 2020 2073 202b 3d20 7365 6c66         s += self
+0000a160: 2e66 6d74 2e66 6f72 6d61 7428 2270 7269  .fmt.format("pri
+0000a170: 6e63 6970 616c 2070 7422 2c20 7365 6c66  ncipal pt", self
+0000a180: 2e70 7029 0a20 2020 2020 2020 2073 202b  .pp).        s +
+0000a190: 3d20 7365 6c66 2e66 6d74 2e66 6f72 6d61  = self.fmt.forma
+0000a1a0: 7428 2266 6f63 616c 206c 656e 6774 6822  t("focal length"
+0000a1b0: 2c20 7365 6c66 2e66 290a 2020 2020 2020  , self.f).      
+0000a1c0: 2020 7265 7475 726e 2073 0a0a 2020 2020    return s..    
+0000a1d0: 6465 6620 7072 6f6a 6563 745f 706f 696e  def project_poin
+0000a1e0: 7428 0a20 2020 2020 2020 2073 656c 662c  t(.        self,
+0000a1f0: 0a20 2020 2020 2020 2050 2c0a 2020 2020  .        P,.    
+0000a200: 2020 2020 706f 7365 3d4e 6f6e 652c 0a20      pose=None,. 
+0000a210: 2020 2020 2020 206f 626a 706f 7365 3d4e         objpose=N
+0000a220: 6f6e 652c 0a20 2020 2020 2020 2062 6568  one,.        beh
+0000a230: 696e 643d 5472 7565 2c0a 2020 2020 2020  ind=True,.      
+0000a240: 2020 7669 7369 6269 6c69 7479 3d46 616c    visibility=Fal
+0000a250: 7365 2c0a 2020 2020 2020 2020 7265 7469  se,.        reti
+0000a260: 6e61 6c3d 4661 6c73 652c 0a20 2020 2020  nal=False,.     
+0000a270: 2020 202a 2a6b 7761 7267 732c 0a20 2020     **kwargs,.   
+0000a280: 2029 3a0a 2020 2020 2020 2020 7222 2222   ):.        r"""
+0000a290: 0a20 2020 2020 2020 2050 726f 6a65 6374  .        Project
+0000a2a0: 2033 4420 706f 696e 7473 2074 6f20 696d   3D points to im
+0000a2b0: 6167 6520 706c 616e 650a 0a20 2020 2020  age plane..     
+0000a2c0: 2020 203a 7061 7261 6d20 503a 2033 4420     :param P: 3D 
+0000a2d0: 776f 726c 6420 706f 696e 7420 6f72 2070  world point or p
+0000a2e0: 6f69 6e74 7320 696e 2045 7563 6c69 6465  oints in Euclide
+0000a2f0: 616e 206f 7220 686f 6d6f 6765 6e65 6f75  an or homogeneou
+0000a300: 7320 666f 726d 0a20 2020 2020 2020 203a  s form.        :
+0000a310: 7479 7065 2050 3a20 6172 7261 795f 6c69  type P: array_li
+0000a320: 6b65 2833 292c 2061 7272 6179 5f6c 696b  ke(3), array_lik
+0000a330: 6528 332c 6e29 2c20 6172 7261 795f 6c69  e(3,n), array_li
+0000a340: 6b65 2834 292c 2061 7272 6179 5f6c 696b  ke(4), array_lik
+0000a350: 6528 342c 6e29 0a20 2020 2020 2020 203a  e(4,n).        :
+0000a360: 7061 7261 6d20 706f 7365 3a20 6361 6d65  param pose: came
+0000a370: 7261 2070 6f73 6520 7769 7468 2072 6573  ra pose with res
+0000a380: 7065 6374 2074 6f20 7468 6520 776f 726c  pect to the worl
+0000a390: 6420 6672 616d 652c 2064 6566 6175 6c74  d frame, default
+0000a3a0: 7320 746f 0a20 2020 2020 2020 2020 2020  s to.           
+0000a3b0: 2063 616d 6572 6127 7320 6060 706f 7365   camera's ``pose
+0000a3c0: 6060 2061 7474 7269 6275 7465 0a20 2020  `` attribute.   
+0000a3d0: 2020 2020 203a 7479 7065 2070 6f73 653a       :type pose:
+0000a3e0: 203a 636c 6173 733a 607e 7370 6174 6961   :class:`~spatia
+0000a3f0: 6c6d 6174 682e 2e70 6f73 6533 642e 5345  lmath..pose3d.SE
+0000a400: 3360 2c20 6f70 7469 6f6e 616c 0a20 2020  3`, optional.   
+0000a410: 2020 2020 203a 7061 7261 6d20 6f62 6a70       :param objp
+0000a420: 6f73 653a 2020 3344 2070 6f69 6e74 2072  ose:  3D point r
+0000a430: 6566 6572 656e 6365 2066 7261 6d65 2c20  eference frame, 
+0000a440: 6465 6661 756c 7473 2074 6f20 776f 726c  defaults to worl
+0000a450: 6420 6672 616d 650a 2020 2020 2020 2020  d frame.        
+0000a460: 3a74 7970 6520 6f62 6a70 6f73 653a 203a  :type objpose: :
+0000a470: 636c 6173 733a 607e 7370 6174 6961 6c6d  class:`~spatialm
+0000a480: 6174 682e 2e70 6f73 6533 642e 5345 3360  ath..pose3d.SE3`
+0000a490: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
+0000a4a0: 2020 203a 7061 7261 6d20 6265 6869 6e64     :param behind
+0000a4b0: 3a20 706f 696e 7473 2062 6568 696e 6420  : points behind 
+0000a4c0: 7468 6520 6361 6d65 7261 2069 6e64 6963  the camera indic
+0000a4d0: 6174 6564 2062 7920 4e61 4e2c 2064 6566  ated by NaN, def
+0000a4e0: 6175 6c74 7320 746f 2054 7275 650a 2020  aults to True.  
+0000a4f0: 2020 2020 2020 3a74 7970 6520 6265 6869        :type behi
+0000a500: 6e64 3a20 626f 6f6c 2c20 6f70 7469 6f6e  nd: bool, option
+0000a510: 616c 0a20 2020 2020 2020 203a 7061 7261  al.        :para
+0000a520: 6d20 7669 7369 6269 6c69 7479 3a20 7265  m visibility: re
+0000a530: 7475 726e 2076 6973 6962 696c 6974 7920  turn visibility 
+0000a540: 6172 7261 792c 2064 6566 6175 6c74 7320  array, defaults 
+0000a550: 746f 2046 616c 7365 0a20 2020 2020 2020  to False.       
+0000a560: 203a 7479 7065 2076 6973 6962 696c 6974   :type visibilit
+0000a570: 793a 2062 6f6f 6c0a 2020 2020 2020 2020  y: bool.        
+0000a580: 3a70 6172 616d 2072 6574 696e 616c 3a20  :param retinal: 
+0000a590: 7472 616e 7366 6f72 6d20 746f 2072 6574  transform to ret
+0000a5a0: 696e 616c 2063 6f6f 7264 696e 6174 6573  inal coordinates
+0000a5b0: 2c20 6465 6661 756c 7473 2074 6f20 4661  , defaults to Fa
+0000a5c0: 6c73 650a 2020 2020 2020 2020 3a74 7970  lse.        :typ
+0000a5d0: 6520 7265 7469 6e61 6c3a 2062 6f6f 6c2c  e retinal: bool,
+0000a5e0: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
+0000a5f0: 2020 3a72 6574 7572 6e3a 2069 6d61 6765    :return: image
+0000a600: 2070 6c61 6e65 2070 6f69 6e74 732c 206f   plane points, o
+0000a610: 7074 696f 6e61 6c20 7669 7369 6269 6c69  ptional visibili
+0000a620: 7479 2076 6563 746f 720a 2020 2020 2020  ty vector.      
+0000a630: 2020 3a72 7479 7065 3a20 6e64 6172 7261    :rtype: ndarra
+0000a640: 7928 322c 6e29 2c20 6e64 6172 7261 7928  y(2,n), ndarray(
+0000a650: 6e29 0a0a 2020 2020 2020 2020 5072 6f6a  n)..        Proj
+0000a660: 6563 7420 6120 3344 2070 6f69 6e74 2074  ect a 3D point t
+0000a670: 6f20 7468 6520 696d 6167 6520 706c 616e  o the image plan
+0000a680: 650a 0a20 2020 2020 2020 202e 2e20 6d61  e..        .. ma
+0000a690: 7468 3a3a 0a0a 2020 2020 2020 2020 2020  th::..          
+0000a6a0: 2020 5c68 7665 637b 707d 203d 205c 6d61    \hvec{p} = \ma
+0000a6b0: 747b 437d 205c 6876 6563 7b50 7d0a 0a20  t{C} \hvec{P}.. 
+0000a6c0: 2020 2020 2020 2077 6865 7265 203a 6d61         where :ma
+0000a6d0: 7468 3a60 5c6d 6174 7b43 7d60 2069 7320  th:`\mat{C}` is 
+0000a6e0: 7468 6520 6361 6d65 7261 2063 616c 6962  the camera calib
+0000a6f0: 7261 7469 6f6e 206d 6174 7269 7820 616e  ration matrix an
+0000a700: 640a 2020 2020 2020 2020 3a6d 6174 683a  d.        :math:
+0000a710: 605c 6876 6563 7b70 7d60 2061 6e64 203a  `\hvec{p}` and :
+0000a720: 6d61 7468 3a60 5c68 7665 637b 507d 6020  math:`\hvec{P}` 
+0000a730: 6172 6520 7468 6520 696d 6167 6520 706c  are the image pl
+0000a740: 616e 6520 616e 6420 776f 726c 640a 2020  ane and world.  
+0000a750: 2020 2020 2020 6672 616d 6520 636f 6f72        frame coor
+0000a760: 6469 6e61 7465 7320 7265 7370 6563 7469  dinates respecti
+0000a770: 7665 6c79 2c20 696e 2068 6f6d 6f67 656e  vely, in homogen
+0000a780: 656f 7573 2066 6f72 6d2e 0a0a 2020 2020  eous form...    
+0000a790: 2020 2020 576f 726c 6420 706f 696e 7473      World points
+0000a7a0: 2061 7265 2067 6976 656e 2061 7320 6120   are given as a 
+0000a7b0: 3144 2061 7272 6179 206f 7220 7468 6520  1D array or the 
+0000a7c0: 636f 6c75 6d6e 7320 6f66 2061 2032 4420  columns of a 2D 
+0000a7d0: 6172 7261 7920 6f66 0a20 2020 2020 2020  array of.       
+0000a7e0: 2045 7563 6c69 6465 616e 206f 7220 686f   Euclidean or ho
+0000a7f0: 6d6f 6765 6e65 6f75 7320 636f 6f72 6469  mogeneous coordi
+0000a800: 6e61 7465 732e 2054 6865 2063 6f6d 7075  nates. The compu
+0000a810: 7465 6420 696d 6167 6520 706c 616e 650a  ted image plane.
+0000a820: 2020 2020 2020 2020 636f 6f72 6469 6e61          coordina
+0000a830: 7465 7320 6172 6520 4575 636c 6964 6561  tes are Euclidea
+0000a840: 6e20 6f72 2068 6f6d 6f67 656e 656f 7573  n or homogeneous
+0000a850: 2061 6e64 2067 6976 656e 2061 7320 6120   and given as a 
+0000a860: 3144 2061 7272 6179 206f 7220 7468 650a  1D array or the.
+0000a870: 2020 2020 2020 2020 636f 7272 6573 706f          correspo
+0000a880: 6e64 696e 6720 636f 6c75 6d6e 7320 6f66  nding columns of
+0000a890: 2061 2032 4420 6172 7261 792e 0a0a 2020   a 2D array...  
+0000a8a0: 2020 2020 2020 4966 2060 6070 6f73 6560        If ``pose`
+0000a8b0: 6020 6973 2073 7065 6369 6669 6564 2069  ` is specified i
+0000a8c0: 7420 6973 2075 7365 6420 666f 7220 7468  t is used for th
+0000a8d0: 6520 6361 6d65 7261 2066 7261 6d65 2070  e camera frame p
+0000a8e0: 6f73 652c 206f 7468 6572 7769 7365 0a20  ose, otherwise. 
+0000a8f0: 2020 2020 2020 2074 6865 2061 7474 7269         the attri
+0000a900: 6275 7465 2060 6070 6f73 6560 6020 6973  bute ``pose`` is
+0000a910: 2075 7365 642e 2020 5468 6520 6f62 6a65   used.  The obje
+0000a920: 6374 2773 2060 6070 6f73 6560 6020 6174  ct's ``pose`` at
+0000a930: 7472 6962 7574 6520 6973 206e 6f74 0a20  tribute is not. 
+0000a940: 2020 2020 2020 2075 7064 6174 6564 2069         updated i
+0000a950: 6620 6060 706f 7365 6060 2069 7320 7370  f ``pose`` is sp
+0000a960: 6563 6966 6965 642e 0a0a 2020 2020 2020  ecified...      
+0000a970: 2020 4120 7369 6e67 6c65 2070 6f69 6e74    A single point
+0000a980: 2063 616e 2062 6520 7370 6563 6966 6965   can be specifie
+0000a990: 6420 6173 2061 2033 2d76 6563 746f 722c  d as a 3-vector,
+0000a9a0: 206d 756c 7469 706c 6520 706f 696e 7473   multiple points
+0000a9b0: 2061 7320 616e 0a20 2020 2020 2020 2061   as an.        a
+0000a9c0: 7272 6179 2077 6974 6820 7468 7265 6520  rray with three 
+0000a9d0: 726f 7773 2061 6e64 2065 6163 6820 636f  rows and each co
+0000a9e0: 6c75 6d6e 2069 7320 7468 6520 3344 2070  lumn is the 3D p
+0000a9f0: 6f69 6e74 2063 6f6f 7264 696e 6174 6520  oint coordinate 
+0000aa00: 2858 2c20 592c 0a20 2020 2020 2020 205a  (X, Y,.        Z
+0000aa10: 292e 0a0a 2020 2020 2020 2020 5468 6520  )...        The 
+0000aa20: 706f 696e 7473 2060 6050 6060 2061 7265  points ``P`` are
+0000aa30: 2062 7920 6465 6661 756c 7420 7769 7468   by default with
+0000aa40: 2072 6573 7065 6374 2074 6f20 7468 6520   respect to the 
+0000aa50: 776f 726c 6420 6672 616d 652c 2062 7574  world frame, but
+0000aa60: 0a20 2020 2020 2020 2074 6865 7920 6361  .        they ca
+0000aa70: 6e20 6265 2074 7261 6e73 666f 726d 6564  n be transformed
+0000aa80: 2062 7920 7370 6563 6966 7969 6e67 2060   by specifying `
+0000aa90: 606f 626a 706f 7365 6060 2e0a 0a20 2020  `objpose``...   
+0000aaa0: 2020 2020 2049 6620 776f 726c 6420 706f       If world po
+0000aab0: 696e 7473 2061 7265 2062 6568 696e 6420  ints are behind 
+0000aac0: 7468 6520 6361 6d65 7261 2061 6e64 2060  the camera and `
+0000aad0: 6062 6568 696e 6460 6020 6973 2054 7275  `behind`` is Tru
+0000aae0: 6520 7468 656e 2074 6865 0a20 2020 2020  e then the.     
+0000aaf0: 2020 2069 6d61 6765 2070 6c61 6e65 2063     image plane c
+0000ab00: 6f6f 7264 696e 6174 6573 2061 7265 2073  oordinates are s
+0000ab10: 6574 2074 6f20 4e61 4e2e 0a0a 2020 2020  et to NaN...    
+0000ab20: 2020 2020 6966 2060 6076 6973 6962 696c      if ``visibil
+0000ab30: 6974 7960 6020 6973 2054 7275 6520 7468  ity`` is True th
+0000ab40: 656e 2065 6163 6820 7072 6f6a 6563 7465  en each projecte
+0000ab50: 6420 706f 696e 7420 6973 2063 6865 636b  d point is check
+0000ab60: 6564 2074 6f20 656e 7375 7265 0a20 2020  ed to ensure.   
+0000ab70: 2020 2020 2069 7420 6c69 6573 2069 6e20       it lies in 
+0000ab80: 7468 6520 626f 756e 6473 206f 6620 7468  the bounds of th
+0000ab90: 6520 696d 6167 6520 706c 616e 652e 2020  e image plane.  
+0000aba0: 496e 2074 6869 7320 6361 7365 2074 6865  In this case the
+0000abb0: 7265 2061 7265 2074 776f 0a20 2020 2020  re are two.     
+0000abc0: 2020 2072 6574 7572 6e20 7661 6c75 6573     return values
+0000abd0: 3a20 7468 6520 696d 6167 6520 706c 616e  : the image plan
+0000abe0: 6520 636f 6f72 6469 6e61 7465 7320 616e  e coordinates an
+0000abf0: 6420 616e 2061 7272 6179 206f 6620 626f  d an array of bo
+0000ac00: 6f6c 6561 6e73 0a20 2020 2020 2020 2069  oleans.        i
+0000ac10: 6e64 6963 6174 696e 6720 6966 2074 6865  ndicating if the
+0000ac20: 2063 6f72 7265 7370 6f6e 6469 6e67 2070   corresponding p
+0000ac30: 6f69 6e74 2069 7320 7669 7369 626c 652e  oint is visible.
+0000ac40: 0a0a 2020 2020 2020 2020 4966 2060 6072  ..        If ``r
+0000ac50: 6574 696e 616c 6060 2069 7320 5472 7565  etinal`` is True
+0000ac60: 2074 6865 6e20 7072 6f6a 6563 7420 706f   then project po
+0000ac70: 696e 7473 2069 6e20 7265 7469 6e61 6c20  ints in retinal 
+0000ac80: 636f 6f72 6469 6e61 7465 732c 0a20 2020  coordinates,.   
+0000ac90: 2020 2020 2069 6e20 756e 6974 7320 6f66       in units of
+0000aca0: 206d 6574 7265 7320 7769 7468 2072 6573   metres with res
+0000acb0: 7065 6374 2074 6f20 7468 6520 7072 696e  pect to the prin
+0000acc0: 6369 7061 6c20 706f 696e 742e 0a0a 2020  cipal point...  
+0000acd0: 2020 2020 2020 4578 616d 706c 653a 0a0a        Example:..
+0000ace0: 2020 2020 2020 2020 2e2e 2072 756e 626c          .. runbl
+0000acf0: 6f63 6b3a 3a20 7079 636f 6e0a 0a20 2020  ock:: pycon..   
+0000ad00: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
+0000ad10: 6d20 6d61 6368 696e 6576 6973 696f 6e74  m machinevisiont
+0000ad20: 6f6f 6c62 6f78 2069 6d70 6f72 7420 4365  oolbox import Ce
+0000ad30: 6e74 7261 6c43 616d 6572 610a 2020 2020  ntralCamera.    
+0000ad40: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
+0000ad50: 7261 203d 2043 656e 7472 616c 4361 6d65  ra = CentralCame
+0000ad60: 7261 2e44 6566 6175 6c74 2829 0a20 2020  ra.Default().   
+0000ad70: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+0000ad80: 6572 612e 7072 6f6a 6563 745f 706f 696e  era.project_poin
+0000ad90: 7428 2830 2e33 2c20 302e 342c 2032 2929  t((0.3, 0.4, 2))
+0000ada0: 0a0a 2020 2020 2020 2020 3a72 6566 6572  ..        :refer
+0000adb0: 656e 6365 733a 0a20 2020 2020 2020 2020  ences:.         
+0000adc0: 2020 202d 2052 6f62 6f74 6963 732c 2056     - Robotics, V
+0000add0: 6973 696f 6e20 2620 436f 6e74 726f 6c20  ision & Control 
+0000ade0: 666f 7220 5079 7468 6f6e 2c20 5365 6374  for Python, Sect
+0000adf0: 696f 6e20 3133 2e31 2c20 502e 2043 6f72  ion 13.1, P. Cor
+0000ae00: 6b65 2c20 5370 7269 6e67 6572 2032 3032  ke, Springer 202
+0000ae10: 332e 0a0a 2020 2020 2020 2020 3a73 6565  3...        :see
+0000ae20: 616c 736f 3a20 3a6d 6574 683a 6043 6020  also: :meth:`C` 
+0000ae30: 3a6d 6574 683a 6070 726f 6a65 6374 5f70  :meth:`project_p
+0000ae40: 6f69 6e74 6020 3a6d 6574 683a 6070 726f  oint` :meth:`pro
+0000ae50: 6a65 6374 5f6c 696e 6560 203a 6d65 7468  ject_line` :meth
+0000ae60: 3a60 7072 6f6a 6563 745f 7175 6164 7269  :`project_quadri
+0000ae70: 6360 0a20 2020 2020 2020 2022 2222 0a20  c`.        """. 
+0000ae80: 2020 2020 2020 2069 6620 706f 7365 2069         if pose i
+0000ae90: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0000aea0: 2020 2020 706f 7365 203d 2073 656c 662e      pose = self.
+0000aeb0: 706f 7365 0a0a 2020 2020 2020 2020 4320  pose..        C 
+0000aec0: 3d20 7365 6c66 2e43 2870 6f73 652c 2072  = self.C(pose, r
+0000aed0: 6574 696e 616c 3d72 6574 696e 616c 290a  etinal=retinal).
+0000aee0: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
+0000aef0: 7374 616e 6365 2850 2c20 6e70 2e6e 6461  stance(P, np.nda
+0000af00: 7272 6179 293a 0a20 2020 2020 2020 2020  rray):.         
+0000af10: 2020 2069 6620 502e 6e64 696d 203d 3d20     if P.ndim == 
+0000af20: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
+0000af30: 2020 2050 203d 2050 2e72 6573 6861 7065     P = P.reshape
+0000af40: 2828 2d31 2c20 3129 2920 2023 206d 616b  ((-1, 1))  # mak
+0000af50: 6520 6974 2061 2063 6f6c 756d 6e0a 2020  e it a column.  
+0000af60: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000af70: 2020 2020 2020 2020 5020 3d20 6261 7365          P = base
+0000af80: 2e67 6574 7665 6374 6f72 2850 2c20 6f75  .getvector(P, ou
+0000af90: 743d 2263 6f6c 2229 0a0a 2020 2020 2020  t="col")..      
+0000afa0: 2020 6966 2050 2e73 6861 7065 5b30 5d20    if P.shape[0] 
+0000afb0: 3d3d 2033 3a0a 2020 2020 2020 2020 2020  == 3:.          
+0000afc0: 2020 5020 3d20 6261 7365 2e65 3268 2850    P = base.e2h(P
+0000afd0: 2920 2023 206d 616b 6520 6974 2068 6f6d  )  # make it hom
+0000afe0: 6f67 656e 656f 7573 0a20 2020 2020 2020  ogeneous.       
+0000aff0: 2020 2020 2065 7563 6c69 6465 616e 203d       euclidean =
+0000b000: 2054 7275 650a 2020 2020 2020 2020 656c   True.        el
+0000b010: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000b020: 6575 636c 6964 6561 6e20 3d20 4661 6c73  euclidean = Fals
+0000b030: 650a 0a20 2020 2020 2020 2023 2070 726f  e..        # pro
+0000b040: 6a65 6374 2033 4420 706f 696e 7473 0a0a  ject 3D points..
+0000b050: 2020 2020 2020 2020 6966 206f 626a 706f          if objpo
+0000b060: 7365 2069 7320 6e6f 7420 4e6f 6e65 3a0a  se is not None:.
+0000b070: 2020 2020 2020 2020 2020 2020 5020 3d20              P = 
+0000b080: 6f62 6a70 6f73 652e 4120 4020 500a 0a20  objpose.A @ P.. 
+0000b090: 2020 2020 2020 2078 203d 2043 2040 2050         x = C @ P
+0000b0a0: 0a0a 2020 2020 2020 2020 6966 2062 6568  ..        if beh
+0000b0b0: 696e 643a 0a20 2020 2020 2020 2020 2020  ind:.           
+0000b0c0: 2078 5b32 2c20 785b 322c 203a 5d20 3c20   x[2, x[2, :] < 
+0000b0d0: 305d 203d 206e 702e 6e61 6e20 2023 2070  0] = np.nan  # p
+0000b0e0: 6f69 6e74 7320 6265 6869 6e64 2074 6865  oints behind the
+0000b0f0: 2063 616d 6572 6120 6172 6520 7365 7420   camera are set 
+0000b100: 746f 204e 614e 0a0a 2020 2020 2020 2020  to NaN..        
+0000b110: 6966 2065 7563 6c69 6465 616e 3a0a 2020  if euclidean:.  
+0000b120: 2020 2020 2020 2020 2020 2320 4575 636c            # Eucl
+0000b130: 6964 6561 6e20 706f 696e 7473 2067 6976  idean points giv
+0000b140: 656e 2c20 7265 7475 726e 2045 7563 6c69  en, return Eucli
+0000b150: 6465 616e 2070 6f69 6e74 730a 2020 2020  dean points.    
+0000b160: 2020 2020 2020 2020 7820 3d20 6261 7365          x = base
+0000b170: 2e68 3265 2878 290a 0a20 2020 2020 2020  .h2e(x)..       
+0000b180: 2020 2020 2023 2061 6464 2047 6175 7373       # add Gauss
+0000b190: 6961 6e20 6e6f 6973 6520 616e 6420 6469  ian noise and di
+0000b1a0: 7374 6f72 7469 6f6e 0a20 2020 2020 2020  stortion.       
+0000b1b0: 2020 2020 2069 6620 7365 6c66 2e5f 6469       if self._di
+0000b1c0: 7374 6f72 7469 6f6e 3a0a 2020 2020 2020  stortion:.      
+0000b1d0: 2020 2020 2020 2020 2020 7820 3d20 7365            x = se
+0000b1e0: 6c66 2e5f 6469 7374 6f72 7428 7829 0a20  lf._distort(x). 
+0000b1f0: 2020 2020 2020 2020 2020 2078 203d 2073             x = s
+0000b200: 656c 662e 5f61 6464 5f6e 6f69 7365 5f64  elf._add_noise_d
+0000b210: 6973 746f 7274 696f 6e28 7829 0a0a 2020  istortion(x)..  
+0000b220: 2020 2020 2020 2020 2020 2320 2064 6f20            #  do 
+0000b230: 7669 7369 6269 6c69 7479 2063 6865 636b  visibility check
+0000b240: 2069 6620 7265 7175 6972 6564 0a20 2020   if required.   
+0000b250: 2020 2020 2020 2020 2069 6620 7669 7369           if visi
+0000b260: 6269 6c69 7479 3a0a 2020 2020 2020 2020  bility:.        
+0000b270: 2020 2020 2020 2020 7669 7369 626c 6520          visible 
+0000b280: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+0000b290: 2020 2020 2020 2020 7e6e 702e 6973 6e61          ~np.isna
+0000b2a0: 6e28 785b 302c 203a 5d29 0a20 2020 2020  n(x[0, :]).     
+0000b2b0: 2020 2020 2020 2020 2020 2020 2020 2026                 &
+0000b2c0: 2028 785b 302c 203a 5d20 3e3d 2030 290a   (x[0, :] >= 0).
+0000b2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2e0: 2020 2020 2620 2878 5b31 2c20 3a5d 203e      & (x[1, :] >
+0000b2f0: 3d20 3029 0a20 2020 2020 2020 2020 2020  = 0).           
+0000b300: 2020 2020 2020 2020 2026 2028 785b 302c           & (x[0,
+0000b310: 203a 5d20 3c20 7365 6c66 2e6e 7529 0a20   :] < self.nu). 
+0000b320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b330: 2020 2026 2028 785b 312c 203a 5d20 3c20     & (x[1, :] < 
+0000b340: 7365 6c66 2e6e 7629 0a20 2020 2020 2020  self.nv).       
+0000b350: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+0000b360: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000b370: 726e 2078 2c20 7669 7369 626c 650a 2020  rn x, visible.  
+0000b380: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000b390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b3a0: 7265 7475 726e 2078 0a20 2020 2020 2020  return x.       
+0000b3b0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000b3c0: 2020 2023 2068 6f6d 6f67 656e 656f 7573     # homogeneous
+0000b3d0: 2070 6f69 6e74 7320 6769 7665 6e2c 2072   points given, r
+0000b3e0: 6574 7572 6e20 686f 6d6f 6765 6e65 6f75  eturn homogeneou
+0000b3f0: 7320 706f 696e 7473 0a20 2020 2020 2020  s points.       
+0000b400: 2020 2020 2072 6574 7572 6e20 780a 0a20       return x.. 
+0000b410: 2020 2064 6566 2070 726f 6a65 6374 5f6c     def project_l
+0000b420: 696e 6528 7365 6c66 2c20 6c69 6e65 7329  ine(self, lines)
+0000b430: 3a0a 2020 2020 2020 2020 7222 2222 0a20  :.        r""". 
+0000b440: 2020 2020 2020 2050 726f 6a65 6374 2033         Project 3
+0000b450: 4420 6c69 6e65 7320 746f 2069 6d61 6765  D lines to image
+0000b460: 2070 6c61 6e65 0a0a 2020 2020 2020 2020   plane..        
+0000b470: 3a70 6172 616d 206c 696e 6573 3a20 506c  :param lines: Pl
+0000b480: 7563 6b65 7220 6c69 6e65 206f 7220 6c69  ucker line or li
+0000b490: 6e65 730a 2020 2020 2020 2020 3a74 7970  nes.        :typ
+0000b4a0: 6520 6c69 6e65 733a 203a 636c 6173 733a  e lines: :class:
+0000b4b0: 607e 7370 6174 6961 6c6d 6174 682e 2e67  `~spatialmath..g
+0000b4c0: 656f 6d33 642e 4c69 6e65 3360 2069 6e73  eom3d.Line3` ins
+0000b4d0: 7461 6e63 6520 7769 7468 204e 2076 616c  tance with N val
+0000b4e0: 7565 730a 2020 2020 2020 2020 3a72 6574  ues.        :ret
+0000b4f0: 7572 6e3a 2032 4420 686f 6d6f 6765 6e65  urn: 2D homogene
+0000b500: 6f75 7320 6c69 6e65 732c 206f 6e65 2070  ous lines, one p
+0000b510: 6572 2063 6f6c 756d 6e0a 2020 2020 2020  er column.      
+0000b520: 2020 3a72 7479 7065 3a20 6e64 6172 7261    :rtype: ndarra
+0000b530: 7928 332c 4e29 0a0a 2020 2020 2020 2020  y(3,N)..        
+0000b540: 5468 6520 3a63 6c61 7373 3a60 7e73 7061  The :class:`~spa
+0000b550: 7469 616c 6d61 7468 2e2e 6765 6f6d 3364  tialmath..geom3d
+0000b560: 2e4c 696e 6533 6020 6f62 6a65 6374 2063  .Line3` object c
+0000b570: 616e 2063 6f6e 7461 696e 206d 756c 7469  an contain multi
+0000b580: 706c 6520 6c69 6e65 732e 2020 5468 6520  ple lines.  The 
+0000b590: 7265 7375 6c74 2061 7272 6179 2068 6173  result array has
+0000b5a0: 206f 6e65 0a20 2020 2020 2020 2063 6f6c   one.        col
+0000b5b0: 756d 6e20 7065 7220 6c69 6e65 2c20 616e  umn per line, an
+0000b5c0: 6420 6561 6368 2063 6f6c 756d 6e20 6973  d each column is
+0000b5d0: 2061 2076 6563 746f 7220 6465 7363 7269   a vector descri
+0000b5e0: 6269 6e67 2074 6865 2069 6d61 6765 2070  bing the image p
+0000b5f0: 6c61 6e65 0a20 2020 2020 2020 206c 696e  lane.        lin
+0000b600: 6520 696e 2068 6f6d 6f67 656e 656f 7573  e in homogeneous
+0000b610: 2066 6f72 6d20 3a6d 6174 683a 605c 656c   form :math:`\el
+0000b620: 6c5f 3020 7520 2b20 5c65 6c6c 5f31 2076  l_0 u + \ell_1 v
+0000b630: 202b 205c 656c 6c5f 3220 3d20 3060 2e0a   + \ell_2 = 0`..
+0000b640: 0a20 2020 2020 2020 2054 6865 2070 726f  .        The pro
+0000b650: 6a65 6374 696f 6e20 6973 0a0a 2020 2020  jection is..    
+0000b660: 2020 2020 2e2e 206d 6174 683a 3a0a 0a20      .. math::.. 
+0000b670: 2020 2020 2020 2020 2020 205c 656c 6c20             \ell 
+0000b680: 3d20 5c76 6578 7b5c 6d61 747b 437d 205c  = \vex{\mat{C} \
+0000b690: 736b 7b5c 7665 637b 4c7d 7d20 5c6d 6174  sk{\vec{L}} \mat
+0000b6a0: 7b43 7d5e 7b5c 746f 707d 7d0a 0a20 2020  {C}^{\top}}..   
+0000b6b0: 2020 2020 2077 6865 7265 203a 6d61 7468       where :math
+0000b6c0: 3a60 5c6d 6174 7b43 7d60 2069 7320 7468  :`\mat{C}` is th
+0000b6d0: 6520 6361 6d65 7261 2063 616c 6962 7261  e camera calibra
+0000b6e0: 7469 6f6e 206d 6174 7269 7820 616e 6420  tion matrix and 
+0000b6f0: 3a6d 6174 683a 605c 736b 7b5c 7665 637b  :math:`\sk{\vec{
+0000b700: 4c7d 7d60 0a20 2020 2020 2020 2069 7320  L}}`.        is 
+0000b710: 7468 6520 736b 6577 206d 6174 7269 7820  the skew matrix 
+0000b720: 7265 7072 6573 656e 7461 7469 6f6e 206f  representation o
+0000b730: 6620 7468 6520 506c 7563 6b65 7220 6c69  f the Plucker li
+0000b740: 6e65 2e0a 0a20 2020 2020 2020 2045 7861  ne...        Exa
+0000b750: 6d70 6c65 3a0a 0a20 2020 2020 2020 202e  mple:..        .
+0000b760: 2e20 7275 6e62 6c6f 636b 3a3a 2070 7963  . runblock:: pyc
+0000b770: 6f6e 0a0a 2020 2020 2020 2020 2020 2020  on..            
+0000b780: 3e3e 3e20 6672 6f6d 206d 6163 6869 6e65  >>> from machine
+0000b790: 7669 7369 6f6e 746f 6f6c 626f 7820 696d  visiontoolbox im
+0000b7a0: 706f 7274 2043 656e 7472 616c 4361 6d65  port CentralCame
+0000b7b0: 7261 0a20 2020 2020 2020 2020 2020 203e  ra.            >
+0000b7c0: 3e3e 2066 726f 6d20 7370 6174 6961 6c6d  >> from spatialm
+0000b7d0: 6174 6820 696d 706f 7274 204c 696e 6533  ath import Line3
+0000b7e0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+0000b7f0: 206c 696e 6520 3d20 4c69 6e65 332e 4a6f   line = Line3.Jo
+0000b800: 696e 2828 2d33 2c20 2d34 2c20 3529 2c20  in((-3, -4, 5), 
+0000b810: 2835 2c20 322c 2036 2929 0a20 2020 2020  (5, 2, 6)).     
+0000b820: 2020 2020 2020 203e 3e3e 206c 696e 650a         >>> line.
+0000b830: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+0000b840: 6361 6d65 7261 203d 2043 656e 7472 616c  camera = Central
+0000b850: 4361 6d65 7261 2829 0a20 2020 2020 2020  Camera().       
+0000b860: 2020 2020 203e 3e3e 2063 616d 6572 612e       >>> camera.
+0000b870: 7072 6f6a 6563 745f 6c69 6e65 286c 696e  project_line(lin
+0000b880: 6529 0a0a 2020 2020 2020 2020 3a72 6566  e)..        :ref
+0000b890: 6572 656e 6365 733a 0a20 2020 2020 2020  erences:.       
+0000b8a0: 2020 2020 202d 2052 6f62 6f74 6963 732c       - Robotics,
+0000b8b0: 2056 6973 696f 6e20 2620 436f 6e74 726f   Vision & Contro
+0000b8c0: 6c20 666f 7220 5079 7468 6f6e 2c20 5365  l for Python, Se
+0000b8d0: 6374 696f 6e20 3133 2e37 2e31 2c20 502e  ction 13.7.1, P.
+0000b8e0: 2043 6f72 6b65 2c20 5370 7269 6e67 6572   Corke, Springer
+0000b8f0: 2032 3032 332e 0a0a 2020 2020 2020 2020   2023...        
+0000b900: 3a73 6565 616c 736f 3a20 3a6d 6574 683a  :seealso: :meth:
+0000b910: 6043 6020 3a63 6c61 7373 3a60 7e73 7061  `C` :class:`~spa
+0000b920: 7469 616c 6d61 7468 2e2e 6765 6f6d 3364  tialmath..geom3d
+0000b930: 2e4c 696e 6533 6020 3a6d 6574 683a 6070  .Line3` :meth:`p
+0000b940: 726f 6a65 6374 5f70 6f69 6e74 6020 3a6d  roject_point` :m
+0000b950: 6574 683a 6070 726f 6a65 6374 5f71 7561  eth:`project_qua
+0000b960: 6472 6963 600a 2020 2020 2020 2020 2222  dric`.        ""
+0000b970: 220a 2020 2020 2020 2020 6966 206e 6f74  ".        if not
+0000b980: 2069 7369 6e73 7461 6e63 6528 6c69 6e65   isinstance(line
+0000b990: 732c 204c 696e 6533 293a 0a20 2020 2020  s, Line3):.     
+0000b9a0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+0000b9b0: 7565 4572 726f 7228 2265 7870 6563 7469  ueError("expecti
+0000b9c0: 6e67 204c 696e 6533 206c 696e 6573 2229  ng Line3 lines")
+0000b9d0: 0a20 2020 2020 2020 2023 2070 726f 6a65  .        # proje
+0000b9e0: 6374 2050 6c75 636b 6572 206c 696e 6573  ct Plucker lines
+0000b9f0: 0a0a 2020 2020 2020 2020 6c69 6e65 7332  ..        lines2
+0000ba00: 6420 3d20 5b5d 0a20 2020 2020 2020 2043  d = [].        C
+0000ba10: 203d 2073 656c 662e 4328 290a 2020 2020   = self.C().    
+0000ba20: 2020 2020 666f 7220 6c69 6e65 2069 6e20      for line in 
+0000ba30: 6c69 6e65 733a 0a20 2020 2020 2020 2020  lines:.         
+0000ba40: 2020 206c 203d 2062 6173 652e 7665 7828     l = base.vex(
+0000ba50: 4320 4020 6c69 6e65 2e73 6b65 7728 2920  C @ line.skew() 
+0000ba60: 4020 432e 5429 0a20 2020 2020 2020 2020  @ C.T).         
+0000ba70: 2020 2078 203d 206c 202f 206e 702e 6d61     x = l / np.ma
+0000ba80: 7828 6e70 2e61 6273 286c 2929 2020 2320  x(np.abs(l))  # 
+0000ba90: 6e6f 726d 616c 697a 6520 6279 206c 6172  normalize by lar
+0000baa0: 6765 7374 2065 6c65 6d65 6e74 0a20 2020  gest element.   
+0000bab0: 2020 2020 2020 2020 206c 696e 6573 3264           lines2d
+0000bac0: 2e61 7070 656e 6428 7829 0a20 2020 2020  .append(x).     
+0000bad0: 2020 2072 6574 7572 6e20 6e70 2e63 6f6c     return np.col
+0000bae0: 756d 6e5f 7374 6163 6b28 6c69 6e65 7332  umn_stack(lines2
+0000baf0: 6429 0a0a 2020 2020 6465 6620 7072 6f6a  d)..    def proj
+0000bb00: 6563 745f 7175 6164 7269 6328 7365 6c66  ect_quadric(self
+0000bb10: 2c20 5129 3a0a 2020 2020 2020 2020 7222  , Q):.        r"
+0000bb20: 2222 0a20 2020 2020 2020 2050 726f 6a65  "".        Proje
+0000bb30: 6374 2033 4420 7175 6164 7269 6320 746f  ct 3D quadric to
+0000bb40: 2069 6d61 6765 2070 6c61 6e65 0a0a 2020   image plane..  
+0000bb50: 2020 2020 2020 3a70 6172 616d 2051 3a20        :param Q: 
+0000bb60: 7175 6164 7269 6320 6d61 7472 6978 0a20  quadric matrix. 
+0000bb70: 2020 2020 2020 203a 7479 7065 2051 3a20         :type Q: 
+0000bb80: 6e64 6172 7261 7928 342c 3429 0a20 2020  ndarray(4,4).   
+0000bb90: 2020 2020 203a 7265 7475 726e 3a20 696d       :return: im
+0000bba0: 6167 6520 706c 616e 6520 636f 6e69 630a  age plane conic.
+0000bbb0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+0000bbc0: 6e64 6172 7261 7928 332c 3329 0a0a 2020  ndarray(3,3)..  
+0000bbd0: 2020 2020 2020 5175 6164 7269 6373 2c20        Quadrics, 
+0000bbe0: 7368 6f72 7420 666f 7220 7175 6164 7261  short for quadra
+0000bbf0: 7469 6320 7375 7266 6163 6573 2c20 6172  tic surfaces, ar
+0000bc00: 6520 6120 7269 6368 2066 616d 696c 7920  e a rich family 
+0000bc10: 6f66 0a20 2020 2020 2020 2033 2d64 696d  of.        3-dim
+0000bc20: 656e 7369 6f6e 616c 2073 7572 6661 6365  ensional surface
+0000bc30: 732e 2054 6865 7265 2061 7265 2031 3720  s. There are 17 
+0000bc40: 7374 616e 6461 7264 2074 7970 6573 2069  standard types i
+0000bc50: 6e63 6c75 6469 6e67 2073 7068 6572 6573  ncluding spheres
+0000bc60: 2c0a 2020 2020 2020 2020 656c 6c69 7073  ,.        ellips
+0000bc70: 6f69 6473 2c20 6879 7065 722d 2062 6f6c  oids, hyper- bol
+0000bc80: 6f69 6473 2c20 7061 7261 626f 6c6f 6964  oids, paraboloid
+0000bc90: 732c 2063 796c 696e 6465 7273 2061 6e64  s, cylinders and
+0000bca0: 2063 6f6e 6573 2061 6c6c 0a20 2020 2020   cones all.     
+0000bcb0: 2020 2064 6573 6372 6962 6564 2062 7920     described by 
+0000bcc0: 706f 696e 7473 203a 6d61 7468 3a60 5c76  points :math:`\v
+0000bcd0: 6563 7b78 7d20 5c69 6e20 5c6d 6174 6862  ec{x} \in \mathb
+0000bce0: 627b 507d 5e33 6020 7375 6368 2074 6861  b{P}^3` such tha
+0000bcf0: 740a 0a20 2020 2020 2020 202e 2e20 6d61  t..        .. ma
+0000bd00: 7468 3a3a 0a0a 2020 2020 2020 2020 2020  th::..          
+0000bd10: 2020 5c68 7665 637b 787d 5e7b 5c74 6f70    \hvec{x}^{\top
+0000bd20: 7d20 5c6d 6174 7b51 7d20 5c68 7665 637b  } \mat{Q} \hvec{
+0000bd30: 787d 203d 2030 0a0a 2020 2020 2020 2020  x} = 0..        
+0000bd40: 5468 6520 6f75 746c 696e 6520 6f66 2074  The outline of t
+0000bd50: 6865 2071 7561 6472 6963 2069 7320 7072  he quadric is pr
+0000bd60: 6f6a 6563 7465 6420 746f 2061 2063 6f6e  ojected to a con
+0000bd70: 6963 2073 6563 7469 6f6e 206f 6e20 7468  ic section on th
+0000bd80: 6520 696d 6167 650a 2020 2020 2020 2020  e image.        
+0000bd90: 706c 616e 650a 0a20 2020 2020 2020 202e  plane..        .
+0000bda0: 2e20 6d61 7468 3a3a 0a0a 2020 2020 2020  . math::..      
+0000bdb0: 2020 2020 2020 635e 2a20 3d20 5c6d 6174        c^* = \mat
+0000bdc0: 7b43 7d20 5c6d 6174 7b51 7d5e 2a20 5c6d  {C} \mat{Q}^* \m
+0000bdd0: 6174 7b43 7d5e 7b5c 746f 707d 0a0a 2020  at{C}^{\top}..  
+0000bde0: 2020 2020 2020 7768 6572 6520 3a6d 6174        where :mat
+0000bdf0: 683a 6028 5c6d 6174 7b58 7d29 5e2a 203d  h:`(\mat{X})^* =
+0000be00: 2064 6574 285c 6d61 747b 587d 2920 5c6d   det(\mat{X}) \m
+0000be10: 6174 7b58 7d5e 7b2d 317d 6020 6973 2074  at{X}^{-1}` is t
+0000be20: 6865 2061 646a 7567 6174 650a 2020 2020  he adjugate.    
+0000be30: 2020 2020 6f70 6572 6174 6f72 2e0a 0a20      operator... 
+0000be40: 2020 2020 2020 2045 7861 6d70 6c65 3a0a         Example:.
+0000be50: 0a20 2020 2020 2020 202e 2e20 7275 6e62  .        .. runb
+0000be60: 6c6f 636b 3a3a 2070 7963 6f6e 0a0a 2020  lock:: pycon..  
+0000be70: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
+0000be80: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
+0000be90: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
+0000bea0: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
+0000beb0: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
+0000bec0: 6d20 7370 6174 6961 6c6d 6174 6820 696d  m spatialmath im
+0000bed0: 706f 7274 2053 4533 0a20 2020 2020 2020  port SE3.       
+0000bee0: 2020 2020 203e 3e3e 2054 5f63 616d 203d       >>> T_cam =
+0000bef0: 2053 4533 2e54 7261 6e73 2830 2e32 2c20   SE3.Trans(0.2, 
+0000bf00: 302e 312c 202d 3529 202a 2053 4533 2e52  0.1, -5) * SE3.R
+0000bf10: 7828 302e 3229 0a20 2020 2020 2020 2020  x(0.2).         
+0000bf20: 2020 203e 3e3e 2051 203d 206e 702e 6469     >>> Q = np.di
+0000bf30: 6167 285b 312c 2031 2c20 312c 202d 315d  ag([1, 1, 1, -1]
+0000bf40: 2920 2023 2075 6e69 7420 7370 6865 7265  )  # unit sphere
+0000bf50: 2061 7420 6f72 6967 696e 0a20 2020 2020   at origin.     
+0000bf60: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+0000bf70: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
+0000bf80: 612e 4465 6661 756c 7428 663d 302e 3031  a.Default(f=0.01
+0000bf90: 352c 2070 6f73 653d 545f 6361 6d29 3b0a  5, pose=T_cam);.
+0000bfa0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+0000bfb0: 6361 6d65 7261 2e70 726f 6a65 6374 5f71  camera.project_q
+0000bfc0: 7561 6472 6963 2851 290a 0a20 2020 2020  uadric(Q)..     
+0000bfd0: 2020 203a 7265 6665 7265 6e63 6573 3a0a     :references:.
+0000bfe0: 2020 2020 2020 2020 2020 2020 2d20 526f              - Ro
+0000bff0: 626f 7469 6373 2c20 5669 7369 6f6e 2026  botics, Vision &
+0000c000: 2043 6f6e 7472 6f6c 2066 6f72 2050 7974   Control for Pyt
+0000c010: 686f 6e2c 2053 6563 7469 6f6e 2031 332e  hon, Section 13.
+0000c020: 372e 312c 2050 2e20 436f 726b 652c 2053  7.1, P. Corke, S
+0000c030: 7072 696e 6765 7220 3230 3233 2e0a 0a20  pringer 2023... 
+0000c040: 2020 2020 2020 203a 7365 6561 6c73 6f3a         :seealso:
+0000c050: 203a 6d65 7468 3a60 4360 203a 6d65 7468   :meth:`C` :meth
+0000c060: 3a60 7072 6f6a 6563 745f 706f 696e 7460  :`project_point`
+0000c070: 203a 6d65 7468 3a60 7072 6f6a 6563 745f   :meth:`project_
+0000c080: 6c69 6e65 600a 2020 2020 2020 2020 2222  line`.        ""
+0000c090: 220a 2020 2020 2020 2020 6966 206e 6f74  ".        if not
+0000c0a0: 2073 6d62 6173 652e 6973 6d61 7472 6978   smbase.ismatrix
+0000c0b0: 2851 2c20 2834 2c20 3429 293a 0a20 2020  (Q, (4, 4)):.   
+0000c0c0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+0000c0d0: 616c 7565 4572 726f 7228 2265 7870 6563  alueError("expec
+0000c0e0: 7469 6e67 2034 7834 2063 6f6e 6963 206d  ting 4x4 conic m
+0000c0f0: 6174 7269 7822 290a 0a20 2020 2020 2020  atrix")..       
+0000c100: 2072 6574 7572 6e20 7365 6c66 2e43 2829   return self.C()
+0000c110: 2040 2051 2040 2073 656c 662e 4328 292e   @ Q @ self.C().
+0000c120: 540a 0a20 2020 2064 6566 2065 7069 6c69  T..    def epili
+0000c130: 6e65 2873 656c 662c 2070 2c20 6361 6d65  ne(self, p, came
+0000c140: 7261 3229 3a0a 2020 2020 2020 2020 7222  ra2):.        r"
+0000c150: 2222 0a20 2020 2020 2020 2043 6f6d 7075  "".        Compu
+0000c160: 7465 2065 7069 706f 6c61 7220 6c69 6e65  te epipolar line
+0000c170: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+0000c180: 2070 3a20 696d 6167 6520 706c 616e 6520   p: image plane 
+0000c190: 706f 696e 7420 6f72 2070 6f69 6e74 730a  point or points.
+0000c1a0: 2020 2020 2020 2020 3a74 7970 6520 703a          :type p:
+0000c1b0: 2061 7272 6179 5f6c 696b 6528 3229 206f   array_like(2) o
+0000c1c0: 7220 6e64 6172 7261 7928 322c 4e29 0a20  r ndarray(2,N). 
+0000c1d0: 2020 2020 2020 203a 7061 7261 6d20 6361         :param ca
+0000c1e0: 6d65 7261 323a 2073 6563 6f6e 6420 6361  mera2: second ca
+0000c1f0: 6d65 7261 0a20 2020 2020 2020 203a 7479  mera.        :ty
+0000c200: 7065 2063 616d 6572 6132 3a20 3a63 6c61  pe camera2: :cla
+0000c210: 7373 3a60 4365 6e74 7261 6c43 616d 6572  ss:`CentralCamer
+0000c220: 6160 2069 6e73 7461 6e63 650a 2020 2020  a` instance.    
+0000c230: 2020 2020 3a72 6574 7572 6e3a 2065 7069      :return: epi
+0000c240: 706f 6c61 7220 6c69 6e65 206f 7220 6c69  polar line or li
+0000c250: 6e65 7320 696e 2068 6f6d 6f67 656e 656f  nes in homogeneo
+0000c260: 7573 2066 6f72 6d0a 2020 2020 2020 2020  us form.        
+0000c270: 3a72 7479 7065 3a20 6e64 6172 7261 7928  :rtype: ndarray(
+0000c280: 3329 2c20 6e64 6172 7261 7928 332c 4e29  3), ndarray(3,N)
+0000c290: 0a0a 2020 2020 2020 2020 436f 6d70 7574  ..        Comput
+0000c2a0: 6520 7468 6520 6570 6970 6f6c 6172 206c  e the epipolar l
+0000c2b0: 696e 6520 696e 2060 6063 616d 6572 6132  ine in ``camera2
+0000c2c0: 6060 2069 6e64 7563 6564 2062 7920 7468  `` induced by th
+0000c2d0: 6520 696d 6167 6520 706c 616e 650a 2020  e image plane.  
+0000c2e0: 2020 2020 2020 706f 696e 7473 2060 6070        points ``p
+0000c2f0: 6060 2069 6e20 7468 6520 6375 7272 656e  `` in the curren
+0000c300: 7420 6361 6d65 7261 2e20 2045 6163 6820  t camera.  Each 
+0000c310: 6c69 6e65 2069 7320 6769 7665 6e20 6279  line is given by
+0000c320: 0a0a 2020 2020 2020 2020 2e2e 206d 6174  ..        .. mat
+0000c330: 683a 3a0a 0a20 2020 2020 2020 2020 2020  h::..           
+0000c340: 205c 656c 6c20 3d20 5c6d 6174 7b46 7d20   \ell = \mat{F} 
+0000c350: 7b7d 5e31 205c 6876 6563 7b70 7d0a 0a20  {}^1 \hvec{p}.. 
+0000c360: 2020 2020 2020 2077 6869 6368 2069 7320         which is 
+0000c370: 696e 2068 6f6d 6f67 656e 656f 7573 2066  in homogeneous f
+0000c380: 6f72 6d20 3a6d 6174 683a 605c 656c 6c5f  orm :math:`\ell_
+0000c390: 3020 7520 2b20 5c65 6c6c 5f31 2076 202b  0 u + \ell_1 v +
+0000c3a0: 205c 656c 6c5f 3220 3d20 3060 0a20 2020   \ell_2 = 0`.   
+0000c3b0: 2020 2020 2061 6e64 2074 6865 2063 6f6e       and the con
+0000c3c0: 6a75 6761 7465 2070 6f69 6e74 203a 6d61  jugate point :ma
+0000c3d0: 7468 3a60 7b7d 5e32 205c 7665 637b 707d  th:`{}^2 \vec{p}
+0000c3e0: 6020 6c69 6573 206f 6e20 7468 6973 206c  ` lies on this l
+0000c3f0: 696e 652e 0a0a 2020 2020 2020 2020 4578  ine...        Ex
+0000c400: 616d 706c 653a 0a0a 2020 2020 2020 2020  ample:..        
+0000c410: 2e2e 2072 756e 626c 6f63 6b3a 3a20 7079  .. runblock:: py
+0000c420: 636f 6e0a 0a20 2020 2020 2020 2020 2020  con..           
+0000c430: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
+0000c440: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
+0000c450: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
+0000c460: 6572 610a 2020 2020 2020 2020 2020 2020  era.            
+0000c470: 3e3e 3e20 6672 6f6d 2073 7061 7469 616c  >>> from spatial
+0000c480: 6d61 7468 2069 6d70 6f72 7420 5345 330a  math import SE3.
+0000c490: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+0000c4a0: 6361 6d65 7261 3120 3d20 4365 6e74 7261  camera1 = Centra
+0000c4b0: 6c43 616d 6572 612e 4465 6661 756c 7428  lCamera.Default(
+0000c4c0: 6e61 6d65 3d27 6361 6d65 7261 3127 290a  name='camera1').
+0000c4d0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+0000c4e0: 6361 6d65 7261 3220 3d20 4365 6e74 7261  camera2 = Centra
+0000c4f0: 6c43 616d 6572 612e 4465 6661 756c 7428  lCamera.Default(
+0000c500: 706f 7365 3d53 4533 2830 2e31 2c20 302e  pose=SE3(0.1, 0.
+0000c510: 3035 2c20 3029 2c20 6e61 6d65 3d27 6361  05, 0), name='ca
+0000c520: 6d65 7261 3227 290a 2020 2020 2020 2020  mera2').        
+0000c530: 2020 2020 3e3e 3e20 5020 3d20 5b2d 302e      >>> P = [-0.
+0000c540: 322c 2030 2e33 2c20 355d 2020 2320 776f  2, 0.3, 5]  # wo
+0000c550: 726c 6420 706f 696e 740a 2020 2020 2020  rld point.      
+0000c560: 2020 2020 2020 3e3e 3e20 7031 203d 2063        >>> p1 = c
+0000c570: 616d 6572 6131 2e70 726f 6a65 6374 5f70  amera1.project_p
+0000c580: 6f69 6e74 2850 2920 2023 2070 726f 6a65  oint(P)  # proje
+0000c590: 6374 2074 6f20 6669 7273 7420 6361 6d65  ct to first came
+0000c5a0: 7261 0a20 2020 2020 2020 2020 2020 203e  ra.            >
+0000c5b0: 3e3e 2063 616d 6572 6131 2e65 7069 6c69  >> camera1.epili
+0000c5c0: 6e65 2870 312c 2063 616d 6572 6132 2920  ne(p1, camera2) 
+0000c5d0: 2020 2320 6570 6970 6f6c 6172 206c 696e    # epipolar lin
+0000c5e0: 6520 696e 2073 6563 6f6e 6420 6361 6d65  e in second came
+0000c5f0: 7261 0a0a 2020 2020 2020 2020 3a72 6566  ra..        :ref
+0000c600: 6572 656e 6365 733a 0a20 2020 2020 2020  erences:.       
+0000c610: 2020 2020 202d 2052 6f62 6f74 6963 732c       - Robotics,
+0000c620: 2056 6973 696f 6e20 2620 436f 6e74 726f   Vision & Contro
+0000c630: 6c20 666f 7220 5079 7468 6f6e 2c20 5365  l for Python, Se
+0000c640: 6374 696f 6e20 3134 2e32 2e31 2c20 502e  ction 14.2.1, P.
+0000c650: 2043 6f72 6b65 2c20 5370 7269 6e67 6572   Corke, Springer
+0000c660: 2032 3032 332e 0a0a 2020 2020 2020 2020   2023...        
+0000c670: 3a73 6565 616c 736f 3a20 3a6d 6574 683a  :seealso: :meth:
+0000c680: 6070 6c6f 745f 6570 696c 696e 6560 203a  `plot_epiline` :
+0000c690: 6d65 7468 3a60 4365 6e74 7261 6c43 616d  meth:`CentralCam
+0000c6a0: 6572 612e 4660 0a20 2020 2020 2020 2022  era.F`.        "
+0000c6b0: 2222 0a20 2020 2020 2020 2023 2070 2069  "".        # p i
+0000c6c0: 7320 3320 7820 4e2c 2072 6573 756c 7420  s 3 x N, result 
+0000c6d0: 6973 2033 2078 204e 0a20 2020 2020 2020  is 3 x N.       
+0000c6e0: 2072 6574 7572 6e20 7365 6c66 2e46 2863   return self.F(c
+0000c6f0: 616d 6572 6132 2920 4020 6261 7365 2e65  amera2) @ base.e
+0000c700: 3268 2870 290a 0a20 2020 2064 6566 2070  2h(p)..    def p
+0000c710: 6c6f 745f 6570 696c 696e 6528 7365 6c66  lot_epiline(self
+0000c720: 2c20 462c 2070 2c20 2a66 6d74 2c20 2a2a  , F, p, *fmt, **
+0000c730: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+0000c740: 2072 2222 220a 2020 2020 2020 2020 506c   r""".        Pl
+0000c750: 6f74 2065 7069 706f 6c61 7220 6c69 6e65  ot epipolar line
+0000c760: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+0000c770: 2046 3a20 6675 6e64 616d 656e 7461 6c20   F: fundamental 
+0000c780: 6d61 7472 6978 0a20 2020 2020 2020 203a  matrix.        :
+0000c790: 7479 7065 2046 3a20 6e64 6172 7261 7928  type F: ndarray(
+0000c7a0: 332c 3329 0a20 2020 2020 2020 203a 7061  3,3).        :pa
+0000c7b0: 7261 6d20 703a 2069 6d61 6765 2070 6c61  ram p: image pla
+0000c7c0: 6e65 2070 6f69 6e74 206f 7220 706f 696e  ne point or poin
+0000c7d0: 7473 0a20 2020 2020 2020 203a 7479 7065  ts.        :type
+0000c7e0: 2070 3a20 6172 7261 795f 6c69 6b65 2832   p: array_like(2
+0000c7f0: 2920 6f72 206e 6461 7272 6179 2832 2c4e  ) or ndarray(2,N
+0000c800: 290a 2020 2020 2020 2020 3a70 6172 616d  ).        :param
+0000c810: 2066 6d74 3a20 6c69 6e65 2073 7479 6c65   fmt: line style
+0000c820: 2061 7267 756d 656e 7420 7061 7373 6564   argument passed
+0000c830: 2074 6f20 6060 706c 6f74 6060 0a20 2020   to ``plot``.   
+0000c840: 2020 2020 203a 7061 7261 6d20 6b77 6172       :param kwar
+0000c850: 6773 3a20 6164 6469 7469 6f6e 616c 206c  gs: additional l
+0000c860: 696e 6520 7374 796c 6520 6172 6775 6d65  ine style argume
+0000c870: 6e74 7320 7061 7373 6564 2074 6f20 6060  nts passed to ``
+0000c880: 706c 6f74 6060 0a0a 2020 2020 2020 2020  plot``..        
+0000c890: 506c 6f74 2074 6865 2065 7069 706f 6c61  Plot the epipola
+0000c8a0: 7220 6c69 6e65 2069 6e64 7563 6564 2062  r line induced b
+0000c8b0: 7920 7468 6520 696d 6167 6520 706c 616e  y the image plan
+0000c8c0: 6520 706f 696e 7473 2060 6070 6060 2069  e points ``p`` i
+0000c8d0: 6e20 7468 650a 2020 2020 2020 2020 6361  n the.        ca
+0000c8e0: 6d65 7261 2773 2076 6972 7475 616c 2069  mera's virtual i
+0000c8f0: 6d61 6765 2070 6c61 6e65 2e20 2045 6163  mage plane.  Eac
+0000c900: 6820 6c69 6e65 2069 7320 6769 7665 6e20  h line is given 
+0000c910: 6279 0a0a 2020 2020 2020 2020 2e2e 206d  by..        .. m
+0000c920: 6174 683a 3a0a 0a20 2020 2020 2020 2020  ath::..         
+0000c930: 2020 205c 656c 6c20 3d20 5c6d 6174 7b46     \ell = \mat{F
+0000c940: 7d20 7b7d 5e31 205c 6876 6563 7b70 7d0a  } {}^1 \hvec{p}.
+0000c950: 0a20 2020 2020 2020 2077 6869 6368 2069  .        which i
+0000c960: 7320 696e 2068 6f6d 6f67 656e 656f 7573  s in homogeneous
+0000c970: 2066 6f72 6d20 3a6d 6174 683a 605c 656c   form :math:`\el
+0000c980: 6c5f 3020 7520 2b20 5c65 6c6c 5f31 2076  l_0 u + \ell_1 v
+0000c990: 202b 205c 656c 6c5f 3220 3d20 3060 0a20   + \ell_2 = 0`. 
+0000c9a0: 2020 2020 2020 2061 6e64 2074 6865 2063         and the c
+0000c9b0: 6f6e 6a75 6761 7465 2070 6f69 6e74 203a  onjugate point :
+0000c9c0: 6d61 7468 3a60 7b7d 5e32 205c 7665 637b  math:`{}^2 \vec{
+0000c9d0: 707d 6020 6c69 6573 206f 6e20 7468 6973  p}` lies on this
+0000c9e0: 206c 696e 652e 0a0a 2020 2020 2020 2020   line...        
+0000c9f0: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
+0000ca00: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+0000ca10: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
+0000ca20: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
+0000ca30: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+0000ca40: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
+0000ca50: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
+0000ca60: 2020 3e3e 3e20 6672 6f6d 2073 7061 7469    >>> from spati
+0000ca70: 616c 6d61 7468 2069 6d70 6f72 7420 5345  almath import SE
+0000ca80: 330a 2020 2020 2020 2020 2020 2020 3e3e  3.            >>
+0000ca90: 3e20 6361 6d65 7261 3120 3d20 4365 6e74  > camera1 = Cent
+0000caa0: 7261 6c43 616d 6572 612e 4465 6661 756c  ralCamera.Defaul
+0000cab0: 7428 6e61 6d65 3d27 6361 6d65 7261 3127  t(name='camera1'
+0000cac0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+0000cad0: 3e20 6361 6d65 7261 3220 3d20 4365 6e74  > camera2 = Cent
+0000cae0: 7261 6c43 616d 6572 612e 4465 6661 756c  ralCamera.Defaul
+0000caf0: 7428 706f 7365 3d53 4533 2830 2e31 2c20  t(pose=SE3(0.1, 
+0000cb00: 302e 3035 2c20 3029 2c20 6e61 6d65 3d27  0.05, 0), name='
+0000cb10: 6361 6d65 7261 3227 290a 2020 2020 2020  camera2').      
+0000cb20: 2020 2020 2020 3e3e 3e20 5020 3d20 5b2d        >>> P = [-
+0000cb30: 302e 322c 2030 2e33 2c20 355d 2020 2320  0.2, 0.3, 5]  # 
+0000cb40: 776f 726c 6420 706f 696e 740a 2020 2020  world point.    
+0000cb50: 2020 2020 2020 2020 3e3e 3e20 7031 203d          >>> p1 =
+0000cb60: 2063 616d 6572 6131 2e70 726f 6a65 6374   camera1.project
+0000cb70: 5f70 6f69 6e74 2850 2920 2023 2070 726f  _point(P)  # pro
+0000cb80: 6a65 6374 2074 6f20 6669 7273 7420 6361  ject to first ca
+0000cb90: 6d65 7261 0a20 2020 2020 2020 2020 2020  mera.           
+0000cba0: 203e 3e3e 2063 616d 6572 6132 2e70 6c6f   >>> camera2.plo
+0000cbb0: 745f 706f 696e 7428 502c 2027 6b64 2729  t_point(P, 'kd')
+0000cbc0: 2023 2070 726f 6a65 6374 2061 6e64 2064   # project and d
+0000cbd0: 6973 706c 6179 2069 6e20 7365 636f 6e64  isplay in second
+0000cbe0: 2063 616d 6572 610a 2020 2020 2020 2020   camera.        
+0000cbf0: 2020 2020 3e3e 3e20 6361 6d65 7261 322e      >>> camera2.
+0000cc00: 706c 6f74 5f65 7069 6c69 6e65 2863 616d  plot_epiline(cam
+0000cc10: 6572 6131 2e46 2863 616d 6572 6132 292c  era1.F(camera2),
+0000cc20: 2070 3129 2023 2070 6c6f 7420 6570 6970   p1) # plot epip
+0000cc30: 6f6c 6172 206c 696e 6520 696e 2073 6563  olar line in sec
+0000cc40: 6f6e 6420 6361 6d65 7261 0a0a 2020 2020  ond camera..    
+0000cc50: 2020 2020 3a72 6566 6572 656e 6365 733a      :references:
+0000cc60: 0a20 2020 2020 2020 2020 2020 202d 2052  .            - R
+0000cc70: 6f62 6f74 6963 732c 2056 6973 696f 6e20  obotics, Vision 
+0000cc80: 2620 436f 6e74 726f 6c20 666f 7220 5079  & Control for Py
+0000cc90: 7468 6f6e 2c20 5365 6374 696f 6e20 3134  thon, Section 14
+0000cca0: 2e32 2e31 2c20 502e 2043 6f72 6b65 2c20  .2.1, P. Corke, 
+0000ccb0: 5370 7269 6e67 6572 2032 3032 332e 0a0a  Springer 2023...
+0000ccc0: 2020 2020 2020 2020 3a73 6565 616c 736f          :seealso
+0000ccd0: 3a20 3a6d 6574 683a 6070 6c6f 745f 706f  : :meth:`plot_po
+0000cce0: 696e 7460 203a 6d65 7468 3a60 6570 696c  int` :meth:`epil
+0000ccf0: 696e 6560 203a 6d65 7468 3a60 4365 6e74  ine` :meth:`Cent
+0000cd00: 7261 6c43 616d 6572 612e 4660 0a20 2020  ralCamera.F`.   
+0000cd10: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000cd20: 2023 2070 2069 7320 3320 7820 4e2c 2072   # p is 3 x N, r
+0000cd30: 6573 756c 7420 6973 2033 2078 204e 0a20  esult is 3 x N. 
+0000cd40: 2020 2020 2020 2073 656c 662e 706c 6f74         self.plot
+0000cd50: 5f6c 696e 6532 2846 2040 2062 6173 652e  _line2(F @ base.
+0000cd60: 6532 6828 7029 2c20 2a66 6d74 2c20 2a2a  e2h(p), *fmt, **
+0000cd70: 6b77 6172 6773 290a 0a20 2020 2064 6566  kwargs)..    def
+0000cd80: 2070 6c6f 745f 6c69 6e65 3328 7365 6c66   plot_line3(self
+0000cd90: 2c20 4c2c 202a 2a6b 7761 7267 7329 3a0a  , L, **kwargs):.
+0000cda0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000cdb0: 2020 2020 506c 6f74 2033 4420 6c69 6e65      Plot 3D line
+0000cdc0: 206f 6e20 7669 7274 7561 6c20 696d 6167   on virtual imag
+0000cdd0: 6520 706c 616e 6520 2862 6173 6520 6d65  e plane (base me
+0000cde0: 7468 6f64 290a 0a20 2020 2020 2020 203a  thod)..        :
+0000cdf0: 7061 7261 6d20 4c3a 2033 4420 6c69 6e65  param L: 3D line
+0000ce00: 2069 6e20 506c 7563 6b65 7220 636f 6f72   in Plucker coor
+0000ce10: 6469 6e61 7465 730a 2020 2020 2020 2020  dinates.        
+0000ce20: 3a74 7970 6520 4c3a 203a 636c 6173 733a  :type L: :class:
+0000ce30: 607e 7370 6174 6961 6c6d 6174 682e 2e67  `~spatialmath..g
+0000ce40: 656f 6d33 642e 4c69 6e65 3360 0a20 2020  eom3d.Line3`.   
+0000ce50: 2020 2020 203a 7061 7261 6d20 6b77 6172       :param kwar
+0000ce60: 6773 3a20 6172 6775 6d65 6e74 7320 7061  gs: arguments pa
+0000ce70: 7373 6564 2074 6f20 6060 706c 6f74 6060  ssed to ``plot``
+0000ce80: 0a0a 2020 2020 2020 2020 5468 6520 506c  ..        The Pl
+0000ce90: 7563 6b65 7220 6c69 6e65 2069 7320 7072  ucker line is pr
+0000cea0: 6f6a 6563 7465 6420 746f 2074 6865 2063  ojected to the c
+0000ceb0: 616d 6572 6127 7320 7669 7274 7561 6c20  amera's virtual 
+0000cec0: 696d 6167 6520 706c 616e 6520 616e 640a  image plane and.
+0000ced0: 2020 2020 2020 2020 706c 6f74 7465 642e          plotted.
+0000cee0: 0a0a 2020 2020 2020 2020 3a6e 6f74 653a  ..        :note:
+0000cef0: 0a20 2020 2020 2020 2020 2020 202d 2053  .            - S
+0000cf00: 7563 6365 7373 6976 6520 6361 6c6c 7320  uccessive calls 
+0000cf10: 6164 6420 6974 656d 7320 746f 2074 6865  add items to the
+0000cf20: 2076 6972 7475 616c 2069 6d61 6765 2070   virtual image p
+0000cf30: 6c61 6e65 2e0a 2020 2020 2020 2020 2020  lane..          
+0000cf40: 2020 2d20 5468 6973 206d 6574 686f 6420    - This method 
+0000cf50: 6973 2063 6f6d 6d6f 6e20 746f 2061 6c6c  is common to all
+0000cf60: 2060 6043 616d 6572 6142 6173 6560 6020   ``CameraBase`` 
+0000cf70: 7375 6263 6c61 7373 6573 2c20 6275 7420  subclasses, but 
+0000cf80: 6974 0a20 2020 2020 2020 2020 2020 2020  it.             
+0000cf90: 2069 6e76 6f6b 6573 2061 2063 616d 6572   invokes a camer
+0000cfa0: 612d 7370 6563 6966 6963 2070 726f 6a65  a-specific proje
+0000cfb0: 6374 696f 6e20 6d65 7468 6f64 2e0a 0a20  ction method... 
+0000cfc0: 2020 2020 2020 203a 7365 6561 6c73 6f3a         :seealso:
+0000cfd0: 203a 6d65 7468 3a60 706c 6f74 5f70 6f69   :meth:`plot_poi
+0000cfe0: 6e74 6020 3a6d 6574 683a 6070 6c6f 745f  nt` :meth:`plot_
+0000cff0: 6c69 6e65 3260 203a 6d65 7468 3a60 706c  line2` :meth:`pl
+0000d000: 6f74 5f77 6972 6566 7261 6d65 6020 3a6d  ot_wireframe` :m
+0000d010: 6574 683a 6063 6c66 600a 2020 2020 2020  eth:`clf`.      
+0000d020: 2020 2222 220a 0a20 2020 2020 2020 206c    """..        l
+0000d030: 203d 2073 656c 662e 7072 6f6a 6563 745f   = self.project_
+0000d040: 6c69 6e65 284c 290a 2020 2020 2020 2020  line(L).        
+0000d050: 666f 7220 686c 2069 6e20 6c2e 543a 0a20  for hl in l.T:. 
+0000d060: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000d070: 706c 6f74 5f6c 696e 6532 2868 6c2c 202a  plot_line2(hl, *
+0000d080: 2a6b 7761 7267 7329 0a0a 2020 2020 6465  *kwargs)..    de
+0000d090: 6620 7261 7928 7365 6c66 2c20 706f 696e  f ray(self, poin
+0000d0a0: 7473 2c20 706f 7365 3d4e 6f6e 6529 3a0a  ts, pose=None):.
+0000d0b0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000d0c0: 2020 2020 5072 6f6a 6563 7420 696d 6167      Project imag
+0000d0d0: 6520 706c 616e 6520 706f 696e 7473 2074  e plane points t
+0000d0e0: 6f20 6120 7261 790a 0a20 2020 2020 2020  o a ray..       
+0000d0f0: 203a 7061 7261 6d20 706f 696e 7473 3a20   :param points: 
+0000d100: 696d 6167 6520 706c 616e 6520 706f 696e  image plane poin
+0000d110: 7473 0a20 2020 2020 2020 203a 7479 7065  ts.        :type
+0000d120: 2070 6f69 6e74 733a 206e 6461 7272 6179   points: ndarray
+0000d130: 2832 2c4e 290a 2020 2020 2020 2020 3a70  (2,N).        :p
+0000d140: 6172 616d 2070 6f73 653a 2063 616d 6572  aram pose: camer
+0000d150: 6120 706f 7365 2c20 6465 6661 756c 7473  a pose, defaults
+0000d160: 2074 6f20 4e6f 6e65 0a20 2020 2020 2020   to None.       
+0000d170: 203a 7479 7065 2070 6f73 653a 203a 636c   :type pose: :cl
+0000d180: 6173 733a 607e 7370 6174 6961 6c6d 6174  ass:`~spatialmat
+0000d190: 682e 2e70 6f73 6533 642e 5345 3360 2c20  h..pose3d.SE3`, 
+0000d1a0: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
+0000d1b0: 203a 7265 7475 726e 3a20 636f 7272 6573   :return: corres
+0000d1c0: 706f 6e64 696e 6720 506c 7563 6b65 7220  ponding Plucker 
+0000d1d0: 6c69 6e65 730a 2020 2020 2020 2020 3a72  lines.        :r
+0000d1e0: 7479 7065 3a20 3a63 6c61 7373 3a60 7e73  type: :class:`~s
+0000d1f0: 7061 7469 616c 6d61 7468 2e2e 6765 6f6d  patialmath..geom
+0000d200: 3364 2e4c 696e 6533 600a 0a20 2020 2020  3d.Line3`..     
+0000d210: 2020 2046 6f72 2065 6163 6820 696d 6167     For each imag
+0000d220: 6520 706c 616e 6520 706f 696e 7420 636f  e plane point co
+0000d230: 6d70 7574 6520 7468 6520 6571 7561 7469  mpute the equati
+0000d240: 6f6e 206f 6620 6120 506c 7563 6b65 7220  on of a Plucker 
+0000d250: 6c69 6e65 0a20 2020 2020 2020 2074 6861  line.        tha
+0000d260: 7420 7265 7072 6573 656e 7473 2074 6865  t represents the
+0000d270: 2033 4420 7261 7920 6672 6f6d 2074 6865   3D ray from the
+0000d280: 2063 616d 6572 6120 6f72 6967 696e 2074   camera origin t
+0000d290: 6872 6f75 6768 2074 6865 2069 6d61 6765  hrough the image
+0000d2a0: 0a20 2020 2020 2020 2070 6c61 6e65 2070  .        plane p
+0000d2b0: 6f69 6e74 2e0a 0a20 2020 2020 2020 2045  oint...        E
+0000d2c0: 7861 6d70 6c65 3a0a 0a20 2020 2020 2020  xample:..       
+0000d2d0: 202e 2e20 7275 6e62 6c6f 636b 3a3a 2070   .. runblock:: p
+0000d2e0: 7963 6f6e 0a0a 2020 2020 2020 2020 2020  ycon..          
+0000d2f0: 2020 3e3e 3e20 6672 6f6d 206d 6163 6869    >>> from machi
+0000d300: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
+0000d310: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
+0000d320: 6d65 7261 0a20 2020 2020 2020 2020 2020  mera.           
+0000d330: 203e 3e3e 2063 616d 6572 6120 3d20 4365   >>> camera = Ce
+0000d340: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
+0000d350: 756c 7428 290a 2020 2020 2020 2020 2020  ult().          
+0000d360: 2020 3e3e 3e20 6c69 6e65 203d 2063 616d    >>> line = cam
+0000d370: 6572 612e 7261 7928 2831 3030 2c20 3230  era.ray((100, 20
+0000d380: 3029 290a 2020 2020 2020 2020 2020 2020  0)).            
+0000d390: 3e3e 3e20 6c69 6e65 0a0a 2020 2020 2020  >>> line..      
+0000d3a0: 2020 3a72 6566 6572 656e 6365 3a0a 2020    :reference:.  
+0000d3b0: 2020 2020 2020 2020 2020 2d20 224d 756c            - "Mul
+0000d3c0: 7469 7669 6577 2047 656f 6d65 7472 7922  tiview Geometry"
+0000d3d0: 2c20 4861 7274 6c65 7920 2620 5a69 7373  , Hartley & Ziss
+0000d3e0: 6572 6d61 6e2c 2070 2e31 3632 0a20 2020  erman, p.162.   
+0000d3f0: 2020 2020 2020 2020 202d 2052 6f62 6f74           - Robot
+0000d400: 6963 732c 2056 6973 696f 6e20 2620 436f  ics, Vision & Co
+0000d410: 6e74 726f 6c20 666f 7220 5079 7468 6f6e  ntrol for Python
+0000d420: 2c20 5365 6374 696f 6e20 3134 2e33 2c20  , Section 14.3, 
+0000d430: 502e 2043 6f72 6b65 2c20 5370 7269 6e67  P. Corke, Spring
+0000d440: 6572 2032 3032 332e 0a0a 2020 2020 2020  er 2023...      
+0000d450: 2020 3a73 6565 616c 736f 3a20 3a63 6c61    :seealso: :cla
+0000d460: 7373 3a60 7e73 7061 7469 616c 6d61 7468  ss:`~spatialmath
+0000d470: 2e2e 6765 6f6d 3364 2e4c 696e 6533 600a  ..geom3d.Line3`.
+0000d480: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000d490: 2020 2020 2320 6465 6669 6e65 2050 6c75      # define Plu
+0000d4a0: 636b 6572 206c 696e 6520 696e 2074 6572  cker line in ter
+0000d4b0: 6d73 206f 6620 706f 696e 7420 2863 656e  ms of point (cen
+0000d4c0: 7472 6520 6f66 2063 616d 6572 6129 2061  tre of camera) a
+0000d4d0: 6e64 2064 6972 6563 7469 6f6e 0a20 2020  nd direction.   
+0000d4e0: 2020 2020 2043 203d 2073 656c 662e 4328       C = self.C(
+0000d4f0: 706f 7365 3d70 6f73 6529 0a20 2020 2020  pose=pose).     
+0000d500: 2020 204d 6920 3d20 6e70 2e6c 696e 616c     Mi = np.linal
+0000d510: 672e 696e 7628 435b 3a33 2c20 3a33 5d29  g.inv(C[:3, :3])
+0000d520: 0a20 2020 2020 2020 2076 203d 2043 5b3a  .        v = C[:
+0000d530: 2c20 335d 0a20 2020 2020 2020 206c 696e  , 3].        lin
+0000d540: 6573 203d 205b 5d0a 2020 2020 2020 2020  es = [].        
+0000d550: 666f 7220 706f 696e 7420 696e 2062 6173  for point in bas
+0000d560: 652e 6765 746d 6174 7269 7828 706f 696e  e.getmatrix(poin
+0000d570: 7473 2c20 2832 2c20 4e6f 6e65 2929 2e54  ts, (2, None)).T
+0000d580: 3a0a 2020 2020 2020 2020 2020 2020 6c69  :.            li
+0000d590: 6e65 732e 6170 7065 6e64 284c 696e 6533  nes.append(Line3
+0000d5a0: 2e50 6f69 6e74 4469 7228 2d4d 6920 4020  .PointDir(-Mi @ 
+0000d5b0: 762c 204d 6920 4020 736d 6261 7365 2e65  v, Mi @ smbase.e
+0000d5c0: 3268 2870 6f69 6e74 2929 290a 2020 2020  2h(point))).    
+0000d5d0: 2020 2020 7265 7475 726e 204c 696e 6533      return Line3
+0000d5e0: 286c 696e 6573 290a 0a20 2020 2040 7072  (lines)..    @pr
+0000d5f0: 6f70 6572 7479 0a20 2020 2064 6566 2063  operty.    def c
+0000d600: 656e 7472 6528 7365 6c66 293a 0a20 2020  entre(self):.   
+0000d610: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000d620: 2050 6f73 6974 696f 6e20 6f66 2063 616d   Position of cam
+0000d630: 6572 6120 6672 616d 650a 0a20 2020 2020  era frame..     
+0000d640: 2020 203a 7265 7475 726e 3a20 4575 636c     :return: Eucl
+0000d650: 6964 6561 6e20 636f 6f72 6469 6e61 7465  idean coordinate
+0000d660: 206f 6620 7468 6520 6361 6d65 7261 2066   of the camera f
+0000d670: 7261 6d65 2773 206f 7269 6769 6e0a 2020  rame's origin.  
+0000d680: 2020 2020 2020 3a72 7479 7065 3a20 6e64        :rtype: nd
+0000d690: 6172 7261 7928 3329 0a0a 2020 2020 2020  array(3)..      
+0000d6a0: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
+0000d6b0: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
+0000d6c0: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
+0000d6d0: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
+0000d6e0: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
+0000d6f0: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
+0000d700: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
+0000d710: 2020 2020 3e3e 3e20 6672 6f6d 2073 7061      >>> from spa
+0000d720: 7469 616c 6d61 7468 2069 6d70 6f72 7420  tialmath import 
+0000d730: 5345 330a 2020 2020 2020 2020 2020 2020  SE3.            
+0000d740: 3e3e 3e20 6361 6d65 7261 3120 3d20 4365  >>> camera1 = Ce
+0000d750: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
+0000d760: 756c 7428 6e61 6d65 3d27 6361 6d65 7261  ult(name='camera
+0000d770: 3127 2c20 706f 7365 3d53 4533 2e54 7261  1', pose=SE3.Tra
+0000d780: 6e73 2831 2c32 2c33 2929 0a20 2020 2020  ns(1,2,3)).     
+0000d790: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+0000d7a0: 6131 0a20 2020 2020 2020 2020 2020 203e  a1.            >
+0000d7b0: 3e3e 2063 616d 6572 6131 2e63 656e 7472  >> camera1.centr
+0000d7c0: 650a 2020 2020 2020 2020 2222 220a 2020  e.        """.  
+0000d7d0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000d7e0: 662e 706f 7365 2e74 0a0a 2020 2020 4070  f.pose.t..    @p
+0000d7f0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+0000d800: 6365 6e74 6572 2873 656c 6629 3a0a 2020  center(self):.  
+0000d810: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000d820: 2020 506f 7369 7469 6f6e 206f 6620 6361    Position of ca
+0000d830: 6d65 7261 2066 7261 6d65 0a0a 2020 2020  mera frame..    
+0000d840: 2020 2020 3a72 6574 7572 6e3a 2045 7563      :return: Euc
+0000d850: 6c69 6465 616e 2063 6f6f 7264 696e 6174  lidean coordinat
+0000d860: 6520 6f66 2074 6865 2063 616d 6572 6120  e of the camera 
+0000d870: 6672 616d 6527 7320 6f72 6967 696e 0a20  frame's origin. 
+0000d880: 2020 2020 2020 203a 7274 7970 653a 206e         :rtype: n
+0000d890: 6461 7272 6179 2833 290a 0a20 2020 2020  darray(3)..     
+0000d8a0: 2020 2045 7861 6d70 6c65 3a0a 0a20 2020     Example:..   
+0000d8b0: 2020 2020 202e 2e20 7275 6e62 6c6f 636b       .. runblock
+0000d8c0: 3a3a 2070 7963 6f6e 0a0a 2020 2020 2020  :: pycon..      
+0000d8d0: 2020 2020 2020 3e3e 3e20 6672 6f6d 206d        >>> from m
+0000d8e0: 6163 6869 6e65 7669 7369 6f6e 746f 6f6c  achinevisiontool
+0000d8f0: 626f 7820 696d 706f 7274 2043 656e 7472  box import Centr
+0000d900: 616c 4361 6d65 7261 0a20 2020 2020 2020  alCamera.       
+0000d910: 2020 2020 203e 3e3e 2066 726f 6d20 7370       >>> from sp
+0000d920: 6174 6961 6c6d 6174 6820 696d 706f 7274  atialmath import
+0000d930: 2053 4533 0a20 2020 2020 2020 2020 2020   SE3.           
+0000d940: 203e 3e3e 2063 616d 6572 6131 203d 2043   >>> camera1 = C
+0000d950: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
+0000d960: 6175 6c74 286e 616d 653d 2763 616d 6572  ault(name='camer
+0000d970: 6131 272c 2070 6f73 653d 5345 332e 5472  a1', pose=SE3.Tr
+0000d980: 616e 7328 312c 322c 3329 290a 2020 2020  ans(1,2,3)).    
+0000d990: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
+0000d9a0: 7261 310a 2020 2020 2020 2020 2020 2020  ra1.            
+0000d9b0: 3e3e 3e20 6361 6d65 7261 312e 6365 6e74  >>> camera1.cent
+0000d9c0: 6572 0a20 2020 2020 2020 2022 2222 0a20  er.        """. 
+0000d9d0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000d9e0: 6c66 2e70 6f73 652e 740a 0a20 2020 2064  lf.pose.t..    d
+0000d9f0: 6566 2066 6f76 2873 656c 6629 3a0a 2020  ef fov(self):.  
+0000da00: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000da10: 2020 4361 6d65 7261 2066 6965 6c64 2d6f    Camera field-o
+0000da20: 662d 7669 6577 2061 6e67 6c65 730a 0a20  f-view angles.. 
+0000da30: 2020 2020 2020 203a 7265 7475 726e 3a20         :return: 
+0000da40: 6669 656c 6420 6f66 2076 6965 7720 616e  field of view an
+0000da50: 676c 6573 2069 6e20 7261 6469 616e 730a  gles in radians.
+0000da60: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+0000da70: 6e64 6172 7261 7928 3229 0a0a 2020 2020  ndarray(2)..    
+0000da80: 2020 2020 436f 6d70 7574 6573 2074 6865      Computes the
+0000da90: 2066 6965 6c64 206f 6620 7669 6577 2061   field of view a
+0000daa0: 6e67 6c65 7320 2832 7831 2920 696e 2072  ngles (2x1) in r
+0000dab0: 6164 6961 6e73 2066 6f72 2074 6865 2063  adians for the c
+0000dac0: 616d 6572 610a 2020 2020 2020 2020 686f  amera.        ho
+0000dad0: 7269 7a6f 6e74 616c 2061 6e64 2076 6572  rizontal and ver
+0000dae0: 7469 6361 6c20 6469 7265 6374 696f 6e73  tical directions
+0000daf0: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
+0000db00: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
+0000db10: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
+0000db20: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
+0000db30: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
+0000db40: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
+0000db50: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
+0000db60: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+0000db70: 2063 616d 6572 6131 203d 2043 656e 7472   camera1 = Centr
+0000db80: 616c 4361 6d65 7261 2e44 6566 6175 6c74  alCamera.Default
+0000db90: 286e 616d 653d 2763 616d 6572 6131 2729  (name='camera1')
+0000dba0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+0000dbb0: 2063 616d 6572 6131 2e66 6f76 2829 0a0a   camera1.fov()..
+0000dbc0: 2020 2020 2020 2020 3a72 6566 6572 656e          :referen
+0000dbd0: 6365 733a 0a20 2020 2020 2020 2020 2020  ces:.           
+0000dbe0: 202d 2052 6f62 6f74 6963 732c 2056 6973   - Robotics, Vis
+0000dbf0: 696f 6e20 2620 436f 6e74 726f 6c20 666f  ion & Control fo
+0000dc00: 7220 5079 7468 6f6e 2c20 5365 6374 696f  r Python, Sectio
+0000dc10: 6e20 3133 2e31 2e34 2c20 502e 2043 6f72  n 13.1.4, P. Cor
+0000dc20: 6b65 2c0a 2020 2020 2020 2020 2020 2020  ke,.            
+0000dc30: 2020 5370 7269 6e67 6572 2032 3032 332e    Springer 2023.
+0000dc40: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000dc50: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
+0000dc60: 2020 2020 2020 7265 7475 726e 2032 202a        return 2 *
+0000dc70: 206e 702e 6172 6374 616e 286e 702e 725f   np.arctan(np.r_
+0000dc80: 5b73 656c 662e 696d 6167 6573 697a 655d  [self.imagesize]
+0000dc90: 202f 2032 202a 206e 702e 725f 5b73 656c   / 2 * np.r_[sel
+0000dca0: 662e 7268 6f5d 202f 2073 656c 662e 6629  f.rho] / self.f)
+0000dcb0: 0a20 2020 2020 2020 2065 7863 6570 743a  .        except:
+0000dcc0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+0000dcd0: 7365 2056 616c 7565 4572 726f 7228 2269  se ValueError("i
+0000dce0: 6d61 6765 7369 7a65 206f 7220 7268 6f20  magesize or rho 
+0000dcf0: 7072 6f70 6572 7469 6573 206e 6f74 2073  properties not s
+0000dd00: 6574 2229 0a0a 2020 2020 6465 6620 6469  et")..    def di
+0000dd10: 7374 6f72 7428 7365 6c66 2c20 706f 696e  stort(self, poin
+0000dd20: 7473 293a 0a20 2020 2020 2020 2022 2222  ts):.        """
+0000dd30: 0a20 2020 2020 2020 2043 6f6d 7075 7465  .        Compute
+0000dd40: 2064 6973 746f 7274 6564 2063 6f6f 7264   distorted coord
+0000dd50: 696e 6174 650a 0a20 2020 2020 2020 203a  inate..        :
+0000dd60: 7061 7261 6d20 706f 696e 7473 3a20 696d  param points: im
+0000dd70: 6167 6520 706c 616e 6520 706f 696e 7473  age plane points
+0000dd80: 0a20 2020 2020 2020 203a 7479 7065 2070  .        :type p
+0000dd90: 6f69 6e74 733a 206e 6461 7272 6179 2832  oints: ndarray(2
+0000dda0: 2c6e 290a 2020 2020 2020 2020 3a72 6574  ,n).        :ret
+0000ddb0: 7572 6e73 3a20 6469 7374 6f72 7465 6420  urns: distorted 
+0000ddc0: 696d 6167 6520 706c 616e 6520 636f 6f72  image plane coor
+0000ddd0: 6469 6e61 7465 730a 2020 2020 2020 2020  dinates.        
+0000dde0: 3a72 7479 7065 3a20 6e64 6172 7261 7928  :rtype: ndarray(
+0000ddf0: 322c 6e29 0a0a 2020 2020 2020 2020 436f  2,n)..        Co
+0000de00: 6d70 7574 6520 7468 6520 696d 6167 6520  mpute the image 
+0000de10: 706c 616e 6520 636f 6f72 6469 6e61 7465  plane coordinate
+0000de20: 7320 6166 7465 7220 6c65 6e73 2064 6973  s after lens dis
+0000de30: 746f 7274 696f 6e20 6861 7320 6265 656e  tortion has been
+0000de40: 0a20 2020 2020 2020 2061 7070 6c69 6564  .        applied
+0000de50: 2e20 2054 6865 206c 656e 7320 6469 7374  .  The lens dist
+0000de60: 6f72 7469 6f6e 206d 6f64 656c 2069 7320  ortion model is 
+0000de70: 696e 6974 6961 6c69 7a65 6420 6174 2063  initialized at c
+0000de80: 6f6e 7374 7275 6374 6f72 2074 696d 652e  onstructor time.
+0000de90: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000dea0: 2020 2020 2069 6620 7365 6c66 2e5f 6469       if self._di
+0000deb0: 7374 6f72 7469 6f6e 2069 7320 4e6f 6e65  stortion is None
+0000dec0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000ded0: 7475 726e 2070 6f69 6e74 730a 0a20 2020  turn points..   
+0000dee0: 2020 2020 2023 2063 6f6e 7665 7274 2074       # convert t
+0000def0: 6f20 6e6f 726d 616c 697a 6564 2069 6d61  o normalized ima
+0000df00: 6765 2063 6f6f 7264 696e 6174 6573 0a20  ge coordinates. 
+0000df10: 2020 2020 2020 2058 203d 206e 702e 6c69         X = np.li
+0000df20: 6e61 6c67 2e69 6e76 2873 656c 662e 4b29  nalg.inv(self.K)
+0000df30: 202a 2073 6d62 6173 652e 6532 6828 706f   * smbase.e2h(po
+0000df40: 696e 7473 290a 0a20 2020 2020 2020 2023  ints)..        #
+0000df50: 2075 6e70 6163 6b20 636f 6f72 6469 6e61   unpack coordina
+0000df60: 7465 730a 2020 2020 2020 2020 7520 3d20  tes.        u = 
+0000df70: 585b 302c 203a 5d0a 2020 2020 2020 2020  X[0, :].        
+0000df80: 7620 3d20 585b 312c 203a 5d0a 0a20 2020  v = X[1, :]..   
+0000df90: 2020 2020 2023 2075 6e70 6163 6b20 6469       # unpack di
+0000dfa0: 7374 6f72 7469 6f6e 2076 6563 746f 720a  stortion vector.
+0000dfb0: 2020 2020 2020 2020 6b20 3d20 7365 6c66          k = self
+0000dfc0: 2e5f 6469 7374 6f72 7469 6f6e 5b3a 335d  ._distortion[:3]
+0000dfd0: 0a20 2020 2020 2020 2070 203d 2073 656c  .        p = sel
+0000dfe0: 662e 5f64 6973 746f 7274 696f 6e5b 333a  f._distortion[3:
+0000dff0: 5d0a 0a20 2020 2020 2020 2072 203d 206e  ]..        r = n
+0000e000: 702e 7371 7274 2875 2a2a 3220 2b20 762a  p.sqrt(u**2 + v*
+0000e010: 2a32 2920 2023 2064 6973 7461 6e63 6520  *2)  # distance 
+0000e020: 6672 6f6d 2070 7269 6e63 6970 616c 2070  from principal p
+0000e030: 6f69 6e74 0a0a 2020 2020 2020 2020 2320  oint..        # 
+0000e040: 636f 6d70 7574 6520 7468 6520 7368 6966  compute the shif
+0000e050: 7420 6475 6520 746f 2064 6973 746f 7274  t due to distort
+0000e060: 696f 6e0a 2020 2020 2020 2020 6465 6c74  ion.        delt
+0000e070: 615f 7520 3d20 280a 2020 2020 2020 2020  a_u = (.        
+0000e080: 2020 2020 7520 2a20 286b 5b30 5d20 2a20      u * (k[0] * 
+0000e090: 722a 2a32 202b 206b 5b31 5d20 2a20 722a  r**2 + k[1] * r*
+0000e0a0: 2a34 202b 206b 5b32 5d20 2a20 722a 2a36  *4 + k[2] * r**6
+0000e0b0: 290a 2020 2020 2020 2020 2020 2020 2b20  ).            + 
+0000e0c0: 3220 2a20 705b 305d 202a 2075 202a 2076  2 * p[0] * u * v
+0000e0d0: 0a20 2020 2020 2020 2020 2020 202b 2070  .            + p
+0000e0e0: 5b31 5d20 2a20 2872 2a2a 3220 2b20 3220  [1] * (r**2 + 2 
+0000e0f0: 2a20 752a 2a32 290a 2020 2020 2020 2020  * u**2).        
+0000e100: 290a 2020 2020 2020 2020 6465 6c74 615f  ).        delta_
+0000e110: 7620 3d20 280a 2020 2020 2020 2020 2020  v = (.          
+0000e120: 2020 7620 2a20 286b 5b30 5d20 2a20 722a    v * (k[0] * r*
+0000e130: 2a32 202b 206b 5b31 5d20 2a20 722a 2a34  *2 + k[1] * r**4
+0000e140: 202b 206b 5b32 5d20 2a20 722a 2a36 290a   + k[2] * r**6).
+0000e150: 2020 2020 2020 2020 2020 2020 2b20 705b              + p[
+0000e160: 305d 202a 2028 722a 2a32 202b 2032 202a  0] * (r**2 + 2 *
+0000e170: 2076 2a2a 3229 0a20 2020 2020 2020 2020   v**2).         
+0000e180: 2020 202b 2032 202a 2070 5b31 5d20 2a20     + 2 * p[1] * 
+0000e190: 7520 2a20 760a 2020 2020 2020 2020 290a  u * v.        ).
+0000e1a0: 0a20 2020 2020 2020 2023 2064 6973 746f  .        # disto
+0000e1b0: 7274 6564 2063 6f6f 7264 696e 6174 6573  rted coordinates
+0000e1c0: 0a20 2020 2020 2020 2075 6420 3d20 7520  .        ud = u 
+0000e1d0: 2b20 6465 6c74 615f 750a 2020 2020 2020  + delta_u.      
+0000e1e0: 2020 7664 203d 2076 202b 2064 656c 7461    vd = v + delta
+0000e1f0: 5f76 0a0a 2020 2020 2020 2020 7265 7475  _v..        retu
+0000e200: 726e 2073 656c 662e 4b20 2a20 736d 6261  rn self.K * smba
+0000e210: 7365 2e65 3268 286e 702e 725f 5b75 642c  se.e2h(np.r_[ud,
+0000e220: 2076 645d 2920 2023 2063 6f6e 7665 7274   vd])  # convert
+0000e230: 2074 6f20 7069 7865 6c20 636f 6f72 6473   to pixel coords
+0000e240: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+0000e250: 2020 2020 6465 6620 6675 2873 656c 6629      def fu(self)
+0000e260: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+0000e270: 2020 2020 2020 4765 7420 666f 6361 6c20        Get focal 
+0000e280: 6c65 6e67 7468 2069 6e20 686f 7269 7a6f  length in horizo
+0000e290: 6e74 616c 2064 6972 6563 7469 6f6e 0a0a  ntal direction..
+0000e2a0: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
+0000e2b0: 2066 6f63 616c 206c 656e 6774 6820 696e   focal length in
+0000e2c0: 2068 6f72 697a 6f6e 7461 6c20 6469 7265   horizontal dire
+0000e2d0: 6374 696f 6e0a 2020 2020 2020 2020 3a72  ction.        :r
+0000e2e0: 7479 7065 3a20 666c 6f61 740a 0a20 2020  type: float..   
+0000e2f0: 2020 2020 2045 7861 6d70 6c65 3a0a 0a20       Example:.. 
+0000e300: 2020 2020 2020 202e 2e20 7275 6e62 6c6f         .. runblo
+0000e310: 636b 3a3a 2070 7963 6f6e 0a0a 2020 2020  ck:: pycon..    
+0000e320: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
+0000e330: 206d 6163 6869 6e65 7669 7369 6f6e 746f   machinevisionto
+0000e340: 6f6c 626f 7820 696d 706f 7274 2043 656e  olbox import Cen
+0000e350: 7472 616c 4361 6d65 7261 0a20 2020 2020  tralCamera.     
+0000e360: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+0000e370: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
+0000e380: 612e 4465 6661 756c 7428 6e61 6d65 3d27  a.Default(name='
+0000e390: 6361 6d65 7261 3127 290a 2020 2020 2020  camera1').      
+0000e3a0: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
+0000e3b0: 2e66 750a 0a20 2020 2020 2020 203a 7365  .fu..        :se
+0000e3c0: 6561 6c73 6f3a 203a 6d65 7468 3a60 6676  ealso: :meth:`fv
+0000e3d0: 6020 3a6d 6574 683a 6066 600a 2020 2020  ` :meth:`f`.    
+0000e3e0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000e3f0: 7265 7475 726e 2073 656c 662e 5f66 750a  return self._fu.
+0000e400: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+0000e410: 2020 2064 6566 2066 7628 7365 6c66 293a     def fv(self):
+0000e420: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000e430: 2020 2020 2047 6574 2066 6f63 616c 206c       Get focal l
+0000e440: 656e 6774 6820 696e 2076 6572 7469 6361  ength in vertica
+0000e450: 6c20 6469 7265 6374 696f 6e0a 0a20 2020  l direction..   
+0000e460: 2020 2020 203a 7265 7475 726e 3a20 666f       :return: fo
+0000e470: 6361 6c20 6c65 6e67 7468 2069 6e20 7665  cal length in ve
+0000e480: 7274 6963 616c 2064 6972 6563 7469 6f6e  rtical direction
+0000e490: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+0000e4a0: 2066 6c6f 6174 0a0a 2020 2020 2020 2020   float..        
+0000e4b0: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
+0000e4c0: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+0000e4d0: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
+0000e4e0: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
+0000e4f0: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+0000e500: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
+0000e510: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
+0000e520: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
+0000e530: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
+0000e540: 6175 6c74 286e 616d 653d 2763 616d 6572  ault(name='camer
+0000e550: 6131 2729 0a20 2020 2020 2020 2020 2020  a1').           
+0000e560: 203e 3e3e 2063 616d 6572 612e 6676 0a0a   >>> camera.fv..
+0000e570: 2020 2020 2020 2020 3a73 6565 616c 736f          :seealso
+0000e580: 3a20 3a6d 6574 683a 6066 7560 203a 6d65  : :meth:`fu` :me
+0000e590: 7468 3a60 6660 0a20 2020 2020 2020 2022  th:`f`.        "
+0000e5a0: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
+0000e5b0: 6e20 7365 6c66 2e5f 6676 0a0a 2020 2020  n self._fv..    
+0000e5c0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+0000e5d0: 6620 6628 7365 6c66 293a 0a20 2020 2020  f f(self):.     
+0000e5e0: 2020 2022 2222 0a20 2020 2020 2020 2053     """.        S
+0000e5f0: 6574 2f67 6574 2066 6f63 616c 206c 656e  et/get focal len
+0000e600: 6774 680a 0a20 2020 2020 2020 203a 7265  gth..        :re
+0000e610: 7475 726e 3a20 666f 6361 6c20 6c65 6e67  turn: focal leng
+0000e620: 7468 2069 6e20 686f 7269 7a6f 6e74 616c  th in horizontal
+0000e630: 2061 6e64 2076 6572 7469 6361 6c20 6469   and vertical di
+0000e640: 7265 6374 696f 6e73 0a20 2020 2020 2020  rections.       
+0000e650: 203a 7274 7970 653a 206e 6461 7272 6179   :rtype: ndarray
+0000e660: 2832 290a 0a20 2020 2020 2020 2052 6574  (2)..        Ret
+0000e670: 7572 6e20 666f 6361 6c20 6c65 6e67 7468  urn focal length
+0000e680: 2069 6e20 686f 7269 7a6f 6e74 616c 2061   in horizontal a
+0000e690: 6e64 2076 6572 7469 6361 6c20 6469 7265  nd vertical dire
+0000e6a0: 6374 696f 6e73 2e0a 0a20 2020 2020 2020  ctions...       
+0000e6b0: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
+0000e6c0: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
+0000e6d0: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
+0000e6e0: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
+0000e6f0: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
+0000e700: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
+0000e710: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
+0000e720: 2020 203e 3e3e 2063 616d 6572 6120 3d20     >>> camera = 
+0000e730: 4365 6e74 7261 6c43 616d 6572 612e 4465  CentralCamera.De
+0000e740: 6661 756c 7428 6e61 6d65 3d27 6361 6d65  fault(name='came
+0000e750: 7261 3127 290a 2020 2020 2020 2020 2020  ra1').          
+0000e760: 2020 3e3e 3e20 6361 6d65 7261 2e66 0a20    >>> camera.f. 
+0000e770: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
+0000e780: 616d 6572 612e 6620 3d20 302e 3031 350a  amera.f = 0.015.
+0000e790: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+0000e7a0: 6361 6d65 7261 2e66 0a20 2020 2020 2020  camera.f.       
+0000e7b0: 2020 2020 203e 3e3e 2063 616d 6572 612e       >>> camera.
+0000e7c0: 6620 3d20 5b30 2e30 3135 2c20 302e 3032  f = [0.015, 0.02
+0000e7d0: 305d 0a20 2020 2020 2020 2020 2020 203e  0].            >
+0000e7e0: 3e3e 2063 616d 6572 612e 660a 0a20 2020  >> camera.f..   
+0000e7f0: 2020 2020 203a 6e6f 7465 3a20 5468 6573       :note: Thes
+0000e800: 6520 6172 6520 6e6f 726d 616c 6c79 2069  e are normally i
+0000e810: 6465 6e74 6963 616c 2062 7574 2077 696c  dentical but wil
+0000e820: 6c20 6469 6666 6572 2069 6620 7468 6520  l differ if the 
+0000e830: 7365 6e73 6f72 0a20 2020 2020 2020 2020  sensor.         
+0000e840: 2020 2068 6173 206e 6f6e 2d73 7175 6172     has non-squar
+0000e850: 6520 7069 7865 6c73 206f 7220 7468 6520  e pixels or the 
+0000e860: 6672 616d 6520 6772 6162 6265 7220 6973  frame grabber is
+0000e870: 2063 6861 6e67 696e 6720 7468 6520 6173   changing the as
+0000e880: 7065 6374 0a20 2020 2020 2020 2020 2020  pect.           
+0000e890: 2072 6174 696f 206f 6620 7468 6520 696d   ratio of the im
+0000e8a0: 6167 652e 0a0a 2020 2020 2020 2020 3a73  age...        :s
+0000e8b0: 6565 616c 736f 3a20 3a6d 6574 683a 6066  eealso: :meth:`f
+0000e8c0: 7560 203a 6d65 7468 3a60 6676 600a 2020  u` :meth:`fv`.  
+0000e8d0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000e8e0: 2020 7265 7475 726e 206e 702e 725f 5b73    return np.r_[s
+0000e8f0: 656c 662e 5f66 752c 2073 656c 662e 5f66  elf._fu, self._f
+0000e900: 765d 0a0a 2020 2020 4066 2e73 6574 7465  v]..    @f.sette
+0000e910: 720a 2020 2020 6465 6620 6628 7365 6c66  r.    def f(self
+0000e920: 2c20 6629 3a0a 2020 2020 2020 2020 2222  , f):.        ""
+0000e930: 225b 7375 6d6d 6172 795d 0a0a 2020 2020  "[summary]..    
+0000e940: 2020 2020 3a70 6172 616d 2066 3a20 666f      :param f: fo
+0000e950: 6361 6c20 6c65 6e67 7468 0a20 2020 2020  cal length.     
+0000e960: 2020 203a 7479 7065 2066 3a20 7363 616c     :type f: scal
+0000e970: 6172 206f 7220 6172 7261 795f 6c69 6b65  ar or array_like
+0000e980: 2832 290a 2020 2020 2020 2020 3a72 6169  (2).        :rai
+0000e990: 7365 7320 5661 6c75 6545 7272 6f72 3a20  ses ValueError: 
+0000e9a0: 696e 636f 7272 6563 7420 6c65 6e67 7468  incorrect length
+0000e9b0: 206f 6620 6060 6660 600a 2020 2020 2020   of ``f``.      
+0000e9c0: 2020 2222 220a 2020 2020 2020 2020 6620    """.        f 
+0000e9d0: 3d20 6261 7365 2e67 6574 7665 6374 6f72  = base.getvector
+0000e9e0: 2866 290a 0a20 2020 2020 2020 2069 6620  (f)..        if 
+0000e9f0: 6c65 6e28 6629 203d 3d20 313a 0a20 2020  len(f) == 1:.   
+0000ea00: 2020 2020 2020 2020 2073 656c 662e 5f66           self._f
+0000ea10: 7520 3d20 665b 305d 0a20 2020 2020 2020  u = f[0].       
+0000ea20: 2020 2020 2073 656c 662e 5f66 7620 3d20       self._fv = 
+0000ea30: 665b 305d 0a20 2020 2020 2020 2065 6c69  f[0].        eli
+0000ea40: 6620 6c65 6e28 6629 203d 3d20 323a 0a20  f len(f) == 2:. 
+0000ea50: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000ea60: 5f66 7520 3d20 665b 305d 0a20 2020 2020  _fu = f[0].     
+0000ea70: 2020 2020 2020 2073 656c 662e 5f66 7620         self._fv 
+0000ea80: 3d20 665b 315d 0a20 2020 2020 2020 2065  = f[1].        e
+0000ea90: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000eaa0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+0000eab0: 7228 662c 2022 6620 6d75 7374 2062 6520  r(f, "f must be 
+0000eac0: 6120 312d 206f 7220 322d 656c 656d 656e  a 1- or 2-elemen
+0000ead0: 7420 7665 6374 6f72 2229 0a0a 2020 2020  t vector")..    
+0000eae0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+0000eaf0: 6620 6670 6978 2873 656c 6629 3a0a 2020  f fpix(self):.  
+0000eb00: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000eb10: 2020 4765 7420 666f 6361 6c20 6c65 6e67    Get focal leng
+0000eb20: 7468 2069 6e20 7069 7865 6c73 0a0a 2020  th in pixels..  
+0000eb30: 2020 2020 2020 3a72 6574 7572 6e3a 2066        :return: f
+0000eb40: 6f63 616c 206c 656e 6774 6820 696e 2068  ocal length in h
+0000eb50: 6f72 697a 6f6e 7461 6c20 616e 6420 7665  orizontal and ve
+0000eb60: 7274 6963 616c 2064 6972 6563 7469 6f6e  rtical direction
+0000eb70: 7320 696e 2070 6978 656c 730a 2020 2020  s in pixels.    
+0000eb80: 2020 2020 3a72 7479 7065 3a20 6e64 6172      :rtype: ndar
+0000eb90: 7261 7928 3229 0a0a 2020 2020 2020 2020  ray(2)..        
+0000eba0: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
+0000ebb0: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+0000ebc0: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
+0000ebd0: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
+0000ebe0: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+0000ebf0: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
+0000ec00: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
+0000ec10: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
+0000ec20: 656e 7472 616c 4361 6d65 7261 2e44 6566  entralCamera.Def
+0000ec30: 6175 6c74 286e 616d 653d 2763 616d 6572  ault(name='camer
+0000ec40: 6131 2729 0a20 2020 2020 2020 2020 2020  a1').           
+0000ec50: 203e 3e3e 2063 616d 6572 612e 6670 6978   >>> camera.fpix
+0000ec60: 0a0a 2020 2020 2020 2020 3a73 6565 616c  ..        :seeal
+0000ec70: 736f 3a20 3a6d 6574 683a 6066 600a 2020  so: :meth:`f`.  
+0000ec80: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000ec90: 2020 7265 7475 726e 206e 702e 725f 5b73    return np.r_[s
+0000eca0: 656c 662e 5f66 7520 2f20 7365 6c66 2e5f  elf._fu / self._
+0000ecb0: 7268 6f75 2c20 7365 6c66 2e5f 6676 202f  rhou, self._fv /
+0000ecc0: 2073 656c 662e 5f72 686f 765d 0a0a 2020   self._rhov]..  
+0000ecd0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+0000ece0: 6465 6620 4b28 7365 6c66 293a 0a20 2020  def K(self):.   
+0000ecf0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000ed00: 2049 6e74 7269 6e73 6963 206d 6174 7269   Intrinsic matri
+0000ed10: 7820 6f66 2063 616d 6572 610a 0a20 2020  x of camera..   
+0000ed20: 2020 2020 203a 7265 7475 726e 3a20 696e       :return: in
+0000ed30: 7472 696e 7369 6320 6d61 7472 6978 0a20  trinsic matrix. 
+0000ed40: 2020 2020 2020 203a 7274 7970 653a 206e         :rtype: n
+0000ed50: 6461 7272 6179 2833 2c33 290a 0a20 2020  darray(3,3)..   
+0000ed60: 2020 2020 2052 6574 7572 6e20 7468 6520       Return the 
+0000ed70: 6361 6d65 7261 2069 6e74 7269 6e73 6963  camera intrinsic
+0000ed80: 206d 6174 7269 782e 0a0a 2020 2020 2020   matrix...      
+0000ed90: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
+0000eda0: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
+0000edb0: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
+0000edc0: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
+0000edd0: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
+0000ede0: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
+0000edf0: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
+0000ee00: 2020 2020 3e3e 3e20 6361 6d65 7261 203d      >>> camera =
+0000ee10: 2043 656e 7472 616c 4361 6d65 7261 2e44   CentralCamera.D
+0000ee20: 6566 6175 6c74 286e 616d 653d 2763 616d  efault(name='cam
+0000ee30: 6572 6131 2729 0a20 2020 2020 2020 2020  era1').         
+0000ee40: 2020 203e 3e3e 2063 616d 6572 612e 4b0a     >>> camera.K.
+0000ee50: 0a20 2020 2020 2020 203a 7265 6665 7265  .        :refere
+0000ee60: 6e63 6573 3a0a 2020 2020 2020 2020 2020  nces:.          
+0000ee70: 2020 2d20 526f 626f 7469 6373 2c20 5669    - Robotics, Vi
+0000ee80: 7369 6f6e 2026 2043 6f6e 7472 6f6c 2066  sion & Control f
+0000ee90: 6f72 2050 7974 686f 6e2c 2053 6563 7469  or Python, Secti
+0000eea0: 6f6e 2031 332e 312c 2050 2e20 436f 726b  on 13.1, P. Cork
+0000eeb0: 652c 2053 7072 696e 6765 7220 3230 3233  e, Springer 2023
+0000eec0: 2e0a 0a20 2020 2020 2020 203a 7365 6561  ...        :seea
+0000eed0: 6c73 6f3a 203a 6d65 7468 3a60 4360 203a  lso: :meth:`C` :
+0000eee0: 6d65 7468 3a60 7070 6020 3a6d 6574 683a  meth:`pp` :meth:
+0000eef0: 6072 686f 600a 2020 2020 2020 2020 2222  `rho`.        ""
+0000ef00: 220a 2020 2020 2020 2020 2320 666d 743a  ".        # fmt:
+0000ef10: 206f 6666 0a20 2020 2020 2020 204b 203d   off.        K =
+0000ef20: 206e 702e 6172 7261 7928 5b5b 7365 6c66   np.array([[self
+0000ef30: 2e66 7520 2f20 7365 6c66 2e72 686f 752c  .fu / self.rhou,
+0000ef40: 2030 2c20 2020 2020 2020 2020 2020 2020   0,             
+0000ef50: 2020 2020 2020 7365 6c66 2e75 305d 2c0a        self.u0],.
+0000ef60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef70: 2020 2020 2020 5b20 302c 2020 2020 2020        [ 0,      
+0000ef80: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000ef90: 2e66 7620 2f20 7365 6c66 2e72 686f 762c  .fv / self.rhov,
+0000efa0: 2073 656c 662e 7630 5d2c 0a20 2020 2020   self.v0],.     
+0000efb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000efc0: 205b 2030 2c20 2020 2020 2020 2020 2020   [ 0,           
+0000efd0: 2020 2020 2020 2030 2c20 2020 2020 2020         0,       
+0000efe0: 2020 2020 2020 2020 2020 2020 2031 5d0a               1].
+0000eff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f000: 2020 2020 2020 5d2c 2064 7479 7065 3d6e        ], dtype=n
+0000f010: 702e 666c 6f61 7436 3429 0a20 2020 2020  p.float64).     
+0000f020: 2020 2023 2066 6d74 3a20 6f6e 0a20 2020     # fmt: on.   
+0000f030: 2020 2020 2072 6574 7572 6e20 4b0a 0a20       return K.. 
+0000f040: 2020 2023 203d 3d3d 3d3d 3d3d 3d3d 3d3d     # ===========
+0000f050: 3d3d 3d3d 3d3d 3d3d 2063 616d 6572 6120  ======== camera 
+0000f060: 6361 6c69 6272 6174 696f 6e20 3d3d 3d3d  calibration ====
+0000f070: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f080: 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 230a 2020  =========== #.  
+0000f090: 2020 6465 6620 4328 7365 6c66 2c20 706f    def C(self, po
+0000f0a0: 7365 3d4e 6f6e 652c 2072 6574 696e 616c  se=None, retinal
+0000f0b0: 3d46 616c 7365 293a 0a20 2020 2020 2020  =False):.       
+0000f0c0: 2022 2222 0a20 2020 2020 2020 2043 616d   """.        Cam
+0000f0d0: 6572 6120 7072 6f6a 6563 7469 6f6e 206d  era projection m
+0000f0e0: 6174 7269 780a 0a20 2020 2020 2020 203a  atrix..        :
+0000f0f0: 7061 7261 6d20 543a 2063 616d 6572 6120  param T: camera 
+0000f100: 706f 7365 2077 6974 6820 7265 7370 6563  pose with respec
+0000f110: 7420 746f 2077 6f72 6c64 2066 7261 6d65  t to world frame
+0000f120: 2c20 6465 6661 756c 7473 2074 6f20 706f  , defaults to po
+0000f130: 7365 2066 726f 6d20 6361 6d65 7261 206f  se from camera o
+0000f140: 626a 6563 740a 2020 2020 2020 2020 3a74  bject.        :t
+0000f150: 7970 6520 543a 203a 636c 6173 733a 607e  ype T: :class:`~
+0000f160: 7370 6174 6961 6c6d 6174 682e 2e70 6f73  spatialmath..pos
+0000f170: 6533 642e 5345 3360 2c20 6f70 7469 6f6e  e3d.SE3`, option
+0000f180: 616c 0a20 2020 2020 2020 203a 7061 7261  al.        :para
+0000f190: 6d20 7265 7469 6e61 6c3a 2074 7261 6e73  m retinal: trans
+0000f1a0: 666f 726d 2074 6f20 7265 7469 6e61 6c20  form to retinal 
+0000f1b0: 636f 6f72 6469 6e61 7465 732c 2064 6566  coordinates, def
+0000f1c0: 6175 6c74 2046 616c 7365 0a20 2020 2020  ault False.     
+0000f1d0: 2020 203a 7479 7065 2072 6574 696e 616c     :type retinal
+0000f1e0: 3a20 626f 6f6c 2c20 6f70 7469 6f6e 616c  : bool, optional
+0000f1f0: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
+0000f200: 3a20 6361 6d65 7261 2070 726f 6a65 6374  : camera project
+0000f210: 696f 6e2f 6361 6c69 6272 6174 696f 6e20  ion/calibration 
+0000f220: 6d61 7472 6978 0a20 2020 2020 2020 203a  matrix.        :
+0000f230: 7274 7970 653a 206e 6461 7272 6179 2833  rtype: ndarray(3
+0000f240: 2c34 290a 0a20 2020 2020 2020 2052 6574  ,4)..        Ret
+0000f250: 7572 6e20 7468 6520 6361 6d65 7261 206d  urn the camera m
+0000f260: 6174 7269 7820 7768 6963 6820 7072 6f6a  atrix which proj
+0000f270: 6563 7473 2033 4420 706f 696e 7473 2074  ects 3D points t
+0000f280: 6f20 7468 6520 696d 6167 6520 706c 616e  o the image plan
+0000f290: 652e 0a20 2020 2020 2020 2049 7420 6973  e..        It is
+0000f2a0: 2061 2066 756e 6374 696f 6e20 6f66 2074   a function of t
+0000f2b0: 6865 2063 616d 6572 6127 7320 696e 7472  he camera's intr
+0000f2c0: 696e 7369 6320 616e 6420 6578 7472 696e  insic and extrin
+0000f2d0: 7369 6320 7061 7261 6d65 7465 7273 2e0a  sic parameters..
+0000f2e0: 0a20 2020 2020 2020 2049 6620 6060 7265  .        If ``re
+0000f2f0: 7469 6e61 6c60 6020 6973 2054 7275 6520  tinal`` is True 
+0000f300: 7468 656e 2070 726f 6a65 6374 2070 6f69  then project poi
+0000f310: 6e74 7320 696e 2072 6574 696e 616c 2063  nts in retinal c
+0000f320: 6f6f 7264 696e 6174 6573 2c0a 2020 2020  oordinates,.    
+0000f330: 2020 2020 696e 2075 6e69 7473 206f 6620      in units of 
+0000f340: 6d65 7472 6573 2077 6974 6820 7265 7370  metres with resp
+0000f350: 6563 7420 746f 2074 6865 2070 7269 6e63  ect to the princ
+0000f360: 6970 616c 2070 6f69 6e74 2e0a 0a20 2020  ipal point...   
+0000f370: 2020 2020 2045 7861 6d70 6c65 3a0a 0a20       Example:.. 
+0000f380: 2020 2020 2020 202e 2e20 7275 6e62 6c6f         .. runblo
+0000f390: 636b 3a3a 2070 7963 6f6e 0a0a 2020 2020  ck:: pycon..    
+0000f3a0: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
+0000f3b0: 206d 6163 6869 6e65 7669 7369 6f6e 746f   machinevisionto
+0000f3c0: 6f6c 626f 7820 696d 706f 7274 2043 656e  olbox import Cen
+0000f3d0: 7472 616c 4361 6d65 7261 0a20 2020 2020  tralCamera.     
+0000f3e0: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+0000f3f0: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
+0000f400: 612e 4465 6661 756c 7428 6e61 6d65 3d27  a.Default(name='
+0000f410: 6361 6d65 7261 3127 290a 2020 2020 2020  camera1').      
+0000f420: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
+0000f430: 2e43 2829 0a20 2020 2020 2020 2020 2020  .C().           
+0000f440: 203e 3e3e 2063 616d 6572 612e 4328 5345   >>> camera.C(SE
+0000f450: 332e 5472 616e 7328 302e 312c 2030 2c20  3.Trans(0.1, 0, 
+0000f460: 3029 290a 2020 2020 2020 2020 2020 2020  0)).            
+0000f470: 3e3e 3e20 6361 6d65 7261 2e6d 6f76 6528  >>> camera.move(
+0000f480: 5345 3328 302e 312c 2030 2c20 3029 292e  SE3(0.1, 0, 0)).
+0000f490: 4328 290a 0a20 2020 2020 2020 203a 7265  C()..        :re
+0000f4a0: 6665 7265 6e63 6573 3a0a 2020 2020 2020  ferences:.      
+0000f4b0: 2020 2020 2020 2d20 526f 626f 7469 6373        - Robotics
+0000f4c0: 2c20 5669 7369 6f6e 2026 2043 6f6e 7472  , Vision & Contr
+0000f4d0: 6f6c 2066 6f72 2050 7974 686f 6e2c 2053  ol for Python, S
+0000f4e0: 6563 7469 6f6e 2031 332e 312c 2050 2e20  ection 13.1, P. 
+0000f4f0: 436f 726b 652c 2053 7072 696e 6765 7220  Corke, Springer 
+0000f500: 3230 3233 2e0a 0a20 2020 2020 2020 203a  2023...        :
+0000f510: 7365 6561 6c73 6f3a 203a 6d65 7468 3a60  seealso: :meth:`
+0000f520: 7072 6f6a 6563 745f 706f 696e 7460 203a  project_point` :
+0000f530: 6d65 7468 3a60 4b60 203a 6d65 7468 3a60  meth:`K` :meth:`
+0000f540: 6465 636f 6d70 6f73 6543 600a 2020 2020  decomposeC`.    
+0000f550: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000f560: 5030 203d 206e 702e 6579 6528 332c 2034  P0 = np.eye(3, 4
+0000f570: 290a 2020 2020 2020 2020 6966 2070 6f73  ).        if pos
+0000f580: 6520 6973 204e 6f6e 653a 0a20 2020 2020  e is None:.     
+0000f590: 2020 2020 2020 2070 6f73 6520 3d20 7365         pose = se
+0000f5a0: 6c66 2e70 6f73 650a 2020 2020 2020 2020  lf.pose.        
+0000f5b0: 6966 2072 6574 696e 616c 3a0a 2020 2020  if retinal:.    
+0000f5c0: 2020 2020 2020 2020 4b20 3d20 6e70 2e64          K = np.d
+0000f5d0: 6961 6728 5b73 656c 662e 6675 2c20 7365  iag([self.fu, se
+0000f5e0: 6c66 2e66 762c 2031 5d29 0a20 2020 2020  lf.fv, 1]).     
+0000f5f0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000f600: 2020 2020 204b 203d 2073 656c 662e 4b0a       K = self.K.
+0000f610: 2020 2020 2020 2020 7265 7475 726e 204b          return K
+0000f620: 2040 2050 3020 4020 706f 7365 2e69 6e76   @ P0 @ pose.inv
+0000f630: 2829 2e41 0a0a 2020 2020 4073 7461 7469  ().A..    @stati
+0000f640: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
+0000f650: 706f 696e 7473 3243 2850 2c20 7029 3a0a  points2C(P, p):.
+0000f660: 2020 2020 2020 2020 7222 2222 0a20 2020          r""".   
+0000f670: 2020 2020 2045 7374 696d 6174 6520 6361       Estimate ca
+0000f680: 6d65 7261 206d 6174 7269 7820 6672 6f6d  mera matrix from
+0000f690: 2064 6174 6120 706f 696e 7473 0a0a 2020   data points..  
+0000f6a0: 2020 2020 2020 3a70 6172 616d 2050 3a20        :param P: 
+0000f6b0: 6361 6c69 6272 6174 696f 6e20 706f 696e  calibration poin
+0000f6c0: 7473 2069 6e20 776f 726c 6420 636f 6f72  ts in world coor
+0000f6d0: 6469 6e61 7465 2066 7261 6d65 0a20 2020  dinate frame.   
+0000f6e0: 2020 2020 203a 7479 7065 2050 3a20 6e64       :type P: nd
+0000f6f0: 6172 7261 7928 332c 4e29 0a20 2020 2020  array(3,N).     
+0000f700: 2020 203a 7061 7261 6d20 703a 2063 616c     :param p: cal
+0000f710: 6962 7261 7469 6f6e 2070 6f69 6e74 7320  ibration points 
+0000f720: 696e 2069 6d61 6765 2070 6c61 6e65 0a20  in image plane. 
+0000f730: 2020 2020 2020 203a 7479 7065 2070 3a20         :type p: 
+0000f740: 6e64 6172 7261 7928 322c 4e29 0a20 2020  ndarray(2,N).   
+0000f750: 2020 2020 203a 7265 7475 726e 3a20 6361       :return: ca
+0000f760: 6d65 7261 2063 616c 6962 7261 7469 6f6e  mera calibration
+0000f770: 206d 6174 7269 7820 616e 6420 7265 7369   matrix and resi
+0000f780: 6475 616c 0a20 2020 2020 2020 203a 7274  dual.        :rt
+0000f790: 7970 653a 206e 6461 7272 6179 2833 2c34  ype: ndarray(3,4
+0000f7a0: 292c 2066 6c6f 6174 0a0a 2020 2020 2020  ), float..      
+0000f7b0: 2020 4573 7469 6d61 7465 2074 6865 2063    Estimate the c
+0000f7c0: 616d 6572 6120 6d61 7472 6978 203a 6d61  amera matrix :ma
+0000f7d0: 7468 3a60 5c6d 6174 7b43 7d60 2064 6574  th:`\mat{C}` det
+0000f7e0: 6572 6d69 6e65 6420 6279 206c 6561 7374  ermined by least
+0000f7f0: 0a20 2020 2020 2020 2073 7175 6172 6573  .        squares
+0000f800: 2066 726f 6d20 636f 7272 6573 706f 6e64   from correspond
+0000f810: 696e 6720 776f 726c 6420 6060 5060 6020  ing world ``P`` 
+0000f820: 616e 6420 696d 6167 652d 706c 616e 6520  and image-plane 
+0000f830: 6060 7060 6020 706f 696e 7473 2e0a 2020  ``p`` points..  
+0000f840: 2020 2020 2020 436f 7272 6573 706f 6e64        Correspond
+0000f850: 696e 6720 706f 696e 7473 2061 7265 2072  ing points are r
+0000f860: 6570 7265 7365 6e74 6564 2062 7920 636f  epresented by co
+0000f870: 7272 6573 706f 6e64 696e 6720 636f 6c75  rresponding colu
+0000f880: 6d6e 7320 6f66 2060 6050 6060 0a20 2020  mns of ``P``.   
+0000f890: 2020 2020 2061 6e64 2060 6070 6060 2e20       and ``p``. 
+0000f8a0: 2041 6c73 6f20 7265 7475 726e 7320 7468   Also returns th
+0000f8b0: 6520 7265 7369 6475 616c 2077 6869 6368  e residual which
+0000f8c0: 2069 733a 0a0a 2020 2020 2020 2020 2e2e   is:..        ..
+0000f8d0: 206d 6174 683a 3a0a 0a20 2020 2020 2020   math::..       
+0000f8e0: 2020 2020 205c 6d61 7820 7c20 5c6d 6174       \max | \mat
+0000f8f0: 7b43 7d5c 6d61 747b 507d 202d 205c 6d61  {C}\mat{P} - \ma
+0000f900: 747b 707d 207c 0a0a 2020 2020 2020 2020  t{p} |..        
+0000f910: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
+0000f920: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+0000f930: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
+0000f940: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
+0000f950: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+0000f960: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
+0000f970: 616d 6572 612c 206d 6b63 7562 650a 2020  amera, mkcube.  
+0000f980: 2020 2020 2020 2020 2020 3e3e 3e20 5020            >>> P 
+0000f990: 3d20 6d6b 6375 6265 2830 2e32 290a 2020  = mkcube(0.2).  
+0000f9a0: 2020 2020 2020 2020 2020 3e3e 3e20 6361            >>> ca
+0000f9b0: 6d65 7261 5f75 6e6b 6e6f 776e 203d 2043  mera_unknown = C
+0000f9c0: 656e 7472 616c 4361 6d65 7261 2866 3d30  entralCamera(f=0
+0000f9d0: 2e30 3135 2c20 7268 6f3d 3130 652d 362c  .015, rho=10e-6,
+0000f9e0: 2069 6d61 6765 7369 7a65 3d5b 3132 3830   imagesize=[1280
+0000f9f0: 2c20 3130 3234 5d2c 206e 6f69 7365 3d30  , 1024], noise=0
+0000fa00: 2e30 352c 2073 6565 643d 3029 0a20 2020  .05, seed=0).   
+0000fa10: 2020 2020 2020 2020 203e 3e3e 2054 5f75           >>> T_u
+0000fa20: 6e6b 6e6f 776e 203d 2053 4533 2e54 7261  nknown = SE3.Tra
+0000fa30: 6e73 2830 2e31 2c20 302e 322c 2031 2e35  ns(0.1, 0.2, 1.5
+0000fa40: 2920 2a20 5345 332e 5250 5928 302e 312c  ) * SE3.RPY(0.1,
+0000fa50: 2030 2e32 2c20 302e 3329 0a20 2020 2020   0.2, 0.3).     
+0000fa60: 2020 2020 2020 203e 3e3e 2070 203d 2063         >>> p = c
+0000fa70: 616d 6572 615f 756e 6b6e 6f77 6e2e 7072  amera_unknown.pr
+0000fa80: 6f6a 6563 745f 706f 696e 7428 502c 206f  oject_point(P, o
+0000fa90: 626a 706f 7365 3d54 5f75 6e6b 6e6f 776e  bjpose=T_unknown
+0000faa0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+0000fab0: 3e20 432c 2072 6573 6964 203d 2043 656e  > C, resid = Cen
+0000fac0: 7472 616c 4361 6d65 7261 2e70 6f69 6e74  tralCamera.point
+0000fad0: 7332 4328 502c 2070 290a 2020 2020 2020  s2C(P, p).      
+0000fae0: 2020 2020 2020 3e3e 3e20 430a 2020 2020        >>> C.    
+0000faf0: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
+0000fb00: 7261 5f75 6e6b 6e6f 776e 2e43 2829 0a20  ra_unknown.C(). 
+0000fb10: 2020 2020 2020 2020 2020 203e 3e3e 2072             >>> r
+0000fb20: 6573 6964 0a0a 2020 2020 2020 2020 3a6e  esid..        :n
+0000fb30: 6f74 653a 2054 6869 7320 6d65 7468 6f64  ote: This method
+0000fb40: 2061 7373 756d 6573 206e 6f20 6c65 6e73   assumes no lens
+0000fb50: 2064 6973 746f 7274 696f 6e20 6166 6665   distortion affe
+0000fb60: 6374 696e 6720 7468 6520 696d 6167 6520  cting the image 
+0000fb70: 706c 616e 650a 2020 2020 2020 2020 2020  plane.          
+0000fb80: 2020 636f 6f72 6469 6e61 7465 732e 0a0a    coordinates...
+0000fb90: 2020 2020 2020 2020 3a72 6566 6572 656e          :referen
+0000fba0: 6365 733a 0a20 2020 2020 2020 2020 2020  ces:.           
+0000fbb0: 202d 2052 6f62 6f74 6963 732c 2056 6973   - Robotics, Vis
+0000fbc0: 696f 6e20 2620 436f 6e74 726f 6c20 666f  ion & Control fo
+0000fbd0: 7220 5079 7468 6f6e 2c20 5365 6374 696f  r Python, Sectio
+0000fbe0: 6e20 3133 2e32 2e31 2c20 502e 2043 6f72  n 13.2.1, P. Cor
+0000fbf0: 6b65 2c0a 2020 2020 2020 2020 2020 2020  ke,.            
+0000fc00: 2020 5370 7269 6e67 6572 2032 3032 332e    Springer 2023.
+0000fc10: 0a0a 2020 2020 2020 2020 3a73 6565 616c  ..        :seeal
+0000fc20: 736f 3a20 3a6d 6574 683a 6043 6020 3a6d  so: :meth:`C` :m
+0000fc30: 6574 683a 6069 6d61 6765 7332 4360 203a  eth:`images2C` :
+0000fc40: 6d65 7468 3a60 6465 636f 6d70 6f73 6543  meth:`decomposeC
+0000fc50: 600a 2020 2020 2020 2020 2222 220a 2020  `.        """.  
+0000fc60: 2020 2020 2020 7a34 203d 206e 702e 7a65        z4 = np.ze
+0000fc70: 726f 7328 2834 2c29 290a 0a20 2020 2020  ros((4,))..     
+0000fc80: 2020 2041 203d 206e 702e 656d 7074 7928     A = np.empty(
+0000fc90: 7368 6170 653d 2830 2c20 3131 2929 0a20  shape=(0, 11)). 
+0000fca0: 2020 2020 2020 2062 203d 206e 702e 656d         b = np.em
+0000fcb0: 7074 7928 7368 6170 653d 2830 2c29 290a  pty(shape=(0,)).
+0000fcc0: 2020 2020 2020 2020 666f 7220 7576 2c20          for uv, 
+0000fcd0: 5820 696e 207a 6970 2870 2e54 2c20 502e  X in zip(p.T, P.
+0000fce0: 5429 3a0a 2020 2020 2020 2020 2020 2020  T):.            
+0000fcf0: 752c 2076 203d 2075 760a 2020 2020 2020  u, v = uv.      
+0000fd00: 2020 2020 2020 2320 666d 743a 206f 6666        # fmt: off
+0000fd10: 0a20 2020 2020 2020 2020 2020 2072 6f77  .            row
+0000fd20: 203d 206e 702e 6172 7261 7928 5b0a 2020   = np.array([.  
+0000fd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fd40: 2020 6e70 2e72 5f5b 2058 2c20 312c 207a    np.r_[ X, 1, z
+0000fd50: 342c 202d 7520 2a20 585d 2c0a 2020 2020  4, -u * X],.    
+0000fd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fd70: 6e70 2e72 5f5b 7a34 2c20 582c 2020 312c  np.r_[z4, X,  1,
+0000fd80: 202d 7620 2a20 585d 0a20 2020 2020 2020   -v * X].       
+0000fd90: 2020 2020 2020 2020 205d 290a 2020 2020           ]).    
+0000fda0: 2020 2020 2020 2020 2320 666d 743a 206f          # fmt: o
+0000fdb0: 6e0a 2020 2020 2020 2020 2020 2020 4120  n.            A 
+0000fdc0: 3d20 6e70 2e76 7374 6163 6b28 2841 2c20  = np.vstack((A, 
+0000fdd0: 726f 7729 290a 2020 2020 2020 2020 2020  row)).          
+0000fde0: 2020 6220 3d20 6e70 2e72 5f5b 622c 2075    b = np.r_[b, u
+0000fdf0: 765d 0a0a 2020 2020 2020 2020 2320 736f  v]..        # so
+0000fe00: 6c76 6520 4178 203d 2062 2077 6865 7265  lve Ax = b where
+0000fe10: 2063 2069 7320 3131 2065 6c65 6d65 6e74   c is 11 element
+0000fe20: 7320 6f66 2063 616d 6572 6120 6d61 7472  s of camera matr
+0000fe30: 6978 0a20 2020 2020 2020 2063 2c20 2a5f  ix.        c, *_
+0000fe40: 203d 2073 6369 7079 2e6c 696e 616c 672e   = scipy.linalg.
+0000fe50: 6c73 7473 7128 412c 2062 290a 0a20 2020  lstsq(A, b)..   
+0000fe60: 2020 2020 2023 2063 6f6d 7075 7465 2061       # compute a
+0000fe70: 6e64 2070 7269 6e74 2074 6865 2072 6573  nd print the res
+0000fe80: 6964 7561 6c0a 2020 2020 2020 2020 7220  idual.        r 
+0000fe90: 3d20 6e70 2e6d 6178 286e 702e 6162 7328  = np.max(np.abs(
+0000fea0: 2841 2040 2063 202d 2062 2929 290a 0a20  (A @ c - b))).. 
+0000feb0: 2020 2020 2020 2063 203d 206e 702e 725f         c = np.r_
+0000fec0: 5b63 2c20 315d 2020 2320 6170 7065 6e64  [c, 1]  # append
+0000fed0: 2061 2031 0a20 2020 2020 2020 2043 203d   a 1.        C =
+0000fee0: 2063 2e72 6573 6861 7065 2828 332c 2034   c.reshape((3, 4
+0000fef0: 2929 2020 2320 6d61 6b65 2061 2033 7834  ))  # make a 3x4
+0000ff00: 206d 6174 7269 780a 0a20 2020 2020 2020   matrix..       
+0000ff10: 2072 6574 7572 6e20 432c 2072 0a0a 2020   return C, r..  
+0000ff20: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
+0000ff30: 2020 2064 6566 2069 6d61 6765 7332 4328     def images2C(
+0000ff40: 7365 6c66 2c20 696d 6167 6573 2c20 6772  self, images, gr
+0000ff50: 6964 7368 6170 653d 2837 2c20 3629 2c20  idshape=(7, 6), 
+0000ff60: 7371 7561 7265 7369 7a65 3d30 2e30 3235  squaresize=0.025
+0000ff70: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+0000ff80: 2020 2020 2020 2043 616c 6962 7261 7465         Calibrate
+0000ff90: 2063 616d 6572 6120 6672 6f6d 2063 6865   camera from che
+0000ffa0: 636b 6572 626f 6172 6420 696d 6167 6573  ckerboard images
+0000ffb0: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+0000ffc0: 2069 6d61 6765 733a 2061 6e20 6974 6572   images: an iter
+0000ffd0: 6174 6f72 2074 6861 7420 7265 7475 726e  ator that return
+0000ffe0: 7320 3a63 6c61 7373 3a60 7e6d 6163 6869  s :class:`~machi
+0000fff0: 6e65 7669 7369 6f6e 746f 6f6c 626f 782e  nevisiontoolbox.
+00010000: 496d 6167 6543 6f72 652e 496d 6167 6560  ImageCore.Image`
+00010010: 206f 626a 6563 7473 0a20 2020 2020 2020   objects.       
+00010020: 203a 7479 7065 2069 6d61 6765 733a 203a   :type images: :
+00010030: 636c 6173 733a 607e 6d61 6368 696e 6576  class:`~machinev
+00010040: 6973 696f 6e74 6f6f 6c62 6f78 2e53 6f75  isiontoolbox.Sou
+00010050: 7263 6573 2e49 6d61 6765 536f 7572 6365  rces.ImageSource
+00010060: 600a 2020 2020 2020 2020 3a70 6172 616d  `.        :param
+00010070: 2067 7269 6473 6861 7065 3a20 6e75 6d62   gridshape: numb
+00010080: 6572 206f 6620 6772 6964 2073 7175 6172  er of grid squar
+00010090: 6573 2069 6e20 6561 6368 2064 696d 656e  es in each dimen
+000100a0: 7369 6f6e 2c20 6465 6661 756c 7473 2074  sion, defaults t
+000100b0: 6f20 2837 2c36 290a 2020 2020 2020 2020  o (7,6).        
+000100c0: 3a74 7970 6520 6772 6964 7368 6170 653a  :type gridshape:
+000100d0: 2074 7570 6c65 2c20 6f70 7469 6f6e 616c   tuple, optional
+000100e0: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+000100f0: 7371 7561 7265 7369 7a65 3a20 7369 7a65  squaresize: size
+00010100: 206f 6620 7468 6520 6772 6964 2073 7175   of the grid squ
+00010110: 6172 6573 2069 6e20 756e 6974 7320 6f66  ares in units of
+00010120: 206c 656e 6774 682c 2064 6566 6175 6c74   length, default
+00010130: 7320 746f 2030 2e30 3235 0a20 2020 2020  s to 0.025.     
+00010140: 2020 203a 7479 7065 2073 7175 6172 6573     :type squares
+00010150: 697a 653a 2066 6c6f 6174 2c20 6f70 7469  ize: float, opti
+00010160: 6f6e 616c 0a20 2020 2020 2020 203a 7265  onal.        :re
+00010170: 7475 726e 3a20 6361 6d65 7261 2063 616c  turn: camera cal
+00010180: 6962 7261 7469 6f6e 206d 6174 7269 782c  ibration matrix,
+00010190: 2064 6973 746f 7274 696f 6e20 7061 7261   distortion para
+000101a0: 6d65 7465 7273 2c20 696d 6167 6520 6672  meters, image fr
+000101b0: 616d 6573 0a20 2020 2020 2020 203a 7274  ames.        :rt
+000101c0: 7970 653a 206e 6461 7272 6179 2833 2c34  ype: ndarray(3,4
+000101d0: 292c 206e 6461 7272 6179 2835 292c 206c  ), ndarray(5), l
+000101e0: 6973 7420 6f66 206e 616d 6564 2074 7570  ist of named tup
+000101f0: 6c65 730a 0a20 2020 2020 2020 2054 6865  les..        The
+00010200: 2064 6973 746f 7274 696f 6e20 636f 6566   distortion coef
+00010210: 6669 6369 656e 7473 2061 7265 2069 6e20  ficients are in 
+00010220: 7468 6520 6f72 6465 7220 3a6d 6174 683a  the order :math:
+00010230: 6028 6b5f 312c 206b 5f32 2c20 705f 312c  `(k_1, k_2, p_1,
+00010240: 2070 5f32 2c20 6b5f 3329 600a 2020 2020   p_2, k_3)`.    
+00010250: 2020 2020 7768 6572 6520 3a6d 6174 683a      where :math:
+00010260: 606b 5f69 6020 6172 6520 7261 6469 616c  `k_i` are radial
+00010270: 2064 6973 746f 7274 696f 6e20 636f 6566   distortion coef
+00010280: 6669 6369 656e 7473 2061 6e64 203a 6d61  ficients and :ma
+00010290: 7468 3a60 705f 6960 2061 7265 0a20 2020  th:`p_i` are.   
+000102a0: 2020 2020 2074 616e 6765 6e74 6961 6c20       tangential 
+000102b0: 6469 7374 6f72 7469 6f6e 2063 6f65 6666  distortion coeff
+000102c0: 6963 6965 6e74 732e 0a0a 2020 2020 2020  icients...      
+000102d0: 2020 496d 6167 6520 6672 616d 6573 2074    Image frames t
+000102e0: 6861 7420 7765 7265 2073 7563 6365 7373  hat were success
+000102f0: 6675 6c6c 7920 7072 6f63 6573 7365 6420  fully processed 
+00010300: 6172 6520 7265 7475 726e 6564 2061 7320  are returned as 
+00010310: 6120 6c69 7374 206f 660a 2020 2020 2020  a list of.      
+00010320: 2020 6e61 6d65 6420 7475 706c 6573 2060    named tuples `
+00010330: 6043 616c 6962 7261 7469 6f6e 4672 616d  `CalibrationFram
+00010340: 6560 6020 7769 7468 2065 6c65 6d65 6e74  e`` with element
+00010350: 733a 0a0a 2020 2020 2020 2020 3d3d 3d3d  s:..        ====
+00010360: 3d3d 3d20 203d 3d3d 3d3d 3d3d 3d3d 3d3d  ===  ===========
+00010370: 3d3d 3d3d 3d3d 3d3d 3d3d 2020 3d3d 3d3d  ==========  ====
+00010380: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00010390: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000103a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000103b0: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+000103c0: 656c 656d 656e 7420 2074 7970 6520 2020  element  type   
+000103d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000103e0: 6465 7363 7269 7074 696f 6e0a 2020 2020  description.    
+000103f0: 2020 2020 3d3d 3d3d 3d3d 3d20 203d 3d3d      =======  ===
+00010400: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00010410: 3d3d 2020 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ==  ============
 00010420: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00010430: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00010440: 3d3d 3d3d 3d3d 3d3d 3d0a 2020 2020 2020  =========.      
-00010450: 2020 656c 656d 656e 7420 2074 7970 6520    element  type 
-00010460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010470: 2020 6465 7363 7269 7074 696f 6e0a 2020    description.  
-00010480: 2020 2020 2020 3d3d 3d3d 3d3d 3d20 203d        =======  =
-00010490: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000104a0: 3d3d 3d3d 2020 3d3d 3d3d 3d3d 3d3d 3d3d  ====  ==========
-000104b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000104c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000104d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000104e0: 3d0a 2020 2020 2020 2020 696d 6167 6520  =.        image 
-000104f0: 2020 203a 636c 6173 733a 6049 6d61 6765     :class:`Image
-00010500: 6020 2020 2020 2020 2020 6361 6c69 6272  `         calibr
-00010510: 6174 696f 6e20 696d 6167 6520 7769 7468  ation image with
-00010520: 206f 7665 726c 6169 6420 616e 6e6f 7461   overlaid annota
-00010530: 7469 6f6e 0a20 2020 2020 2020 2070 6f73  tion.        pos
-00010540: 6520 2020 2020 3a63 6c61 7373 3a60 5345  e     :class:`SE
-00010550: 3360 2069 6e73 7461 6e63 6520 2070 6f73  3` instance  pos
-00010560: 6520 6f66 2074 6865 2063 616d 6572 6120  e of the camera 
-00010570: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
-00010580: 7468 6520 6f72 6967 696e 206f 6620 7468  the origin of th
-00010590: 6973 2069 6d61 6765 0a20 2020 2020 2020  is image.       
-000105a0: 2069 6420 2020 2020 2020 696e 7420 2020   id       int   
-000105b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000105c0: 2073 6571 7565 6e63 6520 6e75 6d62 6572   sequence number
-000105d0: 206f 6620 7468 6973 2069 6d61 6765 2069   of this image i
-000105e0: 6e20 6060 696d 6167 6573 6060 0a20 2020  n ``images``.   
-000105f0: 2020 2020 203d 3d3d 3d3d 3d3d 2020 3d3d       =======  ==
-00010600: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00010610: 3d3d 3d20 203d 3d3d 3d3d 3d3d 3d3d 3d3d  ===  ===========
-00010620: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00010630: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00010640: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00010650: 0a0a 2020 2020 2020 2020 3a6e 6f74 653a  ..        :note:
-00010660: 2054 6865 2075 6e69 7473 2075 7365 6420   The units used 
-00010670: 666f 7220 6060 7371 7561 7265 7369 7a65  for ``squaresize
-00010680: 6060 206d 7573 7420 6d61 7463 6820 7468  `` must match th
-00010690: 6520 756e 6974 7320 7573 6564 0a20 2020  e units used.   
-000106a0: 2020 2020 2020 2020 2066 6f72 2064 6566           for def
-000106b0: 696e 696e 6720 3344 2070 6f69 6e74 7320  ining 3D points 
-000106c0: 696e 2073 7061 6365 2e0a 0a20 2020 2020  in space...     
-000106d0: 2020 203a 7265 6665 7265 6e63 6573 3a0a     :references:.
-000106e0: 2020 2020 2020 2020 2020 2020 2d20 526f              - Ro
-000106f0: 626f 7469 6373 2c20 5669 7369 6f6e 2026  botics, Vision &
-00010700: 2043 6f6e 7472 6f6c 2066 6f72 2050 7974   Control for Pyt
-00010710: 686f 6e2c 2053 6563 7469 6f6e 2031 332e  hon, Section 13.
-00010720: 372c 2050 2e20 436f 726b 652c 200a 2020  7, P. Corke, .  
-00010730: 2020 2020 2020 2020 2020 2020 5370 7269              Spri
-00010740: 6e67 6572 2032 3032 332e 0a0a 2020 2020  nger 2023...    
-00010750: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
-00010760: 6574 683a 6043 6020 3a6d 6574 683a 6070  eth:`C` :meth:`p
-00010770: 6f69 6e74 7332 4360 203a 6d65 7468 3a60  oints2C` :meth:`
-00010780: 6465 636f 6d70 6f73 6543 6020 3a63 6c61  decomposeC` :cla
-00010790: 7373 3a60 7e73 7061 7469 616c 6d61 7468  ss:`~spatialmath
-000107a0: 2e2e 706f 7365 3364 2e53 4533 600a 2020  ..pose3d.SE3`.  
-000107b0: 2020 2020 2020 2222 220a 0a20 2020 2020        """..     
-000107c0: 2020 2063 7269 7465 7269 6120 3d20 2863     criteria = (c
-000107d0: 762e 5445 524d 5f43 5249 5445 5249 415f  v.TERM_CRITERIA_
-000107e0: 4550 5320 2b20 6376 2e54 4552 4d5f 4352  EPS + cv.TERM_CR
-000107f0: 4954 4552 4941 5f4d 4158 5f49 5445 522c  ITERIA_MAX_ITER,
-00010800: 2033 302c 2030 2e30 3031 290a 2020 2020   30, 0.001).    
-00010810: 2020 2020 2320 6372 6561 7465 2073 6574      # create set
-00010820: 206f 6620 6665 6174 7572 6520 706f 696e   of feature poin
-00010830: 7473 2c20 6c69 6b65 2028 302c 302c 3029  ts, like (0,0,0)
-00010840: 2c20 2831 2c30 2c30 292c 2028 322c 302c  , (1,0,0), (2,0,
-00010850: 3029 202e 2e2e 2e2c 2836 2c35 2c30 290a  0) ....,(6,5,0).
-00010860: 2020 2020 2020 2020 2320 7468 6573 6520          # these 
-00010870: 616c 6c20 6861 7665 205a 3d30 2073 696e  all have Z=0 sin
-00010880: 6365 2074 6865 7920 6172 6520 7265 6c61  ce they are rela
-00010890: 7469 7665 2074 6f20 7468 6520 6361 6c69  tive to the cali
-000108a0: 6272 6174 696f 6e20 7461 7267 6574 2066  bration target f
-000108b0: 7261 6d65 0a20 2020 2020 2020 206f 626a  rame.        obj
-000108c0: 7020 3d20 6e70 2e7a 6572 6f73 2828 6772  p = np.zeros((gr
-000108d0: 6964 7368 6170 655b 305d 202a 2067 7269  idshape[0] * gri
-000108e0: 6473 6861 7065 5b31 5d2c 2033 292c 206e  dshape[1], 3), n
-000108f0: 702e 666c 6f61 7433 3229 0a20 2020 2020  p.float32).     
-00010900: 2020 206f 626a 705b 3a2c 203a 325d 203d     objp[:, :2] =
-00010910: 206e 702e 6d67 7269 645b 303a 6772 6964   np.mgrid[0:grid
-00010920: 7368 6170 655b 305d 2c20 303a 6772 6964  shape[0], 0:grid
-00010930: 7368 6170 655b 315d 5d2e 542e 7265 7368  shape[1]].T.resh
-00010940: 6170 6528 2d31 2c20 3229 202a 2073 7175  ape(-1, 2) * squ
-00010950: 6172 6573 697a 650a 0a20 2020 2020 2020  aresize..       
-00010960: 2023 206c 6973 7473 2074 6f20 7374 6f72   # lists to stor
-00010970: 6520 6f62 6a65 6374 2070 6f69 6e74 7320  e object points 
-00010980: 616e 6420 696d 6167 6520 706f 696e 7473  and image points
-00010990: 2066 726f 6d20 616c 6c20 7468 6520 696d   from all the im
-000109a0: 6167 6573 0a20 2020 2020 2020 206f 626a  ages.        obj
-000109b0: 706f 696e 7473 203d 205b 5d20 2320 3364  points = [] # 3d
-000109c0: 2070 6f69 6e74 2069 6e20 7265 616c 2077   point in real w
-000109d0: 6f72 6c64 2073 7061 6365 0a20 2020 2020  orld space.     
-000109e0: 2020 2069 6d67 706f 696e 7473 203d 205b     imgpoints = [
-000109f0: 5d20 2320 3264 2070 6f69 6e74 7320 696e  ] # 2d points in
-00010a00: 2069 6d61 6765 2070 6c61 6e65 2e0a 2020   image plane..  
-00010a10: 2020 2020 2020 636f 726e 6572 5f69 6d61        corner_ima
-00010a20: 6765 7320 3d20 5b5d 0a20 2020 2020 2020  ges = [].       
-00010a30: 2076 616c 6964 203d 205b 5d0a 0a20 2020   valid = []..   
-00010a40: 2020 2020 2066 6f72 2069 2c20 696d 6167       for i, imag
-00010a50: 6520 696e 2065 6e75 6d65 7261 7465 2869  e in enumerate(i
-00010a60: 6d61 6765 7329 3a0a 0a20 2020 2020 2020  mages):..       
-00010a70: 2020 2020 2067 7261 7920 3d20 696d 6167       gray = imag
-00010a80: 652e 6d6f 6e6f 2829 2e41 0a20 2020 2020  e.mono().A.     
-00010a90: 2020 2020 2020 2023 2046 696e 6420 7468         # Find th
-00010aa0: 6520 6368 6573 7320 626f 6172 6420 636f  e chess board co
-00010ab0: 726e 6572 730a 2020 2020 2020 2020 2020  rners.          
-00010ac0: 2020 7265 742c 2063 6f72 6e65 7273 203d    ret, corners =
-00010ad0: 2063 762e 6669 6e64 4368 6573 7362 6f61   cv.findChessboa
-00010ae0: 7264 436f 726e 6572 7328 6772 6179 2c20  rdCorners(gray, 
-00010af0: 6772 6964 7368 6170 652c 204e 6f6e 6529  gridshape, None)
-00010b00: 0a20 2020 2020 2020 2020 2020 2023 2049  .            # I
-00010b10: 6620 666f 756e 642c 2061 6464 206f 626a  f found, add obj
-00010b20: 6563 7420 706f 696e 7473 2c20 696d 6167  ect points, imag
-00010b30: 6520 706f 696e 7473 2028 6166 7465 7220  e points (after 
-00010b40: 7265 6669 6e69 6e67 2074 6865 6d29 0a20  refining them). 
-00010b50: 2020 2020 2020 2020 2020 2069 6620 7265             if re
-00010b60: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
-00010b70: 2020 206f 626a 706f 696e 7473 2e61 7070     objpoints.app
-00010b80: 656e 6428 6f62 6a70 290a 2020 2020 2020  end(objp).      
-00010b90: 2020 2020 2020 2020 2020 636f 726e 6572            corner
-00010ba0: 7332 203d 2063 762e 636f 726e 6572 5375  s2 = cv.cornerSu
-00010bb0: 6250 6978 2867 7261 792c 636f 726e 6572  bPix(gray,corner
-00010bc0: 732c 2028 3131 2c31 3129 2c20 282d 312c  s, (11,11), (-1,
-00010bd0: 2d31 292c 2063 7269 7465 7269 6129 0a20  -1), criteria). 
-00010be0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00010bf0: 6d67 706f 696e 7473 2e61 7070 656e 6428  mgpoints.append(
-00010c00: 636f 726e 6572 7329 0a20 2020 2020 2020  corners).       
-00010c10: 2020 2020 2020 2020 2023 2044 7261 7720           # Draw 
-00010c20: 7468 6520 636f 726e 6572 730a 2020 2020  the corners.    
-00010c30: 2020 2020 2020 2020 2020 2020 696d 6167              imag
-00010c40: 6520 3d20 496d 6167 6528 696d 6167 652c  e = Image(image,
-00010c50: 2063 6f70 793d 5472 7565 290a 2020 2020   copy=True).    
-00010c60: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00010c70: 6f74 2069 6d61 6765 2e69 7363 6f6c 6f72  ot image.iscolor
-00010c80: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00010c90: 2020 2020 2020 696d 6167 6520 3d20 696d        image = im
-00010ca0: 6167 652e 636f 6c6f 7269 7a65 2829 0a20  age.colorize(). 
-00010cb0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00010cc0: 6f72 6e65 725f 696d 6167 6573 2e61 7070  orner_images.app
-00010cd0: 656e 6428 6376 2e64 7261 7743 6865 7373  end(cv.drawChess
-00010ce0: 626f 6172 6443 6f72 6e65 7273 2869 6d61  boardCorners(ima
-00010cf0: 6765 2e41 2c20 6772 6964 7368 6170 652c  ge.A, gridshape,
-00010d00: 2063 6f72 6e65 7273 322c 2072 6574 2929   corners2, ret))
-00010d10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010d20: 2076 616c 6964 2e61 7070 656e 6428 6929   valid.append(i)
-00010d30: 0a0a 2020 2020 2020 2020 7265 742c 2043  ..        ret, C
-00010d40: 2c20 6469 7374 6f72 7469 6f6e 2c20 7276  , distortion, rv
-00010d50: 6563 732c 2074 7665 6373 203d 2063 762e  ecs, tvecs = cv.
-00010d60: 6361 6c69 6272 6174 6543 616d 6572 6128  calibrateCamera(
-00010d70: 6f62 6a70 6f69 6e74 732c 2069 6d67 706f  objpoints, imgpo
-00010d80: 696e 7473 2c20 6772 6179 2e73 6861 7065  ints, gray.shape
-00010d90: 5b3a 3a2d 315d 2c20 4e6f 6e65 2c20 4e6f  [::-1], None, No
-00010da0: 6e65 290a 0a20 2020 2020 2020 2043 616c  ne)..        Cal
-00010db0: 6962 7261 7469 6f6e 4672 616d 6520 3d20  ibrationFrame = 
-00010dc0: 6e61 6d65 6474 7570 6c65 2822 4361 6c69  namedtuple("Cali
-00010dd0: 6272 6174 696f 6e46 7261 6d65 222c 2022  brationFrame", "
-00010de0: 696d 6167 6520 706f 7365 2069 6422 290a  image pose id").
-00010df0: 2020 2020 2020 2020 6966 2072 6574 3a0a          if ret:.
-00010e00: 2020 2020 2020 2020 2020 2020 6672 616d              fram
-00010e10: 6573 203d 205b 5d0a 2020 2020 2020 2020  es = [].        
-00010e20: 2020 2020 666f 7220 7276 6563 2c20 7476      for rvec, tv
-00010e30: 6563 2c20 636f 726e 6572 5f69 6d61 6765  ec, corner_image
-00010e40: 2c20 6964 2069 6e20 7a69 7028 7276 6563  , id in zip(rvec
-00010e50: 732c 2074 7665 6373 2c20 636f 726e 6572  s, tvecs, corner
-00010e60: 5f69 6d61 6765 732c 2076 616c 6964 293a  _images, valid):
-00010e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010e80: 2066 7261 6d65 203d 2043 616c 6962 7261   frame = Calibra
-00010e90: 7469 6f6e 4672 616d 6528 0a20 2020 2020  tionFrame(.     
-00010ea0: 2020 2020 2020 2020 2020 2020 2020 2049                 I
-00010eb0: 6d61 6765 2863 6f72 6e65 725f 696d 6167  mage(corner_imag
-00010ec0: 652c 2063 6f6c 6f72 6f72 6465 723d 2242  e, colororder="B
-00010ed0: 4752 2229 2c20 0a20 2020 2020 2020 2020  GR"), .         
-00010ee0: 2020 2020 2020 2020 2020 2028 5345 3328             (SE3(
-00010ef0: 7476 6563 2920 2a20 5345 332e 4575 6c65  tvec) * SE3.Eule
-00010f00: 7256 6563 2872 7665 632e 666c 6174 7465  rVec(rvec.flatte
-00010f10: 6e28 2929 292e 696e 7628 292c 0a20 2020  n())).inv(),.   
-00010f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010f30: 2069 6429 0a20 2020 2020 2020 2020 2020   id).           
-00010f40: 2020 2020 2066 7261 6d65 732e 6170 7065       frames.appe
-00010f50: 6e64 2866 7261 6d65 290a 2020 2020 2020  nd(frame).      
-00010f60: 2020 2020 2020 7265 7475 726e 2043 2c20        return C, 
-00010f70: 6469 7374 6f72 7469 6f6e 5b30 5d2c 2066  distortion[0], f
-00010f80: 7261 6d65 730a 2020 2020 2020 2020 656c  rames.        el
-00010f90: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00010fa0: 7265 7475 726e 204e 6f6e 650a 0a20 2020  return None..   
-00010fb0: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
-00010fc0: 2020 6465 6620 6465 636f 6d70 6f73 6543    def decomposeC
-00010fd0: 2863 6c73 2c20 4329 3a0a 2020 2020 2020  (cls, C):.      
-00010fe0: 2020 7222 2222 0a20 2020 2020 2020 2044    r""".        D
-00010ff0: 6563 6f6d 706f 7365 2063 616d 6572 6120  ecompose camera 
-00011000: 6361 6c69 6272 6174 696f 6e20 6d61 7472  calibration matr
-00011010: 6978 0a0a 2020 2020 2020 2020 3a70 6172  ix..        :par
-00011020: 616d 2043 3a20 6361 6d65 7261 2063 616c  am C: camera cal
-00011030: 6962 7261 7469 6f6e 206d 6174 7269 780a  ibration matrix.
-00011040: 2020 2020 2020 2020 3a74 7970 6520 433a          :type C:
-00011050: 206e 6461 7272 6179 2833 2c34 290a 2020   ndarray(3,4).  
-00011060: 2020 2020 2020 3a72 6574 7572 6e3a 2063        :return: c
-00011070: 616d 6572 6120 6d6f 6465 6c20 7061 7261  amera model para
-00011080: 6d65 7465 7273 0a20 2020 2020 2020 203a  meters.        :
-00011090: 7274 7970 653a 203a 636c 6173 733a 6043  rtype: :class:`C
-000110a0: 656e 7472 616c 4361 6d65 7261 600a 0a20  entralCamera`.. 
-000110b0: 2020 2020 2020 2044 6563 6f6d 706f 7365         Decompose
-000110c0: 2061 203a 6d61 7468 3a60 335c 7469 6d65   a :math:`3\time
-000110d0: 7320 3460 2063 616d 6572 6120 6361 6c69  s 4` camera cali
-000110e0: 6272 6174 696f 6e20 6d61 7472 6978 2060  bration matrix `
-000110f0: 6043 6060 2074 6f0a 2020 2020 2020 2020  `C`` to.        
-00011100: 6465 7465 726d 696e 6520 6665 6173 6962  determine feasib
-00011110: 6c65 2069 6e74 7269 6e73 6963 2061 6e64  le intrinsic and
-00011120: 2065 7874 7269 6e73 6963 2070 6172 616d   extrinsic param
-00011130: 6574 6572 732e 2054 6865 2072 6573 756c  eters. The resul
-00011140: 7420 6973 2061 0a20 2020 2020 2020 2060  t is a.        `
-00011150: 6043 656e 7472 616c 4361 6d65 7261 6060  `CentralCamera``
-00011160: 2069 6e73 7461 6e63 6520 7769 7468 2074   instance with t
-00011170: 6865 2066 6f6c 6c6f 7769 6e67 2070 6172  he following par
-00011180: 616d 6574 6572 7320 7365 743a 0a0a 2020  ameters set:..  
-00011190: 2020 2020 2020 3d3d 3d3d 3d3d 3d3d 3d3d        ==========
-000111a0: 3d3d 3d3d 3d3d 2020 3d3d 3d3d 3d3d 3d3d  ======  ========
-000111b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000111c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a20 2020  ============.   
-000111d0: 2020 2020 2050 6172 616d 6574 6572 2020       Parameter  
-000111e0: 2020 2020 2020 204d 6561 6e69 6e67 0a20         Meaning. 
-000111f0: 2020 2020 2020 203d 3d3d 3d3d 3d3d 3d3d         =========
-00011200: 3d3d 3d3d 3d3d 3d20 203d 3d3d 3d3d 3d3d  =======  =======
-00011210: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00011220: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020  =============.  
-00011230: 2020 2020 2020 6060 6660 6020 2020 2020        ``f``     
-00011240: 2020 2020 2020 2020 666f 6361 6c20 6c65          focal le
-00011250: 6e67 7468 2069 6e20 7069 7865 6c73 0a20  ngth in pixels. 
-00011260: 2020 2020 2020 2060 6073 7860 602c 2060         ``sx``, `
-00011270: 6073 7960 6020 2020 2070 6978 656c 2073  `sy``    pixel s
-00011280: 697a 6520 7768 6572 6520 6060 7378 6060  ize where ``sx``
-00011290: 203d 310a 2020 2020 2020 2020 2860 6075   =1.        (``u
-000112a0: 3060 602c 2060 6076 3060 6029 2020 7072  0``, ``v0``)  pr
-000112b0: 696e 6369 7061 6c20 706f 696e 740a 2020  incipal point.  
-000112c0: 2020 2020 2020 6060 706f 7365 6060 2020        ``pose``  
-000112d0: 2020 2020 2020 2020 706f 7365 206f 6620          pose of 
-000112e0: 7468 6520 6361 6d65 7261 2066 7261 6d65  the camera frame
-000112f0: 2077 7274 2077 6f72 6c64 0a20 2020 2020   wrt world.     
-00011300: 2020 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     =============
-00011310: 3d3d 3d20 203d 3d3d 3d3d 3d3d 3d3d 3d3d  ===  ===========
-00011320: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00011330: 3d3d 3d3d 3d3d 3d3d 3d0a 0a20 2020 2020  =========..     
-00011340: 2020 2045 7861 6d70 6c65 3a0a 0a20 2020     Example:..   
-00011350: 2020 2020 202e 2e20 7275 6e62 6c6f 636b       .. runblock
-00011360: 3a3a 2070 7963 6f6e 0a0a 2020 2020 2020  :: pycon..      
-00011370: 2020 2020 2020 3e3e 3e20 6672 6f6d 206d        >>> from m
-00011380: 6163 6869 6e65 7669 7369 6f6e 746f 6f6c  achinevisiontool
-00011390: 626f 7820 696d 706f 7274 2043 656e 7472  box import Centr
-000113a0: 616c 4361 6d65 7261 0a20 2020 2020 2020  alCamera.       
-000113b0: 2020 2020 203e 3e3e 2066 726f 6d20 7370       >>> from sp
-000113c0: 6174 6961 6c6d 6174 6820 696d 706f 7274  atialmath import
-000113d0: 2053 4533 0a20 2020 2020 2020 2020 2020   SE3.           
-000113e0: 203e 3e3e 2063 616d 6572 6120 3d20 4365   >>> camera = Ce
-000113f0: 6e74 7261 6c43 616d 6572 6128 6e61 6d65  ntralCamera(name
-00011400: 3d27 6361 6d65 7261 3127 290a 2020 2020  ='camera1').    
-00011410: 2020 2020 2020 2020 3e3e 3e20 4320 3d20          >>> C = 
-00011420: 6361 6d65 7261 2e43 2853 4533 2830 2e31  camera.C(SE3(0.1
-00011430: 2c20 302c 2030 2929 0a20 2020 2020 2020  , 0, 0)).       
-00011440: 2020 2020 203e 3e3e 2043 656e 7472 616c       >>> Central
-00011450: 4361 6d65 7261 2e64 6563 6f6d 706f 7365  Camera.decompose
-00011460: 4328 4329 0a0a 2020 2020 2020 2020 3a6e  C(C)..        :n
-00011470: 6f74 653a 2053 696e 6365 206f 6e6c 7920  ote: Since only 
-00011480: 3a6d 6174 683a 6066 2073 5f78 6020 616e  :math:`f s_x` an
-00011490: 6420 3a6d 6174 683a 6066 2073 5f79 6020  d :math:`f s_y` 
-000114a0: 6361 6e20 6265 2065 7374 696d 6174 6564  can be estimated
-000114b0: 2077 650a 2020 2020 2020 2020 2020 2020   we.            
-000114c0: 7365 7420 3a6d 6174 683a 6073 5f78 203d  set :math:`s_x =
-000114d0: 2031 602e 0a0a 2020 2020 2020 2020 3a72   1`...        :r
-000114e0: 6566 6572 656e 6365 3a0a 2020 2020 2020  eference:.      
-000114f0: 2020 2020 2020 2d20 4d75 6c74 6970 6c65        - Multiple
-00011500: 2056 6965 7720 4765 6f6d 6574 7279 2c20   View Geometry, 
-00011510: 4861 7274 6c65 7926 5a69 7373 6572 6d61  Hartley&Zisserma
-00011520: 6e2c 2070 2031 3633 2d31 3634 0a20 2020  n, p 163-164.   
-00011530: 2020 2020 2020 2020 202d 2052 6f62 6f74           - Robot
-00011540: 6963 732c 2056 6973 696f 6e20 2620 436f  ics, Vision & Co
-00011550: 6e74 726f 6c20 666f 7220 5079 7468 6f6e  ntrol for Python
-00011560: 2c20 5365 6374 696f 6e20 3133 2e32 2e33  , Section 13.2.3
-00011570: 2c20 502e 2043 6f72 6b65 2c20 0a20 2020  , P. Corke, .   
-00011580: 2020 2020 2020 2020 2020 2053 7072 696e             Sprin
-00011590: 6765 7220 3230 3233 2e0a 0a20 2020 2020  ger 2023...     
-000115a0: 2020 203a 7365 6561 6c73 6f3a 203a 6d65     :seealso: :me
-000115b0: 7468 3a60 4360 203a 6d65 7468 3a60 706f  th:`C` :meth:`po
-000115c0: 696e 7473 3243 600a 2020 2020 2020 2020  ints2C`.        
-000115d0: 2222 220a 2020 2020 2020 2020 6465 6620  """.        def 
-000115e0: 7271 2853 293a 0a20 2020 2020 2020 2020  rq(S):.         
-000115f0: 2020 2023 2066 726f 6d20 7667 675f 7271     # from vgg_rq
-00011600: 2e6d 0a20 2020 2020 2020 2020 2020 2023  .m.            #
-00011610: 205b 522c 515d 203d 2076 6767 5f72 7128   [R,Q] = vgg_rq(
-00011620: 5329 2020 4a75 7374 206c 696b 6520 7172  S)  Just like qr
-00011630: 2062 7574 2074 6865 206f 7468 6572 2077   but the other w
-00011640: 6179 2061 726f 756e 642e 0a20 2020 2020  ay around..     
-00011650: 2020 2020 2020 2023 2049 6620 5b52 2c51         # If [R,Q
-00011660: 5d20 3d20 7667 675f 7271 2858 292c 2074  ] = vgg_rq(X), t
-00011670: 6865 6e20 5220 6973 2075 7070 6572 2d74  hen R is upper-t
-00011680: 7269 616e 6775 6c61 722c 2051 2069 7320  riangular, Q is 
-00011690: 6f72 7468 6f67 6f6e 616c 2c20 616e 6420  orthogonal, and 
-000116a0: 583d 3d52 2a51 2e0a 2020 2020 2020 2020  X==R*Q..        
-000116b0: 2020 2020 2320 4d6f 7265 6f76 6572 2c20      # Moreover, 
-000116c0: 6966 2053 2069 7320 6120 7265 616c 206d  if S is a real m
-000116d0: 6174 7269 782c 2074 6865 6e20 6465 7428  atrix, then det(
-000116e0: 5129 3e30 2e0a 2020 2020 2020 2020 2020  Q)>0..          
-000116f0: 2020 2320 4279 2061 7766 0a0a 2020 2020    # By awf..    
-00011700: 2020 2020 2020 2020 5320 3d20 532e 540a          S = S.T.
-00011710: 2020 2020 2020 2020 2020 2020 512c 2055              Q, U
-00011720: 203d 206e 702e 6c69 6e61 6c67 2e71 7228   = np.linalg.qr(
-00011730: 535b 3a3a 2d31 2c20 3a3a 2d31 5d29 0a20  S[::-1, ::-1]). 
-00011740: 2020 2020 2020 2020 2020 2051 203d 2051             Q = Q
-00011750: 2e54 0a20 2020 2020 2020 2020 2020 2051  .T.            Q
-00011760: 203d 2051 5b3a 3a2d 312c 203a 3a2d 315d   = Q[::-1, ::-1]
-00011770: 0a20 2020 2020 2020 2020 2020 2055 203d  .            U =
-00011780: 2055 2e54 0a20 2020 2020 2020 2020 2020   U.T.           
-00011790: 2055 203d 2055 5b3a 3a2d 312c 203a 3a2d   U = U[::-1, ::-
-000117a0: 315d 0a0a 2020 2020 2020 2020 2020 2020  1]..            
-000117b0: 6966 206e 702e 6c69 6e61 6c67 2e64 6574  if np.linalg.det
-000117c0: 2851 2920 3c20 303a 0a20 2020 2020 2020  (Q) < 0:.       
-000117d0: 2020 2020 2020 2020 2055 5b3a 2c20 305d           U[:, 0]
-000117e0: 203d 202d 555b 3a2c 2030 5d0a 2020 2020   = -U[:, 0].    
-000117f0: 2020 2020 2020 2020 2020 2020 515b 302c              Q[0,
-00011800: 203a 5d20 3d20 2d51 5b30 2c20 3a5d 0a20   :] = -Q[0, :]. 
-00011810: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00011820: 6e20 552c 2051 0a0a 0a20 2020 2020 2020  n U, Q...       
-00011830: 2069 6620 6e6f 7420 432e 7368 6170 6520   if not C.shape 
-00011840: 3d3d 2028 332c 3429 3a0a 2020 2020 2020  == (3,4):.      
-00011850: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00011860: 6545 7272 6f72 2827 6172 6775 6d65 6e74  eError('argument
-00011870: 2069 7320 6e6f 7420 6120 3378 3420 6d61   is not a 3x4 ma
-00011880: 7472 6978 2729 0a0a 2020 2020 2020 2020  trix')..        
-00011890: 752c 2073 2c20 7620 3d20 6e70 2e6c 696e  u, s, v = np.lin
-000118a0: 616c 672e 7376 6428 4329 0a20 2020 2020  alg.svd(C).     
-000118b0: 2020 2076 203d 2076 2e54 0a0a 2020 2020     v = v.T..    
-000118c0: 2020 2020 2320 6465 7465 726d 696e 6520      # determine 
-000118d0: 6361 6d65 7261 2070 6f73 6974 696f 6e0a  camera position.
-000118e0: 2020 2020 2020 2020 7420 3d20 765b 3a2c          t = v[:,
-000118f0: 2033 5d20 2023 206c 6173 7420 636f 6c75   3]  # last colu
-00011900: 6d6e 0a20 2020 2020 2020 2074 203d 2074  mn.        t = t
-00011910: 202f 2074 5b33 5d0a 2020 2020 2020 2020   / t[3].        
-00011920: 7420 3d20 745b 3a33 5d0a 0a20 2020 2020  t = t[:3]..     
-00011930: 2020 2023 2064 6574 6572 6d69 6e65 2063     # determine c
-00011940: 616d 6572 6120 6f72 6965 6e74 6174 696f  amera orientatio
-00011950: 6e0a 2020 2020 2020 2020 4d20 3d20 435b  n.        M = C[
-00011960: 3a33 2c20 3a33 5d0a 2020 2020 2020 2020  :3, :3].        
-00011970: 2320 4b2c 2052 203d 2072 7128 4d29 0a20  # K, R = rq(M). 
-00011980: 2020 2020 2020 204b 2c20 5220 3d20 7363         K, R = sc
-00011990: 6970 792e 6c69 6e61 6c67 2e72 7128 4d29  ipy.linalg.rq(M)
-000119a0: 0a0a 2020 2020 2020 2020 2320 6465 616c  ..        # deal
-000119b0: 2077 6974 6820 4b20 6861 7669 6e67 206e   with K having n
-000119c0: 6567 6174 6976 6520 656c 656d 656e 7473  egative elements
-000119d0: 206f 6e20 7468 6520 6469 6167 6f6e 616c   on the diagonal
-000119e0: 0a20 2020 2020 2020 2023 206d 616b 6520  .        # make 
-000119f0: 6120 6d61 7472 6978 2074 6f20 6669 7820  a matrix to fix 
-00011a00: 7468 6973 2c20 4b2a 4320 6861 7320 706f  this, K*C has po
-00011a10: 7369 7469 7665 2064 6961 676f 6e61 6c0a  sitive diagonal.
-00011a20: 2020 2020 2020 2020 4320 3d20 6e70 2e64          C = np.d
-00011a30: 6961 6728 6e70 2e73 6967 6e28 6e70 2e64  iag(np.sign(np.d
-00011a40: 6961 6728 4b29 2929 0a20 2020 2020 2020  iag(K))).       
-00011a50: 200a 2020 2020 2020 2020 2320 6e6f 7720   .        # now 
-00011a60: 204b 2a52 203d 2028 4b2a 4329 202a 2028   K*R = (K*C) * (
-00011a70: 696e 7628 4329 2a52 292c 2073 6f20 7765  inv(C)*R), so we
-00011a80: 206e 6565 6420 746f 2063 6865 636b 2043   need to check C
-00011a90: 2069 7320 6120 7072 6f70 6572 2072 6f74   is a proper rot
-00011aa0: 6174 696f 6e0a 2020 2020 2020 2020 2320  ation.        # 
-00011ab0: 6d61 7472 6978 2e20 2049 6620 6973 6e27  matrix.  If isn'
-00011ac0: 7420 7468 656e 2074 6865 2073 6974 7561  t then the situa
-00011ad0: 7469 6f6e 2069 7320 756e 6669 7861 626c  tion is unfixabl
-00011ae0: 650a 2020 2020 2020 2020 0a20 2020 2020  e.        .     
-00011af0: 2020 2069 6620 6e6f 7420 6e70 2e69 7363     if not np.isc
-00011b00: 6c6f 7365 286e 702e 6c69 6e61 6c67 2e64  lose(np.linalg.d
-00011b10: 6574 2843 292c 2031 293a 0a20 2020 2020  et(C), 1):.     
-00011b20: 2020 2020 2020 2072 6169 7365 2052 756e         raise Run
-00011b30: 7469 6d65 4572 726f 7228 2763 616e 6e6f  timeError('canno
-00011b40: 7420 636f 7272 6563 7420 7369 676e 7320  t correct signs 
-00011b50: 696e 2074 6865 2069 6e74 7269 6e73 6963  in the intrinsic
-00011b60: 206d 6174 7269 7827 290a 2020 2020 2020   matrix').      
-00011b70: 2020 0a20 2020 2020 2020 2023 2061 6c6c    .        # all
-00011b80: 2067 6f6f 642c 206c 6574 2773 2066 6978   good, let's fix
-00011b90: 2069 740a 2020 2020 2020 2020 4b20 3d20   it.        K = 
-00011ba0: 4b20 4020 430a 2020 2020 2020 2020 5220  K @ C.        R 
-00011bb0: 3d20 432e 5420 4020 520a 2020 2020 2020  = C.T @ R.      
-00011bc0: 2020 0a20 2020 2020 2020 2023 206e 6f72    .        # nor
-00011bd0: 6d61 6c69 7a65 204b 2073 6f20 7468 6174  malize K so that
-00011be0: 206c 6f77 6572 206c 6566 7420 6973 2031   lower left is 1
-00011bf0: 0a20 2020 2020 2020 204b 203d 204b 202f  .        K = K /
-00011c00: 204b 5b32 2c20 325d 0a20 2020 2020 2020   K[2, 2].       
-00011c10: 200a 2020 2020 2020 2020 2320 7075 6c6c   .        # pull
-00011c20: 206f 7574 2066 6f63 616c 206c 656e 6774   out focal lengt
-00011c30: 6820 616e 6420 7363 616c 6520 6661 6374  h and scale fact
-00011c40: 6f72 730a 2020 2020 2020 2020 6620 3d20  ors.        f = 
-00011c50: 4b5b 302c 2030 5d0a 2020 2020 2020 2020  K[0, 0].        
-00011c60: 7320 3d20 6e70 2e72 5f5b 312c 204b 5b31  s = np.r_[1, K[1
-00011c70: 2c31 5d20 2f20 4b5b 302c 2030 5d5d 0a0a  ,1] / K[0, 0]]..
-00011c80: 2020 2020 2020 2020 2320 6275 696c 6420          # build 
-00011c90: 616e 2065 7175 6976 616c 656e 7420 6361  an equivalent ca
-00011ca0: 6d65 7261 206d 6f64 656c 0a20 2020 2020  mera model.     
-00011cb0: 2020 2072 6574 7572 6e20 636c 7328 6e61     return cls(na
-00011cc0: 6d65 3d27 696e 7643 272c 0a20 2020 2020  me='invC',.     
-00011cd0: 2020 2020 2020 2066 3d66 2c20 7070 3d4b         f=f, pp=K
-00011ce0: 5b3a 322c 2032 5d2c 2072 686f 3d73 2c20  [:2, 2], rho=s, 
-00011cf0: 706f 7365 3d53 4533 2e52 7428 522e 542c  pose=SE3.Rt(R.T,
-00011d00: 2074 2929 0a0a 2320 6874 7470 733a 2f2f   t))..# https://
-00011d10: 646f 6373 2e6f 7065 6e63 762e 6f72 672f  docs.opencv.org/
-00011d20: 332e 312e 302f 6439 2f64 3063 2f67 726f  3.1.0/d9/d0c/gro
-00011d30: 7570 5f5f 6361 6c69 6233 642e 6874 6d6c  up__calib3d.html
-00011d40: 2367 6161 6165 3561 3738 3939 6661 6131  #gaaae5a7899faa1
-00011d50: 6666 6466 3236 3863 6439 3038 3839 3430  ffdf268cd9088940
-00011d60: 3234 380a 0a20 2020 2023 203d 3d3d 3d3d  248..    # =====
-00011d70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00011d80: 3d3d 2068 6f6d 6f67 7261 7068 7920 3d3d  == homography ==
-00011d90: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00011da0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 230a  ============= #.
-00011db0: 0a20 2020 2064 6566 2048 2873 656c 662c  .    def H(self,
-00011dc0: 2054 2c20 6e2c 2064 293a 0a20 2020 2020   T, n, d):.     
-00011dd0: 2020 2022 2222 0a20 2020 2020 2020 2043     """.        C
-00011de0: 6f6d 7075 7465 2068 6f6d 6f67 7261 7068  ompute homograph
-00011df0: 7920 6672 6f6d 2070 6c61 6e65 2061 6e64  y from plane and
-00011e00: 2063 616d 6572 6120 706f 7365 0a0a 2020   camera pose..  
-00011e10: 2020 2020 2020 3a70 6172 616d 2054 3a20        :param T: 
-00011e20: 7265 6c61 7469 7665 2063 616d 6572 6120  relative camera 
-00011e30: 6d6f 7469 6f6e 0a20 2020 2020 2020 203a  motion.        :
-00011e40: 7479 7065 2054 3a20 3a63 6c61 7373 3a60  type T: :class:`
-00011e50: 7e73 7061 7469 616c 6d61 7468 2e2e 706f  ~spatialmath..po
-00011e60: 7365 3364 2e53 4533 600a 2020 2020 2020  se3d.SE3`.      
-00011e70: 2020 3a70 6172 616d 206e 3a20 706c 616e    :param n: plan
-00011e80: 6520 6e6f 726d 616c 2077 6974 6820 7265  e normal with re
-00011e90: 7370 6563 7420 746f 2077 6f72 6c64 2066  spect to world f
-00011ea0: 7261 6d65 0a20 2020 2020 2020 203a 7479  rame.        :ty
-00011eb0: 7065 206e 3a20 6172 7261 795f 6c69 6b65  pe n: array_like
-00011ec0: 2833 290a 2020 2020 2020 2020 3a70 6172  (3).        :par
-00011ed0: 616d 2064 3a20 706c 616e 6520 6f66 6673  am d: plane offs
-00011ee0: 6574 2066 726f 6d20 776f 726c 6420 6672  et from world fr
-00011ef0: 616d 6520 6f72 6967 696e 0a20 2020 2020  ame origin.     
-00011f00: 2020 203a 7479 7065 2064 3a20 666c 6f61     :type d: floa
-00011f10: 740a 2020 2020 2020 2020 3a72 6574 7572  t.        :retur
-00011f20: 6e3a 2068 6f6d 6f67 7261 7068 7920 6d61  n: homography ma
-00011f30: 7472 6978 0a20 2020 2020 2020 203a 7274  trix.        :rt
-00011f40: 7970 653a 206e 6461 7272 6179 2833 2c33  ype: ndarray(3,3
-00011f50: 290a 0a20 2020 2020 2020 2043 6f6d 7075  )..        Compu
-00011f60: 7465 7320 7468 6520 686f 6d6f 6772 6170  tes the homograp
-00011f70: 6879 206d 6174 7269 7820 666f 7220 7468  hy matrix for th
-00011f80: 6520 6361 6d65 7261 206f 6273 6572 7669  e camera observi
-00011f90: 6e67 2070 6f69 6e74 7320 6f6e 2061 0a20  ng points on a. 
-00011fa0: 2020 2020 2020 2070 6c61 6e65 2066 726f         plane fro
-00011fb0: 6d20 7477 6f20 7669 6577 706f 696e 7473  m two viewpoints
-00011fc0: 2e20 5468 6520 6669 7273 7420 7669 6577  . The first view
-00011fd0: 2069 7320 6672 6f6d 2074 6865 2063 7572   is from the cur
-00011fe0: 7265 6e74 2063 616d 6572 610a 2020 2020  rent camera.    
-00011ff0: 2020 2020 706f 7365 2028 6060 7365 6c66      pose (``self
-00012000: 2e70 6f73 6560 6029 2c20 616e 6420 7468  .pose``), and th
-00012010: 6520 7365 636f 6e64 2069 7320 6166 7465  e second is afte
-00012020: 7220 6120 7265 6c61 7469 7665 206d 6f74  r a relative mot
-00012030: 696f 6e0a 2020 2020 2020 2020 7265 7072  ion.        repr
-00012040: 6573 656e 7465 6420 6279 2074 6865 2072  esented by the r
-00012050: 6967 6964 2d62 6f64 7920 6d6f 7469 6f6e  igid-body motion
-00012060: 2060 6054 6060 2e20 5468 6520 706c 616e   ``T``. The plan
-00012070: 6520 6861 7320 6e6f 726d 616c 2060 606e  e has normal ``n
-00012080: 6060 0a20 2020 2020 2020 2061 6e64 2061  ``.        and a
-00012090: 7420 6469 7374 616e 6365 2060 6064 6060  t distance ``d``
-000120a0: 2077 6974 6820 7265 7370 6563 7420 746f   with respect to
-000120b0: 2074 6865 2077 6f72 6c64 2066 7261 6d65   the world frame
-000120c0: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
-000120d0: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
-000120e0: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
-000120f0: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
-00012100: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
-00012110: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
-00012120: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
-00012130: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00012140: 2066 726f 6d20 7370 6174 6961 6c6d 6174   from spatialmat
-00012150: 6820 696d 706f 7274 2053 4533 0a20 2020  h import SE3.   
-00012160: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-00012170: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
-00012180: 6572 612e 4465 6661 756c 7428 6e61 6d65  era.Default(name
-00012190: 3d27 6361 6d65 7261 3127 2920 2320 6c6f  ='camera1') # lo
-000121a0: 6f6b 696e 6720 616c 6f6e 6720 7a2d 6178  oking along z-ax
-000121b0: 6973 0a20 2020 2020 2020 2020 2020 203e  is.            >
-000121c0: 3e3e 2070 6c61 6e65 203d 205b 302c 2031  >> plane = [0, 1
-000121d0: 2c20 315d 0a20 2020 2020 2020 2020 2020  , 1].           
-000121e0: 203e 3e3e 2048 203d 2063 616d 6572 612e   >>> H = camera.
-000121f0: 4828 5345 332e 5478 2830 2e32 292c 2070  H(SE3.Tx(0.2), p
-00012200: 6c61 6e65 2c20 3529 0a20 2020 2020 2020  lane, 5).       
-00012210: 2020 2020 203e 3e3e 2048 0a0a 2020 2020       >>> H..    
-00012220: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
-00012230: 6574 683a 6070 6f69 6e74 7332 4860 203a  eth:`points2H` :
-00012240: 6d65 7468 3a60 6465 636f 6d70 6f73 6548  meth:`decomposeH
-00012250: 600a 2020 2020 2020 2020 2222 220a 2020  `.        """.  
-00012260: 2020 2020 2020 6966 2064 203c 2030 3a0a        if d < 0:.
-00012270: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00012280: 6520 5661 6c75 6545 7272 6f72 2864 2c20  e ValueError(d, 
-00012290: 2770 6c61 6e65 2064 6973 7461 6e63 6520  'plane distance 
-000122a0: 6420 6d75 7374 2062 6520 3e20 3027 290a  d must be > 0').
-000122b0: 0a20 2020 2020 2020 206e 203d 2062 6173  .        n = bas
-000122c0: 652e 6765 7476 6563 746f 7228 6e29 0a20  e.getvector(n). 
-000122d0: 2020 2020 2020 2069 6620 6e5b 325d 203c         if n[2] <
-000122e0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-000122f0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00012300: 286e 2c20 276e 6f72 6d61 6c20 6d75 7374  (n, 'normal must
-00012310: 2062 6520 6177 6179 2066 726f 6d20 6361   be away from ca
-00012320: 6d65 7261 2028 6e5b 325d 203e 3d20 3029  mera (n[2] >= 0)
-00012330: 2729 0a0a 2020 2020 2020 2020 2320 5420  ')..        # T 
-00012340: 7472 616e 7366 6f72 6d20 7669 6577 2031  transform view 1
-00012350: 2074 6f20 7669 6577 2032 0a20 2020 2020   to view 2.     
-00012360: 2020 2054 203d 2053 4533 2854 292e 696e     T = SE3(T).in
-00012370: 7628 290a 0a20 2020 2020 2020 2048 4820  v()..        HH 
-00012380: 3d20 542e 5220 2b20 312e 3020 2f20 6420  = T.R + 1.0 / d 
-00012390: 2a20 542e 7420 4020 6e20 2023 206e 6565  * T.t @ n  # nee
-000123a0: 6420 746f 2065 6e73 7572 6520 636f 6c75  d to ensure colu
-000123b0: 6d6e 2074 6865 6e20 726f 7720 3d20 3378  mn then row = 3x
-000123c0: 330a 0a20 2020 2020 2020 2023 2061 7070  3..        # app
-000123d0: 6c79 2063 616d 6572 6120 696e 7472 696e  ly camera intrin
-000123e0: 7369 6373 0a20 2020 2020 2020 2048 4820  sics.        HH 
-000123f0: 3d20 7365 6c66 2e4b 2040 2048 4820 4020  = self.K @ HH @ 
-00012400: 6e70 2e6c 696e 616c 672e 696e 7628 7365  np.linalg.inv(se
-00012410: 6c66 2e4b 290a 0a20 2020 2020 2020 2072  lf.K)..        r
-00012420: 6574 7572 6e20 4848 202f 2048 485b 322c  eturn HH / HH[2,
-00012430: 2032 5d20 2023 206e 6f72 6d61 6c69 7365   2]  # normalise
-00012440: 640a 0a20 2020 2040 7374 6174 6963 6d65  d..    @staticme
-00012450: 7468 6f64 0a20 2020 2064 6566 2070 6f69  thod.    def poi
-00012460: 6e74 7332 4828 7031 2c20 7032 2c20 6d65  nts2H(p1, p2, me
-00012470: 7468 6f64 3d27 6c65 6173 7473 7175 6172  thod='leastsquar
-00012480: 6573 272c 2073 6565 643d 4e6f 6e65 2c20  es', seed=None, 
-00012490: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
-000124a0: 2020 2022 2222 0a20 2020 2020 2020 2045     """.        E
-000124b0: 7374 696d 6174 6520 686f 6d6f 6772 6170  stimate homograp
-000124c0: 6879 2066 726f 6d20 636f 7272 6573 706f  hy from correspo
-000124d0: 6e64 696e 6720 706f 696e 7473 0a0a 2020  nding points..  
-000124e0: 2020 2020 2020 3a70 6172 616d 2070 313a        :param p1:
-000124f0: 2069 6d61 6765 2070 6c61 6e65 2070 6f69   image plane poi
-00012500: 6e74 7320 6672 6f6d 2066 6972 7374 2063  nts from first c
-00012510: 616d 6572 610a 2020 2020 2020 2020 3a74  amera.        :t
-00012520: 7970 6520 7031 3a20 6e64 6172 7261 7928  ype p1: ndarray(
-00012530: 322c 4e29 0a20 2020 2020 2020 203a 7061  2,N).        :pa
-00012540: 7261 6d20 7032 3a20 696d 6167 6520 706c  ram p2: image pl
-00012550: 616e 6520 706f 696e 7473 2066 726f 6d20  ane points from 
-00012560: 7365 636f 6e64 2063 616d 6572 610a 2020  second camera.  
-00012570: 2020 2020 2020 3a74 7970 6520 7032 3a20        :type p2: 
-00012580: 6e64 6172 7261 7928 322c 4e29 0a20 2020  ndarray(2,N).   
-00012590: 2020 2020 203a 7061 7261 6d20 6d65 7468       :param meth
-000125a0: 6f64 3a20 616c 676f 7269 7468 6d3a 2027  od: algorithm: '
-000125b0: 6c65 6173 7473 7175 6172 6573 2720 5b64  leastsquares' [d
-000125c0: 6566 6175 6c74 5d2c 2027 7261 6e73 6163  efault], 'ransac
-000125d0: 272c 2027 6c6d 6564 7327 2c20 2770 726f  ', 'lmeds', 'pro
-000125e0: 7361 6327 0a20 2020 2020 2020 203a 7479  sac'.        :ty
-000125f0: 7065 206d 6574 686f 643a 2073 7472 0a20  pe method: str. 
-00012600: 2020 2020 2020 203a 7061 7261 6d20 6b77         :param kw
-00012610: 6172 6773 3a20 6f70 7469 6f6e 616c 2061  args: optional a
-00012620: 7267 756d 656e 7473 2061 7320 7265 7175  rguments as requ
-00012630: 6972 6564 2066 6f72 2072 616e 7361 6327  ired for ransac'
-00012640: 2061 6e64 2027 6c6d 6564 7327 0a20 2020   and 'lmeds'.   
-00012650: 2020 2020 2020 2020 206d 6574 686f 6473           methods
-00012660: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
-00012670: 3a20 686f 6d6f 6772 6170 6879 2c20 7265  : homography, re
-00012680: 7369 6475 616c 2061 6e64 206f 7074 696f  sidual and optio
-00012690: 6e61 6c20 696e 6c69 6572 730a 2020 2020  nal inliers.    
-000126a0: 2020 2020 3a72 7479 7065 3a20 6e64 6172      :rtype: ndar
-000126b0: 7261 7928 332c 3329 2c20 666c 6f61 742c  ray(3,3), float,
-000126c0: 206e 6461 7272 6179 284e 2c62 6f6f 6c29   ndarray(N,bool)
-000126d0: 0a0a 2020 2020 2020 2020 436f 6d70 7574  ..        Comput
-000126e0: 6520 6120 686f 6d6f 6772 6170 6879 2066  e a homography f
-000126f0: 726f 6d20 7477 6f20 7365 7473 206f 6620  rom two sets of 
-00012700: 636f 7272 6573 706f 6e64 696e 6720 696d  corresponding im
-00012710: 6167 6520 706c 616e 6520 706f 696e 7473  age plane points
-00012720: 0a20 2020 2020 2020 2077 686f 7365 2077  .        whose w
-00012730: 6f72 6c64 2070 6f69 6e74 7320 6c69 6520  orld points lie 
-00012740: 6f6e 2061 2070 6c61 6e65 2e0a 0a20 2020  on a plane...   
-00012750: 2020 2020 2045 7861 6d70 6c65 3a0a 0a20       Example:.. 
-00012760: 2020 2020 2020 202e 2e20 7275 6e62 6c6f         .. runblo
-00012770: 636b 3a3a 2070 7963 6f6e 0a0a 2020 2020  ck:: pycon..    
-00012780: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-00012790: 206d 6163 6869 6e65 7669 7369 6f6e 746f   machinevisionto
-000127a0: 6f6c 626f 7820 696d 706f 7274 2043 656e  olbox import Cen
-000127b0: 7472 616c 4361 6d65 7261 2c20 6d6b 6772  tralCamera, mkgr
-000127c0: 6964 0a20 2020 2020 2020 2020 2020 203e  id.            >
-000127d0: 3e3e 2066 726f 6d20 7370 6174 6961 6c6d  >> from spatialm
-000127e0: 6174 6820 696d 706f 7274 2053 4533 0a20  ath import SE3. 
-000127f0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-00012800: 616d 6572 6131 203d 2043 656e 7472 616c  amera1 = Central
-00012810: 4361 6d65 7261 286e 616d 653d 2263 616d  Camera(name="cam
-00012820: 6572 6120 3122 2c20 663d 302e 3030 322c  era 1", f=0.002,
-00012830: 2069 6d61 6765 7369 7a65 3d31 3030 302c   imagesize=1000,
-00012840: 2072 686f 3d31 3065 2d36 2c20 706f 7365   rho=10e-6, pose
-00012850: 3d53 4533 2e54 7828 2d30 2e31 292a 5345  =SE3.Tx(-0.1)*SE
-00012860: 332e 5279 2830 2e34 2929 0a20 2020 2020  3.Ry(0.4)).     
-00012870: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
-00012880: 6132 203d 2043 656e 7472 616c 4361 6d65  a2 = CentralCame
-00012890: 7261 286e 616d 653d 2263 616d 6572 6120  ra(name="camera 
-000128a0: 3222 2c20 663d 302e 3030 322c 2069 6d61  2", f=0.002, ima
-000128b0: 6765 7369 7a65 3d31 3030 302c 2072 686f  gesize=1000, rho
-000128c0: 3d31 3065 2d36 2c20 706f 7365 3d53 4533  =10e-6, pose=SE3
-000128d0: 2e54 7828 302e 3129 2a53 4533 2e52 7928  .Tx(0.1)*SE3.Ry(
-000128e0: 2d30 2e34 2929 0a20 2020 2020 2020 2020  -0.4)).         
-000128f0: 2020 203e 3e3e 2054 5f67 7269 6420 3d20     >>> T_grid = 
-00012900: 5345 332e 547a 2831 2920 2a20 5345 332e  SE3.Tz(1) * SE3.
-00012910: 5278 2830 2e31 2920 2a20 5345 332e 5279  Rx(0.1) * SE3.Ry
-00012920: 2830 2e32 290a 2020 2020 2020 2020 2020  (0.2).          
-00012930: 2020 3e3e 3e20 5020 3d20 6d6b 6772 6964    >>> P = mkgrid
-00012940: 2833 2c20 312e 302c 2070 6f73 653d 545f  (3, 1.0, pose=T_
-00012950: 6772 6964 290a 2020 2020 2020 2020 2020  grid).          
-00012960: 2020 3e3e 3e20 7031 203d 2063 616d 6572    >>> p1 = camer
-00012970: 6131 2e70 726f 6a65 6374 5f70 6f69 6e74  a1.project_point
-00012980: 2850 290a 2020 2020 2020 2020 2020 2020  (P).            
-00012990: 3e3e 3e20 7032 203d 2063 616d 6572 6132  >>> p2 = camera2
-000129a0: 2e70 726f 6a65 6374 5f70 6f69 6e74 2850  .project_point(P
-000129b0: 293b 0a20 2020 2020 2020 2020 2020 203e  );.            >
-000129c0: 3e3e 2048 2c20 7265 7369 6420 3d20 4365  >> H, resid = Ce
-000129d0: 6e74 7261 6c43 616d 6572 612e 706f 696e  ntralCamera.poin
-000129e0: 7473 3248 2870 312c 2070 3229 0a20 2020  ts2H(p1, p2).   
-000129f0: 2020 2020 2020 2020 203e 3e3e 2048 0a20           >>> H. 
-00012a00: 2020 2020 2020 2020 2020 203e 3e3e 2072             >>> r
-00012a10: 6573 6964 0a0a 2020 2020 2020 2020 3a6e  esid..        :n
-00012a20: 6f74 653a 2049 6620 7468 6520 6d65 7468  ote: If the meth
-00012a30: 6f64 2069 7320 2772 616e 7361 6327 206f  od is 'ransac' o
-00012a40: 7220 276c 6d65 6473 2720 7468 656e 2061  r 'lmeds' then a
-00012a50: 2062 6f6f 6c65 616e 2061 7272 6179 0a20   boolean array. 
-00012a60: 2020 2020 2020 2020 2020 206f 6620 696e             of in
-00012a70: 6c69 6572 7320 6973 2061 6c73 6f20 7265  liers is also re
-00012a80: 7475 726e 6564 2c20 5472 7565 206d 6561  turned, True mea
-00012a90: 6e73 2074 6865 2063 6f72 7265 7370 6f6e  ns the correspon
-00012aa0: 6469 6e67 2069 6e70 7574 0a20 2020 2020  ding input.     
-00012ab0: 2020 2020 2020 2070 6f69 6e74 2070 6169         point pai
-00012ac0: 7220 6973 2061 6e20 696e 6c69 6572 2e0a  r is an inlier..
-00012ad0: 0a20 2020 2020 2020 203a 7265 6665 7265  .        :refere
-00012ae0: 6e63 653a 0a20 2020 2020 2020 2020 2020  nce:.           
-00012af0: 202d 2052 6f62 6f74 6963 732c 2056 6973   - Robotics, Vis
-00012b00: 696f 6e20 2620 436f 6e74 726f 6c20 666f  ion & Control fo
-00012b10: 7220 5079 7468 6f6e 2c20 5365 6374 696f  r Python, Sectio
-00012b20: 6e20 3134 2e32 2e34 2c20 502e 2043 6f72  n 14.2.4, P. Cor
-00012b30: 6b65 2c20 0a20 2020 2020 2020 2020 2020  ke, .           
-00012b40: 2020 2053 7072 696e 6765 7220 3230 3233     Springer 2023
-00012b50: 2e0a 0a20 2020 2020 2020 203a 7365 6561  ...        :seea
-00012b60: 6c73 6f3a 203a 6d65 7468 3a60 4860 203a  lso: :meth:`H` :
-00012b70: 6d65 7468 3a60 6465 636f 6d70 6f73 6548  meth:`decomposeH
-00012b80: 6020 0a20 2020 2020 2020 2020 2020 2060  ` .            `
-00012b90: 6f70 656e 6376 2e66 696e 6448 6f6d 6f67  opencv.findHomog
-00012ba0: 7261 7068 7920 3c68 7474 7073 3a2f 2f64  raphy <https://d
-00012bb0: 6f63 732e 6f70 656e 6376 2e6f 7267 2f6d  ocs.opencv.org/m
-00012bc0: 6173 7465 722f 6439 2f64 3063 2f67 726f  aster/d9/d0c/gro
-00012bd0: 7570 5f5f 6361 6c69 6233 642e 6874 6d6c  up__calib3d.html
-00012be0: 2367 6134 6162 6332 6563 6539 6661 6239  #ga4abc2ece9fab9
-00012bf0: 3339 3866 3265 3536 3064 3533 6338 6339  398f2e560d53c8c9
-00012c00: 3738 303e 605f 0a20 2020 2020 2020 2022  780>`_.        "
-00012c10: 2222 0a0a 2020 2020 2020 2020 706f 696e  ""..        poin
-00012c20: 7473 3248 5f64 6963 7420 3d20 7b0a 2020  ts2H_dict = {.  
-00012c30: 2020 2020 2020 2020 2020 276c 6561 7374            'least
-00012c40: 7371 7561 7265 7327 3a20 302c 0a20 2020  squares': 0,.   
-00012c50: 2020 2020 2020 2020 2027 7261 6e73 6163           'ransac
-00012c60: 273a 2063 762e 5241 4e53 4143 2c0a 2020  ': cv.RANSAC,.  
-00012c70: 2020 2020 2020 2020 2020 276c 6d65 6473            'lmeds
-00012c80: 273a 2063 762e 4c4d 4544 532c 0a20 2020  ': cv.LMEDS,.   
-00012c90: 2020 2020 2020 2020 2027 7072 6f73 6163           'prosac
-00012ca0: 273a 2063 762e 5248 4f20 0a20 2020 2020  ': cv.RHO .     
-00012cb0: 2020 207d 0a20 2020 2020 2020 2069 6620     }.        if 
-00012cc0: 7365 6564 2069 7320 6e6f 7420 4e6f 6e65  seed is not None
-00012cd0: 3a0a 2020 2020 2020 2020 2020 2020 6376  :.            cv
-00012ce0: 2e73 6574 524e 4753 6565 6428 7365 6564  .setRNGSeed(seed
-00012cf0: 290a 0a20 2020 2020 2020 2048 2c20 6d61  )..        H, ma
-00012d00: 736b 203d 2063 762e 6669 6e64 486f 6d6f  sk = cv.findHomo
-00012d10: 6772 6170 6879 280a 2020 2020 2020 2020  graphy(.        
-00012d20: 2020 2020 7372 6350 6f69 6e74 733d 7031      srcPoints=p1
-00012d30: 2e54 2c0a 2020 2020 2020 2020 2020 2020  .T,.            
-00012d40: 6473 7450 6f69 6e74 733d 7032 2e54 2c0a  dstPoints=p2.T,.
-00012d50: 2020 2020 2020 2020 2020 2020 6d65 7468              meth
-00012d60: 6f64 3d70 6f69 6e74 7332 485f 6469 6374  od=points2H_dict
-00012d70: 5b6d 6574 686f 645d 2c0a 2020 2020 2020  [method],.      
-00012d80: 2020 2020 2020 2a2a 6b77 6172 6773 290a        **kwargs).
-00012d90: 0a20 2020 2020 2020 206d 6173 6b20 3d20  .        mask = 
-00012da0: 6d61 736b 2e72 6176 656c 2829 2e61 7374  mask.ravel().ast
-00012db0: 7970 6528 6e70 2e62 6f6f 6c29 0a20 2020  ype(np.bool).   
-00012dc0: 2020 2020 2065 203d 2062 6173 652e 686f       e = base.ho
-00012dd0: 6d74 7261 6e73 2848 2c20 7031 5b3a 2c20  mtrans(H, p1[:, 
-00012de0: 6d61 736b 5d29 202d 2070 325b 3a2c 206d  mask]) - p2[:, m
-00012df0: 6173 6b5d 0a20 2020 2020 2020 2072 6573  ask].        res
-00012e00: 6964 203d 206e 702e 6c69 6e61 6c67 2e6e  id = np.linalg.n
-00012e10: 6f72 6d28 6529 0a0a 2020 2020 2020 2020  orm(e)..        
-00012e20: 6966 206d 6574 686f 6420 696e 2028 2772  if method in ('r
-00012e30: 616e 7361 6327 2c20 276c 6d65 6473 2729  ansac', 'lmeds')
-00012e40: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00012e50: 7475 726e 2048 2c20 7265 7369 642c 206d  turn H, resid, m
-00012e60: 6173 6b0a 2020 2020 2020 2020 656c 7365  ask.        else
-00012e70: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00012e80: 7475 726e 2048 2c20 7265 7369 640a 0a20  turn H, resid.. 
-00012e90: 2020 2023 2068 7474 7073 3a2f 2f64 6f63     # https://doc
-00012ea0: 732e 6f70 656e 6376 2e6f 7267 2f33 2e31  s.opencv.org/3.1
-00012eb0: 2e30 2f64 392f 6430 632f 6772 6f75 705f  .0/d9/d0c/group_
-00012ec0: 5f63 616c 6962 3364 2e68 746d 6c23 6761  _calib3d.html#ga
-00012ed0: 3766 3630 6264 6666 3738 3833 3364 3165  7f60bdff78833d1e
-00012ee0: 3366 6436 6439 6430 6664 3533 3864 3932  3fd6d9d0fd538d92
-00012ef0: 0a20 2020 2064 6566 2064 6563 6f6d 706f  .    def decompo
-00012f00: 7365 4828 7365 6c66 2c20 482c 204b 3d4e  seH(self, H, K=N
-00012f10: 6f6e 6529 3a0a 2020 2020 2020 2020 2222  one):.        ""
-00012f20: 220a 2020 2020 2020 2020 4465 636f 6d70  ".        Decomp
-00012f30: 6f73 6520 686f 6d6f 6772 6170 6879 206d  ose homography m
-00012f40: 6174 7269 780a 0a20 2020 2020 2020 203a  atrix..        :
-00012f50: 7061 7261 6d20 483a 2068 6f6d 6f67 7261  param H: homogra
-00012f60: 7068 7920 6d61 7472 6978 0a20 2020 2020  phy matrix.     
-00012f70: 2020 203a 7479 7065 2048 3a20 6e64 6172     :type H: ndar
-00012f80: 7261 7928 332c 3329 0a20 2020 2020 2020  ray(3,3).       
-00012f90: 203a 7061 7261 6d20 4b3a 2063 616d 6572   :param K: camer
-00012fa0: 6120 696e 7472 696e 7369 6373 2c20 6465  a intrinsics, de
-00012fb0: 6661 756c 7473 2074 6f20 7061 7261 6d65  faults to parame
-00012fc0: 7465 7273 2066 726f 6d20 6f62 6a65 6374  ters from object
-00012fd0: 0a20 2020 2020 2020 203a 7479 7065 204b  .        :type K
-00012fe0: 3a20 6e64 6172 7261 7928 332c 3329 2c20  : ndarray(3,3), 
-00012ff0: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
-00013000: 203a 7265 7475 726e 3a20 6361 6d65 7261   :return: camera
-00013010: 2070 6f73 6573 2c20 706c 616e 6520 6e6f   poses, plane no
-00013020: 726d 616c 730a 2020 2020 2020 2020 3a72  rmals.        :r
-00013030: 7479 7065 3a20 3a63 6c61 7373 3a60 7e73  type: :class:`~s
-00013040: 7061 7469 616c 6d61 7468 2e2e 706f 7365  patialmath..pose
-00013050: 3364 2e53 4533 602c 206c 6973 7420 6f66  3d.SE3`, list of
-00013060: 206e 6461 7272 6179 2833 2c31 290a 0a20   ndarray(3,1).. 
-00013070: 2020 2020 2020 2044 6563 6f6d 706f 7365         Decompose
-00013080: 7320 7468 6520 686f 6d6f 6772 6170 6879  s the homography
-00013090: 206d 6174 7269 7820 696e 746f 2074 6865   matrix into the
-000130a0: 2063 616d 6572 6120 6d6f 7469 6f6e 2061   camera motion a
-000130b0: 6e64 2074 6865 206e 6f72 6d61 6c0a 2020  nd the normal.  
-000130c0: 2020 2020 2020 746f 2074 6865 2070 6c61        to the pla
-000130d0: 6e65 2e20 496e 2070 7261 6374 6963 652c  ne. In practice,
-000130e0: 2074 6865 7265 2061 7265 206d 756c 7469   there are multi
-000130f0: 706c 6520 736f 6c75 7469 6f6e 732e 2054  ple solutions. T
-00013100: 6865 2074 7261 6e73 6c61 7469 6f6e 0a20  he translation. 
-00013110: 2020 2020 2020 206e 6f74 2074 6f20 7363         not to sc
-00013120: 616c 652e 0a0a 2020 2020 2020 2020 4578  ale...        Ex
-00013130: 616d 706c 653a 0a0a 2020 2020 2020 2020  ample:..        
-00013140: 2e2e 2072 756e 626c 6f63 6b3a 3a20 7079  .. runblock:: py
-00013150: 636f 6e0a 0a20 2020 2020 2020 2020 2020  con..           
-00013160: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
-00013170: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
-00013180: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
-00013190: 6572 612c 206d 6b67 7269 640a 2020 2020  era, mkgrid.    
-000131a0: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-000131b0: 2073 7061 7469 616c 6d61 7468 2069 6d70   spatialmath imp
-000131c0: 6f72 7420 5345 330a 2020 2020 2020 2020  ort SE3.        
-000131d0: 2020 2020 3e3e 3e20 6361 6d65 7261 3120      >>> camera1 
-000131e0: 3d20 4365 6e74 7261 6c43 616d 6572 6128  = CentralCamera(
-000131f0: 6e61 6d65 3d22 6361 6d65 7261 2031 222c  name="camera 1",
-00013200: 2066 3d30 2e30 3032 2c20 696d 6167 6573   f=0.002, images
-00013210: 697a 653d 3130 3030 2c20 7268 6f3d 3130  ize=1000, rho=10
-00013220: 652d 362c 2070 6f73 653d 5345 332e 5478  e-6, pose=SE3.Tx
-00013230: 282d 302e 3129 2a53 4533 2e52 7928 302e  (-0.1)*SE3.Ry(0.
-00013240: 3429 290a 2020 2020 2020 2020 2020 2020  4)).            
-00013250: 3e3e 3e20 6361 6d65 7261 3220 3d20 4365  >>> camera2 = Ce
-00013260: 6e74 7261 6c43 616d 6572 6128 6e61 6d65  ntralCamera(name
-00013270: 3d22 6361 6d65 7261 2032 222c 2066 3d30  ="camera 2", f=0
-00013280: 2e30 3032 2c20 696d 6167 6573 697a 653d  .002, imagesize=
-00013290: 3130 3030 2c20 7268 6f3d 3130 652d 362c  1000, rho=10e-6,
-000132a0: 2070 6f73 653d 5345 332e 5478 2830 2e31   pose=SE3.Tx(0.1
-000132b0: 292a 5345 332e 5279 282d 302e 3429 290a  )*SE3.Ry(-0.4)).
-000132c0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-000132d0: 545f 6772 6964 203d 2053 4533 2e54 7a28  T_grid = SE3.Tz(
-000132e0: 3129 202a 2053 4533 2e52 7828 302e 3129  1) * SE3.Rx(0.1)
-000132f0: 202a 2053 4533 2e52 7928 302e 3229 0a20   * SE3.Ry(0.2). 
-00013300: 2020 2020 2020 2020 2020 203e 3e3e 2050             >>> P
-00013310: 203d 206d 6b67 7269 6428 332c 2031 2e30   = mkgrid(3, 1.0
-00013320: 2c20 706f 7365 3d54 5f67 7269 6429 0a20  , pose=T_grid). 
-00013330: 2020 2020 2020 2020 2020 203e 3e3e 2070             >>> p
-00013340: 3120 3d20 6361 6d65 7261 312e 7072 6f6a  1 = camera1.proj
-00013350: 6563 745f 706f 696e 7428 5029 0a20 2020  ect_point(P).   
-00013360: 2020 2020 2020 2020 203e 3e3e 2070 3220           >>> p2 
-00013370: 3d20 6361 6d65 7261 322e 7072 6f6a 6563  = camera2.projec
-00013380: 745f 706f 696e 7428 5029 3b0a 2020 2020  t_point(P);.    
-00013390: 2020 2020 2020 2020 3e3e 3e20 482c 2072          >>> H, r
-000133a0: 6573 6964 203d 2043 656e 7472 616c 4361  esid = CentralCa
-000133b0: 6d65 7261 2e70 6f69 6e74 7332 4828 7031  mera.points2H(p1
-000133c0: 2c20 7032 290a 2020 2020 2020 2020 2020  , p2).          
-000133d0: 2020 3e3e 3e20 542c 206e 6f72 6d61 6c73    >>> T, normals
-000133e0: 203d 2063 616d 6572 6131 2e64 6563 6f6d   = camera1.decom
-000133f0: 706f 7365 4828 4829 0a20 2020 2020 2020  poseH(H).       
-00013400: 2020 2020 203e 3e3e 2054 2e70 7269 6e74       >>> T.print
-00013410: 6c69 6e65 286f 7269 656e 743d 2263 616d  line(orient="cam
-00013420: 6572 6122 290a 2020 2020 2020 2020 2020  era").          
-00013430: 2020 3e3e 3e20 6e6f 726d 616c 730a 0a20    >>> normals.. 
-00013440: 2020 2020 2020 203a 7265 6665 7265 6e63         :referenc
-00013450: 653a 0a20 2020 2020 2020 2020 2020 202d  e:.            -
-00013460: 2052 6f62 6f74 6963 732c 2056 6973 696f   Robotics, Visio
-00013470: 6e20 2620 436f 6e74 726f 6c20 666f 7220  n & Control for 
-00013480: 5079 7468 6f6e 2c20 5365 6374 696f 6e20  Python, Section 
-00013490: 3134 2e32 2e34 2c20 502e 2043 6f72 6b65  14.2.4, P. Corke
-000134a0: 2c20 0a20 2020 2020 2020 2020 2020 2020  , .             
-000134b0: 2053 7072 696e 6765 7220 3230 3233 2e0a   Springer 2023..
-000134c0: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
-000134d0: 6f3a 203a 6d65 7468 3a60 706f 696e 7473  o: :meth:`points
-000134e0: 3248 6020 3a6d 6574 683a 6048 600a 2020  2H` :meth:`H`.  
-000134f0: 2020 2020 2020 2020 2020 606f 7065 6e63            `openc
-00013500: 762e 6465 636f 6d70 6f73 6548 6f6d 6f67  v.decomposeHomog
-00013510: 7261 7068 794d 6174 203c 6874 7470 733a  raphyMat <https:
-00013520: 2f2f 646f 6373 2e6f 7065 6e63 762e 6f72  //docs.opencv.or
-00013530: 672f 332e 342f 6439 2f64 3063 2f67 726f  g/3.4/d9/d0c/gro
-00013540: 7570 5f5f 6361 6c69 6233 642e 6874 6d6c  up__calib3d.html
-00013550: 2367 6137 6636 3062 6466 6637 3838 3333  #ga7f60bdff78833
-00013560: 6431 6533 6664 3664 3964 3066 6435 3338  d1e3fd6d9d0fd538
-00013570: 6439 323e 605f 0a20 2020 2020 2020 2022  d92>`_.        "
-00013580: 2222 0a0a 2020 2020 2020 2020 7265 7476  ""..        retv
-00013590: 616c 2c20 726f 7461 7469 6f6e 732c 2074  al, rotations, t
-000135a0: 7261 6e73 6c61 7469 6f6e 732c 206e 6f72  ranslations, nor
-000135b0: 6d61 6c73 203d 2063 762e 6465 636f 6d70  mals = cv.decomp
-000135c0: 6f73 6548 6f6d 6f67 7261 7068 794d 6174  oseHomographyMat
-000135d0: 2848 2c20 7365 6c66 2e4b 290a 0a20 2020  (H, self.K)..   
-000135e0: 2020 2020 2054 203d 2053 4533 2e45 6d70       T = SE3.Emp
-000135f0: 7479 2829 0a20 2020 2020 2020 2066 6f72  ty().        for
-00013600: 2052 2c20 7420 696e 207a 6970 2872 6f74   R, t in zip(rot
-00013610: 6174 696f 6e73 2c20 7472 616e 736c 6174  ations, translat
-00013620: 696f 6e73 293a 0a20 2020 2020 2020 2020  ions):.         
-00013630: 2020 2023 2077 6520 6e6f 726d 616c 697a     # we normaliz
-00013640: 6520 7468 6520 726f 7461 7469 6f6e 206d  e the rotation m
-00013650: 6174 7269 782c 2074 686f 7365 2072 6574  atrix, those ret
-00013660: 7572 6e65 6420 6279 206f 7065 6e43 5620  urned by openCV 
-00013670: 6361 6e0a 2020 2020 2020 2020 2020 2020  can.            
-00013680: 2320 6e6f 7420 7175 6974 6520 7072 6f70  # not quite prop
-00013690: 6572 2053 4f28 3329 2076 616c 7565 730a  er SO(3) values.
-000136a0: 2020 2020 2020 2020 2020 2020 706f 7365              pose
-000136b0: 203d 2053 4533 2e52 7428 736d 6261 7365   = SE3.Rt(smbase
-000136c0: 2e74 726e 6f72 6d28 5229 2c20 7429 2e69  .trnorm(R), t).i
-000136d0: 6e76 2829 0a20 2020 2020 2020 2020 2020  nv().           
-000136e0: 2054 2e61 7070 656e 6428 706f 7365 290a   T.append(pose).
-000136f0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00013700: 2c20 6e6f 726d 616c 730a 0a20 2020 2020  , normals..     
-00013710: 2020 2023 2069 6620 4b20 6973 204e 6f6e     # if K is Non
-00013720: 653a 0a20 2020 2020 2020 2023 2020 2020  e:.        #    
-00013730: 204b 203d 206e 702e 6964 656e 7469 7479   K = np.identity
-00013740: 2833 290a 2020 2020 2020 2020 2320 2020  (3).        #   
-00013750: 2020 2320 616c 736f 2068 6176 6520 4b20    # also have K 
-00013760: 3d20 7365 6c66 2e4b 0a0a 2020 2020 2020  = self.K..      
-00013770: 2020 2320 4820 3d20 6e70 2e6c 696e 616c    # H = np.linal
-00013780: 672e 696e 7628 4b29 2040 2048 2040 204b  g.inv(K) @ H @ K
-00013790: 0a0a 2020 2020 2020 2020 2320 2320 6e6f  ..        # # no
-000137a0: 726d 616c 6973 6520 736f 2074 6861 7420  rmalise so that 
-000137b0: 7468 6520 7365 636f 6e64 2073 696e 6775  the second singu
-000137c0: 6c61 7220 7661 6c75 6520 6973 206f 6e65  lar value is one
-000137d0: 0a20 2020 2020 2020 2023 2055 2c20 532c  .        # U, S,
-000137e0: 2056 203d 206e 702e 6c69 6e61 6c67 2e73   V = np.linalg.s
-000137f0: 7664 2848 2c20 636f 6d70 7574 655f 7576  vd(H, compute_uv
-00013800: 3d54 7275 6529 0a20 2020 2020 2020 2023  =True).        #
-00013810: 2048 203d 2048 202f 2053 5b31 5d0a 0a20   H = H / S[1].. 
-00013820: 2020 2020 2020 2023 2023 2063 6f6d 7075         # # compu
-00013830: 7465 2074 6865 2053 5644 206f 6620 7468  te the SVD of th
-00013840: 6520 7379 6d6d 6574 7269 6320 6d61 7472  e symmetric matr
-00013850: 6978 2048 272a 4820 3d20 5653 5627 0a20  ix H'*H = VSV'. 
-00013860: 2020 2020 2020 2023 2055 2c20 532c 2056         # U, S, V
-00013870: 203d 206e 702e 6c69 6e61 6c67 2e73 7664   = np.linalg.svd
-00013880: 286e 702e 7472 616e 7370 6f73 6528 4829  (np.transpose(H)
-00013890: 2040 2048 290a 0a20 2020 2020 2020 2023   @ H)..        #
-000138a0: 2023 2065 6e73 7572 6520 5620 6973 2072   # ensure V is r
-000138b0: 6967 6874 2d68 616e 6465 640a 2020 2020  ight-handed.    
-000138c0: 2020 2020 2320 6966 206e 702e 6c69 6e61      # if np.lina
-000138d0: 6c67 2e64 6574 2856 2920 3c20 303a 0a20  lg.det(V) < 0:. 
-000138e0: 2020 2020 2020 2023 2020 2020 2070 7269         #     pri
-000138f0: 6e74 2827 6465 7428 5629 2077 6173 203c  nt('det(V) was <
-00013900: 2030 2729 0a20 2020 2020 2020 2023 2020   0').        #  
-00013910: 2020 2056 203d 202d 560a 0a20 2020 2020     V = -V..     
-00013920: 2020 2023 2023 2067 6574 2073 7175 6172     # # get squar
-00013930: 6564 2073 696e 6775 6c61 7220 7661 6c75  ed singular valu
-00013940: 6573 0a20 2020 2020 2020 2023 2073 3020  es.        # s0 
-00013950: 3d20 535b 305d 0a20 2020 2020 2020 2023  = S[0].        #
-00013960: 2073 3220 3d20 535b 325d 0a0a 2020 2020   s2 = S[2]..    
-00013970: 2020 2020 2320 2320 7630 203d 2056 5b30      # # v0 = V[0
-00013980: 3a2c 2030 5d0a 2020 2020 2020 2020 2320  :, 0].        # 
-00013990: 2320 7631 203d 2056 5b30 3a2c 2031 5d0a  # v1 = V[0:, 1].
-000139a0: 2020 2020 2020 2020 2320 2320 7632 203d          # # v2 =
-000139b0: 2056 5b30 3a2c 2032 5d0a 0a20 2020 2020   V[0:, 2]..     
-000139c0: 2020 2023 2023 2070 7572 6520 726f 7461     # # pure rota
-000139d0: 7469 6f6e 202d 2077 6865 7265 2061 6c6c  tion - where all
-000139e0: 2073 696e 6775 6c61 7220 7661 6c75 6573   singular values
-000139f0: 203d 3d20 310a 2020 2020 2020 2020 2320   == 1.        # 
-00013a00: 6966 206e 702e 6162 7328 7330 202d 2073  if np.abs(s0 - s
-00013a10: 3229 203c 2028 3130 3020 2a20 6e70 2e73  2) < (100 * np.s
-00013a20: 7061 6369 6e67 2831 2929 3a0a 2020 2020  pacing(1)):.    
-00013a30: 2020 2020 2320 2020 2020 7072 696e 7428      #     print(
-00013a40: 2757 6172 6e69 6e67 3a20 486f 6d6f 6772  'Warning: Homogr
-00013a50: 6170 6879 2064 7565 2074 6f20 7075 7265  aphy due to pure
-00013a60: 2072 6f74 6174 696f 6e27 290a 2020 2020   rotation').    
-00013a70: 2020 2020 2320 2020 2020 6966 206e 702e      #     if np.
-00013a80: 6c69 6e61 6c67 2e64 6574 2848 2920 3c20  linalg.det(H) < 
-00013a90: 303a 0a20 2020 2020 2020 2023 2020 2020  0:.        #    
-00013aa0: 2020 2020 2048 203d 202d 480a 2020 2020       H = -H.    
-00013ab0: 2020 2020 2320 2020 2020 2320 736f 6c20      #     # sol 
-00013ac0: 3d20 6e61 6d65 6474 7570 6c65 2827 5427  = namedtuple('T'
-00013ad0: 2c20 542c 2027 270a 2020 2020 2020 2020  , T, ''.        
-00013ae0: 2320 2320 544f 444f 2066 696e 6973 6820  # # TODO finish 
-00013af0: 6672 6f6d 2069 6e76 686f 6d6f 672e 6d0a  from invhomog.m.
-00013b00: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
-00013b10: 2755 6e66 696e 6973 6865 6427 290a 2020  'Unfinished').  
-00013b20: 2020 2020 2020 2320 7265 7475 726e 2046        # return F
-00013b30: 616c 7365 0a0a 0a20 2020 2023 203d 3d3d  alse...    # ===
-00013b40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00013b50: 2066 756e 6461 6d65 6e74 616c 206d 6174   fundamental mat
-00013b60: 7269 7820 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  rix ============
-00013b70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00013b80: 3d3d 3d20 230a 0a20 2020 2064 6566 2046  === #..    def F
-00013b90: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
-00013ba0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00013bb0: 2020 2046 756e 6461 6d65 6e74 616c 206d     Fundamental m
-00013bc0: 6174 7269 780a 0a20 2020 2020 2020 203a  atrix..        :
-00013bd0: 7061 7261 6d20 6f74 6865 723a 2073 6563  param other: sec
-00013be0: 6f6e 6420 6361 6d65 7261 2076 6965 770a  ond camera view.
-00013bf0: 2020 2020 2020 2020 3a74 7970 6520 6f74          :type ot
-00013c00: 6865 723a 203a 636c 6173 733a 6043 656e  her: :class:`Cen
-00013c10: 7472 616c 4361 6d65 7261 602c 203a 636c  tralCamera`, :cl
-00013c20: 6173 733a 607e 7370 6174 6961 6c6d 6174  ass:`~spatialmat
-00013c30: 682e 2e70 6f73 6533 642e 5345 3360 0a20  h..pose3d.SE3`. 
-00013c40: 2020 2020 2020 203a 7265 7475 726e 3a20         :return: 
-00013c50: 6675 6e64 616d 656e 7461 6c20 6d61 7472  fundamental matr
-00013c60: 6978 0a20 2020 2020 2020 203a 7274 7970  ix.        :rtyp
-00013c70: 653a 206e 756d 7079 2833 2c33 290a 0a20  e: numpy(3,3).. 
-00013c80: 2020 2020 2020 2043 6f6d 7075 7465 2074         Compute t
-00013c90: 6865 2066 756e 6461 6d65 6e74 616c 206d  he fundamental m
-00013ca0: 6174 7269 7820 7265 6c61 7469 6e67 2074  atrix relating t
-00013cb0: 776f 2063 616d 6572 6120 7669 6577 732e  wo camera views.
-00013cc0: 2020 5468 650a 2020 2020 2020 2020 6669    The.        fi
-00013cd0: 7273 7420 7669 6577 2069 7320 6465 6669  rst view is defi
-00013ce0: 6e65 6420 6279 2074 6865 2069 6e73 7461  ned by the insta
-00013cf0: 6e63 652e 2020 5468 6520 7365 636f 6e64  nce.  The second
-00013d00: 0a20 2020 2020 2020 2069 7320 6465 6669  .        is defi
-00013d10: 6e65 6420 6279 3a0a 2020 2020 2020 2020  ned by:.        
-00013d20: 0a20 2020 2020 2020 202a 2061 6e6f 7468  .        * anoth
-00013d30: 6572 203a 636c 6173 733a 6043 656e 7472  er :class:`Centr
-00013d40: 616c 4361 6d65 7261 6020 696e 7374 616e  alCamera` instan
-00013d50: 6365 0a20 2020 2020 2020 202a 2061 6e20  ce.        * an 
-00013d60: 5345 3320 706f 7365 2064 6573 6372 6962  SE3 pose describ
-00013d70: 696e 6720 7468 6520 706f 7365 206f 6620  ing the pose of 
-00013d80: 7468 6520 7365 636f 6e64 2076 6965 7720  the second view 
-00013d90: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
-00013da0: 0a20 2020 2020 2020 2020 2074 6865 2066  .          the f
-00013db0: 6972 7374 2c20 6173 7375 6d69 6e67 2074  irst, assuming t
-00013dc0: 6865 2073 616d 6520 6361 6d65 7261 2069  he same camera i
-00013dd0: 6e74 7269 6e73 6963 2070 6172 616d 6574  ntrinsic paramet
-00013de0: 6572 732e 0a0a 2020 2020 2020 2020 4578  ers...        Ex
-00013df0: 616d 706c 653a 0a0a 2020 2020 2020 2020  ample:..        
-00013e00: 2e2e 2072 756e 626c 6f63 6b3a 3a20 7079  .. runblock:: py
-00013e10: 636f 6e0a 0a20 2020 2020 2020 2020 2020  con..           
-00013e20: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
-00013e30: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
-00013e40: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
-00013e50: 6572 610a 2020 2020 2020 2020 2020 2020  era.            
-00013e60: 3e3e 3e20 6672 6f6d 2073 7061 7469 616c  >>> from spatial
-00013e70: 6d61 7468 2069 6d70 6f72 7420 5345 330a  math import SE3.
-00013e80: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00013e90: 6361 6d65 7261 3120 3d20 4365 6e74 7261  camera1 = Centra
-00013ea0: 6c43 616d 6572 6128 6e61 6d65 3d22 6361  lCamera(name="ca
-00013eb0: 6d65 7261 2031 222c 2066 3d30 2e30 3032  mera 1", f=0.002
-00013ec0: 2c20 696d 6167 6573 697a 653d 3130 3030  , imagesize=1000
-00013ed0: 2c20 7268 6f3d 3130 652d 362c 2070 6f73  , rho=10e-6, pos
-00013ee0: 653d 5345 332e 5478 282d 302e 3129 2a53  e=SE3.Tx(-0.1)*S
-00013ef0: 4533 2e52 7928 302e 3429 290a 2020 2020  E3.Ry(0.4)).    
-00013f00: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-00013f10: 7261 3220 3d20 4365 6e74 7261 6c43 616d  ra2 = CentralCam
-00013f20: 6572 6128 6e61 6d65 3d22 6361 6d65 7261  era(name="camera
-00013f30: 2032 222c 2066 3d30 2e30 3032 2c20 696d   2", f=0.002, im
-00013f40: 6167 6573 697a 653d 3130 3030 2c20 7268  agesize=1000, rh
-00013f50: 6f3d 3130 652d 362c 2070 6f73 653d 5345  o=10e-6, pose=SE
-00013f60: 332e 5478 2830 2e31 292a 5345 332e 5279  3.Tx(0.1)*SE3.Ry
-00013f70: 282d 302e 3429 290a 2020 2020 2020 2020  (-0.4)).        
-00013f80: 2020 2020 3e3e 3e20 4620 3d20 6361 6d65      >>> F = came
-00013f90: 7261 312e 4628 6361 6d65 7261 3229 0a20  ra1.F(camera2). 
-00013fa0: 2020 2020 2020 2020 2020 203e 3e3e 2046             >>> F
-00013fb0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00013fc0: 2046 203d 2063 616d 6572 6131 2e46 2853   F = camera1.F(S
-00013fd0: 4533 2e54 7828 302e 3229 290a 2020 2020  E3.Tx(0.2)).    
-00013fe0: 2020 2020 2020 2020 3e3e 3e20 460a 0a20          >>> F.. 
-00013ff0: 2020 2020 2020 203a 7265 6665 7265 6e63         :referenc
-00014000: 653a 0a20 2020 2020 2020 2020 2020 202d  e:.            -
-00014010: 2059 2e4d 612c 204a 2e4b 6f73 6563 6b61   Y.Ma, J.Kosecka
-00014020: 2c20 532e 536f 6174 746f 2c20 532e 5361  , S.Soatto, S.Sa
-00014030: 7374 7279 2c20 2241 6e20 696e 7669 7461  stry, "An invita
-00014040: 7469 6f6e 2074 6f20 3344 222c 0a20 2020  tion to 3D",.   
-00014050: 2020 2020 2020 2020 2020 2053 7072 696e             Sprin
-00014060: 6765 722c 2032 3030 332e 2070 2e31 3737  ger, 2003. p.177
-00014070: 0a20 2020 2020 2020 2020 2020 202d 2052  .            - R
-00014080: 6f62 6f74 6963 732c 2056 6973 696f 6e20  obotics, Vision 
-00014090: 2620 436f 6e74 726f 6c20 666f 7220 5079  & Control for Py
-000140a0: 7468 6f6e 2c20 5365 6374 696f 6e20 3134  thon, Section 14
-000140b0: 2e32 2e31 2c20 502e 2043 6f72 6b65 2c20  .2.1, P. Corke, 
-000140c0: 0a20 2020 2020 2020 2020 2020 2020 2053  .              S
-000140d0: 7072 696e 6765 7220 3230 3233 2e0a 2020  pringer 2023..  
-000140e0: 2020 2020 2020 0a20 2020 2020 2020 203a        .        :
-000140f0: 7365 6561 6c73 6f3a 203a 6d65 7468 3a60  seealso: :meth:`
-00014100: 706f 696e 7473 3246 6020 3a6d 6574 683a  points2F` :meth:
-00014110: 6045 600a 2020 2020 2020 2020 2222 220a  `E`.        """.
-00014120: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-00014130: 7374 616e 6365 286f 7468 6572 2c20 5345  stance(other, SE
-00014140: 3329 3a0a 2020 2020 2020 2020 2020 2020  3):.            
-00014150: 4520 3d20 7365 6c66 2e45 286f 7468 6572  E = self.E(other
-00014160: 290a 2020 2020 2020 2020 2020 2020 4b20  ).            K 
-00014170: 3d20 7365 6c66 2e4b 0a20 2020 2020 2020  = self.K.       
-00014180: 2020 2020 2072 6574 7572 6e20 6e70 2e6c       return np.l
-00014190: 696e 616c 672e 696e 7628 4b29 2e54 2040  inalg.inv(K).T @
-000141a0: 2045 2040 206e 702e 6c69 6e61 6c67 2e69   E @ np.linalg.i
-000141b0: 6e76 284b 290a 0a20 2020 2020 2020 2065  nv(K)..        e
-000141c0: 6c69 6620 6973 696e 7374 616e 6365 286f  lif isinstance(o
-000141d0: 7468 6572 2c20 4365 6e74 7261 6c43 616d  ther, CentralCam
-000141e0: 6572 6129 3a0a 2020 2020 2020 2020 2020  era):.          
-000141f0: 2020 2320 7573 6520 7265 6c61 7469 7665    # use relative
-00014200: 2070 6f73 6520 616e 6420 6361 6d65 7261   pose and camera
-00014210: 2070 6172 616d 6574 6572 7320 6f66 200a   parameters of .
-00014220: 2020 2020 2020 2020 2020 2020 4520 3d20              E = 
-00014230: 7365 6c66 2e45 286f 7468 6572 290a 2020  self.E(other).  
-00014240: 2020 2020 2020 2020 2020 4b31 203d 2073            K1 = s
-00014250: 656c 662e 4b0a 2020 2020 2020 2020 2020  elf.K.          
-00014260: 2020 4b32 203d 206f 7468 6572 2e4b 0a20    K2 = other.K. 
-00014270: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00014280: 6e20 6e70 2e6c 696e 616c 672e 696e 7628  n np.linalg.inv(
-00014290: 4b32 292e 5420 4020 4520 4020 6e70 2e6c  K2).T @ E @ np.l
-000142a0: 696e 616c 672e 696e 7628 4b31 290a 0a20  inalg.inv(K1).. 
-000142b0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-000142c0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-000142d0: 616c 7565 4572 726f 7228 2762 6164 2074  alueError('bad t
-000142e0: 7970 6527 290a 0a20 2020 2040 7374 6174  ype')..    @stat
-000142f0: 6963 6d65 7468 6f64 0a20 2020 2064 6566  icmethod.    def
-00014300: 2070 6f69 6e74 7332 4628 0a20 2020 2020   points2F(.     
-00014310: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00014320: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
-00014330: 2020 2020 2020 2070 322c 0a20 2020 2020         p2,.     
-00014340: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00014350: 6574 686f 643d 2738 7027 2c0a 2020 2020  ethod='8p',.    
-00014360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014370: 7265 7369 6475 616c 3d54 7275 652c 0a20  residual=True,. 
-00014380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014390: 2020 2073 6565 643d 4e6f 6e65 2c0a 2020     seed=None,.  
-000143a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000143b0: 2020 2a2a 6b77 6172 6773 293a 0a20 2020    **kwargs):.   
-000143c0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000143d0: 2045 7374 696d 6174 6520 6675 6e64 616d   Estimate fundam
-000143e0: 656e 7461 6c20 6d61 7472 6978 2066 726f  ental matrix fro
-000143f0: 6d20 636f 7272 6573 706f 6e64 696e 6720  m corresponding 
-00014400: 706f 696e 7473 0a0a 2020 2020 2020 2020  points..        
-00014410: 3a70 6172 616d 2070 313a 2069 6d61 6765  :param p1: image
-00014420: 2070 6c61 6e65 2070 6f69 6e74 7320 6672   plane points fr
-00014430: 6f6d 2066 6972 7374 2063 616d 6572 610a  om first camera.
-00014440: 2020 2020 2020 2020 3a74 7970 6520 7031          :type p1
-00014450: 3a20 6e64 6172 7261 7928 322c 4e29 0a20  : ndarray(2,N). 
-00014460: 2020 2020 2020 203a 7061 7261 6d20 7032         :param p2
-00014470: 3a20 696d 6167 6520 706c 616e 6520 706f  : image plane po
-00014480: 696e 7473 2066 726f 6d20 7365 636f 6e64  ints from second
-00014490: 2063 616d 6572 610a 2020 2020 2020 2020   camera.        
-000144a0: 3a74 7970 6520 7032 3a20 6e64 6172 7261  :type p2: ndarra
-000144b0: 7928 322c 4e29 0a20 2020 2020 2020 203a  y(2,N).        :
-000144c0: 7061 7261 6d20 6d65 7468 6f64 3a20 616c  param method: al
-000144d0: 676f 7269 7468 6d20 2737 7027 2c20 2738  gorithm '7p', '8
-000144e0: 7027 205b 6465 6661 756c 745d 2c20 2772  p' [default], 'r
-000144f0: 616e 7361 6327 2c20 276c 6d65 6473 270a  ansac', 'lmeds'.
-00014500: 2020 2020 2020 2020 3a74 7970 6520 6d65          :type me
-00014510: 7468 6f64 3a20 7374 722c 206f 7074 696f  thod: str, optio
-00014520: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
-00014530: 616d 206b 7761 7267 733a 206f 7074 696f  am kwargs: optio
-00014540: 6e61 6c20 6172 6775 6d65 6e74 7320 6173  nal arguments as
-00014550: 2072 6571 7569 7265 6420 666f 7220 7261   required for ra
-00014560: 6e73 6163 272c 2027 6c6d 6564 7327 0a20  nsac', 'lmeds'. 
-00014570: 2020 2020 2020 2020 2020 206d 6574 686f             metho
-00014580: 6473 0a20 2020 2020 2020 203a 7265 7475  ds.        :retu
-00014590: 726e 3a20 6675 6e64 616d 656e 7461 6c20  rn: fundamental 
-000145a0: 6d61 7472 6978 2061 6e64 2072 6573 6964  matrix and resid
-000145b0: 7561 6c0a 2020 2020 2020 2020 3a72 7479  ual.        :rty
-000145c0: 7065 3a20 6e64 6172 7261 7928 332c 3329  pe: ndarray(3,3)
-000145d0: 2c20 666c 6f61 740a 0a20 2020 2020 2020  , float..       
-000145e0: 2043 6f6d 7075 7465 7320 7468 6520 6675   Computes the fu
-000145f0: 6e64 616d 656e 7461 6c20 6d61 7472 6978  ndamental matrix
-00014600: 2066 726f 6d20 7477 6f20 7365 7473 206f   from two sets o
-00014610: 6620 636f 7272 6573 706f 6e64 696e 670a  f corresponding.
-00014620: 2020 2020 2020 2020 696d 6167 652d 706c          image-pl
-00014630: 616e 6520 706f 696e 7473 2e20 436f 7272  ane points. Corr
-00014640: 6573 706f 6e64 696e 6720 706f 696e 7473  esponding points
-00014650: 2061 7265 2067 6976 656e 2062 7920 636f   are given by co
-00014660: 7272 6573 706f 6e64 696e 670a 2020 2020  rresponding.    
-00014670: 2020 2020 636f 6c75 6d6e 7320 6f66 2060      columns of `
-00014680: 6070 3160 6020 616e 6420 6060 7032 6060  `p1`` and ``p2``
-00014690: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
-000146a0: 6c65 3a0a 0a20 2020 2020 2020 202e 2e20  le:..        .. 
-000146b0: 7275 6e62 6c6f 636b 3a3a 2070 7963 6f6e  runblock:: pycon
-000146c0: 0a0a 2020 2020 2020 2020 2020 2020 3e3e  ..            >>
-000146d0: 3e20 6672 6f6d 206d 6163 6869 6e65 7669  > from machinevi
-000146e0: 7369 6f6e 746f 6f6c 626f 7820 696d 706f  siontoolbox impo
-000146f0: 7274 2043 656e 7472 616c 4361 6d65 7261  rt CentralCamera
-00014700: 2c20 6d6b 6772 6964 0a20 2020 2020 2020  , mkgrid.       
-00014710: 2020 2020 203e 3e3e 2066 726f 6d20 7370       >>> from sp
-00014720: 6174 6961 6c6d 6174 6820 696d 706f 7274  atialmath import
-00014730: 2053 4533 0a20 2020 2020 2020 2020 2020   SE3.           
-00014740: 203e 3e3e 2063 616d 6572 6131 203d 2043   >>> camera1 = C
-00014750: 656e 7472 616c 4361 6d65 7261 286e 616d  entralCamera(nam
-00014760: 653d 2263 616d 6572 6120 3122 2c20 663d  e="camera 1", f=
-00014770: 302e 3030 322c 2069 6d61 6765 7369 7a65  0.002, imagesize
-00014780: 3d31 3030 302c 2072 686f 3d31 3065 2d36  =1000, rho=10e-6
-00014790: 2c20 706f 7365 3d53 4533 2e54 7828 2d30  , pose=SE3.Tx(-0
-000147a0: 2e31 292a 5345 332e 5279 2830 2e34 2929  .1)*SE3.Ry(0.4))
-000147b0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-000147c0: 2063 616d 6572 6132 203d 2043 656e 7472   camera2 = Centr
-000147d0: 616c 4361 6d65 7261 286e 616d 653d 2263  alCamera(name="c
-000147e0: 616d 6572 6120 3222 2c20 663d 302e 3030  amera 2", f=0.00
-000147f0: 322c 2069 6d61 6765 7369 7a65 3d31 3030  2, imagesize=100
-00014800: 302c 2072 686f 3d31 3065 2d36 2c20 706f  0, rho=10e-6, po
-00014810: 7365 3d53 4533 2e54 7828 302e 3129 2a53  se=SE3.Tx(0.1)*S
-00014820: 4533 2e52 7928 2d30 2e34 2929 0a20 2020  E3.Ry(-0.4)).   
-00014830: 2020 2020 2020 2020 203e 3e3e 2054 5f67           >>> T_g
-00014840: 7269 6420 3d20 5345 332e 547a 2831 2920  rid = SE3.Tz(1) 
-00014850: 2a20 5345 332e 5278 2830 2e31 2920 2a20  * SE3.Rx(0.1) * 
-00014860: 5345 332e 5279 2830 2e32 290a 2020 2020  SE3.Ry(0.2).    
-00014870: 2020 2020 2020 2020 3e3e 3e20 5020 3d20          >>> P = 
-00014880: 6d6b 6772 6964 2833 2c20 312e 302c 2070  mkgrid(3, 1.0, p
-00014890: 6f73 653d 545f 6772 6964 290a 2020 2020  ose=T_grid).    
-000148a0: 2020 2020 2020 2020 3e3e 3e20 7031 203d          >>> p1 =
-000148b0: 2063 616d 6572 6131 2e70 726f 6a65 6374   camera1.project
-000148c0: 5f70 6f69 6e74 2850 290a 2020 2020 2020  _point(P).      
-000148d0: 2020 2020 2020 3e3e 3e20 7032 203d 2063        >>> p2 = c
-000148e0: 616d 6572 6132 2e70 726f 6a65 6374 5f70  amera2.project_p
-000148f0: 6f69 6e74 2850 293b 0a20 2020 2020 2020  oint(P);.       
-00014900: 2020 2020 203e 3e3e 2046 2c20 7265 7369       >>> F, resi
-00014910: 6420 3d20 4365 6e74 7261 6c43 616d 6572  d = CentralCamer
-00014920: 612e 706f 696e 7473 3246 2870 312c 2070  a.points2F(p1, p
-00014930: 3229 0a20 2020 2020 2020 2020 2020 203e  2).            >
-00014940: 3e3e 2046 0a20 2020 2020 2020 2020 2020  >> F.           
-00014950: 203e 3e3e 2072 6573 6964 0a0a 2020 2020   >>> resid..    
-00014960: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
-00014970: 6574 683a 6046 6020 3a6d 6574 683a 6045  eth:`F` :meth:`E
-00014980: 600a 2020 2020 2020 2020 2020 2020 606f  `.            `o
-00014990: 7065 6e63 762e 6669 6e64 4675 6e64 616d  pencv.findFundam
-000149a0: 656e 7461 6c4d 6174 203c 6874 7470 733a  entalMat <https:
-000149b0: 2f2f 646f 6373 2e6f 7065 6e63 762e 6f72  //docs.opencv.or
-000149c0: 672f 6d61 7374 6572 2f64 392f 6430 632f  g/master/d9/d0c/
-000149d0: 6772 6f75 705f 5f63 616c 6962 3364 2e68  group__calib3d.h
-000149e0: 746d 6c23 6761 3539 6230 6435 3766 3436  tml#ga59b0d57f46
-000149f0: 6638 3637 3766 6235 3930 3432 3934 6132  f8677fb5904294a2
-00014a00: 3364 3430 3461 3e60 5f0a 2020 2020 2020  3d404a>`_.      
-00014a10: 2020 2222 220a 2020 2020 2020 2020 0a20    """.        . 
-00014a20: 2020 2020 2020 2070 6f69 6e74 7332 465f         points2F_
-00014a30: 6469 6374 203d 207b 0a20 2020 2020 2020  dict = {.       
-00014a40: 2020 2020 2020 2020 2027 3770 273a 2063           '7p': c
-00014a50: 762e 464d 5f37 504f 494e 542c 0a20 2020  v.FM_7POINT,.   
-00014a60: 2020 2020 2020 2020 2020 2020 2027 3870               '8p
-00014a70: 273a 2063 762e 464d 5f38 504f 494e 542c  ': cv.FM_8POINT,
-00014a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014a90: 2027 7261 6e73 6163 273a 2063 762e 464d   'ransac': cv.FM
-00014aa0: 5f52 414e 5341 432c 0a20 2020 2020 2020  _RANSAC,.       
-00014ab0: 2020 2020 2020 2020 2027 6c6d 6564 7327           'lmeds'
-00014ac0: 3a20 6376 2e46 4d5f 4c4d 4544 537d 0a0a  : cv.FM_LMEDS}..
-00014ad0: 2020 2020 2020 2020 6966 2073 6565 6420          if seed 
-00014ae0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-00014af0: 2020 2020 2020 2020 2063 762e 7365 7452           cv.setR
-00014b00: 4e47 5365 6564 2873 6565 6429 0a0a 2020  NGSeed(seed)..  
-00014b10: 2020 2020 2020 462c 206d 6173 6b20 3d20        F, mask = 
-00014b20: 6376 2e66 696e 6446 756e 6461 6d65 6e74  cv.findFundament
-00014b30: 616c 4d61 7428 7031 2e54 2c20 7032 2e54  alMat(p1.T, p2.T
-00014b40: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00014b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b60: 2020 2020 2020 2020 2020 6d65 7468 6f64            method
-00014b70: 3d70 6f69 6e74 7332 465f 6469 6374 5b6d  =points2F_dict[m
-00014b80: 6574 686f 645d 2c0a 2020 2020 2020 2020  ethod],.        
-00014b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014bb0: 2a2a 6b77 6172 6773 290a 0a20 2020 2020  **kwargs)..     
-00014bc0: 2020 206d 6173 6b20 3d20 6d61 736b 2e72     mask = mask.r
-00014bd0: 6176 656c 2829 2e61 7374 7970 6528 6e70  avel().astype(np
-00014be0: 2e62 6f6f 6c29 0a0a 2020 2020 2020 2020  .bool)..        
-00014bf0: 2320 6164 6420 7661 7269 6f75 7320 7265  # add various re
-00014c00: 7475 726e 2076 616c 7565 730a 2020 2020  turn values.    
-00014c10: 2020 2020 7265 7476 616c 203d 205b 465d      retval = [F]
-00014c20: 0a20 2020 2020 2020 2069 6620 7265 7369  .        if resi
-00014c30: 6475 616c 3a0a 2020 2020 2020 2020 2020  dual:.          
-00014c40: 2020 6520 3d20 6261 7365 2e65 3268 2870    e = base.e2h(p
-00014c50: 325b 3a2c 206d 6173 6b5d 292e 5420 4020  2[:, mask]).T @ 
-00014c60: 4620 4020 6261 7365 2e65 3268 2870 315b  F @ base.e2h(p1[
-00014c70: 3a2c 206d 6173 6b5d 290a 2020 2020 2020  :, mask]).      
-00014c80: 2020 2020 2020 7265 7369 6420 3d20 6e70        resid = np
-00014c90: 2e6c 696e 616c 672e 6e6f 726d 286e 702e  .linalg.norm(np.
-00014ca0: 6469 6167 6f6e 616c 2865 2929 0a20 2020  diagonal(e)).   
-00014cb0: 2020 2020 2020 2020 2072 6574 7661 6c2e           retval.
-00014cc0: 6170 7065 6e64 2872 6573 6964 290a 2020  append(resid).  
-00014cd0: 2020 2020 2020 6966 206d 6574 686f 6420        if method 
-00014ce0: 696e 2028 2772 616e 7361 6327 2c20 276c  in ('ransac', 'l
-00014cf0: 6d65 6473 2729 3a0a 2020 2020 2020 2020  meds'):.        
-00014d00: 2020 2020 7265 7476 616c 2e61 7070 656e      retval.appen
-00014d10: 6428 6d61 736b 290a 0a20 2020 2020 2020  d(mask)..       
-00014d20: 2072 6574 7572 6e20 7265 7476 616c 0a20   return retval. 
-00014d30: 2020 2020 2020 2023 2065 6c69 6e65 7320         # elines 
-00014d40: 3d20 6261 7365 2e65 3268 2870 3229 2e54  = base.e2h(p2).T
-00014d50: 2040 2046 2023 2068 6f6d 6f67 206c 696e   @ F # homog lin
-00014d60: 6573 2c20 6f6e 6520 7065 7220 726f 770a  es, one per row.
-00014d70: 2020 2020 2020 2020 2320 7031 6820 3d20          # p1h = 
-00014d80: 6261 7365 2e65 3268 2870 3129 0a20 2020  base.e2h(p1).   
-00014d90: 2020 2020 2023 2072 6573 6964 7561 6c73       # residuals
-00014da0: 203d 205b 5d0a 2020 2020 2020 2020 2320   = [].        # 
-00014db0: 666f 7220 692c 206c 696e 6520 696e 2065  for i, line in e
-00014dc0: 6e75 6d65 7261 7465 2865 6c69 6e65 7329  numerate(elines)
-00014dd0: 3a0a 2020 2020 2020 2020 2320 2020 2020  :.        #     
-00014de0: 6420 3d20 6c69 6e65 2040 2070 3168 5b3a  d = line @ p1h[:
-00014df0: 2c20 695d 202f 206e 702e 7371 7274 286c  , i] / np.sqrt(l
-00014e00: 696e 655b 305d 202a 2a20 3220 2b20 6c69  ine[0] ** 2 + li
-00014e10: 6e65 5b31 5d20 2a2a 2032 290a 2020 2020  ne[1] ** 2).    
-00014e20: 2020 2020 2320 2020 2020 7265 7369 6475      #     residu
-00014e30: 616c 732e 6170 7065 6e64 2864 290a 2020  als.append(d).  
-00014e40: 2020 2020 2020 2320 7265 7369 6420 3d20        # resid = 
-00014e50: 6e70 2e61 7272 6179 2872 6573 6964 7561  np.array(residua
-00014e60: 6c73 292e 6d65 616e 2829 0a0a 2020 2020  ls).mean()..    
-00014e70: 2020 2020 0a20 2020 2040 7374 6174 6963      .    @static
-00014e80: 6d65 7468 6f64 0a20 2020 2064 6566 2065  method.    def e
-00014e90: 7069 6469 7374 2846 2c20 7031 2c20 7032  pidist(F, p1, p2
-00014ea0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00014eb0: 2020 2020 2020 2045 7069 706f 6c61 7220         Epipolar 
-00014ec0: 6469 7374 616e 6365 0a0a 2020 2020 2020  distance..      
-00014ed0: 2020 3a70 6172 616d 2046 3a20 6675 6e64    :param F: fund
-00014ee0: 616d 656e 7461 6c20 6d61 7472 6978 0a20  amental matrix. 
-00014ef0: 2020 2020 2020 203a 7479 7065 2046 3a20         :type F: 
-00014f00: 6e64 6172 7261 7928 332c 3329 0a20 2020  ndarray(3,3).   
-00014f10: 2020 2020 203a 7061 7261 6d20 7031 3a20       :param p1: 
-00014f20: 696d 6167 6520 706c 616e 6520 706f 696e  image plane poin
-00014f30: 7420 6f72 2070 6f69 6e74 7320 6672 6f6d  t or points from
-00014f40: 2066 6972 7374 2063 616d 6572 610a 2020   first camera.  
-00014f50: 2020 2020 2020 3a74 7970 6520 7031 3a20        :type p1: 
-00014f60: 6e64 6172 7261 7928 3229 206f 7220 6e64  ndarray(2) or nd
-00014f70: 6172 7261 7928 322c 4e29 0a20 2020 2020  array(2,N).     
-00014f80: 2020 203a 7061 7261 6d20 7032 3a20 696d     :param p2: im
-00014f90: 6167 6520 706c 616e 6520 706f 696e 7420  age plane point 
-00014fa0: 6f72 2070 6f69 6e74 7320 6672 6f6d 2073  or points from s
-00014fb0: 6563 6f6e 6420 6361 6d65 7261 0a20 2020  econd camera.   
-00014fc0: 2020 2020 203a 7479 7065 2070 323a 206e       :type p2: n
-00014fd0: 6461 7272 6179 2832 2920 6f72 206e 6461  darray(2) or nda
-00014fe0: 7272 6179 2832 2c4d 290a 2020 2020 2020  rray(2,M).      
-00014ff0: 2020 3a72 6574 7572 6e3a 2064 6973 7461    :return: dista
-00015000: 6e63 6520 6d61 7472 6978 0a20 2020 2020  nce matrix.     
-00015010: 2020 203a 7274 7970 653a 206e 6461 7272     :rtype: ndarr
-00015020: 6179 284e 2c4d 290a 0a20 2020 2020 2020  ay(N,M)..       
-00015030: 2043 6f6d 7075 7465 7320 7468 6520 6469   Computes the di
-00015040: 7374 616e 6365 206f 6620 7468 6520 706f  stance of the po
-00015050: 696e 7473 2060 6070 3260 6020 6672 6f6d  ints ``p2`` from
-00015060: 2074 6865 200a 2020 2020 2020 2020 6570   the .        ep
-00015070: 6970 6f6c 6172 206c 696e 6573 2069 6e64  ipolar lines ind
-00015080: 7563 6564 2062 7920 706f 696e 7473 2060  uced by points `
-00015090: 6070 3160 602e 2020 456c 656d 656e 7420  `p1``.  Element 
-000150a0: 5b69 2c6a 5d20 6f66 2074 6865 2072 6574  [i,j] of the ret
-000150b0: 7572 6e0a 2020 2020 2020 2020 7661 6c75  urn.        valu
-000150c0: 6520 6973 2074 6865 2069 7374 616e 6365  e is the istance
-000150d0: 206f 6620 706f 696e 7420 6a20 696e 2063   of point j in c
-000150e0: 616d 6572 6120 3220 6672 6f6d 2074 6865  amera 2 from the
-000150f0: 2065 7069 706f 6c61 7220 6c69 6e65 0a20   epipolar line. 
-00015100: 2020 2020 2020 2069 6e64 7563 6564 2062         induced b
-00015110: 7920 706f 696e 7420 6920 696e 2063 616d  y point i in cam
-00015120: 6572 6120 312e 0a20 2020 2020 2020 2022  era 1..        "
-00015130: 2222 0a20 2020 2020 2020 2069 6620 7031  "".        if p1
-00015140: 2e6e 6469 6d20 3d3d 2031 3a0a 2020 2020  .ndim == 1:.    
-00015150: 2020 2020 2020 2020 7031 203d 206e 702e          p1 = np.
-00015160: 635f 5b70 315d 0a20 2020 2020 2020 2069  c_[p1].        i
-00015170: 6620 7032 2e6e 6469 6d20 3d3d 2031 3a0a  f p2.ndim == 1:.
-00015180: 2020 2020 2020 2020 2020 2020 7032 203d              p2 =
-00015190: 206e 702e 635f 5b70 325d 0a0a 2020 2020   np.c_[p2]..    
-000151a0: 2020 2020 4420 3d20 6e70 2e65 6d70 7479      D = np.empty
-000151b0: 2828 7031 2e73 6861 7065 5b31 5d2c 2070  ((p1.shape[1], p
-000151c0: 322e 7368 6170 655b 315d 2929 0a0a 2020  2.shape[1]))..  
-000151d0: 2020 2020 2020 2320 636f 6d70 7574 6520        # compute 
-000151e0: 6570 6970 6f6c 6172 206c 696e 6573 2063  epipolar lines c
-000151f0: 6f72 7265 7370 6f6e 6469 6e67 2074 6f20  orresponding to 
-00015200: 7031 0a20 2020 2020 2020 206c 203d 2046  p1.        l = F
-00015210: 2040 2062 6173 652e 6532 6828 7031 290a   @ base.e2h(p1).
-00015220: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
-00015230: 2072 616e 6765 2870 312e 7368 6170 655b   range(p1.shape[
-00015240: 315d 293a 0a20 2020 2020 2020 2020 2020  1]):.           
-00015250: 2066 6f72 206a 2069 6e20 7261 6e67 6528   for j in range(
-00015260: 7032 2e73 6861 7065 5b31 5d29 3a0a 2020  p2.shape[1]):.  
-00015270: 2020 2020 2020 2020 2020 2020 2020 445b                D[
-00015280: 692c 206a 5d20 3d20 6e70 2e61 6273 286c  i, j] = np.abs(l
-00015290: 5b30 2c20 695d 202a 2070 325b 302c 6a5d  [0, i] * p2[0,j]
-000152a0: 202b 206c 5b31 2c20 695d 202a 2070 325b   + l[1, i] * p2[
-000152b0: 312c 206a 5d20 2b20 6c5b 322c 2069 5d29  1, j] + l[2, i])
-000152c0: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-000152d0: 2020 2020 2020 202f 206e 702e 7371 7274         / np.sqrt
-000152e0: 286c 5b30 2c20 695d 2a2a 3220 2b20 6c5b  (l[0, i]**2 + l[
-000152f0: 312c 2069 5d2a 2a32 290a 2020 2020 2020  1, i]**2).      
-00015300: 2020 7265 7475 726e 2044 0a0a 2020 2020    return D..    
-00015310: 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  # ==============
-00015320: 3d3d 3d3d 3d3d 3d20 6573 7365 6e74 6961  ======= essentia
-00015330: 6c20 6d61 7472 6978 203d 3d3d 3d3d 3d3d  l matrix =======
-00015340: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00015350: 3d3d 3d3d 3d3d 3d3d 2023 0a0a 2020 2020  ======== #..    
-00015360: 6465 6620 4528 7365 6c66 2c20 6f74 6865  def E(self, othe
-00015370: 7229 3a0a 2020 2020 2020 2020 2222 220a  r):.        """.
-00015380: 2020 2020 2020 2020 4573 7365 6e74 6961          Essentia
-00015390: 6c20 6d61 7472 6978 2066 726f 6d20 7477  l matrix from tw
-000153a0: 6f20 6361 6d65 7261 2076 6965 7773 0a0a  o camera views..
-000153b0: 2020 2020 2020 2020 3a70 6172 616d 206f          :param o
-000153c0: 7468 6572 3a20 7365 636f 6e64 2063 616d  ther: second cam
-000153d0: 6572 6120 7669 6577 2c20 6361 6d65 7261  era view, camera
-000153e0: 2070 6f73 6520 6f72 2066 756e 6461 6d65   pose or fundame
-000153f0: 6e74 616c 206d 6174 7269 780a 2020 2020  ntal matrix.    
-00015400: 2020 2020 3a74 7970 6520 6f74 6865 723a      :type other:
-00015410: 203a 636c 6173 733a 6043 656e 7472 616c   :class:`Central
-00015420: 4361 6d65 7261 602c 203a 636c 6173 733a  Camera`, :class:
-00015430: 607e 7370 6174 6961 6c6d 6174 682e 2e70  `~spatialmath..p
-00015440: 6f73 6533 642e 5345 3360 2c20 6e64 6172  ose3d.SE3`, ndar
-00015450: 7261 7928 332c 3329 0a20 2020 2020 2020  ray(3,3).       
-00015460: 203a 7265 7475 726e 3a20 6573 7365 6e74   :return: essent
-00015470: 6961 6c20 6d61 7472 6978 0a20 2020 2020  ial matrix.     
-00015480: 2020 203a 7274 7970 653a 206e 6461 7272     :rtype: ndarr
-00015490: 6179 2833 2c33 290a 0a20 2020 2020 2020  ay(3,3)..       
-000154a0: 2043 6f6d 7075 7465 2074 6865 2065 7373   Compute the ess
-000154b0: 656e 7469 616c 206d 6174 7269 7820 7265  ential matrix re
-000154c0: 6c61 7469 6e67 2074 776f 2063 616d 6572  lating two camer
-000154d0: 6120 7669 6577 732e 2054 6865 2066 6972  a views. The fir
-000154e0: 7374 2076 6965 770a 2020 2020 2020 2020  st view.        
-000154f0: 6973 2064 6566 696e 6564 2062 7920 7468  is defined by th
-00015500: 6520 696e 7374 616e 6365 2c20 616e 6420  e instance, and 
-00015510: 7365 636f 6e64 2076 6965 7720 6973 2073  second view is s
-00015520: 7065 6369 6669 6564 2062 793a 0a0a 2020  pecified by:..  
-00015530: 2020 2020 2020 2a20 6120 6361 6d65 7261        * a camera
-00015540: 2069 6e73 7461 6e63 6520 7265 7072 6573   instance repres
-00015550: 656e 7465 6420 6279 2061 203a 636c 6173  ented by a :clas
-00015560: 733a 6043 656e 7472 616c 4361 6d65 7261  s:`CentralCamera
-00015570: 602e 2041 7373 756d 6573 2074 6865 0a20  `. Assumes the. 
-00015580: 2020 2020 2020 2020 2063 616d 6572 6173           cameras
-00015590: 2068 6176 6520 7468 6520 7361 6d65 2069   have the same i
-000155a0: 6e74 7269 6e73 6963 732e 0a20 2020 2020  ntrinsics..     
-000155b0: 2020 202a 2061 2072 656c 6174 6976 6520     * a relative 
-000155c0: 6d6f 7469 6f6e 2072 6570 7265 7365 6e74  motion represent
-000155d0: 6564 2062 7920 6120 3a63 6c61 7373 3a60  ed by a :class:`
-000155e0: 7e73 7061 7469 616c 6d61 7468 2e2e 706f  ~spatialmath..po
-000155f0: 7365 3364 2e53 4533 600a 2020 2020 2020  se3d.SE3`.      
-00015600: 2020 2a20 6120 6675 6e64 616d 656e 7461    * a fundamenta
-00015610: 6c20 6d61 7472 6978 0a20 2020 2020 2020  l matrix.       
-00015620: 200a 2020 2020 2020 2020 3a72 6566 6572   .        :refer
-00015630: 656e 6365 3a0a 2020 2020 2020 2020 2020  ence:.          
-00015640: 2020 2d20 592e 4d61 2c20 4a2e 4b6f 7365    - Y.Ma, J.Kose
-00015650: 636b 612c 2053 2e53 6f61 7474 6f2c 2053  cka, S.Soatto, S
-00015660: 2e53 6173 7472 792c 2022 416e 2069 6e76  .Sastry, "An inv
-00015670: 6974 6174 696f 6e20 746f 2033 4422 2c0a  itation to 3D",.
-00015680: 2020 2020 2020 2020 2020 2020 2020 5370                Sp
-00015690: 7269 6e67 6572 2c20 3230 3033 2e20 702e  ringer, 2003. p.
-000156a0: 3137 370a 0a20 2020 2020 2020 203a 7365  177..        :se
-000156b0: 6561 6c73 6f3a 203a 6d65 7468 3a60 4660  ealso: :meth:`F`
-000156c0: 203a 6d65 7468 3a60 6465 636f 6d70 6f73   :meth:`decompos
-000156d0: 6545 6020 3a6d 6574 683a 6070 6f69 6e74  eE` :meth:`point
-000156e0: 7332 4560 0a20 2020 2020 2020 2022 2222  s2E`.        """
-000156f0: 0a0a 2020 2020 2020 2020 6966 2069 7369  ..        if isi
-00015700: 6e73 7461 6e63 6528 6f74 6865 722c 206e  nstance(other, n
-00015710: 702e 6e64 6172 7261 7929 2061 6e64 206f  p.ndarray) and o
-00015720: 7468 6572 2e73 6861 7065 203d 3d20 2833  ther.shape == (3
-00015730: 2c33 293a 0a20 2020 2020 2020 2020 2020  ,3):.           
-00015740: 2023 2065 7373 656e 7469 616c 206d 6174   # essential mat
-00015750: 7269 7820 6672 6f6d 2046 206d 6174 7269  rix from F matri
-00015760: 7820 616e 6420 696e 7472 696e 7369 6373  x and intrinsics
-00015770: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00015780: 7572 6e20 7365 6c66 2e4b 2e54 2040 206f  urn self.K.T @ o
-00015790: 7468 6572 2040 2073 656c 662e 4b0a 0a20  ther @ self.K.. 
-000157a0: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
-000157b0: 7374 616e 6365 286f 7468 6572 2c20 4365  stance(other, Ce
-000157c0: 6e74 7261 6c43 616d 6572 6129 3a0a 2020  ntralCamera):.  
-000157d0: 2020 2020 2020 2020 2020 2320 6361 6d65            # came
-000157e0: 7261 2072 656c 6174 6976 6520 706f 7365  ra relative pose
-000157f0: 0a20 2020 2020 2020 2020 2020 2054 3231  .            T21
-00015800: 203d 206f 7468 6572 2e70 6f73 652e 696e   = other.pose.in
-00015810: 7628 2920 2a20 7365 6c66 2e70 6f73 650a  v() * self.pose.
-00015820: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
-00015830: 696e 7374 616e 6365 286f 7468 6572 2c20  instance(other, 
-00015840: 5345 3329 3a0a 2020 2020 2020 2020 2020  SE3):.          
-00015850: 2020 2320 7265 6c61 7469 7665 2070 6f73    # relative pos
-00015860: 6520 6769 7665 6e20 6578 706c 6963 6974  e given explicit
-00015870: 6c79 0a20 2020 2020 2020 2020 2020 2054  ly.            T
-00015880: 3231 203d 206f 7468 6572 2e69 6e76 2829  21 = other.inv()
-00015890: 0a0a 2020 2020 2020 2020 656c 7365 3a0a  ..        else:.
-000158a0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-000158b0: 6520 5661 6c75 6545 7272 6f72 2827 6261  e ValueError('ba
-000158c0: 6420 7479 7065 2729 0a20 2020 2020 2020  d type').       
-000158d0: 200a 2020 2020 2020 2020 7265 7475 726e   .        return
-000158e0: 2062 6173 652e 736b 6577 2854 3231 2e74   base.skew(T21.t
-000158f0: 2920 4020 5432 312e 520a 0a20 2020 2064  ) @ T21.R..    d
-00015900: 6566 2070 6f69 6e74 7332 4528 7365 6c66  ef points2E(self
-00015910: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015920: 2020 2020 2020 7031 2c0a 2020 2020 2020        p1,.      
-00015930: 2020 2020 2020 2020 2020 2020 2020 7032                p2
-00015940: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015950: 2020 2020 2020 6d65 7468 6f64 3d4e 6f6e        method=Non
-00015960: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00015970: 2020 2020 2020 204b 3d4e 6f6e 652c 0a20         K=None,. 
-00015980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015990: 2020 202a 2a6b 7761 7267 7329 3a0a 2020     **kwargs):.  
-000159a0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-000159b0: 2020 4573 7365 6e74 6961 6c20 6d61 7472    Essential matr
-000159c0: 6978 2066 726f 6d20 706f 696e 7473 0a0a  ix from points..
-000159d0: 2020 2020 2020 2020 3a70 6172 616d 2050          :param P
-000159e0: 313a 2069 6d61 6765 2070 6c61 6e65 2070  1: image plane p
-000159f0: 6f69 6e74 730a 2020 2020 2020 2020 3a74  oints.        :t
-00015a00: 7970 6520 5031 3a20 6e64 6172 7261 7928  ype P1: ndarray(
-00015a10: 322c 4e29 0a20 2020 2020 2020 203a 7061  2,N).        :pa
-00015a20: 7261 6d20 5032 3a20 696d 6167 6520 706c  ram P2: image pl
-00015a30: 616e 6520 706f 696e 7473 0a20 2020 2020  ane points.     
-00015a40: 2020 203a 7479 7065 2050 323a 206e 6461     :type P2: nda
-00015a50: 7272 6179 2832 2c4e 290a 2020 2020 2020  rray(2,N).      
-00015a60: 2020 3a70 6172 616d 206d 6574 686f 643a    :param method:
-00015a70: 206d 6574 686f 642c 2063 616e 2062 6520   method, can be 
-00015a80: 2772 616e 7361 6327 206f 7220 276c 6d65  'ransac' or 'lme
-00015a90: 6473 270a 2020 2020 2020 2020 3a74 7970  ds'.        :typ
-00015aa0: 6520 6d65 7468 6f64 3a20 7374 720a 2020  e method: str.  
-00015ab0: 2020 2020 2020 3a70 6172 616d 204b 3a20        :param K: 
-00015ac0: 6361 6d65 7261 2069 6e74 7269 6e73 6963  camera intrinsic
-00015ad0: 206d 6174 7269 782c 2064 6566 6175 6c74   matrix, default
-00015ae0: 7320 746f 2074 6861 7420 6f66 2063 616d  s to that of cam
-00015af0: 6572 6120 6f62 6a65 6374 0a20 2020 2020  era object.     
-00015b00: 2020 203a 7479 7065 204b 3a20 6e64 6172     :type K: ndar
-00015b10: 7261 7928 332c 3329 2c20 6f70 7469 6f6e  ray(3,3), option
-00015b20: 616c 0a20 2020 2020 2020 203a 7061 7261  al.        :para
-00015b30: 6d20 6b77 6172 6773 3a20 6164 6469 7469  m kwargs: additi
-00015b40: 6f6e 616c 2061 7267 756d 656e 7473 2072  onal arguments r
-00015b50: 6571 7569 7265 6420 666f 7220 2772 616e  equired for 'ran
-00015b60: 7361 6327 206f 7220 276c 6d65 6473 270a  sac' or 'lmeds'.
-00015b70: 2020 2020 2020 2020 2020 2020 6f70 7469              opti
-00015b80: 6f6e 730a 2020 2020 2020 2020 3a72 6574  ons.        :ret
-00015b90: 7572 6e3a 2065 7373 656e 7469 616c 206d  urn: essential m
-00015ba0: 6174 7269 7820 616e 6420 6f70 7469 6f6e  atrix and option
-00015bb0: 616c 2069 6e6c 6965 7220 7665 7674 6f72  al inlier vevtor
-00015bc0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-00015bd0: 206e 6461 7272 6179 2833 2c33 292c 206e   ndarray(3,3), n
-00015be0: 6461 7272 6179 284e 2c20 626f 6f6c 290a  darray(N, bool).
-00015bf0: 0a20 2020 2020 2020 2043 6f6d 7075 7465  .        Compute
-00015c00: 2074 6865 2065 7373 656e 7469 616c 206d   the essential m
-00015c10: 6174 7269 7820 6672 6f6d 2074 776f 2073  atrix from two s
-00015c20: 6574 7320 6f66 2063 6f72 7265 7370 6f6e  ets of correspon
-00015c30: 6469 6e67 2070 6f69 6e74 732e 0a20 2020  ding points..   
-00015c40: 2020 2020 2045 6163 6820 7365 7420 6f66       Each set of
-00015c50: 2070 6f69 6e74 7320 6973 2072 6570 7265   points is repre
-00015c60: 7365 6e74 6564 2062 7920 7468 6520 636f  sented by the co
-00015c70: 6c75 6d6e 7320 6f66 2074 6865 2061 7272  lumns of the arr
-00015c80: 6179 2060 6070 3160 600a 2020 2020 2020  ay ``p1``.      
-00015c90: 2020 6f72 2060 6070 3260 602e 0a0a 2020    or ``p2``...  
-00015ca0: 2020 2020 2020 4578 616d 706c 653a 0a0a        Example:..
-00015cb0: 2020 2020 2020 2020 2e2e 2072 756e 626c          .. runbl
-00015cc0: 6f63 6b3a 3a20 7079 636f 6e0a 0a20 2020  ock:: pycon..   
-00015cd0: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
-00015ce0: 6d20 6d61 6368 696e 6576 6973 696f 6e74  m machinevisiont
-00015cf0: 6f6f 6c62 6f78 2069 6d70 6f72 7420 4365  oolbox import Ce
-00015d00: 6e74 7261 6c43 616d 6572 612c 206d 6b67  ntralCamera, mkg
-00015d10: 7269 640a 2020 2020 2020 2020 2020 2020  rid.            
-00015d20: 3e3e 3e20 6672 6f6d 2073 7061 7469 616c  >>> from spatial
-00015d30: 6d61 7468 2069 6d70 6f72 7420 5345 330a  math import SE3.
-00015d40: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00015d50: 6361 6d65 7261 3120 3d20 4365 6e74 7261  camera1 = Centra
-00015d60: 6c43 616d 6572 6128 6e61 6d65 3d22 6361  lCamera(name="ca
-00015d70: 6d65 7261 2031 222c 2066 3d30 2e30 3032  mera 1", f=0.002
-00015d80: 2c20 696d 6167 6573 697a 653d 3130 3030  , imagesize=1000
-00015d90: 2c20 7268 6f3d 3130 652d 362c 2070 6f73  , rho=10e-6, pos
-00015da0: 653d 5345 332e 5478 282d 302e 3129 2a53  e=SE3.Tx(-0.1)*S
-00015db0: 4533 2e52 7928 302e 3429 290a 2020 2020  E3.Ry(0.4)).    
-00015dc0: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-00015dd0: 7261 3220 3d20 4365 6e74 7261 6c43 616d  ra2 = CentralCam
-00015de0: 6572 6128 6e61 6d65 3d22 6361 6d65 7261  era(name="camera
-00015df0: 2032 222c 2066 3d30 2e30 3032 2c20 696d   2", f=0.002, im
-00015e00: 6167 6573 697a 653d 3130 3030 2c20 7268  agesize=1000, rh
-00015e10: 6f3d 3130 652d 362c 2070 6f73 653d 5345  o=10e-6, pose=SE
-00015e20: 332e 5478 2830 2e31 292a 5345 332e 5279  3.Tx(0.1)*SE3.Ry
-00015e30: 282d 302e 3429 290a 2020 2020 2020 2020  (-0.4)).        
-00015e40: 2020 2020 3e3e 3e20 545f 6772 6964 203d      >>> T_grid =
-00015e50: 2053 4533 2e54 7a28 3129 202a 2053 4533   SE3.Tz(1) * SE3
-00015e60: 2e52 7828 302e 3129 202a 2053 4533 2e52  .Rx(0.1) * SE3.R
-00015e70: 7928 302e 3229 0a20 2020 2020 2020 2020  y(0.2).         
-00015e80: 2020 203e 3e3e 2050 203d 206d 6b67 7269     >>> P = mkgri
-00015e90: 6428 332c 2031 2e30 2c20 706f 7365 3d54  d(3, 1.0, pose=T
-00015ea0: 5f67 7269 6429 0a20 2020 2020 2020 2020  _grid).         
-00015eb0: 2020 203e 3e3e 2070 3120 3d20 6361 6d65     >>> p1 = came
-00015ec0: 7261 312e 7072 6f6a 6563 745f 706f 696e  ra1.project_poin
-00015ed0: 7428 5029 0a20 2020 2020 2020 2020 2020  t(P).           
-00015ee0: 203e 3e3e 2070 3220 3d20 6361 6d65 7261   >>> p2 = camera
-00015ef0: 322e 7072 6f6a 6563 745f 706f 696e 7428  2.project_point(
-00015f00: 5029 3b0a 2020 2020 2020 2020 2020 2020  P);.            
-00015f10: 3e3e 3e20 452c 2069 6e6c 6965 7273 203d  >>> E, inliers =
-00015f20: 2063 616d 6572 6131 2e70 6f69 6e74 7332   camera1.points2
-00015f30: 4528 7031 2c20 7032 290a 2020 2020 2020  E(p1, p2).      
-00015f40: 2020 2020 2020 3e3e 3e20 450a 2020 2020        >>> E.    
-00015f50: 2020 2020 2020 2020 3e3e 3e20 696e 6c69          >>> inli
-00015f60: 6572 730a 0a20 2020 2020 2020 203a 6e6f  ers..        :no
-00015f70: 7465 3a20 4966 2074 6865 206d 6574 686f  te: If the metho
-00015f80: 6420 6973 2027 7261 6e73 6163 2720 6f72  d is 'ransac' or
-00015f90: 2027 6c6d 6564 7327 2074 6865 6e20 6120   'lmeds' then a 
-00015fa0: 626f 6f6c 6561 6e20 6172 7261 790a 2020  boolean array.  
-00015fb0: 2020 2020 2020 2020 2020 6f66 2069 6e6c            of inl
-00015fc0: 6965 7273 2069 7320 616c 736f 2072 6574  iers is also ret
-00015fd0: 7572 6e65 642c 2054 7275 6520 6d65 616e  urned, True mean
-00015fe0: 7320 7468 6520 636f 7272 6573 706f 6e64  s the correspond
-00015ff0: 696e 6720 696e 7075 740a 2020 2020 2020  ing input.      
-00016000: 2020 2020 2020 706f 696e 7420 7061 6972        point pair
-00016010: 2069 7320 616e 2069 6e6c 6965 722e 0a0a   is an inlier...
-00016020: 2020 2020 2020 2020 3a73 6565 616c 736f          :seealso
-00016030: 3a20 3a6d 6574 683a 6045 6020 3a6d 6574  : :meth:`E` :met
-00016040: 683a 6064 6563 6f6d 706f 7365 4560 200a  h:`decomposeE` .
-00016050: 2020 2020 2020 2020 2020 2020 606f 7065              `ope
-00016060: 6e63 762e 6669 6e64 4573 7365 6e74 6961  ncv.findEssentia
-00016070: 6c4d 6174 203c 6874 7470 733a 2f2f 646f  lMat <https://do
-00016080: 6373 2e6f 7065 6e63 762e 6f72 672f 6d61  cs.opencv.org/ma
-00016090: 7374 6572 2f64 392f 6430 632f 6772 6f75  ster/d9/d0c/grou
-000160a0: 705f 5f63 616c 6962 3364 2e68 746d 6c23  p__calib3d.html#
-000160b0: 6761 6432 3435 6436 3065 3634 6430 6331  gad245d60e64d0c1
-000160c0: 3237 3064 6266 6430 3532 3038 3437 6262  270dbfd0520847bb
-000160d0: 3837 3e60 5f0a 0a20 2020 2020 2020 2022  87>`_..        "
-000160e0: 2222 0a20 2020 2020 2020 2069 6620 4b20  "".        if K 
-000160f0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-00016100: 2020 2020 204b 203d 2073 656c 662e 4b0a       K = self.K.
-00016110: 0a20 2020 2020 2020 2070 6f69 6e74 7332  .        points2
-00016120: 455f 6469 6374 203d 207b 0a20 2020 2020  E_dict = {.     
-00016130: 2020 2020 2020 2027 7261 6e73 6163 273a         'ransac':
-00016140: 2063 762e 5241 4e53 4143 2c0a 2020 2020   cv.RANSAC,.    
-00016150: 2020 2020 2020 2020 276c 6d65 6473 273a          'lmeds':
-00016160: 2063 762e 4c4d 4544 530a 2020 2020 2020   cv.LMEDS.      
-00016170: 2020 7d0a 2020 2020 2020 2020 6966 206d    }.        if m
-00016180: 6574 686f 6420 6973 206e 6f74 204e 6f6e  ethod is not Non
-00016190: 653a 0a20 2020 2020 2020 2020 2020 206d  e:.            m
-000161a0: 6574 686f 6420 3d20 706f 696e 7473 3245  ethod = points2E
-000161b0: 5f64 6963 745b 6d65 7468 6f64 5d0a 0a20  _dict[method].. 
-000161c0: 2020 2020 2020 2045 2c20 6d61 736b 203d         E, mask =
-000161d0: 2063 762e 6669 6e64 4573 7365 6e74 6961   cv.findEssentia
-000161e0: 6c4d 6174 2870 312e 542c 2070 322e 542c  lMat(p1.T, p2.T,
-000161f0: 2063 616d 6572 614d 6174 7269 783d 4b2c   cameraMatrix=K,
-00016200: 206d 6574 686f 643d 6d65 7468 6f64 2c20   method=method, 
-00016210: 2a2a 6b77 6172 6773 290a 2020 2020 2020  **kwargs).      
-00016220: 2020 6966 206d 6173 6b20 6973 206e 6f74    if mask is not
-00016230: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-00016240: 2020 206d 6173 6b20 3d20 6d61 736b 2e66     mask = mask.f
-00016250: 6c61 7474 656e 2829 2e61 7374 7970 6528  latten().astype(
-00016260: 6e70 2e62 6f6f 6c29 0a20 2020 2020 2020  np.bool).       
-00016270: 2020 2020 2072 6574 7572 6e20 452c 206d       return E, m
-00016280: 6173 6b0a 2020 2020 2020 2020 656c 7365  ask.        else
-00016290: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-000162a0: 7475 726e 2045 0a0a 2020 2020 6465 6620  turn E..    def 
-000162b0: 6465 636f 6d70 6f73 6545 2873 656c 662c  decomposeE(self,
-000162c0: 2045 2c20 503d 4e6f 6e65 293a 0a20 2020   E, P=None):.   
-000162d0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000162e0: 2044 6563 6f6d 706f 7365 2065 7373 656e   Decompose essen
-000162f0: 7469 616c 206d 6174 7269 780a 0a20 2020  tial matrix..   
-00016300: 2020 2020 203a 7061 7261 6d20 453a 2065       :param E: e
-00016310: 7373 656e 7469 616c 206d 6174 7269 780a  ssential matrix.
-00016320: 2020 2020 2020 2020 3a74 7970 6520 453a          :type E:
-00016330: 206e 6461 7272 6179 2833 2c33 290a 2020   ndarray(3,3).  
-00016340: 2020 2020 2020 3a70 6172 616d 2050 3a20        :param P: 
-00016350: 776f 726c 6420 706f 696e 7420 6f72 2066  world point or f
-00016360: 6561 7475 7265 206d 6174 6368 206f 626a  eature match obj
-00016370: 6563 7420 746f 2072 6573 6f6c 7665 2061  ect to resolve a
-00016380: 6d62 6967 7569 7479 0a20 2020 2020 2020  mbiguity.       
-00016390: 203a 7479 7065 2050 3a20 6172 7261 795f   :type P: array_
-000163a0: 6c69 6b65 2833 292c 203a 636c 6173 733a  like(3), :class:
-000163b0: 607e 6d61 6368 696e 6576 6973 696f 6e74  `~machinevisiont
-000163c0: 6f6f 6c62 6f78 2e49 6d61 6765 506f 696e  oolbox.ImagePoin
-000163d0: 7446 6561 7475 7265 732e 4665 6174 7572  tFeatures.Featur
-000163e0: 654d 6174 6368 600a 2020 2020 2020 2020  eMatch`.        
-000163f0: 3a72 6574 7572 6e3a 2063 616d 6572 6120  :return: camera 
-00016400: 7265 6c61 7469 7665 2070 6f73 650a 2020  relative pose.  
-00016410: 2020 2020 2020 3a72 7479 7065 3a20 3a63        :rtype: :c
-00016420: 6c61 7373 3a60 7e73 7061 7469 616c 6d61  lass:`~spatialma
-00016430: 7468 2e2e 706f 7365 3364 2e53 4533 600a  th..pose3d.SE3`.
-00016440: 0a20 2020 2020 2020 2044 6574 6572 6d69  .        Determi
-00016450: 6e65 7320 7265 6c61 7469 7665 2070 6f73  nes relative pos
-00016460: 6520 6672 6f6d 2065 7373 656e 7469 616c  e from essential
-00016470: 206d 6174 7269 782e 2054 6869 7320 6f70   matrix. This op
-00016480: 6572 6174 696f 6e20 6861 730a 2020 2020  eration has.    
-00016490: 2020 2020 6d75 6c74 6970 6c65 2073 6f6c      multiple sol
-000164a0: 7574 696f 6e73 2077 6869 6368 2069 7320  utions which is 
-000164b0: 7265 736f 6c76 6564 2062 7920 7061 7373  resolved by pass
-000164c0: 696e 6720 696e 3a0a 0a20 2020 2020 2020  ing in:..       
-000164d0: 202d 2061 2073 696e 676c 6520 3344 2077   - a single 3D w
-000164e0: 6f72 6c64 2070 6f69 6e74 2069 6e20 6672  orld point in fr
-000164f0: 6f6e 7420 6f66 2074 6865 2063 616d 6572  ont of the camer
-00016500: 610a 2020 2020 2020 2020 2d20 6120 3a63  a.        - a :c
-00016510: 6c61 7373 3a60 7e6d 6163 6869 6e65 7669  lass:`~machinevi
-00016520: 7369 6f6e 746f 6f6c 626f 782e 496d 6167  siontoolbox.Imag
-00016530: 6550 6f69 6e74 4665 6174 7572 6573 2e46  ePointFeatures.F
-00016540: 6561 7475 7265 4d61 7463 6860 206f 626a  eatureMatch` obj
-00016550: 6563 740a 0a20 2020 2020 2020 203a 7265  ect..        :re
-00016560: 6665 7265 6e63 653a 0a20 2020 2020 2020  ference:.       
-00016570: 2020 2020 202d 2052 6f62 6f74 6963 732c       - Robotics,
-00016580: 2056 6973 696f 6e20 2620 436f 6e74 726f   Vision & Contro
-00016590: 6c20 666f 7220 5079 7468 6f6e 2c20 5365  l for Python, Se
-000165a0: 6374 696f 6e20 3134 2e32 2e32 2050 2e20  ction 14.2.2 P. 
-000165b0: 436f 726b 652c 200a 2020 2020 2020 2020  Corke, .        
-000165c0: 2020 2020 2020 5370 7269 6e67 6572 2032        Springer 2
-000165d0: 3032 332e 0a20 2020 2020 2020 200a 2020  023..        .  
-000165e0: 2020 2020 2020 3a73 6565 616c 736f 3a20        :seealso: 
-000165f0: 3a6d 6574 683a 6045 6020 3a6d 6574 683a  :meth:`E` :meth:
-00016600: 6070 6f69 6e74 7332 4560 0a20 2020 2020  `points2E`.     
-00016610: 2020 2020 2020 203a 636c 6173 733a 607e         :class:`~
-00016620: 6d61 6368 696e 6576 6973 696f 6e74 6f6f  machinevisiontoo
-00016630: 6c62 6f78 2e49 6d61 6765 506f 696e 7446  lbox.ImagePointF
-00016640: 6561 7475 7265 732e 4665 6174 7572 654d  eatures.FeatureM
-00016650: 6174 6368 600a 2020 2020 2020 2020 2020  atch`.          
-00016660: 2020 606f 7065 6e63 762e 6465 636f 6d70    `opencv.decomp
-00016670: 6f73 6545 7373 656e 7469 616c 4d61 7420  oseEssentialMat 
-00016680: 3c68 7474 7073 3a2f 2f64 6f63 732e 6f70  <https://docs.op
-00016690: 656e 6376 2e6f 7267 2f6d 6173 7465 722f  encv.org/master/
-000166a0: 6439 2f64 3063 2f67 726f 7570 5f5f 6361  d9/d0c/group__ca
-000166b0: 6c69 6233 642e 6874 6d6c 2367 6135 3461  lib3d.html#ga54a
-000166c0: 3266 3562 3366 3861 6561 6636 6337 3664  2f5b3f8aeaf6c76d
-000166d0: 3461 3331 6465 6365 3835 6435 643e 605f  4a31dece85d5d>`_
-000166e0: 0a20 2020 2020 2020 2020 2020 2060 6f70  .            `op
-000166f0: 656e 6376 2e72 6563 6f76 6572 506f 7365  encv.recoverPose
-00016700: 203c 6874 7470 733a 2f2f 646f 6373 2e6f   <https://docs.o
-00016710: 7065 6e63 762e 6f72 672f 6d61 7374 6572  pencv.org/master
-00016720: 2f64 392f 6430 632f 6772 6f75 705f 5f63  /d9/d0c/group__c
-00016730: 616c 6962 3364 2e68 746d 6c23 6761 6462  alib3d.html#gadb
-00016740: 3764 3264 6663 6331 3834 6331 6432 6634  7d2dfcc184c1d2f4
-00016750: 3936 6438 3633 3966 3433 3731 6330 3e60  96d8639f4371c0>`
-00016760: 5f0a 2020 2020 2020 2020 2222 220a 2020  _.        """.  
-00016770: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-00016780: 6e63 6528 502c 2046 6561 7475 7265 4d61  nce(P, FeatureMa
-00016790: 7463 6829 3a0a 2020 2020 2020 2020 2020  tch):.          
-000167a0: 2020 2320 7061 7373 6564 2061 204d 6174    # passed a Mat
-000167b0: 6368 206f 626a 6563 740a 2020 2020 2020  ch object.      
-000167c0: 2020 2020 2020 6d61 7463 6820 3d20 500a        match = P.
-000167d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-000167e0: 7661 6c2c 2052 2c20 742c 206d 6173 6b20  val, R, t, mask 
-000167f0: 3d20 6376 2e72 6563 6f76 6572 506f 7365  = cv.recoverPose
-00016800: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00016810: 2020 2020 2020 453d 452c 0a20 2020 2020        E=E,.     
-00016820: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00016830: 6f69 6e74 7331 3d6d 6174 6368 2e70 312e  oints1=match.p1.
-00016840: 542c 0a20 2020 2020 2020 2020 2020 2020  T,.             
-00016850: 2020 2020 2020 2070 6f69 6e74 7332 3d6d         points2=m
-00016860: 6174 6368 2e70 322e 542c 0a20 2020 2020  atch.p2.T,.     
-00016870: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00016880: 616d 6572 614d 6174 7269 783d 7365 6c66  ameraMatrix=self
-00016890: 2e43 2829 5b3a 332c 203a 335d 0a20 2020  .C()[:3, :3].   
-000168a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000168b0: 2029 0a20 2020 2020 2020 2020 2020 2023   ).            #
-000168c0: 206e 6f74 2065 7870 6c69 6369 746c 7920   not explicitly 
-000168d0: 7374 6174 6564 2c20 6275 7420 7365 656d  stated, but seem
-000168e0: 7320 7468 6174 2074 6869 7320 7265 7475  s that this retu
-000168f0: 726e 7320 2852 2c20 7429 2066 726f 6d20  rns (R, t) from 
-00016900: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
-00016910: 616d 6572 6120 746f 2077 6f72 6c64 0a0a  amera to world..
-00016920: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00016930: 726e 2053 4533 2e52 7428 522c 2074 292e  rn SE3.Rt(R, t).
-00016940: 696e 7628 290a 0a20 2020 2020 2020 2065  inv()..        e
-00016950: 6c73 653a 0a20 2020 2020 2020 200a 2020  lse:.        .  
-00016960: 2020 2020 2020 2020 2020 5231 2c20 5232            R1, R2
-00016970: 2c20 7420 3d20 6376 2e64 6563 6f6d 706f  , t = cv.decompo
-00016980: 7365 4573 7365 6e74 6961 6c4d 6174 2845  seEssentialMat(E
-00016990: 3d45 290a 2020 2020 2020 2020 2020 2020  =E).            
-000169a0: 2320 6e6f 7420 6578 706c 6963 6974 6c79  # not explicitly
-000169b0: 2073 7461 7465 642c 2062 7574 2073 6565   stated, but see
-000169c0: 6d73 2074 6861 7420 7468 6973 2072 6574  ms that this ret
-000169d0: 7572 6e73 2028 522c 2074 2920 6672 6f6d  urns (R, t) from
-000169e0: 200a 2020 2020 2020 2020 2020 2020 2320   .            # 
-000169f0: 6361 6d65 7261 2074 6f20 776f 726c 640a  camera to world.
-00016a00: 0a20 2020 2020 2020 2020 2020 2070 6f73  .            pos
-00016a10: 7369 626c 6573 203d 205b 2852 312c 2074  sibles = [(R1, t
-00016a20: 292c 2028 5231 2c20 2d74 292c 2028 5232  ), (R1, -t), (R2
-00016a30: 2c20 7429 2c20 2852 322c 202d 7429 5d0a  , t), (R2, -t)].
-00016a40: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00016a50: 6261 7365 2e69 7376 6563 746f 7228 502c  base.isvector(P,
-00016a60: 2033 293a 0a20 2020 2020 2020 2020 2020   3):.           
-00016a70: 2020 2020 2066 6f72 2052 7420 696e 2070       for Rt in p
-00016a80: 6f73 7369 626c 6573 3a0a 2020 2020 2020  ossibles:.      
-00016a90: 2020 2020 2020 2020 2020 2020 2020 706f                po
-00016aa0: 7365 203d 2053 4533 2e52 7428 5274 5b30  se = SE3.Rt(Rt[0
-00016ab0: 5d2c 2052 745b 315d 292e 696e 7628 290a  ], Rt[1]).inv().
-00016ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ad0: 2020 2020 7020 3d20 7365 6c66 2e70 726f      p = self.pro
-00016ae0: 6a65 6374 5f70 6f69 6e74 2850 2c20 706f  ject_point(P, po
-00016af0: 7365 3d70 6f73 652c 2062 6568 696e 643d  se=pose, behind=
-00016b00: 5472 7565 290a 2020 2020 2020 2020 2020  True).          
-00016b10: 2020 2020 2020 2020 2020 2320 6368 6563            # chec
-00016b20: 6b20 6966 2070 6f69 6e74 2069 7320 7072  k if point is pr
-00016b30: 6f6a 6563 7465 6420 6265 6869 6e64 2074  ojected behind t
-00016b40: 6865 2063 616d 6572 612c 2069 6e64 6963  he camera, indic
-00016b50: 6174 6564 0a20 2020 2020 2020 2020 2020  ated.           
-00016b60: 2020 2020 2020 2020 2023 2062 7920 6e61           # by na
-00016b70: 6e20 7661 6c75 6573 0a20 2020 2020 2020  n values.       
-00016b80: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00016b90: 6e6f 7420 6e70 2e69 736e 616e 2870 5b30  not np.isnan(p[0
-00016ba0: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00016bb0: 2020 2020 2020 2020 2020 2020 2320 7265              # re
-00016bc0: 7475 726e 2074 6865 2066 6972 7374 2067  turn the first g
-00016bd0: 6f6f 6420 6f6e 650a 2020 2020 2020 2020  ood one.        
-00016be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016bf0: 7265 7475 726e 2070 6f73 650a 2020 2020  return pose.    
-00016c00: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00016c10: 2020 2020 2020 2020 2020 2020 2020 5420                T 
-00016c20: 3d20 5345 332e 456d 7074 7928 290a 2020  = SE3.Empty().  
-00016c30: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00016c40: 7220 5274 2069 6e20 706f 7373 6962 6c65  r Rt in possible
-00016c50: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-00016c60: 2020 2020 2020 2070 6f73 6520 3d20 5345         pose = SE
-00016c70: 332e 5274 2852 745b 305d 2c20 5274 5b31  3.Rt(Rt[0], Rt[1
-00016c80: 5d29 2e69 6e76 2829 0a20 2020 2020 2020  ]).inv().       
-00016c90: 2020 2020 2020 2020 2020 2020 2054 2e61               T.a
-00016ca0: 7070 656e 6428 706f 7365 290a 2020 2020  ppend(pose).    
-00016cb0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00016cc0: 726e 2054 0a0a 0a20 2020 2023 203d 3d3d  rn T...    # ===
-00016cd0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00016ce0: 3d3d 2069 6d61 6765 2070 6c61 6e65 206d  == image plane m
-00016cf0: 6f74 696f 6e20 3d3d 3d3d 3d3d 3d3d 3d3d  otion ==========
-00016d00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00016d10: 3d3d 3d20 230a 0a20 2020 2064 6566 2076  === #..    def v
-00016d20: 6973 6a61 635f 7028 7365 6c66 2c20 7576  isjac_p(self, uv
-00016d30: 2c20 6465 7074 6829 3a0a 2020 2020 2020  , depth):.      
-00016d40: 2020 7222 2222 0a20 2020 2020 2020 2056    r""".        V
-00016d50: 6973 7561 6c20 4a61 636f 6269 616e 2066  isual Jacobian f
-00016d60: 6f72 2070 6f69 6e74 2066 6561 7475 7265  or point feature
-00016d70: 730a 0a20 2020 2020 2020 203a 7061 7261  s..        :para
-00016d80: 6d20 703a 2069 6d61 6765 2070 6c61 6e65  m p: image plane
-00016d90: 2070 6f69 6e74 206f 7220 706f 696e 7473   point or points
-00016da0: 0a20 2020 2020 2020 203a 7479 7065 2070  .        :type p
-00016db0: 3a20 6172 7261 795f 6c69 6b65 2832 292c  : array_like(2),
-00016dc0: 206e 6461 7272 6179 2832 2c4e 290a 2020   ndarray(2,N).  
-00016dd0: 2020 2020 2020 3a70 6172 616d 2064 6570        :param dep
-00016de0: 7468 3a20 706f 696e 7420 6465 7074 680a  th: point depth.
-00016df0: 2020 2020 2020 2020 3a74 7970 6520 6465          :type de
-00016e00: 7074 683a 2066 6c6f 6174 2c20 6172 7261  pth: float, arra
-00016e10: 795f 6c69 6b65 284e 290a 2020 2020 2020  y_like(N).      
-00016e20: 2020 3a72 6574 7572 6e3a 2076 6973 7561    :return: visua
-00016e30: 6c20 4a61 636f 6269 616e 206d 6174 7269  l Jacobian matri
-00016e40: 780a 2020 2020 2020 2020 3a72 7479 7065  x.        :rtype
-00016e50: 3a20 6e64 6172 7261 7928 322c 3629 2c20  : ndarray(2,6), 
-00016e60: 6e64 6172 7261 7928 324e 2c36 290a 0a20  ndarray(2N,6).. 
-00016e70: 2020 2020 2020 2043 6f6d 7075 7465 2074         Compute t
-00016e80: 6865 2069 6d61 6765 204a 6163 6f62 6961  he image Jacobia
-00016e90: 6e20 3a6d 6174 683a 605c 6d61 747b 4a7d  n :math:`\mat{J}
-00016ea0: 6020 7768 6963 6820 6d61 7073 0a0a 2020  ` which maps..  
-00016eb0: 2020 2020 2020 2e2e 206d 6174 683a 3a0a        .. math::.
-00016ec0: 0a20 2020 2020 2020 2020 2020 205c 6476  .            \dv
-00016ed0: 6563 7b70 7d20 3d20 5c6d 6174 7b4a 7d28  ec{p} = \mat{J}(
-00016ee0: 5c76 6563 7b70 7d2c 207a 2920 5c76 6563  \vec{p}, z) \vec
-00016ef0: 7b5c 6e75 7d0a 0a20 2020 2020 2020 2063  {\nu}..        c
-00016f00: 616d 6572 6120 7370 6174 6961 6c20 7665  amera spatial ve
-00016f10: 6c6f 6369 7479 203a 6d61 7468 3a60 5c76  locity :math:`\v
-00016f20: 6563 7b5c 6e75 7d60 2074 6f20 7468 6520  ec{\nu}` to the 
-00016f30: 696d 6167 6520 706c 616e 6520 7665 6c6f  image plane velo
-00016f40: 6369 7479 0a20 2020 2020 2020 203a 6d61  city.        :ma
-00016f50: 7468 3a60 5c64 7665 637b 707d 6020 6f66  th:`\dvec{p}` of
-00016f60: 2074 6865 2070 6f69 6e74 2e0a 0a20 2020   the point...   
-00016f70: 2020 2020 2049 6620 6060 7060 6020 6465       If ``p`` de
-00016f80: 7363 7269 6265 7320 6d75 6c74 6970 6c65  scribes multiple
-00016f90: 2070 6f69 6e74 7320 7468 656e 2072 6574   points then ret
-00016fa0: 7572 6e20 6120 7374 6163 6b20 6f66 2074  urn a stack of t
-00016fb0: 6865 7365 200a 2020 2020 2020 2020 3a6d  hese .        :m
-00016fc0: 6174 683a 6032 5c74 696d 6573 2036 6020  ath:`2\times 6` 
-00016fd0: 6d61 7472 6963 6573 2c20 6f6e 6520 7065  matrices, one pe
-00016fe0: 7220 706f 696e 742e 0a20 2020 2020 2020  r point..       
-00016ff0: 200a 2020 2020 2020 2020 4465 7074 6820   .        Depth 
-00017000: 6973 2074 6865 207a 2d63 6f6d 706f 6e65  is the z-compone
-00017010: 6e74 206f 6620 7468 6520 706f 696e 7427  nt of the point'
-00017020: 7320 636f 6f72 6469 6e61 7465 2069 6e20  s coordinate in 
-00017030: 7468 6520 6361 6d65 7261 2066 7261 6d65  the camera frame
-00017040: 2e0a 2020 2020 2020 2020 4966 2060 6064  ..        If ``d
-00017050: 6570 7468 6060 2069 7320 6120 7363 616c  epth`` is a scal
-00017060: 6172 2074 6865 6e20 6974 2069 7320 7468  ar then it is th
-00017070: 6520 6465 7074 6820 666f 7220 616c 6c20  e depth for all 
-00017080: 706f 696e 7473 2e20 0a0a 2020 2020 2020  points. ..      
-00017090: 2020 4578 616d 706c 653a 0a0a 2020 2020    Example:..    
-000170a0: 2020 2020 2e2e 2072 756e 626c 6f63 6b3a      .. runblock:
-000170b0: 3a20 7079 636f 6e0a 0a20 2020 2020 2020  : pycon..       
-000170c0: 2020 2020 203e 3e3e 2066 726f 6d20 6d61       >>> from ma
-000170d0: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-000170e0: 6f78 2069 6d70 6f72 7420 4365 6e74 7261  ox import Centra
-000170f0: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-00017100: 2020 2020 3e3e 3e20 6672 6f6d 2073 7061      >>> from spa
-00017110: 7469 616c 6d61 7468 2069 6d70 6f72 7420  tialmath import 
-00017120: 5345 330a 2020 2020 2020 2020 2020 2020  SE3.            
-00017130: 3e3e 3e20 6361 6d65 7261 203d 2043 656e  >>> camera = Cen
-00017140: 7472 616c 4361 6d65 7261 2e44 6566 6175  tralCamera.Defau
-00017150: 6c74 2829 0a20 2020 2020 2020 2020 2020  lt().           
-00017160: 203e 3e3e 2063 616d 6572 612e 7669 736a   >>> camera.visj
-00017170: 6163 5f70 2828 3230 302c 2033 3030 292c  ac_p((200, 300),
-00017180: 2032 290a 0a20 2020 2020 2020 203a 7265   2)..        :re
-00017190: 6665 7265 6e63 6573 3a0a 2020 2020 2020  ferences:.      
-000171a0: 2020 2020 2020 2d20 4120 7475 746f 7269        - A tutori
-000171b0: 616c 206f 6e20 5669 7375 616c 2053 6572  al on Visual Ser
-000171c0: 766f 2043 6f6e 7472 6f6c 2c20 4875 7463  vo Control, Hutc
-000171d0: 6869 6e73 6f6e 2c20 4861 6765 7220 2620  hinson, Hager & 
-000171e0: 436f 726b 652c 200a 2020 2020 2020 2020  Corke, .        
-000171f0: 2020 2020 2020 4945 4545 2054 7261 6e73        IEEE Trans
-00017200: 2e20 5226 412c 2056 6f6c 2031 3228 3529  . R&A, Vol 12(5)
-00017210: 2c20 4f63 742c 2031 3939 362c 2070 7020  , Oct, 1996, pp 
-00017220: 3635 312d 3637 302e 0a20 2020 2020 2020  651-670..       
-00017230: 2020 2020 202d 2052 6f62 6f74 6963 732c       - Robotics,
-00017240: 2056 6973 696f 6e20 2620 436f 6e74 726f   Vision & Contro
-00017250: 6c20 666f 7220 5079 7468 6f6e 2c20 5365  l for Python, Se
-00017260: 6374 696f 6e20 3135 2e32 2e31 2c20 502e  ction 15.2.1, P.
-00017270: 2043 6f72 6b65 2c20 0a20 2020 2020 2020   Corke, .       
-00017280: 2020 2020 2020 2053 7072 696e 6765 7220         Springer 
-00017290: 3230 3233 2e0a 2020 2020 2020 2020 0a20  2023..        . 
-000172a0: 2020 2020 2020 203a 7365 6561 6c73 6f3a         :seealso:
-000172b0: 203a 6d65 7468 3a60 666c 6f77 6669 656c   :meth:`flowfiel
-000172c0: 6460 203a 6d65 7468 3a60 7669 736a 6163  d` :meth:`visjac
-000172d0: 5f70 5f70 6f6c 6172 6020 3a6d 6574 683a  _p_polar` :meth:
-000172e0: 6076 6973 6a61 635f 6c60 203a 6d65 7468  `visjac_l` :meth
-000172f0: 3a60 7669 736a 6163 5f65 600a 2020 2020  :`visjac_e`.    
-00017300: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
-00017310: 2075 7620 3d20 6261 7365 2e67 6574 6d61   uv = base.getma
-00017320: 7472 6978 2875 762c 2028 322c 204e 6f6e  trix(uv, (2, Non
-00017330: 6529 290a 2020 2020 2020 2020 5a20 3d20  e)).        Z = 
-00017340: 6465 7074 680a 0a20 2020 2020 2020 205a  depth..        Z
-00017350: 203d 2062 6173 652e 6765 7476 6563 746f   = base.getvecto
-00017360: 7228 5a29 0a20 2020 2020 2020 2069 6620  r(Z).        if 
-00017370: 6c65 6e28 5a29 203d 3d20 313a 0a20 2020  len(Z) == 1:.   
-00017380: 2020 2020 2020 2020 205a 203d 206e 702e           Z = np.
-00017390: 7265 7065 6174 285a 2c20 7576 2e73 6861  repeat(Z, uv.sha
-000173a0: 7065 5b31 5d29 0a20 2020 2020 2020 2065  pe[1]).        e
-000173b0: 6c69 6620 6c65 6e28 5a29 2021 3d20 7576  lif len(Z) != uv
-000173c0: 2e73 6861 7065 5b31 5d3a 0a20 2020 2020  .shape[1]:.     
-000173d0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-000173e0: 2056 616c 7565 4572 726f 7228 275a 206d   ValueError('Z m
-000173f0: 7573 7420 6265 2061 2073 6361 6c61 7220  ust be a scalar 
-00017400: 6f72 2068 6176 6520 7361 6d65 206e 756d  or have same num
-00017410: 6265 7220 6f66 2063 6f6c 756d 6e73 2061  ber of columns a
-00017420: 7320 7576 2729 0a20 2020 2020 2020 2020  s uv').         
-00017430: 2020 200a 2020 2020 2020 2020 4c20 3d20     .        L = 
-00017440: 6e70 2e65 6d70 7479 2828 302c 2036 2929  np.empty((0, 6))
-00017450: 2020 2320 656d 7074 7920 6d61 7472 6978    # empty matrix
-00017460: 0a0a 2020 2020 2020 2020 4b20 3d20 7365  ..        K = se
-00017470: 6c66 2e4b 0a20 2020 2020 2020 204b 696e  lf.K.        Kin
-00017480: 7620 3d20 6e70 2e6c 696e 616c 672e 696e  v = np.linalg.in
-00017490: 7628 4b29 0a20 2020 2020 2020 200a 2020  v(K).        .  
-000174a0: 2020 2020 2020 666f 7220 7a2c 2070 2069        for z, p i
-000174b0: 6e20 7a69 7028 5a2c 2075 762e 5429 3a20  n zip(Z, uv.T): 
-000174c0: 2023 2069 7465 7261 7465 206f 7665 7220   # iterate over 
-000174d0: 6561 6368 2063 6f6c 756d 6e20 2870 6f69  each column (poi
-000174e0: 6e74 290a 0a20 2020 2020 2020 2020 2020  nt)..           
-000174f0: 2023 2063 6f6e 7665 7274 2074 6f20 6e6f   # convert to no
-00017500: 726d 616c 697a 6564 2069 6d61 6765 2d70  rmalized image-p
-00017510: 6c61 6e65 2063 6f6f 7264 696e 6174 6573  lane coordinates
-00017520: 0a20 2020 2020 2020 2020 2020 2078 7920  .            xy 
-00017530: 3d20 4b69 6e76 2040 2062 6173 652e 6532  = Kinv @ base.e2
-00017540: 6828 7029 0a20 2020 2020 2020 2020 2020  h(p).           
-00017550: 2078 203d 2078 795b 302c 305d 0a20 2020   x = xy[0,0].   
-00017560: 2020 2020 2020 2020 2079 203d 2078 795b           y = xy[
-00017570: 312c 305d 0a0a 2020 2020 2020 2020 2020  1,0]..          
-00017580: 2020 2320 3278 3620 4a61 636f 6269 616e    # 2x6 Jacobian
-00017590: 2066 6f72 2074 6869 7320 706f 696e 740a   for this point.
-000175a0: 2020 2020 2020 2020 2020 2020 2320 666d              # fm
-000175b0: 743a 206f 6666 0a20 2020 2020 2020 2020  t: off.         
-000175c0: 2020 204c 7020 3d20 4b5b 3a32 2c3a 325d     Lp = K[:2,:2]
-000175d0: 2040 206e 702e 6172 7261 7928 0a20 2020   @ np.array(.   
-000175e0: 2020 2020 2020 2020 2020 2020 205b 205b               [ [
-000175f0: 2d31 2f7a 2c20 2030 2c20 2020 2020 782f  -1/z,  0,     x/
-00017600: 7a2c 2078 202a 2079 2c20 2020 2020 202d  z, x * y,      -
-00017610: 2831 202b 2078 2a2a 3229 2c20 795d 2c0a  (1 + x**2), y],.
-00017620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017630: 2020 5b20 302c 2020 202d 312f 7a2c 2020    [ 0,   -1/z,  
-00017640: 2079 2f7a 2c20 2831 202b 2079 2a2a 3229   y/z, (1 + y**2)
-00017650: 2c20 2d78 2a79 2c20 2020 2020 2020 2d78  , -x*y,       -x
-00017660: 5d20 5d29 0a20 2020 2020 2020 2020 2020  ] ]).           
-00017670: 2023 2066 6d74 3a20 6f6e 0a20 2020 2020   # fmt: on.     
-00017680: 2020 2020 2020 2023 2073 7461 636b 2074         # stack t
-00017690: 6865 6d20 7665 7274 6963 616c 6c79 0a20  hem vertically. 
-000176a0: 2020 2020 2020 2020 2020 204c 203d 206e             L = n
-000176b0: 702e 7673 7461 636b 285b 4c2c 204c 705d  p.vstack([L, Lp]
-000176c0: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-000176d0: 6e20 4c0a 0a20 2020 2064 6566 2076 6973  n L..    def vis
-000176e0: 6a61 635f 705f 706f 6c61 7228 7365 6c66  jac_p_polar(self
-000176f0: 2c20 702c 205a 293a 0a20 2020 2020 2020  , p, Z):.       
-00017700: 2072 2222 220a 2020 2020 2020 2020 5669   r""".        Vi
-00017710: 7375 616c 204a 6163 6f62 6961 6e20 666f  sual Jacobian fo
-00017720: 7220 706f 696e 7420 6665 6174 7572 6573  r point features
-00017730: 2069 6e20 706f 6c61 7220 636f 6f72 6469   in polar coordi
-00017740: 6e61 7465 730a 0a20 2020 2020 2020 203a  nates..        :
-00017750: 7061 7261 6d20 703a 2069 6d61 6765 2070  param p: image p
-00017760: 6c61 6e65 2070 6f69 6e74 206f 7220 706f  lane point or po
-00017770: 696e 7473 0a20 2020 2020 2020 203a 7479  ints.        :ty
-00017780: 7065 2070 3a20 6172 7261 795f 6c69 6b65  pe p: array_like
-00017790: 2832 292c 206e 6461 7272 6179 2832 2c4e  (2), ndarray(2,N
-000177a0: 290a 2020 2020 2020 2020 3a70 6172 616d  ).        :param
-000177b0: 2064 6570 7468 3a20 706f 696e 7420 6465   depth: point de
-000177c0: 7074 680a 2020 2020 2020 2020 3a74 7970  pth.        :typ
-000177d0: 6520 6465 7074 683a 2066 6c6f 6174 2c20  e depth: float, 
-000177e0: 6172 7261 795f 6c69 6b65 284e 290a 2020  array_like(N).  
-000177f0: 2020 2020 2020 3a72 6574 7572 6e3a 2076        :return: v
-00017800: 6973 7561 6c20 4a61 636f 6269 616e 206d  isual Jacobian m
-00017810: 6174 7269 7820 696e 2070 6f6c 6172 2063  atrix in polar c
-00017820: 6f6f 7264 696e 6174 6573 0a20 2020 2020  oordinates.     
-00017830: 2020 203a 7274 7970 653a 206e 6461 7272     :rtype: ndarr
-00017840: 6179 2832 2c36 292c 206e 6461 7272 6179  ay(2,6), ndarray
-00017850: 2832 4e2c 3629 0a0a 2020 2020 2020 2020  (2N,6)..        
-00017860: 436f 6d70 7574 6520 7468 6520 696d 6167  Compute the imag
-00017870: 6520 4a61 636f 6269 616e 203a 6d61 7468  e Jacobian :math
-00017880: 3a60 5c6d 6174 7b4a 7d60 2077 6869 6368  :`\mat{J}` which
-00017890: 206d 6170 730a 0a20 2020 2020 2020 202e   maps..        .
-000178a0: 2e20 6d61 7468 3a3a 0a0a 2020 2020 2020  . math::..      
-000178b0: 2020 2020 2020 5c62 6567 696e 7b70 6d61        \begin{pma
-000178c0: 7472 6978 7d20 5c64 6f74 7b5c 7068 697d  trix} \dot{\phi}
-000178d0: 205c 5c20 5c64 6f74 7b72 7d20 5c65 6e64   \\ \dot{r} \end
-000178e0: 7b70 6d61 7472 6978 7d20 3d20 5c6d 6174  {pmatrix} = \mat
-000178f0: 7b4a 7d28 5c76 6563 7b70 7d2c 207a 2920  {J}(\vec{p}, z) 
-00017900: 5c76 6563 7b5c 6e75 7d0a 0a20 2020 2020  \vec{\nu}..     
-00017910: 2020 2063 616d 6572 6120 7370 6174 6961     camera spatia
-00017920: 6c20 7665 6c6f 6369 7479 203a 6d61 7468  l velocity :math
-00017930: 3a60 5c76 6563 7b5c 6e75 7d60 2074 6f20  :`\vec{\nu}` to 
-00017940: 7468 6520 696d 6167 6520 706c 616e 6520  the image plane 
-00017950: 7665 6c6f 6369 7479 0a20 2020 2020 2020  velocity.       
-00017960: 206f 6620 7468 6520 706f 696e 7420 6578   of the point ex
-00017970: 7072 6573 7365 6420 696e 2070 6f6c 6172  pressed in polar
-00017980: 2063 6f6f 7264 696e 6174 6520 666f 726d   coordinate form
-00017990: 203a 6d61 7468 3a60 285c 7068 692c 2072   :math:`(\phi, r
-000179a0: 2960 2e0a 0a20 2020 2020 2020 2049 6620  )`...        If 
-000179b0: 6060 7060 6020 6465 7363 7269 6265 7320  ``p`` describes 
-000179c0: 6d75 6c74 6970 6c65 2070 6f69 6e74 7320  multiple points 
-000179d0: 7468 656e 2072 6574 7572 6e20 6120 7374  then return a st
-000179e0: 6163 6b20 6f66 2074 6865 7365 200a 2020  ack of these .  
-000179f0: 2020 2020 2020 3a6d 6174 683a 6032 5c74        :math:`2\t
-00017a00: 696d 6573 2036 6020 6d61 7472 6963 6573  imes 6` matrices
-00017a10: 2c20 6f6e 6520 7065 7220 706f 696e 742e  , one per point.
-00017a20: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-00017a30: 2020 4465 7074 6820 6973 2074 6865 207a    Depth is the z
-00017a40: 2d63 6f6d 706f 6e65 6e74 206f 6620 7468  -component of th
-00017a50: 6520 706f 696e 7427 7320 636f 6f72 6469  e point's coordi
-00017a60: 6e61 7465 2069 6e20 7468 6520 6361 6d65  nate in the came
-00017a70: 7261 2066 7261 6d65 2e0a 2020 2020 2020  ra frame..      
-00017a80: 2020 4966 2060 6064 6570 7468 6060 2069    If ``depth`` i
-00017a90: 7320 6120 7363 616c 6172 2074 6865 6e20  s a scalar then 
-00017aa0: 6974 2069 7320 7468 6520 6465 7074 6820  it is the depth 
-00017ab0: 666f 7220 616c 6c20 706f 696e 7473 2e20  for all points. 
-00017ac0: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-00017ad0: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
-00017ae0: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
-00017af0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
-00017b00: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
-00017b10: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
-00017b20: 7420 4365 6e74 7261 6c43 616d 6572 610a  t CentralCamera.
-00017b30: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-00017b40: 6672 6f6d 2073 7061 7469 616c 6d61 7468  from spatialmath
-00017b50: 2069 6d70 6f72 7420 5345 330a 2020 2020   import SE3.    
-00017b60: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
-00017b70: 7261 203d 2043 656e 7472 616c 4361 6d65  ra = CentralCame
-00017b80: 7261 2e44 6566 6175 6c74 2829 0a20 2020  ra.Default().   
-00017b90: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
-00017ba0: 6572 612e 7669 736a 6163 5f70 5f70 6f6c  era.visjac_p_pol
-00017bb0: 6172 2828 3230 302c 2033 3030 292c 2032  ar((200, 300), 2
-00017bc0: 290a 0a20 2020 2020 2020 203a 7265 6665  )..        :refe
-00017bd0: 7265 6e63 6573 3a0a 2020 2020 2020 2020  rences:.        
-00017be0: 2020 2020 2d20 436f 6d62 696e 696e 6720      - Combining 
-00017bf0: 4361 7274 6573 6961 6e20 616e 6420 706f  Cartesian and po
-00017c00: 6c61 7220 636f 6f72 6469 6e61 7465 7320  lar coordinates 
-00017c10: 696e 2049 4256 532e 200a 2020 2020 2020  in IBVS. .      
-00017c20: 2020 2020 2020 2020 436f 726b 6520 5049          Corke PI
-00017c30: 2c20 5370 696e 646c 6572 2046 2c20 4368  , Spindler F, Ch
-00017c40: 6175 6d65 7474 6520 4620 0a20 2020 2020  aumette F .     
-00017c50: 2020 2020 2020 2020 2049 524f 5320 3230           IROS 20
-00017c60: 3039 2c20 7070 2035 3936 32e2 8093 3539  09, pp 5962...59
-00017c70: 3637 0a20 2020 2020 2020 2020 2020 202d  67.            -
-00017c80: 2052 6f62 6f74 6963 732c 2056 6973 696f   Robotics, Visio
-00017c90: 6e20 2620 436f 6e74 726f 6c20 666f 7220  n & Control for 
-00017ca0: 5079 7468 6f6e 2c20 5365 6374 696f 6e20  Python, Section 
-00017cb0: 3136 2e32 2050 2e20 436f 726b 652c 200a  16.2 P. Corke, .
-00017cc0: 2020 2020 2020 2020 2020 2020 2020 5370                Sp
-00017cd0: 7269 6e67 6572 2032 3032 332e 0a20 2020  ringer 2023..   
-00017ce0: 2020 2020 200a 2020 2020 2020 2020 3a73       .        :s
-00017cf0: 6565 616c 736f 3a20 3a6d 6574 683a 6076  eealso: :meth:`v
-00017d00: 6973 6a61 635f 7060 203a 6d65 7468 3a60  isjac_p` :meth:`
-00017d10: 7669 736a 6163 5f6c 6020 3a6d 6574 683a  visjac_l` :meth:
-00017d20: 6076 6973 6a61 635f 6560 0a20 2020 2020  `visjac_e`.     
-00017d30: 2020 2022 2222 0a0a 2020 2020 2020 2020     """..        
-00017d40: 4a20 3d20 5b5d 0a20 2020 2020 2020 2070  J = [].        p
-00017d50: 203d 2073 6d62 6173 652e 6765 746d 6174   = smbase.getmat
-00017d60: 7269 7828 702c 2028 322c 204e 6f6e 6529  rix(p, (2, None)
-00017d70: 290a 2020 2020 2020 2020 6620 3d20 7365  ).        f = se
-00017d80: 6c66 2e66 5b30 5d0a 0a20 2020 2020 2020  lf.f[0]..       
-00017d90: 2069 6620 736d 6261 7365 2e69 7373 6361   if smbase.issca
-00017da0: 6c61 7228 5a29 3a0a 2020 2020 2020 2020  lar(Z):.        
-00017db0: 2020 2020 5a20 3d20 5b5a 5d20 2a20 702e      Z = [Z] * p.
-00017dc0: 7368 6170 655b 315d 0a0a 2020 2020 2020  shape[1]..      
-00017dd0: 2020 666f 7220 2870 6869 2c20 7229 2c20    for (phi, r), 
-00017de0: 5a6b 2069 6e20 7a69 7028 702e 542c 205a  Zk in zip(p.T, Z
-00017df0: 293a 0a0a 2020 2020 2020 2020 2020 2020  ):..            
-00017e00: 2320 6b20 3d20 2866 2a2a 3220 2b20 722a  # k = (f**2 + r*
-00017e10: 2a32 2920 2f20 660a 2020 2020 2020 2020  *2) / f.        
-00017e20: 2020 2020 2320 6b32 203d 2066 202f 2028      # k2 = f / (
-00017e30: 7220 2a20 5a6b 290a 0a20 2020 2020 2020  r * Zk)..       
-00017e40: 2020 2020 2063 203d 206e 702e 636f 7328       c = np.cos(
-00017e50: 7068 6929 0a20 2020 2020 2020 2020 2020  phi).           
-00017e60: 2073 203d 206e 702e 7369 6e28 7068 6929   s = np.sin(phi)
-00017e70: 0a20 2020 2020 2020 2020 2020 200a 2020  .            .  
-00017e80: 2020 2020 2020 2020 2020 7220 3d20 6d61            r = ma
-00017e90: 7828 722c 2030 2e30 3529 0a20 2020 2020  x(r, 0.05).     
-00017ea0: 2020 2020 2020 204a 6b20 3d20 6e70 2e61         Jk = np.a
-00017eb0: 7272 6179 285b 0a20 2020 2020 2020 2020  rray([.         
-00017ec0: 2020 2020 2020 205b 202d 732f 722f 5a6b         [ -s/r/Zk
-00017ed0: 2c20 632f 722f 5a6b 2c20 302c 202d 632f  , c/r/Zk, 0, -c/
-00017ee0: 722c 202d 732f 722c 2031 5d2c 0a20 2020  r, -s/r, 1],.   
-00017ef0: 2020 2020 2020 2020 2020 2020 205b 632f               [c/
-00017f00: 5a6b 2c20 732f 5a6b 2c20 2d72 2f5a 6b2c  Zk, s/Zk, -r/Zk,
-00017f10: 202d 2831 2b72 2a2a 3229 2a73 2c20 2831   -(1+r**2)*s, (1
-00017f20: 2b72 2a2a 3229 2a63 2c20 305d 0a20 2020  +r**2)*c, 0].   
-00017f30: 2020 2020 2020 2020 205d 290a 0a20 2020           ])..   
-00017f40: 2020 2020 2020 2020 2023 204a 6b20 3d20           # Jk = 
-00017f50: 6e70 2e61 7272 6179 285b 0a20 2020 2020  np.array([.     
-00017f60: 2020 2020 2020 2023 2020 2020 205b 2020         #     [  
-00017f70: 2020 206b 3220 2a20 7374 682c 2020 2020     k2 * sth,    
-00017f80: 202d 6b32 202a 2063 7468 2c20 2020 2020   -k2 * cth,     
-00017f90: 2030 2c20 6620 2f20 7220 2a20 6374 682c   0, f / r * cth,
-00017fa0: 2066 202f 2072 202a 2073 7468 202c 202d   f / r * sth , -
-00017fb0: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
-00017fc0: 2320 2020 2020 5b2d 6620 2f20 5a6b 202a  #     [-f / Zk *
-00017fd0: 2063 7468 2c20 2d66 202f 205a 6b20 2a20   cth, -f / Zk * 
-00017fe0: 7374 682c 2072 202f 205a 6b2c 2020 2020  sth, r / Zk,    
-00017ff0: 206b 202a 2073 7468 2c20 2020 2020 2d6b   k * sth,     -k
-00018000: 202a 2063 7468 2c20 2030 5d2c 0a20 2020   * cth,  0],.   
-00018010: 2020 2020 2020 2020 2023 2020 2020 205d           #     ]
-00018020: 290a 2020 2020 2020 2020 2020 2020 2320  ).            # 
-00018030: 4a6b 203d 206e 702e 6172 7261 7928 5b0a  Jk = np.array([.
-00018040: 2020 2020 2020 2020 2020 2020 2320 2020              #   
-00018050: 2020 5b63 7468 2f5a 6b20 2c20 7374 6820    [cth/Zk , sth 
-00018060: 2f20 5a6b 2c20 2d72 202f 205a 6b2c 2020  / Zk, -r / Zk,  
-00018070: 202d 2831 2b72 2a2a 3229 202a 2073 7468   -(1+r**2) * sth
-00018080: 2c20 2020 2020 2d6b 202a 2063 7468 2c20  ,     -k * cth, 
-00018090: 2030 5d2c 0a20 2020 2020 2020 2020 2020   0],.           
-000180a0: 2023 2020 2020 205b 2020 2020 206b 3220   #     [     k2 
-000180b0: 2a20 7374 682c 2020 2020 202d 6b32 202a  * sth,     -k2 *
-000180c0: 2063 7468 2c20 2020 2020 2030 2c20 6620   cth,      0, f 
-000180d0: 2f20 7220 2a20 6374 682c 2066 202f 2072  / r * cth, f / r
-000180e0: 202a 2073 7468 202c 202d 315d 5d29 0a0a   * sth , -1]])..
-000180f0: 2020 2020 2020 2020 2020 2020 4a2e 6170              J.ap
-00018100: 7065 6e64 284a 6b29 0a0a 2020 2020 2020  pend(Jk)..      
-00018110: 2020 7265 7475 726e 206e 702e 7673 7461    return np.vsta
-00018120: 636b 284a 290a 0a20 2020 2020 2020 2023  ck(J)..        #
-00018130: 2069 6620 300a 2020 2020 2020 2020 2320   if 0.        # 
-00018140: 7220 3d20 7274 2831 293b 2074 6865 7461  r = rt(1); theta
-00018150: 203d 2072 7428 3229 3b0a 0a20 2020 2020   = rt(2);..     
-00018160: 2020 2023 2025 2063 6f6d 7075 7465 2074     # % compute t
-00018170: 6865 206d 6170 7069 6e67 2066 726f 6d20  he mapping from 
-00018180: 7576 2d64 6f74 2074 6f20 722d 7468 6574  uv-dot to r-thet
-00018190: 6120 646f 7420 0a20 2020 2020 2020 2023  a dot .        #
-000181a0: 204d 203d 2031 2f72 202a 205b 722a 636f   M = 1/r * [r*co
-000181b0: 7328 7468 6574 6129 2072 2a73 696e 2874  s(theta) r*sin(t
-000181c0: 6865 7461 293b 202d 7369 6e28 7468 6574  heta); -sin(thet
-000181d0: 6129 2063 6f73 2874 6865 7461 295d 3b0a  a) cos(theta)];.
-000181e0: 0a20 2020 2020 2020 2023 2025 2063 6f6e  .        # % con
-000181f0: 7665 7274 2072 2d74 6865 7461 2066 6f72  vert r-theta for
-00018200: 6d20 746f 2075 7620 666f 726d 0a20 2020  m to uv form.   
-00018210: 2020 2020 2023 2075 203d 2072 202a 2063       # u = r * c
-00018220: 6f73 2874 6865 7461 293b 2076 203d 2072  os(theta); v = r
-00018230: 202a 2073 696e 2874 6865 7461 293b 0a0a   * sin(theta);..
-00018240: 2020 2020 2020 2020 2320 2520 636f 6d70          # % comp
-00018250: 7574 6520 7468 6520 4a61 636f 6269 616e  ute the Jacobian
-00018260: 0a20 2020 2020 2020 2023 204a 203d 204d  .        # J = M
-00018270: 202a 2063 616d 2e76 6973 6a61 635f 7028   * cam.visjac_p(
-00018280: 5b75 3b20 765d 2c20 5a29 3b0a 0a0a 2020  [u; v], Z);...  
-00018290: 2020 6465 6620 7669 736a 6163 5f6c 2873    def visjac_l(s
-000182a0: 656c 662c 206c 696e 6573 2c20 706c 616e  elf, lines, plan
-000182b0: 6529 3a0a 2020 2020 2020 2020 7222 2222  e):.        r"""
-000182c0: 0a20 2020 2020 2020 2056 6973 7561 6c20  .        Visual 
-000182d0: 4a61 636f 6269 616e 2066 6f72 206c 696e  Jacobian for lin
-000182e0: 6520 6665 6174 7572 6573 0a0a 2020 2020  e features..    
-000182f0: 2020 2020 3a70 6172 616d 206c 696e 6573      :param lines
-00018300: 3a20 696d 6167 6520 706c 616e 6520 6c69  : image plane li
-00018310: 6e65 2070 6172 616d 6574 6572 730a 2020  ne parameters.  
-00018320: 2020 2020 2020 3a74 7970 6520 703a 2061        :type p: a
-00018330: 7272 6179 5f6c 696b 6528 3229 2c20 6e64  rray_like(2), nd
-00018340: 6172 7261 7928 322c 4e29 0a20 2020 2020  array(2,N).     
-00018350: 2020 203a 7061 7261 6d20 706c 616e 653a     :param plane:
-00018360: 2070 6c61 6e65 2063 6f6e 7461 696e 696e   plane containin
-00018370: 6720 7468 6520 6c69 6e65 0a20 2020 2020  g the line.     
-00018380: 2020 203a 7479 7065 2070 6c61 6e65 3a20     :type plane: 
-00018390: 6172 7261 795f 6c69 6b65 2834 290a 2020  array_like(4).  
-000183a0: 2020 2020 2020 3a72 6574 7572 6e3a 2076        :return: v
-000183b0: 6973 7561 6c20 4a61 636f 6269 616e 206d  isual Jacobian m
-000183c0: 6174 7269 7820 666f 7220 6c69 6e65 2066  atrix for line f
-000183d0: 6561 7475 7265 0a20 2020 2020 2020 203a  eature.        :
-000183e0: 7274 7970 653a 206e 6461 7272 6179 2832  rtype: ndarray(2
-000183f0: 2c36 292c 206e 6461 7272 6179 2832 4e2c  ,6), ndarray(2N,
-00018400: 3629 0a0a 2020 2020 2020 2020 436f 6d70  6)..        Comp
-00018410: 7574 6520 7468 6520 4a61 636f 6269 616e  ute the Jacobian
-00018420: 2077 6869 6368 2067 6976 6573 2074 6865   which gives the
-00018430: 2072 6174 6573 206f 6620 6368 616e 6765   rates of change
-00018440: 206f 6620 7468 6520 6c69 6e65 0a20 2020   of the line.   
-00018450: 2020 2020 2070 6172 616d 6574 6572 7320       parameters 
-00018460: 696e 2074 6572 6d73 206f 6620 6361 6d65  in terms of came
-00018470: 7261 2073 7061 7469 616c 2076 656c 6f63  ra spatial veloc
-00018480: 6974 792e 200a 0a20 2020 2020 2020 2046  ity. ..        F
-00018490: 6f72 2069 6d61 6765 2070 6c61 6e65 7320  or image planes 
-000184a0: 6c69 6e65 730a 2020 2020 2020 2020 0a20  lines.        . 
-000184b0: 2020 2020 2020 202e 2e20 6d61 7468 3a3a         .. math::
-000184c0: 2075 205c 636f 7320 5c74 6865 7461 202b   u \cos \theta +
-000184d0: 2076 205c 7369 6e20 5c74 6865 7461 203d   v \sin \theta =
-000184e0: 205c 7268 6f0a 2020 2020 2020 2020 0a20   \rho.        . 
-000184f0: 2020 2020 2020 2074 6865 2069 6d61 6765         the image
-00018500: 204a 6163 6f62 6961 6e20 3a6d 6174 683a   Jacobian :math:
-00018510: 605c 6d61 747b 4a7d 6020 6d61 7073 0a0a  `\mat{J}` maps..
-00018520: 2020 2020 2020 2020 2e2e 206d 6174 683a          .. math:
-00018530: 3a0a 0a20 2020 2020 2020 2020 2020 205c  :..            \
-00018540: 6265 6769 6e7b 706d 6174 7269 787d 205c  begin{pmatrix} \
-00018550: 646f 747b 5c74 6865 7461 7d20 5c5c 205c  dot{\theta} \\ \
-00018560: 646f 747b 5c72 686f 7d20 5c65 6e64 7b70  dot{\rho} \end{p
-00018570: 6d61 7472 6978 7d20 3d20 5c6d 6174 7b4a  matrix} = \mat{J
-00018580: 7d28 5c76 6563 7b70 7d2c 207a 2920 5c76  }(\vec{p}, z) \v
-00018590: 6563 7b5c 6e75 7d0a 0a20 2020 2020 2020  ec{\nu}..       
-000185a0: 2063 616d 6572 6120 7370 6174 6961 6c20   camera spatial 
-000185b0: 7665 6c6f 6369 7479 203a 6d61 7468 3a60  velocity :math:`
-000185c0: 5c76 6563 7b5c 6e75 7d60 2074 6f20 7468  \vec{\nu}` to th
-000185d0: 6520 696d 6167 6520 706c 616e 6520 7665  e image plane ve
-000185e0: 6c6f 6369 7479 0a20 2020 2020 2020 206f  locity.        o
-000185f0: 6620 7468 6520 6c69 6e65 2070 6172 616d  f the line param
-00018600: 6574 6572 7320 3a6d 6174 683a 6028 5c74  eters :math:`(\t
-00018610: 6865 7461 2c20 5c72 686f 2960 2e0a 0a20  heta, \rho)`... 
-00018620: 2020 2020 2020 2054 6865 2077 6f72 6c64         The world
-00018630: 2070 6c61 6e65 2063 6f6e 7461 696e 696e   plane containin
-00018640: 6720 7468 6520 6c69 6e65 2069 7320 616c  g the line is al
-00018650: 736f 2072 6571 7569 7265 642c 2061 6e64  so required, and
-00018660: 2069 7320 7072 6f76 6964 6564 0a20 2020   is provided.   
-00018670: 2020 2020 2061 7320 6120 7665 6374 6f72       as a vector
-00018680: 203a 6d61 7468 3a60 2861 2c62 2c63 2c64   :math:`(a,b,c,d
-00018690: 2960 2073 7563 6820 7468 6174 0a0a 2020  )` such that..  
-000186a0: 2020 2020 2020 2e2e 206d 6174 683a 2061        .. math: a
-000186b0: 5820 2b20 6259 202b 635a 202b 2064 203d  X + bY +cZ + d =
-000186c0: 2030 0a0a 2020 2020 2020 2020 4966 2060   0..        If `
-000186d0: 606c 696e 6573 6060 2064 6573 6372 6962  `lines`` describ
-000186e0: 6573 206d 756c 7469 706c 6520 706f 696e  es multiple poin
-000186f0: 7473 2074 6865 6e20 7265 7475 726e 2061  ts then return a
-00018700: 2073 7461 636b 206f 6620 7468 6573 6520   stack of these 
-00018710: 0a20 2020 2020 2020 203a 6d61 7468 3a60  .        :math:`
-00018720: 325c 7469 6d65 7320 3660 206d 6174 7269  2\times 6` matri
-00018730: 6365 732c 206f 6e65 2070 6572 2070 6f69  ces, one per poi
-00018740: 6e74 2e0a 2020 2020 2020 2020 0a20 2020  nt..        .   
-00018750: 2020 2020 2044 6570 7468 2069 7320 7468       Depth is th
-00018760: 6520 7a2d 636f 6d70 6f6e 656e 7420 6f66  e z-component of
-00018770: 2074 6865 2070 6f69 6e74 2773 2063 6f6f   the point's coo
-00018780: 7264 696e 6174 6520 696e 2074 6865 2063  rdinate in the c
-00018790: 616d 6572 6120 6672 616d 652e 0a20 2020  amera frame..   
-000187a0: 2020 2020 2049 6620 6060 6465 7074 6860       If ``depth`
-000187b0: 6020 6973 2061 2073 6361 6c61 7220 7468  ` is a scalar th
-000187c0: 656e 2069 7420 6973 2074 6865 2064 6570  en it is the dep
-000187d0: 7468 2066 6f72 2061 6c6c 2070 6f69 6e74  th for all point
-000187e0: 732e 200a 0a20 2020 2020 2020 2045 7861  s. ..        Exa
-000187f0: 6d70 6c65 3a0a 0a20 2020 2020 2020 202e  mple:..        .
-00018800: 2e20 7275 6e62 6c6f 636b 3a3a 2070 7963  . runblock:: pyc
-00018810: 6f6e 0a0a 2020 2020 2020 2020 2020 2020  on..            
-00018820: 3e3e 3e20 6672 6f6d 206d 6163 6869 6e65  >>> from machine
-00018830: 7669 7369 6f6e 746f 6f6c 626f 7820 696d  visiontoolbox im
-00018840: 706f 7274 2043 656e 7472 616c 4361 6d65  port CentralCame
-00018850: 7261 0a20 2020 2020 2020 2020 2020 203e  ra.            >
-00018860: 3e3e 2066 726f 6d20 7370 6174 6961 6c6d  >> from spatialm
-00018870: 6174 6820 696d 706f 7274 2053 4533 0a20  ath import SE3. 
-00018880: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
-00018890: 616d 6572 6120 3d20 4365 6e74 7261 6c43  amera = CentralC
-000188a0: 616d 6572 612e 4465 6661 756c 7428 290a  amera.Default().
-000188b0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
-000188c0: 6361 6d65 7261 2e76 6973 6a61 635f 6c28  camera.visjac_l(
-000188d0: 2830 2e32 2c20 3530 3029 2c20 2830 2c20  (0.2, 500), (0, 
-000188e0: 302c 2031 2c20 2d33 2929 0a0a 2020 2020  0, 1, -3))..    
-000188f0: 2020 2020 3a72 6566 6572 656e 6365 733a      :references:
-00018900: 0a20 2020 2020 2020 2020 2020 202d 2041  .            - A
-00018910: 204e 6577 2041 7070 726f 6163 6820 746f   New Approach to
-00018920: 2056 6973 7561 6c20 5365 7276 6f69 6e67   Visual Servoing
-00018930: 2069 6e20 526f 626f 7469 6373 2c0a 2020   in Robotics,.  
-00018940: 2020 2020 2020 2020 2020 2020 422e 2045              B. E
-00018950: 7370 6961 752c 2046 2e20 4368 6175 6d65  spiau, F. Chaume
-00018960: 7474 652c 2061 6e64 2050 2e20 5269 7665  tte, and P. Rive
-00018970: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
-00018980: 2049 4545 4520 5472 616e 7361 6374 696f   IEEE Transactio
-00018990: 6e73 206f 6e20 526f 626f 7469 6373 2061  ns on Robotics a
-000189a0: 6e64 2041 7574 6f6d 6174 696f 6e2c 200a  nd Automation, .
-000189b0: 2020 2020 2020 2020 2020 2020 2020 766f                vo
-000189c0: 6c2e 2038 2c20 7070 2e20 3331 332d 3332  l. 8, pp. 313-32
-000189d0: 362c 204a 756e 6520 3139 3932 2e0a 2020  6, June 1992..  
-000189e0: 2020 2020 2020 2020 2020 2d20 5669 7375            - Visu
-000189f0: 616c 2073 6572 766f 2063 6f6e 7472 6f6c  al servo control
-00018a00: 2032 3a20 4164 7661 6e63 6564 2061 7070   2: Advanced app
-00018a10: 726f 6163 6865 730a 2020 2020 2020 2020  roaches.        
-00018a20: 2020 2020 2020 4368 6175 6d65 7474 6520        Chaumette 
-00018a30: 462c 2048 7574 6368 696e 736f 6e20 532c  F, Hutchinson S,
-00018a40: 0a20 2020 2020 2020 2020 2020 2020 2049  .              I
-00018a50: 4545 4520 526f 626f 7420 4175 746f 6d20  EEE Robot Autom 
-00018a60: 4d61 6720 3134 2831 293a 3130 39e2 8093  Mag 14(1):109...
-00018a70: 3131 3820 2832 3030 3729 0a20 2020 2020  118 (2007).     
-00018a80: 2020 2020 2020 202d 2052 6f62 6f74 6963         - Robotic
-00018a90: 732c 2056 6973 696f 6e20 2620 436f 6e74  s, Vision & Cont
-00018aa0: 726f 6c20 666f 7220 5079 7468 6f6e 2c20  rol for Python, 
-00018ab0: 5365 6374 696f 6e20 3135 2e33 2e31 2c20  Section 15.3.1, 
-00018ac0: 502e 2043 6f72 6b65 2c20 0a20 2020 2020  P. Corke, .     
-00018ad0: 2020 2020 2020 2020 2053 7072 696e 6765           Springe
-00018ae0: 7220 3230 3233 2e0a 2020 2020 2020 2020  r 2023..        
-00018af0: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
-00018b00: 6f3a 203a 6d65 7468 3a60 7669 736a 6163  o: :meth:`visjac
-00018b10: 5f70 6020 3a6d 6574 683a 6076 6973 6a61  _p` :meth:`visja
-00018b20: 635f 705f 706f 6c61 7260 203a 6d65 7468  c_p_polar` :meth
-00018b30: 3a60 7669 736a 6163 5f65 600a 2020 2020  :`visjac_e`.    
-00018b40: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
-00018b50: 2061 2c20 622c 2063 2c20 6420 3d20 706c   a, b, c, d = pl
-00018b60: 616e 650a 0a20 2020 2020 2020 206c 696e  ane..        lin
-00018b70: 6573 203d 2073 6d62 6173 652e 6765 746d  es = smbase.getm
-00018b80: 6174 7269 7828 6c69 6e65 732c 2028 322c  atrix(lines, (2,
-00018b90: 204e 6f6e 6529 290a 2020 2020 2020 2020   None)).        
-00018ba0: 6a61 6320 3d20 5b5d 0a20 2020 2020 2020  jac = [].       
-00018bb0: 2066 6f72 2074 6865 7461 2c20 7268 6f20   for theta, rho 
-00018bc0: 696e 206c 696e 6573 2e54 3a0a 2020 2020  in lines.T:.    
-00018bd0: 2020 2020 2020 2020 7374 6820 3d20 6e70          sth = np
-00018be0: 2e73 696e 2874 6865 7461 290a 2020 2020  .sin(theta).    
-00018bf0: 2020 2020 2020 2020 6374 6820 3d20 6e70          cth = np
-00018c00: 2e63 6f73 2874 6865 7461 290a 0a20 2020  .cos(theta)..   
-00018c10: 2020 2020 2020 2020 206c 616d 5f74 6820           lam_th 
-00018c20: 3d20 2861 2a73 7468 202d 2062 2a63 7468  = (a*sth - b*cth
-00018c30: 2029 202f 2064 0a20 2020 2020 2020 2020   ) / d.         
-00018c40: 2020 206c 616d 5f72 686f 203d 2028 612a     lam_rho = (a*
-00018c50: 7268 6f2a 6374 6820 2b20 622a 7268 6f2a  rho*cth + b*rho*
-00018c60: 7374 6820 2b20 6329 202f 2064 0a0a 2020  sth + c) / d..  
-00018c70: 2020 2020 2020 2020 2020 4c20 3d20 6e70            L = np
-00018c80: 2e61 7272 6179 285b 0a20 2020 2020 2020  .array([.       
-00018c90: 2020 2020 2020 2020 205b 6c61 6d5f 7468           [lam_th
-00018ca0: 2a63 7468 2c20 6c61 6d5f 7468 2a73 7468  *cth, lam_th*sth
-00018cb0: 2c20 202d 6c61 6d5f 7468 2a72 686f 2c20  ,  -lam_th*rho, 
-00018cc0: 2d72 686f 2a63 7468 2c20 2d72 686f 2a73  -rho*cth, -rho*s
-00018cd0: 7468 2c20 2d31 5d2c 0a20 2020 2020 2020  th, -1],.       
-00018ce0: 2020 2020 2020 2020 205b 6c61 6d5f 7268           [lam_rh
-00018cf0: 6f2a 6374 682c 206c 616d 5f72 686f 2a73  o*cth, lam_rho*s
-00018d00: 7468 2c20 2d6c 616d 5f72 686f 2a72 686f  th, -lam_rho*rho
-00018d10: 2c20 2831 202b 2072 686f 2a2a 3229 2a73  , (1 + rho**2)*s
-00018d20: 7468 2c20 2d28 3120 2b20 7268 6f2a 2a32  th, -(1 + rho**2
-00018d30: 292a 6374 682c 2030 5d0a 2020 2020 2020  )*cth, 0].      
-00018d40: 2020 2020 2020 2020 2020 5d29 0a20 2020            ]).   
-00018d50: 2020 2020 2020 2020 206a 6163 2e61 7070           jac.app
-00018d60: 656e 6428 4c29 0a0a 2020 2020 2020 2020  end(L)..        
-00018d70: 7265 7475 726e 206e 702e 7673 7461 636b  return np.vstack
-00018d80: 286a 6163 2920 2020 200a 0a0a 2020 2020  (jac)    ...    
-00018d90: 6465 6620 7669 736a 6163 5f65 2873 656c  def visjac_e(sel
-00018da0: 662c 2045 2c20 706c 616e 6529 3a0a 2020  f, E, plane):.  
-00018db0: 2020 2020 2020 7222 2222 0a20 2020 2020        r""".     
-00018dc0: 2020 2056 6973 7561 6c20 4a61 636f 6269     Visual Jacobi
-00018dd0: 616e 2066 6f72 2065 6c6c 6970 7365 2066  an for ellipse f
-00018de0: 6561 7475 7265 730a 0a20 2020 2020 2020  eatures..       
-00018df0: 203a 7061 7261 6d20 453a 2069 6d61 6765   :param E: image
-00018e00: 2070 6c61 6e65 2065 6c6c 6970 7365 2070   plane ellipse p
-00018e10: 6172 616d 6574 6572 730a 2020 2020 2020  arameters.      
-00018e20: 2020 3a74 7970 6520 453a 2061 7272 6179    :type E: array
-00018e30: 5f6c 696b 6528 3529 2c20 6e64 6172 7261  _like(5), ndarra
-00018e40: 7928 352c 4e29 0a20 2020 2020 2020 203a  y(5,N).        :
-00018e50: 7061 7261 6d20 706c 616e 653a 2070 6c61  param plane: pla
-00018e60: 6e65 2063 6f6e 7461 696e 696e 6720 7468  ne containing th
-00018e70: 6520 656c 6c69 7073 650a 2020 2020 2020  e ellipse.      
-00018e80: 2020 3a74 7970 6520 706c 616e 653a 2061    :type plane: a
-00018e90: 7272 6179 5f6c 696b 6528 3429 0a20 2020  rray_like(4).   
-00018ea0: 2020 2020 203a 7265 7475 726e 3a20 7669       :return: vi
-00018eb0: 7375 616c 204a 6163 6f62 6961 6e20 6d61  sual Jacobian ma
-00018ec0: 7472 6978 2066 6f72 2065 6c6c 6970 7365  trix for ellipse
-00018ed0: 2066 6561 7475 7265 0a20 2020 2020 2020   feature.       
-00018ee0: 203a 7274 7970 653a 206e 6461 7272 6179   :rtype: ndarray
-00018ef0: 2832 2c36 292c 206e 6461 7272 6179 2832  (2,6), ndarray(2
-00018f00: 4e2c 3629 0a0a 2020 2020 2020 2020 436f  N,6)..        Co
-00018f10: 6d70 7574 6520 7468 6520 4a61 636f 6269  mpute the Jacobi
-00018f20: 616e 2067 6976 6573 2074 6865 2072 6174  an gives the rat
-00018f30: 6573 206f 6620 6368 616e 6765 206f 6620  es of change of 
-00018f40: 7468 6520 656c 6c69 7073 6520 7061 7261  the ellipse para
-00018f50: 6d65 7465 7273 0a20 2020 2020 2020 2069  meters.        i
-00018f60: 6e20 7465 726d 7320 6f66 2063 616d 6572  n terms of camer
-00018f70: 6120 7370 6174 6961 6c20 7665 6c6f 6369  a spatial veloci
-00018f80: 7479 2e20 0a0a 2020 2020 2020 2020 466f  ty. ..        Fo
-00018f90: 7220 696d 6167 6520 706c 616e 6520 656c  r image plane el
-00018fa0: 6c69 7073 6573 0a20 2020 2020 2020 200a  lipses.        .
-00018fb0: 2020 2020 2020 2020 2e2e 206d 6174 683a          .. math:
-00018fc0: 3a20 755e 3220 2b20 455f 3020 765e 3220  : u^2 + E_0 v^2 
-00018fd0: 2d32 2045 5f31 2075 2076 202b 2032 2045  -2 E_1 u v + 2 E
-00018fe0: 5f32 2075 202b 2032 2045 5f33 2076 202b  _2 u + 2 E_3 v +
-00018ff0: 2045 5f34 203d 2030 0a20 2020 2020 2020   E_4 = 0.       
-00019000: 200a 2020 2020 2020 2020 7468 6520 696d   .        the im
-00019010: 6167 6520 4a61 636f 6269 616e 203a 6d61  age Jacobian :ma
-00019020: 7468 3a60 5c6d 6174 7b4a 7d60 206d 6170  th:`\mat{J}` map
-00019030: 730a 0a20 2020 2020 2020 202e 2e20 6d61  s..        .. ma
-00019040: 7468 3a3a 0a0a 2020 2020 2020 2020 2020  th::..          
-00019050: 2020 5c62 6567 696e 7b70 6d61 7472 6978    \begin{pmatrix
-00019060: 7d20 5c64 6f74 7b45 5f30 7d20 5c5c 205c  } \dot{E_0} \\ \
-00019070: 7664 6f74 7320 5c5c 205c 646f 747b 455f  vdots \\ \dot{E_
-00019080: 347d 205c 656e 647b 706d 6174 7269 787d  4} \end{pmatrix}
-00019090: 203d 205c 6d61 747b 4a7d 285c 7665 637b   = \mat{J}(\vec{
-000190a0: 707d 2c20 7a29 205c 7665 637b 5c6e 757d  p}, z) \vec{\nu}
-000190b0: 0a0a 2020 2020 2020 2020 6361 6d65 7261  ..        camera
-000190c0: 2073 7061 7469 616c 2076 656c 6f63 6974   spatial velocit
-000190d0: 7920 3a6d 6174 683a 605c 7665 637b 5c6e  y :math:`\vec{\n
-000190e0: 757d 6020 746f 2074 6865 2076 656c 6f63  u}` to the veloc
-000190f0: 6974 790a 2020 2020 2020 2020 6f66 2074  ity.        of t
-00019100: 6865 2065 6c6c 6970 7365 2070 6172 616d  he ellipse param
-00019110: 6574 6572 7320 3a6d 6174 683a 6028 455f  eters :math:`(E_
-00019120: 3020 5c6c 646f 7473 2045 5f34 2960 2e0a  0 \ldots E_4)`..
-00019130: 0a20 2020 2020 2020 2054 6865 2077 6f72  .        The wor
-00019140: 6c64 2070 6c61 6e65 2063 6f6e 7461 696e  ld plane contain
-00019150: 696e 6720 7468 6520 656c 6c69 7073 6520  ing the ellipse 
-00019160: 6973 2061 6c73 6f20 7265 7175 6972 6564  is also required
-00019170: 2c20 616e 6420 6973 2070 726f 7669 6465  , and is provide
-00019180: 640a 2020 2020 2020 2020 6173 2061 2076  d.        as a v
-00019190: 6563 746f 7220 3a6d 6174 683a 6028 612c  ector :math:`(a,
-000191a0: 622c 632c 6429 6020 7375 6368 2074 6861  b,c,d)` such tha
-000191b0: 740a 0a20 2020 2020 2020 202e 2e20 6d61  t..        .. ma
-000191c0: 7468 3a20 6158 202b 2062 5920 2b63 5a20  th: aX + bY +cZ 
-000191d0: 2b20 6420 3d20 300a 0a20 2020 2020 2020  + d = 0..       
-000191e0: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
-000191f0: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
-00019200: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
-00019210: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
-00019220: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
-00019230: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
-00019240: 4361 6d65 7261 0a20 2020 2020 2020 2020  Camera.         
-00019250: 2020 203e 3e3e 2066 726f 6d20 7370 6174     >>> from spat
-00019260: 6961 6c6d 6174 6820 696d 706f 7274 2053  ialmath import S
-00019270: 4533 0a20 2020 2020 2020 2020 2020 203e  E3.            >
-00019280: 3e3e 2063 616d 6572 6120 3d20 4365 6e74  >> camera = Cent
-00019290: 7261 6c43 616d 6572 612e 4465 6661 756c  ralCamera.Defaul
-000192a0: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
-000192b0: 3e3e 3e20 6361 6d65 7261 2e76 6973 6a61  >>> camera.visja
-000192c0: 635f 6528 2828 302e 352c 2030 2c20 2d31  c_e(((0.5, 0, -1
-000192d0: 3030 302c 202d 3530 302c 2033 3734 3930  000, -500, 37490
-000192e0: 3029 292c 2028 302c 2030 2c20 312c 202d  0)), (0, 0, 1, -
-000192f0: 3129 0a0a 2020 2020 2020 2020 3a72 6566  1)..        :ref
-00019300: 6572 656e 6365 733a 0a20 2020 2020 2020  erences:.       
-00019310: 2020 2020 202d 2041 204e 6577 2041 7070       - A New App
-00019320: 726f 6163 6820 746f 2056 6973 7561 6c20  roach to Visual 
-00019330: 5365 7276 6f69 6e67 2069 6e20 526f 626f  Servoing in Robo
-00019340: 7469 6373 2c0a 2020 2020 2020 2020 2020  tics,.          
-00019350: 2020 2020 422e 2045 7370 6961 752c 2046      B. Espiau, F
-00019360: 2e20 4368 6175 6d65 7474 652c 2061 6e64  . Chaumette, and
-00019370: 2050 2e20 5269 7665 732c 0a20 2020 2020   P. Rives,.     
-00019380: 2020 2020 2020 2020 2049 4545 4520 5472           IEEE Tr
-00019390: 616e 7361 6374 696f 6e73 206f 6e20 526f  ansactions on Ro
-000193a0: 626f 7469 6373 2061 6e64 2041 7574 6f6d  botics and Autom
-000193b0: 6174 696f 6e2c 200a 2020 2020 2020 2020  ation, .        
-000193c0: 2020 2020 2020 766f 6c2e 2038 2c20 7070        vol. 8, pp
-000193d0: 2e20 3331 332d 3332 362c 204a 756e 6520  . 313-326, June 
-000193e0: 3139 3932 2e0a 2020 2020 2020 2020 2020  1992..          
-000193f0: 2020 2d20 5669 7375 616c 2073 6572 766f    - Visual servo
-00019400: 2063 6f6e 7472 6f6c 2032 3a20 4164 7661   control 2: Adva
-00019410: 6e63 6564 2061 7070 726f 6163 6865 730a  nced approaches.
-00019420: 2020 2020 2020 2020 2020 2020 2020 4368                Ch
-00019430: 6175 6d65 7474 6520 462c 2048 7574 6368  aumette F, Hutch
-00019440: 696e 736f 6e20 532c 0a20 2020 2020 2020  inson S,.       
-00019450: 2020 2020 2020 2049 4545 4520 526f 626f         IEEE Robo
-00019460: 7420 4175 746f 6d20 4d61 6720 3134 2831  t Autom Mag 14(1
-00019470: 293a 3130 39e2 8093 3131 3820 2832 3030  ):109...118 (200
-00019480: 3729 0a20 2020 2020 2020 2020 2020 202d  7).            -
-00019490: 2052 6f62 6f74 6963 732c 2056 6973 696f   Robotics, Visio
-000194a0: 6e20 2620 436f 6e74 726f 6c20 666f 7220  n & Control for 
-000194b0: 5079 7468 6f6e 2c20 5365 6374 696f 6e20  Python, Section 
-000194c0: 3135 2e33 2e32 2c20 502e 2043 6f72 6b65  15.3.2, P. Corke
-000194d0: 2c20 0a20 2020 2020 2020 2020 2020 2020  , .             
-000194e0: 2053 7072 696e 6765 7220 3230 3233 2e0a   Springer 2023..
-000194f0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-00019500: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
-00019510: 3a60 7669 736a 6163 5f70 6020 3a6d 6574  :`visjac_p` :met
-00019520: 683a 6076 6973 6a61 635f 705f 706f 6c61  h:`visjac_p_pola
-00019530: 7260 203a 6d65 7468 3a60 7669 736a 6163  r` :meth:`visjac
-00019540: 5f6c 600a 2020 2020 2020 2020 2222 220a  _l`.        """.
-00019550: 0a20 2020 2020 2020 2061 203d 202d 706c  .        a = -pl
-00019560: 616e 655b 305d 202f 2070 6c61 6e65 5b33  ane[0] / plane[3
-00019570: 5d0a 2020 2020 2020 2020 6220 3d20 2d70  ].        b = -p
-00019580: 6c61 6e65 5b31 5d20 2f20 706c 616e 655b  lane[1] / plane[
-00019590: 335d 0a20 2020 2020 2020 2063 203d 202d  3].        c = -
-000195a0: 706c 616e 655b 325d 202f 2070 6c61 6e65  plane[2] / plane
-000195b0: 5b33 5d0a 2020 2020 2020 2020 4c20 3d20  [3].        L = 
-000195c0: 6e70 2e61 7272 6179 285b 0a20 2020 2020  np.array([.     
-000195d0: 2020 2020 2020 205b 322a 622a 455b 315d         [2*b*E[1]
-000195e0: 2d32 2a61 2a45 5b30 5d2c 2032 2a45 5b30  -2*a*E[0], 2*E[0
-000195f0: 5d2a 2862 2d61 2a45 5b31 5d29 2c20 322a  ]*(b-a*E[1]), 2*
-00019600: 622a 455b 335d 2d32 2a61 2a45 5b30 5d2a  b*E[3]-2*a*E[0]*
-00019610: 455b 325d 2c20 322a 455b 335d 2c20 322a  E[2], 2*E[3], 2*
-00019620: 455b 305d 2a45 5b32 5d2c 202d 322a 455b  E[0]*E[2], -2*E[
-00019630: 315d 2a28 455b 305d 2b31 295d 2c0a 2020  1]*(E[0]+1)],.  
-00019640: 2020 2020 2020 2020 2020 5b62 2d61 2a45            [b-a*E
-00019650: 5b31 5d2c 2062 2a45 5b31 5d2d 612a 2832  [1], b*E[1]-a*(2
-00019660: 2a45 5b31 5d2a 2a32 2d45 5b30 5d29 2c20  *E[1]**2-E[0]), 
-00019670: 612a 2845 5b33 5d2d 322a 455b 315d 2a45  a*(E[3]-2*E[1]*E
-00019680: 5b32 5d29 2b62 2a45 5b32 5d2c 202d 455b  [2])+b*E[2], -E[
-00019690: 325d 2c20 2d28 322a 455b 315d 2a45 5b32  2], -(2*E[1]*E[2
-000196a0: 5d2d 455b 335d 292c 2045 5b30 5d2d 322a  ]-E[3]), E[0]-2*
-000196b0: 455b 315d 2a2a 322d 315d 2c0a 2020 2020  E[1]**2-1],.    
-000196c0: 2020 2020 2020 2020 5b63 2d61 2a45 5b32          [c-a*E[2
-000196d0: 5d2c 2061 2a28 455b 335d 2d32 2a45 5b31  ], a*(E[3]-2*E[1
-000196e0: 5d2a 455b 325d 292b 632a 455b 315d 2c20  ]*E[2])+c*E[1], 
-000196f0: 632a 455b 325d 2d61 2a28 322a 455b 325d  c*E[2]-a*(2*E[2]
-00019700: 2a2a 322d 455b 345d 292c 202d 455b 315d  **2-E[4]), -E[1]
-00019710: 2c20 312b 322a 455b 325d 2a2a 322d 455b  , 1+2*E[2]**2-E[
-00019720: 345d 2c20 455b 335d 2d32 2a45 5b31 5d2a  4], E[3]-2*E[1]*
-00019730: 455b 325d 5d2c 0a20 2020 2020 2020 2020  E[2]],.         
-00019740: 2020 205b 455b 325d 2a62 2b45 5b31 5d2a     [E[2]*b+E[1]*
-00019750: 632d 322a 612a 455b 335d 2c20 455b 335d  c-2*a*E[3], E[3]
-00019760: 2a62 2b45 5b30 5d2a 632d 322a 612a 455b  *b+E[0]*c-2*a*E[
-00019770: 315d 2a45 5b33 5d2c 2062 2a45 5b34 5d2b  1]*E[3], b*E[4]+
-00019780: 632a 455b 335d 2d32 2a61 2a45 5b32 5d2a  c*E[3]-2*a*E[2]*
-00019790: 455b 335d 2c20 455b 345d 2d45 5b30 5d2c  E[3], E[4]-E[0],
-000197a0: 2032 2a45 5b32 5d2a 455b 335d 2b45 5b31   2*E[2]*E[3]+E[1
-000197b0: 5d2c 202d 322a 455b 315d 2a45 5b33 5d2d  ], -2*E[1]*E[3]-
-000197c0: 455b 325d 5d2c 0a20 2020 2020 2020 2020  E[2]],.         
-000197d0: 2020 205b 322a 632a 455b 325d 2d32 2a61     [2*c*E[2]-2*a
-000197e0: 2a45 5b34 5d2c 2032 2a63 2a45 5b33 5d2d  *E[4], 2*c*E[3]-
-000197f0: 322a 612a 455b 315d 2a45 5b34 5d2c 2032  2*a*E[1]*E[4], 2
-00019800: 2a63 2a45 5b34 5d2d 322a 612a 455b 325d  *c*E[4]-2*a*E[2]
-00019810: 2a45 5b34 5d2c 202d 322a 455b 335d 2c20  *E[4], -2*E[3], 
-00019820: 322a 455b 325d 2a45 5b34 5d2b 322a 455b  2*E[2]*E[4]+2*E[
-00019830: 325d 2c20 2d32 2a45 5b31 5d2a 455b 345d  2], -2*E[1]*E[4]
-00019840: 5d0a 2020 2020 2020 2020 2020 2020 5d29  ].            ])
-00019850: 0a0a 2020 2020 2020 2020 4c20 3d20 4c20  ..        L = L 
-00019860: 4020 6e70 2e64 6961 6728 5b30 2e35 2c20  @ np.diag([0.5, 
-00019870: 302e 352c 2030 2e35 2c20 312c 2031 2c20  0.5, 0.5, 1, 1, 
-00019880: 315d 2920 2020 2320 6e6f 7420 7375 7265  1])   # not sure
-00019890: 2077 6879 2e2e 2e0a 2020 2020 2020 2020   why....        
-000198a0: 7265 7475 726e 204c 0a0a 2020 2020 6465  return L..    de
-000198b0: 6620 666c 6f77 6669 656c 6428 7365 6c66  f flowfield(self
-000198c0: 2c20 7665 6c2c 205a 3d32 293a 0a20 2020  , vel, Z=2):.   
-000198d0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000198e0: 2044 6973 706c 6179 206f 7074 6963 616c   Display optical
-000198f0: 2066 6c6f 7720 6669 656c 640a 0a20 2020   flow field..   
-00019900: 2020 2020 203a 7061 7261 6d20 7665 6c3a       :param vel:
-00019910: 2063 616d 6572 6120 7370 6174 6961 6c20   camera spatial 
-00019920: 7665 6c6f 6369 7479 0a20 2020 2020 2020  velocity.       
-00019930: 203a 7479 7065 2076 656c 3a20 6172 7261   :type vel: arra
-00019940: 795f 6c69 6b65 2836 290a 2020 2020 2020  y_like(6).      
-00019950: 2020 3a70 6172 616d 205a 3a20 5f64 6573    :param Z: _des
-00019960: 6372 6970 7469 6f6e 5f2c 2064 6566 6175  cription_, defau
-00019970: 6c74 7320 746f 2032 0a20 2020 2020 2020  lts to 2.       
-00019980: 203a 7479 7065 205a 3a20 7363 616c 6172   :type Z: scalar
-00019990: 2c20 6f70 7469 6f6e 616c 0a0a 2020 2020  , optional..    
-000199a0: 2020 2020 4469 7370 6c61 7920 7468 6520      Display the 
-000199b0: 6f70 7469 6361 6c20 666c 6f77 2066 6965  optical flow fie
-000199c0: 6c64 2075 7369 6e67 204d 6174 706c 6f74  ld using Matplot
-000199d0: 6c69 622c 2066 6f72 2061 2067 7269 6420  lib, for a grid 
-000199e0: 6f66 2070 6f69 6e74 7320 6174 0a20 2020  of points at.   
-000199f0: 2020 2020 2064 6973 7461 6e63 6520 6060       distance ``
-00019a00: 5a60 6020 666f 7220 6120 6361 6d65 7261  Z`` for a camera
-00019a10: 2076 656c 6f63 6974 7920 6f66 2060 6076   velocity of ``v
-00019a20: 656c 6060 2e0a 0a20 2020 2020 2020 2045  el``...        E
-00019a30: 7861 6d70 6c65 3a0a 0a20 2020 2020 2020  xample:..       
-00019a40: 202e 2e20 7275 6e62 6c6f 636b 3a3a 2070   .. runblock:: p
-00019a50: 7963 6f6e 0a0a 2020 2020 2020 2020 2020  ycon..          
-00019a60: 2020 3e3e 3e20 6672 6f6d 206d 6163 6869    >>> from machi
-00019a70: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
-00019a80: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
-00019a90: 6d65 7261 0a20 2020 2020 2020 2020 2020  mera.           
-00019aa0: 203e 3e3e 2063 616d 6572 6120 3d20 4365   >>> camera = Ce
-00019ab0: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
-00019ac0: 756c 7428 290a 2020 2020 2020 2020 2020  ult().          
-00019ad0: 2020 3e3e 3e20 6361 6d65 7261 2e66 6c6f    >>> camera.flo
-00019ae0: 7766 6965 6c64 285b 302c 2030 2c20 302c  wfield([0, 0, 0,
-00019af0: 2030 2c20 312c 2030 5d29 0a0a 2020 2020   0, 1, 0])..    
-00019b00: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
-00019b10: 6574 683a 6076 6973 6a61 635f 7060 0a20  eth:`visjac_p`. 
-00019b20: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00019b30: 2020 2076 656c 203d 2062 6173 652e 6765     vel = base.ge
-00019b40: 7476 6563 746f 7228 7665 6c2c 2036 290a  tvector(vel, 6).
-00019b50: 0a20 2020 2020 2020 2075 203d 206e 702e  .        u = np.
-00019b60: 6172 616e 6765 2830 2c20 7365 6c66 2e6e  arange(0, self.n
-00019b70: 752c 2035 3029 0a20 2020 2020 2020 2076  u, 50).        v
-00019b80: 203d 206e 702e 6172 616e 6765 2830 2c20   = np.arange(0, 
-00019b90: 7365 6c66 2e6e 762c 2035 3029 0a20 2020  self.nv, 50).   
-00019ba0: 2020 2020 205b 552c 565d 203d 206e 702e       [U,V] = np.
-00019bb0: 6d65 7368 6772 6964 2875 2c20 762c 2069  meshgrid(u, v, i
-00019bc0: 6e64 6578 696e 673d 2769 6a27 290a 2020  ndexing='ij').  
-00019bd0: 2020 2020 2020 6475 203d 206e 702e 656d        du = np.em
-00019be0: 7074 7928 7368 6170 653d 552e 7368 6170  pty(shape=U.shap
-00019bf0: 6529 0a20 2020 2020 2020 2064 7620 3d20  e).        dv = 
-00019c00: 6e70 2e65 6d70 7479 2873 6861 7065 3d55  np.empty(shape=U
-00019c10: 2e73 6861 7065 290a 2020 2020 2020 2020  .shape).        
-00019c20: 666f 7220 7220 696e 2072 616e 6765 2855  for r in range(U
-00019c30: 2e73 6861 7065 5b30 5d29 3a20 2020 2020  .shape[0]):     
-00019c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019c50: 200a 2020 2020 2020 2020 2020 2020 666f   .            fo
-00019c60: 7220 6320 696e 2072 616e 6765 2855 2e73  r c in range(U.s
-00019c70: 6861 7065 5b31 5d29 3a0a 2020 2020 2020  hape[1]):.      
-00019c80: 2020 2020 2020 2020 2020 4a20 3d20 7365            J = se
-00019c90: 6c66 2e76 6973 6a61 635f 7028 2855 5b72  lf.visjac_p((U[r
-00019ca0: 2c63 5d2c 2056 5b72 2c63 5d29 2c20 5a20  ,c], V[r,c]), Z 
-00019cb0: 2920 2020 2020 2020 2020 2020 200a 2020  )            .  
-00019cc0: 2020 2020 2020 2020 2020 2020 2020 7564                ud
-00019cd0: 2c20 7664 203d 2020 4a20 4020 7665 6c0a  , vd =  J @ vel.
-00019ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019cf0: 6475 5b72 2c63 5d20 3d20 7564 0a20 2020  du[r,c] = ud.   
-00019d00: 2020 2020 2020 2020 2020 2020 2064 765b               dv[
-00019d10: 722c 635d 203d 202d 7664 0a0a 2020 2020  r,c] = -vd..    
-00019d20: 2020 2020 7365 6c66 2e63 6c66 2829 0a20      self.clf(). 
-00019d30: 2020 2020 2020 2061 7820 3d20 7365 6c66         ax = self
-00019d40: 2e5f 696e 6974 5f69 6d61 6765 706c 616e  ._init_imageplan
-00019d50: 6528 290a 2020 2020 2020 2020 6178 2e71  e().        ax.q
-00019d60: 7569 7665 7228 552c 2056 2c20 6475 2c20  uiver(U, V, du, 
-00019d70: 6476 2c20 302e 342c 207a 6f72 6465 723d  dv, 0.4, zorder=
-00019d80: 3230 290a 0a20 2020 2064 6566 2064 6572  20)..    def der
-00019d90: 6976 6174 6976 6573 2873 656c 662c 2078  ivatives(self, x
-00019da0: 2c20 5029 3a0a 2020 2020 2020 2020 7222  , P):.        r"
-00019db0: 2222 0a20 2020 2020 2020 2043 6f6d 7075  "".        Compu
-00019dc0: 7465 2070 726f 6a65 6374 696f 6e20 616e  te projection an
-00019dd0: 6420 6465 7269 7661 7469 7665 7320 666f  d derivatives fo
-00019de0: 7220 6275 6e64 6c65 2061 646a 7573 746d  r bundle adjustm
-00019df0: 656e 740a 0a20 2020 2020 2020 203a 7061  ent..        :pa
-00019e00: 7261 6d20 783a 2063 616d 6572 6120 706f  ram x: camera po
-00019e10: 7365 2061 7320 7472 616e 736c 6174 696f  se as translatio
-00019e20: 6e20 616e 6420 7175 6174 6572 6e69 6f6e  n and quaternion
-00019e30: 2076 6563 746f 7220 7061 7274 0a20 2020   vector part.   
-00019e40: 2020 2020 203a 7479 7065 2078 3a20 6172       :type x: ar
-00019e50: 7261 795f 6c69 6b65 2836 290a 2020 2020  ray_like(6).    
-00019e60: 2020 2020 3a70 6172 616d 2050 3a20 3344      :param P: 3D
-00019e70: 2077 6f72 6c64 2070 6f69 6e74 0a20 2020   world point.   
-00019e80: 2020 2020 203a 7479 7065 2050 3a20 6172       :type P: ar
-00019e90: 7261 795f 6c69 6b65 2833 290a 2020 2020  ray_like(3).    
-00019ea0: 2020 2020 3a72 6574 7572 6e3a 2070 2c20      :return: p, 
-00019eb0: 412c 2042 0a20 2020 2020 2020 203a 7274  A, B.        :rt
-00019ec0: 7970 653a 206e 6461 7272 6179 2832 292c  ype: ndarray(2),
-00019ed0: 206e 6461 7272 6179 2832 2c36 292c 206e   ndarray(2,6), n
-00019ee0: 6461 7272 6179 2832 2c33 290a 0a20 2020  darray(2,3)..   
-00019ef0: 2020 2020 2046 6f72 2061 2077 6f72 6c64       For a world
-00019f00: 2070 6f69 6e74 203a 6d61 7468 3a60 5c76   point :math:`\v
-00019f10: 6563 7b78 7d60 2063 6f6d 7075 7465 2074  ec{x}` compute t
-00019f20: 6865 2069 6d61 6765 2070 6c61 6e65 2070  he image plane p
-00019f30: 726f 6a65 6374 696f 6e20 616e 6420 7468  rojection and th
-00019f40: 650a 2020 2020 2020 2020 7365 6e73 6974  e.        sensit
-00019f50: 6976 6974 7920 746f 2063 616d 6572 6120  ivity to camera 
-00019f60: 616e 6420 706f 696e 7420 6368 616e 6765  and point change
-00019f70: 0a0a 2020 2020 2020 2020 2e2e 206d 6174  ..        .. mat
-00019f80: 683a 3a20 5c6d 6174 7b41 7d20 3d20 5c66  h:: \mat{A} = \f
-00019f90: 7261 637b 5c70 6172 7469 616c 205c 7665  rac{\partial \ve
-00019fa0: 637b 667d 285c 7665 637b 787d 297d 7b5c  c{f}(\vec{x})}{\
-00019fb0: 7061 7274 6961 6c20 5c70 6f73 657d 2c20  partial \pose}, 
-00019fc0: 5c6d 6174 7b42 7d20 3d20 5c66 7261 637b  \mat{B} = \frac{
-00019fd0: 5c70 6172 7469 616c 205c 7665 637b 667d  \partial \vec{f}
-00019fe0: 285c 7665 637b 787d 297d 7b5c 7061 7274  (\vec{x})}{\part
-00019ff0: 6961 6c20 5c76 6563 7b50 7d7d 0a0a 2020  ial \vec{P}}..  
-0001a000: 2020 2020 2020 7768 6572 6520 3a6d 6174        where :mat
-0001a010: 683a 605c 7665 637b 667d 285c 7665 637b  h:`\vec{f}(\vec{
-0001a020: 787d 2960 2069 7320 7468 6520 7065 7273  x})` is the pers
-0001a030: 7065 6374 6976 6520 7072 6f6a 6563 7469  pective projecti
-0001a040: 6f6e 2066 756e 6374 696f 6e2e 0a0a 2020  on function...  
-0001a050: 2020 2020 2020 3a73 6565 616c 736f 3a20        :seealso: 
-0001a060: 3a6d 6574 683a 6070 726f 6a65 6374 5f70  :meth:`project_p
-0001a070: 6f69 6e74 600a 2020 2020 2020 2020 2222  oint`.        ""
-0001a080: 220a 2020 2020 2020 2020 2363 6f6d 7075  ".        #compu
-0001a090: 7465 204a 6163 6f62 6961 6e73 2061 6e64  te Jacobians and
-0001a0a0: 2070 726f 6a65 6374 696f 6e0a 0a20 2020   projection..   
-0001a0b0: 2020 2020 2066 726f 6d20 206d 6163 6869       from  machi
-0001a0c0: 6e65 7669 7369 6f6e 746f 6f6c 626f 782e  nevisiontoolbox.
-0001a0d0: 6361 6d65 7261 5f64 6572 6976 6174 6976  camera_derivativ
-0001a0e0: 6573 2069 6d70 6f72 7420 6361 6d65 7261  es import camera
-0001a0f0: 4d6f 6465 6c0a 2020 2020 2020 2020 0a20  Model.        . 
-0001a100: 2020 2020 2020 204b 7020 3d20 5b73 656c         Kp = [sel
-0001a110: 662e 665b 305d 2c20 7365 6c66 2e72 686f  f.f[0], self.rho
-0001a120: 752c 2073 656c 662e 7268 6f76 2c20 7365  u, self.rhov, se
-0001a130: 6c66 2e75 302c 2073 656c 662e 7630 5d0a  lf.u0, self.v0].
-0001a140: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001a150: 6361 6d65 7261 4d6f 6465 6c28 2a78 2c20  cameraModel(*x, 
-0001a160: 2a50 2c20 2a4b 7029 0a20 2020 2020 2020  *P, *Kp).       
-0001a170: 200a 0a20 2020 2064 6566 2065 7374 706f   ..    def estpo
-0001a180: 7365 2873 656c 662c 2050 2c20 702c 206d  se(self, P, p, m
-0001a190: 6574 686f 643d 2769 7465 7261 7469 7665  ethod='iterative
-0001a1a0: 272c 2066 7261 6d65 3d22 776f 726c 6422  ', frame="world"
-0001a1b0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0001a1c0: 2020 2020 2020 2045 7374 696d 6174 6520         Estimate 
-0001a1d0: 6f62 6a65 6374 2070 6f73 650a 0a20 2020  object pose..   
-0001a1e0: 2020 2020 203a 7061 7261 6d20 503a 2041       :param P: A
-0001a1f0: 2073 6574 206f 6620 3344 2070 6f69 6e74   set of 3D point
-0001a200: 7320 6465 6669 6e69 6e67 2074 6865 206f  s defining the o
-0001a210: 626a 6563 7420 7769 7468 2072 6573 7065  bject with respe
-0001a220: 6374 2074 6f20 6974 7320 6f77 6e20 6672  ct to its own fr
-0001a230: 616d 650a 2020 2020 2020 2020 3a74 7970  ame.        :typ
-0001a240: 6520 503a 206e 6461 7272 6179 2833 2c20  e P: ndarray(3, 
-0001a250: 4e29 0a20 2020 2020 2020 203a 7061 7261  N).        :para
-0001a260: 6d20 703a 2049 6d61 6765 2070 6c61 6e65  m p: Image plane
-0001a270: 2070 726f 6a65 6374 696f 6e20 6f66 2074   projection of t
-0001a280: 6865 206f 626a 6563 7420 706f 696e 7473  he object points
-0001a290: 0a20 2020 2020 2020 203a 7479 7065 2070  .        :type p
-0001a2a0: 3a20 6e64 6172 7261 7928 322c 204e 290a  : ndarray(2, N).
-0001a2b0: 2020 2020 2020 2020 3a70 6172 616d 206d          :param m
-0001a2c0: 6574 686f 643a 2070 6f73 6520 6573 7469  ethod: pose esti
-0001a2d0: 6d61 7469 6f6e 2061 6c67 6f72 6974 686d  mation algorithm
-0001a2e0: 2c20 7365 6520 4f70 656e 4356 2073 6f6c  , see OpenCV sol
-0001a2f0: 7665 506e 502c 2064 6566 6175 6c74 7320  vePnP, defaults 
-0001a300: 746f 2027 6974 6572 6174 6976 6527 0a20  to 'iterative'. 
-0001a310: 2020 2020 2020 203a 7479 7065 206d 6574         :type met
-0001a320: 686f 643a 2073 7472 2c20 6f70 7469 6f6e  hod: str, option
-0001a330: 616c 0a20 2020 2020 2020 203a 7061 7261  al.        :para
-0001a340: 6d20 6672 616d 653a 2065 7374 696d 6174  m frame: estimat
-0001a350: 6520 706f 7365 2077 6974 6820 7265 7370  e pose with resp
-0001a360: 6563 7420 746f 2066 7261 6d65 2022 776f  ect to frame "wo
-0001a370: 726c 6422 205b 6465 6661 756c 745d 206f  rld" [default] o
-0001a380: 7220 2263 616d 6572 6122 0a20 2020 2020  r "camera".     
-0001a390: 2020 203a 7479 7065 2066 7261 6d65 3a20     :type frame: 
-0001a3a0: 7374 722c 206f 7074 696f 6e61 6c0a 2020  str, optional.  
-0001a3b0: 2020 2020 2020 3a72 6574 7572 6e3a 2070        :return: p
-0001a3c0: 6f73 6520 6f66 2074 6172 6765 7420 6672  ose of target fr
-0001a3d0: 616d 6520 7265 6c61 7469 7665 2074 6f20  ame relative to 
-0001a3e0: 7468 6520 776f 726c 6420 6672 616d 650a  the world frame.
-0001a3f0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-0001a400: 3a63 6c61 7373 3a60 7e73 7061 7469 616c  :class:`~spatial
-0001a410: 6d61 7468 2e2e 706f 7365 3364 2e53 4533  math..pose3d.SE3
-0001a420: 600a 0a20 2020 2020 2020 2055 7369 6e67  `..        Using
-0001a430: 2061 2073 6574 206f 6620 706f 696e 7473   a set of points
-0001a440: 2064 6566 696e 696e 6720 736f 6d65 206f   defining some o
-0001a450: 626a 6563 7420 7769 7468 2072 6573 7065  bject with respe
-0001a460: 6374 2074 6f20 6974 7320 6f77 6e20 6672  ct to its own fr
-0001a470: 616d 6520 7b42 7d2c 2061 6e64 0a20 2020  ame {B}, and.   
-0001a480: 2020 2020 2061 2073 6574 206f 6620 696d       a set of im
-0001a490: 6167 652d 706c 616e 6520 7072 6f6a 6563  age-plane projec
-0001a4a0: 7469 6f6e 732c 2065 7374 696d 6174 6520  tions, estimate 
-0001a4b0: 7468 6520 706f 7365 206f 6620 7b42 7d20  the pose of {B} 
-0001a4c0: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
-0001a4d0: 7468 6520 776f 726c 640a 2020 2020 2020  the world.      
-0001a4e0: 2020 6f72 2063 616d 6572 6120 6672 616d    or camera fram
-0001a4f0: 652e 2020 0a20 2020 2020 2020 200a 2020  e.  .        .  
-0001a500: 2020 2020 2020 546f 2065 7374 696d 6174        To estimat
-0001a510: 6520 7468 6520 6361 6d65 7261 2773 2070  e the camera's p
-0001a520: 6f73 6520 7769 7468 2072 6573 7065 6374  ose with respect
-0001a530: 2074 6f20 7468 6520 776f 726c 6420 6672   to the world fr
-0001a540: 616d 6520 7468 6520 6361 6d65 7261 2773  ame the camera's
-0001a550: 2070 6f73 650a 2020 2020 2020 2020 6060   pose.        ``
-0001a560: 7365 6c66 2e70 6f73 6560 6020 6973 2075  self.pose`` is u
-0001a570: 7365 642e 0a0a 2020 2020 2020 2020 3a6e  sed...        :n
-0001a580: 6f74 653a 0a20 2020 2020 2020 200a 2020  ote:.        .  
-0001a590: 2020 2020 2020 2020 2020 2a20 416c 6c20            * All 
-0001a5a0: 6f66 2074 6865 204f 7065 6e43 5620 6573  of the OpenCV es
-0001a5b0: 7469 6d61 7469 6f6e 2061 6c67 6f72 6974  timation algorit
-0001a5c0: 686d 7320 6172 6520 7375 7070 6f72 7465  hms are supporte
-0001a5d0: 642e 0a20 2020 2020 2020 2020 2020 202a  d..            *
-0001a5e0: 2041 6c67 6f72 6974 686d 2060 6022 6970   Algorithm ``"ip
-0001a5f0: 7065 2d73 7175 6172 6522 6060 2072 6571  pe-square"`` req
-0001a600: 7569 7265 7320 6578 6163 746c 7920 666f  uires exactly fo
-0001a610: 7572 2070 6f69 6e74 7320 6174 2074 6865  ur points at the
-0001a620: 2063 6f72 6e65 7273 206f 6620 610a 2020   corners of a.  
-0001a630: 2020 2020 2020 2020 2020 2020 7371 7561              squa
-0001a640: 7265 2061 6e64 2069 6e20 7468 6520 6f72  re and in the or
-0001a650: 6465 723a 2028 2d78 2c20 7929 2c20 2878  der: (-x, y), (x
-0001a660: 2c20 7929 2c20 2878 2c20 2d79 292c 2028  , y), (x, -y), (
-0001a670: 2d78 2c20 2d79 292e 0a20 2020 2020 2020  -x, -y)..       
-0001a680: 200a 2020 2020 2020 2020 3a73 6565 616c   .        :seeal
-0001a690: 736f 3a20 3a6d 6574 683a 6070 726f 6a65  so: :meth:`proje
-0001a6a0: 6374 5f70 6f69 6e74 600a 2020 2020 2020  ct_point`.      
-0001a6b0: 2020 2020 2020 606f 7065 6e63 762e 736f        `opencv.so
-0001a6c0: 6c76 6550 6e50 203c 6874 7470 733a 2f2f  lvePnP <https://
-0001a6d0: 646f 6373 2e6f 7065 6e63 762e 6f72 672f  docs.opencv.org/
-0001a6e0: 332e 342f 6439 2f64 3063 2f67 726f 7570  3.4/d9/d0c/group
-0001a6f0: 5f5f 6361 6c69 6233 642e 6874 6d6c 2367  __calib3d.html#g
-0001a700: 6135 3439 6332 3037 3566 6163 3134 3832  a549c2075fac1482
-0001a710: 3966 6634 6135 3862 6339 3331 6330 3333  9ff4a58bc931c033
-0001a720: 643e 605f 0a20 2020 2020 2020 2022 2222  d>`_.        """
-0001a730: 0a0a 2020 2020 2020 2020 6d65 7468 6f64  ..        method
-0001a740: 5f64 6963 7420 3d20 7b0a 2020 2020 2020  _dict = {.      
-0001a750: 2020 2020 2020 2769 7465 7261 7469 7665        'iterative
-0001a760: 273a 2063 762e 534f 4c56 4550 4e50 5f49  ': cv.SOLVEPNP_I
-0001a770: 5445 5241 5449 5645 2c0a 2020 2020 2020  TERATIVE,.      
-0001a780: 2020 2020 2020 2765 706e 7027 3a20 6376        'epnp': cv
-0001a790: 2e53 4f4c 5645 504e 505f 4550 4e50 2c0a  .SOLVEPNP_EPNP,.
-0001a7a0: 2020 2020 2020 2020 2020 2020 2770 3370              'p3p
-0001a7b0: 273a 2063 762e 534f 4c56 4550 4e50 5f50  ': cv.SOLVEPNP_P
-0001a7c0: 3350 2c0a 2020 2020 2020 2020 2020 2020  3P,.            
-0001a7d0: 2761 7033 7027 3a20 6376 2e53 4f4c 5645  'ap3p': cv.SOLVE
-0001a7e0: 504e 505f 4150 3350 2c0a 2020 2020 2020  PNP_AP3P,.      
-0001a7f0: 2020 2020 2020 2769 7070 6527 3a20 6376        'ippe': cv
-0001a800: 2e53 4f4c 5645 504e 505f 4950 5045 2c0a  .SOLVEPNP_IPPE,.
-0001a810: 2020 2020 2020 2020 2020 2020 2769 7070              'ipp
-0001a820: 652d 7371 7561 7265 273a 2063 762e 534f  e-square': cv.SO
-0001a830: 4c56 4550 4e50 5f49 5050 455f 5351 5541  LVEPNP_IPPE_SQUA
-0001a840: 5245 2c0a 2020 2020 2020 2020 7d0a 0a20  RE,.        }.. 
-0001a850: 2020 2020 2020 2023 2061 7320 7065 7220         # as per 
-0001a860: 7468 6520 4e6f 7465 206f 6e20 736f 6c76  the Note on solv
-0001a870: 6550 6e50 2070 6167 650a 2020 2020 2020  ePnP page.      
-0001a880: 2020 2320 2077 6520 6e65 6564 2074 6f20    #  we need to 
-0001a890: 656e 7375 7265 2074 6861 7420 7468 6520  ensure that the 
-0001a8a0: 696d 6167 6520 706f 696e 7420 6461 7461  image point data
-0001a8b0: 2069 7320 636f 6e74 6967 756f 7573 206e   is contiguous n
-0001a8c0: 7831 7832 2061 7272 6179 0a20 2020 2020  x1x2 array.     
-0001a8d0: 2020 206e 203d 2070 2e73 6861 7065 5b31     n = p.shape[1
-0001a8e0: 5d0a 2020 2020 2020 2020 7020 3d20 6e70  ].        p = np
-0001a8f0: 2e61 7363 6f6e 7469 6775 6f75 7361 7272  .ascontiguousarr
-0001a900: 6179 2870 5b3a 322c 203a 5d2e 5429 2e72  ay(p[:2, :].T).r
-0001a910: 6573 6861 7065 2828 6e2c 2031 2c20 3229  eshape((n, 1, 2)
-0001a920: 290a 0a20 2020 2020 2020 2023 2064 6f20  )..        # do 
-0001a930: 7468 6520 706f 7365 2065 7374 696d 6174  the pose estimat
-0001a940: 696f 6e0a 2020 2020 2020 2020 736f 6c20  ion.        sol 
-0001a950: 3d20 6376 2e73 6f6c 7665 506e 5028 502e  = cv.solvePnP(P.
-0001a960: 542c 2070 2c20 7365 6c66 2e4b 2c20 7365  T, p, self.K, se
-0001a970: 6c66 2e5f 6469 7374 6f72 7469 6f6e 2c20  lf._distortion, 
-0001a980: 666c 6167 733d 6d65 7468 6f64 5f64 6963  flags=method_dic
-0001a990: 745b 6d65 7468 6f64 5d29 0a0a 2020 2020  t[method])..    
-0001a9a0: 2020 2020 6966 2073 6f6c 5b30 5d3a 0a20      if sol[0]:. 
-0001a9b0: 2020 2020 2020 2020 2020 2023 2070 6f73             # pos
-0001a9c0: 6520 6f66 2074 6172 6765 7420 7769 7468  e of target with
-0001a9d0: 2072 6573 7065 6374 2074 6f20 6361 6d65   respect to came
-0001a9e0: 7261 0a20 2020 2020 2020 2020 2020 2070  ra.            p
-0001a9f0: 6f73 655f 435f 5420 3d20 5345 3328 736f  ose_C_T = SE3(so
-0001aa00: 6c5b 325d 2920 2a20 5345 332e 4575 6c65  l[2]) * SE3.Eule
-0001aa10: 7256 6563 2873 6f6c 5b31 5d29 0a20 2020  rVec(sol[1]).   
-0001aa20: 2020 2020 2020 2020 2023 2070 6f73 6520           # pose 
-0001aa30: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
-0001aa40: 776f 726c 6420 6672 616d 650a 2020 2020  world frame.    
-0001aa50: 2020 2020 2020 2020 6966 2066 7261 6d65          if frame
-0001aa60: 203d 3d20 2263 616d 6572 6122 3a0a 2020   == "camera":.  
-0001aa70: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0001aa80: 7475 726e 2070 6f73 655f 435f 540a 2020  turn pose_C_T.  
-0001aa90: 2020 2020 2020 2020 2020 656c 6966 2066            elif f
-0001aaa0: 7261 6d65 203d 3d20 2277 6f72 6c64 223a  rame == "world":
-0001aab0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001aac0: 2072 6574 7572 6e20 7365 6c66 2e70 6f73   return self.pos
-0001aad0: 6520 2a20 706f 7365 5f43 5f54 0a20 2020  e * pose_C_T.   
-0001aae0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0001aaf0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0001ab00: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-0001ab10: 6627 6261 6420 6672 616d 6520 7661 6c75  f'bad frame valu
-0001ab20: 6520 7b66 7261 6d65 7d27 290a 2020 2020  e {frame}').    
-0001ab30: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
-0001ab40: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0001ab50: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
-0001ab60: 6e65 0a0a 0a23 202d 2d2d 2d2d 2d2d 2d2d  ne...# ---------
-0001ab70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001ab80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001ab90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001aba0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
-0001abb0: 230a 0a63 6c61 7373 2046 6973 6845 7965  #..class FishEye
-0001abc0: 4361 6d65 7261 2843 616d 6572 6142 6173  Camera(CameraBas
-0001abd0: 6529 3a0a 2020 2020 7222 2222 0a20 2020  e):.    r""".   
-0001abe0: 2043 7265 6174 6520 6669 7368 6579 6520   Create fisheye 
-0001abf0: 6361 6d65 7261 2070 726f 6a65 6374 696f  camera projectio
-0001ac00: 6e20 6d6f 6465 6c0a 0a20 2020 202e 2e20  n model..    .. 
-0001ac10: 696e 6865 7269 7461 6e63 652d 6469 6167  inheritance-diag
-0001ac20: 7261 6d3a 3a20 6d61 6368 696e 6576 6973  ram:: machinevis
-0001ac30: 696f 6e74 6f6f 6c62 6f78 2e43 616d 6572  iontoolbox.Camer
-0001ac40: 612e 4669 7368 4579 6543 616d 6572 610a  a.FishEyeCamera.
-0001ac50: 2020 2020 2020 2020 3a74 6f70 2d63 6c61          :top-cla
-0001ac60: 7373 6573 3a20 6d61 6368 696e 6576 6973  sses: machinevis
-0001ac70: 696f 6e74 6f6f 6c62 6f78 2e43 616d 6572  iontoolbox.Camer
-0001ac80: 612e 4361 6d65 7261 0a20 2020 2020 2020  a.Camera.       
-0001ac90: 203a 7061 7274 733a 2031 0a0a 2020 2020   :parts: 1..    
-0001aca0: 3a70 6172 616d 206b 3a20 7363 616c 6520  :param k: scale 
-0001acb0: 6661 6374 6f72 0a20 2020 203a 7479 7065  factor.    :type
-0001acc0: 206b 3a20 666c 6f61 742c 206f 7074 696f   k: float, optio
-0001acd0: 6e61 6c0a 2020 2020 3a70 6172 616d 2070  nal.    :param p
-0001ace0: 726f 6a65 6374 696f 6e3a 2070 726f 6a65  rojection: proje
-0001acf0: 6374 696f 6e20 6d6f 6465 6c3a 2060 6027  ction model: ``'
-0001ad00: 6571 7569 616e 6775 6c61 7227 6060 205b  equiangular'`` [
-0001ad10: 6465 6661 756c 745d 2c20 6060 2773 696e  default], ``'sin
-0001ad20: 6527 6060 2c20 6060 2765 7175 6973 6f6c  e'``, ``'equisol
-0001ad30: 6964 2760 6020 6f72 2060 6027 7374 6572  id'`` or ``'ster
-0001ad40: 656f 6772 6170 6869 6327 6060 0a20 2020  eographic'``.   
-0001ad50: 203a 7479 7065 2070 726f 6a65 6374 696f   :type projectio
-0001ad60: 6e3a 2073 7472 2c20 6f70 7469 6f6e 616c  n: str, optional
-0001ad70: 0a20 2020 203a 7061 7261 6d20 6b77 6172  .    :param kwar
-0001ad80: 6773 3a20 6172 6775 6d65 6e74 7320 7061  gs: arguments pa
-0001ad90: 7373 6564 2074 6f20 3a63 6c61 7373 3a60  ssed to :class:`
-0001ada0: 4361 6d65 7261 4261 7365 6020 636f 6e73  CameraBase` cons
-0001adb0: 7472 7563 746f 720a 0a20 2020 2041 2066  tructor..    A f
-0001adc0: 6973 6865 7965 2063 616d 6572 6120 636f  isheye camera co
-0001add0: 6e74 6169 6e73 2061 2077 6964 6520 616e  ntains a wide an
-0001ade0: 676c 6520 6c65 6e73 2c20 616e 6420 7468  gle lens, and th
-0001adf0: 6520 616e 676c 6520 6f66 2074 6865 0a20  e angle of the. 
-0001ae00: 2020 2069 6e63 6f6d 696e 6720 7261 7920     incoming ray 
-0001ae10: 6973 206d 6170 7065 6420 746f 2061 2072  is mapped to a r
-0001ae20: 6164 6975 7320 7769 7468 2072 6573 7065  adius with respe
-0001ae30: 6374 2074 6f20 7468 6520 7072 696e 6369  ct to the princi
-0001ae40: 7061 6c20 706f 696e 742e 0a20 2020 2054  pal point..    T
-0001ae50: 6865 206d 6170 7069 6e67 2066 726f 6d20  he mapping from 
-0001ae60: 656c 6576 6174 696f 6e20 616e 676c 6520  elevation angle 
-0001ae70: 3a6d 6174 683a 605c 7468 6574 6160 2074  :math:`\theta` t
-0001ae80: 6f20 696d 6167 6520 706c 616e 6520 7261  o image plane ra
-0001ae90: 6469 7573 2069 730a 2020 2020 6769 7665  dius is.    give
-0001aea0: 6e20 6279 3a0a 0a20 2020 2020 2020 203d  n by:..        =
-0001aeb0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2020 203d  ============   =
-0001aec0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001aed0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001aee0: 3d3d 3d3d 3d3d 0a20 2020 2020 2020 2050  ======.        P
-0001aef0: 726f 6a65 6374 696f 6e20 2020 2020 203a  rojection      :
-0001af00: 6d61 7468 3a60 7228 5c74 6865 7461 2960  math:`r(\theta)`
-0001af10: 0a20 2020 2020 2020 203d 3d3d 3d3d 3d3d  .        =======
-0001af20: 3d3d 3d3d 3d3d 2020 203d 3d3d 3d3d 3d3d  ======   =======
-0001af30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001af40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001af50: 0a20 2020 2020 2020 2065 7175 6961 6e67  .        equiang
-0001af60: 756c 6172 2020 2020 203a 6d61 7468 3a60  ular     :math:`
-0001af70: 7220 3d20 6b20 5c74 6865 7461 600a 2020  r = k \theta`.  
-0001af80: 2020 2020 2020 7369 6e65 2020 2020 2020        sine      
-0001af90: 2020 2020 2020 3a6d 6174 683a 6072 203d        :math:`r =
-0001afa0: 206b 205c 7369 6e20 5c74 6865 7461 600a   k \sin \theta`.
-0001afb0: 2020 2020 2020 2020 6571 7569 736f 6c69          equisoli
-0001afc0: 6420 2020 2020 2020 3a6d 6174 683a 6072  d       :math:`r
-0001afd0: 203d 206b 205c 7369 6e20 5c66 7261 637b   = k \sin \frac{
-0001afe0: 5c74 6865 7461 7d7b 327d 600a 2020 2020  \theta}{2}`.    
-0001aff0: 2020 2020 7374 6572 656f 6772 6170 6869      stereographi
-0001b000: 6320 2020 3a6d 6174 683a 6072 203d 206b  c   :math:`r = k
-0001b010: 205c 7461 6e20 5c66 7261 637b 5c74 6865   \tan \frac{\the
-0001b020: 7461 7d7b 327d 600a 2020 2020 2020 2020  ta}{2}`.        
-0001b030: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 2020  =============   
-0001b040: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001b050: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001b060: 3d3d 3d3d 3d3d 3d0a 0a20 2020 203a 6e6f  =======..    :no
-0001b070: 7465 3a20 0a20 2020 2020 2020 202d 2049  te: .        - I
-0001b080: 6620 6060 4b60 6020 6973 206e 6f74 2073  f ``K`` is not s
-0001b090: 7065 6369 6669 6564 2069 7420 6973 2063  pecified it is c
-0001b0a0: 6f6d 7075 7465 6420 7375 6368 2074 6861  omputed such tha
-0001b0b0: 7420 7468 6520 6369 7263 756c 6172 0a20  t the circular. 
-0001b0c0: 2020 2020 2020 2020 2020 2069 6d61 6769             imagi
-0001b0d0: 6e67 2072 6567 696f 6e20 6d61 7869 6d61  ng region maxima
-0001b0e0: 6c6c 7920 6669 6c6c 7320 7468 6520 7371  lly fills the sq
-0001b0f0: 7561 7265 2069 6d61 6765 2070 6c61 6e65  uare image plane
-0001b100: 2e0a 2020 2020 2020 2020 2d20 5468 6973  ..        - This
-0001b110: 2063 616d 6572 6120 6d6f 6465 6c20 6173   camera model as
-0001b120: 7375 6d65 7320 6365 6e74 7261 6c20 7072  sumes central pr
-0001b130: 6f6a 6563 7469 6f6e 2c20 7468 6174 2069  ojection, that i
-0001b140: 732c 2074 6865 2066 6f63 616c 2070 6f69  s, the focal poi
-0001b150: 6e74 0a20 2020 2020 2020 2020 2020 2069  nt.            i
-0001b160: 7320 6174 207a 3d30 2061 6e64 2074 6865  s at z=0 and the
-0001b170: 2069 6d61 6765 2070 6c61 6e65 2069 7320   image plane is 
-0001b180: 6174 207a 3d66 2e20 2054 6865 2069 6d61  at z=f.  The ima
-0001b190: 6765 2069 7320 6e6f 7420 696e 7665 7274  ge is not invert
-0001b1a0: 6564 2e0a 0a20 2020 203a 7265 6665 7265  ed...    :refere
-0001b1b0: 6e63 6573 3a20 0a20 2020 2020 2020 202d  nces: .        -
-0001b1c0: 2052 6f62 6f74 6963 732c 2056 6973 696f   Robotics, Visio
-0001b1d0: 6e20 2620 436f 6e74 726f 6c20 666f 7220  n & Control for 
-0001b1e0: 5079 7468 6f6e 2c20 5365 6374 696f 6e20  Python, Section 
-0001b1f0: 3133 2e33 2e31 2c20 502e 2043 6f72 6b65  13.3.1, P. Corke
-0001b200: 2c20 5370 7269 6e67 6572 2032 3032 332e  , Springer 2023.
-0001b210: 0a0a 2020 2020 3a73 6565 616c 736f 3a20  ..    :seealso: 
-0001b220: 3a63 6c61 7373 3a60 4361 6d65 7261 4261  :class:`CameraBa
-0001b230: 7365 6020 3a63 6c61 7373 3a60 4365 6e74  se` :class:`Cent
-0001b240: 7261 6c43 616d 6572 6160 203a 636c 6173  ralCamera` :clas
-0001b250: 733a 6043 6174 6164 696f 7074 7269 6343  s:`CatadioptricC
-0001b260: 616d 6572 6160 0a20 2020 2020 2020 203a  amera`.        :
-0001b270: 636c 6173 733a 6053 7068 6572 6963 616c  class:`Spherical
-0001b280: 4361 6d65 7261 6020 0a20 2020 2022 2222  Camera` .    """
-0001b290: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-0001b2a0: 5f5f 2873 656c 662c 206b 3d4e 6f6e 652c  __(self, k=None,
-0001b2b0: 2070 726f 6a65 6374 696f 6e3d 2765 7175   projection='equ
-0001b2c0: 6961 6e67 756c 6172 272c 202a 2a6b 7761  iangular', **kwa
-0001b2d0: 7267 7329 3a0a 0a20 2020 2020 2020 2073  rgs):..        s
-0001b2e0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
-0001b2f0: 6361 6d74 7970 653d 2766 6973 6865 7965  camtype='fisheye
-0001b300: 272c 202a 2a6b 7761 7267 7329 0a0a 2020  ', **kwargs)..  
-0001b310: 2020 2020 2020 7365 6c66 2e70 726f 6a65        self.proje
-0001b320: 6374 696f 6e20 3d20 7072 6f6a 6563 7469  ction = projecti
-0001b330: 6f6e 0a0a 2020 2020 2020 2020 6966 206b  on..        if k
-0001b340: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-0001b350: 2020 2020 2020 7220 3d20 6e70 2e6d 696e        r = np.min
-0001b360: 2828 7365 6c66 2e69 6d61 6765 7369 7a65  ((self.imagesize
-0001b370: 202d 2073 656c 662e 7070 2920 2a20 7365   - self.pp) * se
-0001b380: 6c66 2e72 686f 290a 0a20 2020 2020 2020  lf.rho)..       
-0001b390: 2069 6620 7365 6c66 2e70 726f 6a65 6374   if self.project
-0001b3a0: 696f 6e20 3d3d 2027 6571 7569 616e 6775  ion == 'equiangu
-0001b3b0: 6c61 7227 3a0a 2020 2020 2020 2020 2020  lar':.          
-0001b3c0: 2020 6966 206b 2069 7320 4e6f 6e65 3a0a    if k is None:.
-0001b3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b3e0: 6b20 3d20 7220 2f20 2870 692f 3229 0a20  k = r / (pi/2). 
-0001b3f0: 2020 2020 2020 2020 2020 2072 6675 6e63             rfunc
-0001b400: 203d 206c 616d 6264 6120 7468 6574 613a   = lambda theta:
-0001b410: 206b 202a 2074 6865 7461 0a20 2020 2020   k * theta.     
-0001b420: 2020 2065 6c69 6620 7365 6c66 2e70 726f     elif self.pro
-0001b430: 6a65 6374 696f 6e20 3d3d 2027 7369 6e65  jection == 'sine
-0001b440: 273a 0a20 2020 2020 2020 2020 2020 2069  ':.            i
-0001b450: 6620 6b20 6973 204e 6f6e 653a 0a20 2020  f k is None:.   
-0001b460: 2020 2020 2020 2020 2020 2020 206b 203d               k =
-0001b470: 2072 0a20 2020 2020 2020 2020 2020 2072   r.            r
-0001b480: 6675 6e63 203d 206c 616d 6264 6120 7468  func = lambda th
-0001b490: 6574 613a 206b 202a 206e 702e 7369 6e28  eta: k * np.sin(
-0001b4a0: 7468 6574 6129 0a20 2020 2020 2020 2065  theta).        e
-0001b4b0: 6c69 6620 7365 6c66 2e70 726f 6a65 6374  lif self.project
-0001b4c0: 696f 6e20 3d3d 2027 6571 7569 736f 6c69  ion == 'equisoli
-0001b4d0: 6427 3a0a 2020 2020 2020 2020 2020 2020  d':.            
-0001b4e0: 6966 206b 2069 7320 4e6f 6e65 3a0a 2020  if k is None:.  
-0001b4f0: 2020 2020 2020 2020 2020 2020 2020 6b20                k 
-0001b500: 3d20 7220 2f20 7369 6e28 7069 202f 2034  = r / sin(pi / 4
-0001b510: 290a 2020 2020 2020 2020 2020 2020 7266  ).            rf
-0001b520: 756e 6320 3d20 6c61 6d62 6461 2074 6865  unc = lambda the
-0001b530: 7461 3a20 6b20 2a20 6e70 2e73 696e 2874  ta: k * np.sin(t
-0001b540: 6865 7461 202f 2032 290a 2020 2020 2020  heta / 2).      
-0001b550: 2020 656c 6966 2073 656c 662e 7072 6f6a    elif self.proj
-0001b560: 6563 7469 6f6e 203d 3d20 2773 7465 7265  ection == 'stere
-0001b570: 6f67 7261 7068 6963 273a 0a20 2020 2020  ographic':.     
-0001b580: 2020 2020 2020 2069 6620 6b20 6973 204e         if k is N
-0001b590: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0001b5a0: 2020 2020 206b 203d 2072 202f 2074 616e       k = r / tan
-0001b5b0: 2870 6920 2f20 3429 0a20 2020 2020 2020  (pi / 4).       
-0001b5c0: 2020 2020 2072 6675 6e63 203d 206c 616d       rfunc = lam
-0001b5d0: 6264 6120 7468 6574 613a 206b 202a 206e  bda theta: k * n
-0001b5e0: 702e 7461 6e28 7468 6574 6120 2f20 3229  p.tan(theta / 2)
-0001b5f0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0001b600: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-0001b610: 2056 616c 7565 4572 726f 7228 2775 6e6b   ValueError('unk
-0001b620: 6e6f 776e 2070 726f 6a65 6374 696f 6e20  nown projection 
-0001b630: 6d6f 6465 6c27 290a 0a20 2020 2020 2020  model')..       
-0001b640: 2073 656c 662e 6b20 3d20 6b0a 2020 2020   self.k = k.    
-0001b650: 2020 2020 7365 6c66 2e72 6675 6e63 203d      self.rfunc =
-0001b660: 2072 6675 6e63 0a20 2020 2020 2020 200a   rfunc.        .
-0001b670: 2020 2020 6465 6620 5f5f 7374 725f 5f28      def __str__(
-0001b680: 7365 6c66 293a 0a20 2020 2020 2020 2073  self):.        s
-0001b690: 203d 2073 7570 6572 2829 2e5f 5f73 7472   = super().__str
-0001b6a0: 5f5f 2829 0a20 2020 2020 2020 2073 202b  __().        s +
-0001b6b0: 3d20 7365 6c66 2e66 6d74 2e66 6f72 6d61  = self.fmt.forma
-0001b6c0: 7428 276d 6f64 656c 272c 2073 656c 662e  t('model', self.
-0001b6d0: 7072 6f6a 6563 7469 6f6e 2c20 666d 743d  projection, fmt=
-0001b6e0: 227b 7d22 290a 2020 2020 2020 2020 7320  "{}").        s 
-0001b6f0: 2b3d 2073 656c 662e 666d 742e 666f 726d  += self.fmt.form
-0001b700: 6174 2827 6b27 2c20 7365 6c66 2e6b 2c20  at('k', self.k, 
-0001b710: 666d 743d 227b 3a2e 3467 7d22 290a 2020  fmt="{:.4g}").  
-0001b720: 2020 2020 2020 7265 7475 726e 2073 2020        return s  
-0001b730: 2020 2020 2020 0a20 2020 2020 2020 200a        .        .
-0001b740: 2020 2020 6465 6620 7072 6f6a 6563 745f      def project_
-0001b750: 706f 696e 7428 7365 6c66 2c20 502c 2070  point(self, P, p
-0001b760: 6f73 653d 4e6f 6e65 2c20 6f62 6a70 6f73  ose=None, objpos
-0001b770: 653d 4e6f 6e65 293a 0a20 2020 2020 2020  e=None):.       
-0001b780: 2072 2222 220a 2020 2020 2020 2020 5072   r""".        Pr
-0001b790: 6f6a 6563 7420 3344 2070 6f69 6e74 7320  oject 3D points 
-0001b7a0: 746f 2069 6d61 6765 2070 6c61 6e65 0a0a  to image plane..
-0001b7b0: 2020 2020 2020 2020 3a70 6172 616d 2050          :param P
-0001b7c0: 3a20 3344 2077 6f72 6c64 2070 6f69 6e74  : 3D world point
-0001b7d0: 206f 7220 706f 696e 7473 0a20 2020 2020   or points.     
-0001b7e0: 2020 203a 7479 7065 2050 3a20 6172 7261     :type P: arra
-0001b7f0: 795f 6c69 6b65 2833 292c 2061 7272 6179  y_like(3), array
-0001b800: 5f6c 696b 6528 332c 6e29 0a20 2020 2020  _like(3,n).     
-0001b810: 2020 203a 7061 7261 6d20 706f 7365 3a20     :param pose: 
-0001b820: 6361 6d65 7261 2070 6f73 6520 7769 7468  camera pose with
-0001b830: 2072 6573 7065 6374 2074 6f20 7468 6520   respect to the 
-0001b840: 776f 726c 6420 6672 616d 652c 2064 6566  world frame, def
-0001b850: 6175 6c74 7320 746f 0a20 2020 2020 2020  aults to.       
-0001b860: 2020 2020 2063 616d 6572 6127 7320 6060       camera's ``
-0001b870: 706f 7365 6060 2061 7474 7269 6275 7465  pose`` attribute
-0001b880: 0a20 2020 2020 2020 203a 7479 7065 2070  .        :type p
-0001b890: 6f73 653a 2053 453a 636c 6173 733a 607e  ose: SE:class:`~
-0001b8a0: 7370 6174 6961 6c6d 6174 682e 2e70 6f73  spatialmath..pos
-0001b8b0: 6533 642e 5345 3360 332c 206f 7074 696f  e3d.SE3`3, optio
-0001b8c0: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
-0001b8d0: 616d 206f 626a 706f 7365 3a20 2033 4420  am objpose:  3D 
-0001b8e0: 706f 696e 7420 7265 6665 7265 6e63 6520  point reference 
-0001b8f0: 6672 616d 652c 2064 6566 6175 6c74 7320  frame, defaults 
-0001b900: 746f 2077 6f72 6c64 2066 7261 6d65 0a20  to world frame. 
-0001b910: 2020 2020 2020 203a 7479 7065 206f 626a         :type obj
-0001b920: 706f 7365 3a20 3a63 6c61 7373 3a60 7e73  pose: :class:`~s
-0001b930: 7061 7469 616c 6d61 7468 2e2e 706f 7365  patialmath..pose
-0001b940: 3364 2e53 4533 602c 206f 7074 696f 6e61  3d.SE3`, optiona
-0001b950: 6c0a 2020 2020 2020 2020 3a70 6172 616d  l.        :param
-0001b960: 2076 6973 6962 696c 6974 793a 2074 6573   visibility: tes
-0001b970: 7420 6966 2070 6f69 6e74 7320 6172 6520  t if points are 
-0001b980: 7669 7369 626c 652c 2064 6566 6175 6c74  visible, default
-0001b990: 2046 616c 7365 0a20 2020 2020 2020 203a   False.        :
-0001b9a0: 7479 7065 2076 6973 6962 696c 6974 793a  type visibility:
-0001b9b0: 2062 6f6f 6c0a 2020 2020 2020 2020 3a72   bool.        :r
-0001b9c0: 6169 7365 7320 5661 6c75 6545 7272 6f72  aises ValueError
-0001b9d0: 3a20 5b64 6573 6372 6970 7469 6f6e 5d0a  : [description].
-0001b9e0: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
-0001b9f0: 2069 6d61 6765 2070 6c61 6e65 2070 6f69   image plane poi
-0001ba00: 6e74 730a 2020 2020 2020 2020 3a72 7479  nts.        :rty
-0001ba10: 7065 3a20 6e64 6172 7261 7928 322c 6e29  pe: ndarray(2,n)
-0001ba20: 0a0a 2020 2020 2020 2020 5072 6f6a 6563  ..        Projec
-0001ba30: 7420 776f 726c 6420 706f 696e 7473 2074  t world points t
-0001ba40: 6f20 7468 6520 6669 7368 6579 6520 6361  o the fisheye ca
-0001ba50: 6d65 7261 2069 6d61 6765 2070 6c61 6e65  mera image plane
-0001ba60: 2e0a 0a20 2020 2020 2020 2054 6865 2065  ...        The e
-0001ba70: 6c65 7661 7469 6f6e 2061 6e67 6c65 2072  levation angle r
-0001ba80: 616e 6765 2069 7320 6672 6f6d 203a 6d61  ange is from :ma
-0001ba90: 7468 3a60 2d70 692f 3260 2028 6265 6c6f  th:`-pi/2` (belo
-0001baa0: 7720 7468 6520 6d69 7272 6f72 2920 746f  w the mirror) to
-0001bab0: 0a20 2020 2020 2020 206d 6178 616e 676c  .        maxangl
-0001bac0: 6520 6162 6f76 6520 7468 6520 686f 7269  e above the hori
-0001bad0: 7a6f 6e74 616c 2070 6c61 6e65 2e20 5468  zontal plane. Th
-0001bae0: 6520 6d61 7070 696e 6720 6672 6f6d 2065  e mapping from e
-0001baf0: 6c65 7661 7469 6f6e 2061 6e67 6c65 0a20  levation angle. 
-0001bb00: 2020 2020 2020 203a 6d61 7468 3a60 5c74         :math:`\t
-0001bb10: 6865 7461 6020 746f 2069 6d61 6765 2070  heta` to image p
-0001bb20: 6c61 6e65 2072 6164 6975 7320 6973 2067  lane radius is g
-0001bb30: 6976 656e 2062 793a 0a0a 2020 2020 2020  iven by:..      
-0001bb40: 2020 2020 2020 3d3d 3d3d 3d3d 3d3d 3d3d        ==========
-0001bb50: 3d3d 3d20 2020 3d3d 3d3d 3d3d 3d3d 3d3d  ===   ==========
-0001bb60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001bb70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020  =============.  
-0001bb80: 2020 2020 2020 2020 2020 5072 6f6a 6563            Projec
-0001bb90: 7469 6f6e 2020 2020 2020 3a6d 6174 683a  tion      :math:
-0001bba0: 6072 285c 7468 6574 6129 600a 2020 2020  `r(\theta)`.    
-0001bbb0: 2020 2020 2020 2020 3d3d 3d3d 3d3d 3d3d          ========
-0001bbc0: 3d3d 3d3d 3d20 2020 3d3d 3d3d 3d3d 3d3d  =====   ========
-0001bbd0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001bbe0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
-0001bbf0: 2020 2020 2020 2020 2020 2020 6571 7569              equi
-0001bc00: 616e 6775 6c61 7220 2020 2020 3a6d 6174  angular     :mat
-0001bc10: 683a 6072 203d 206b 205c 7468 6574 6160  h:`r = k \theta`
-0001bc20: 0a20 2020 2020 2020 2020 2020 2073 696e  .            sin
-0001bc30: 6520 2020 2020 2020 2020 2020 203a 6d61  e            :ma
-0001bc40: 7468 3a60 7220 3d20 6b20 5c73 696e 205c  th:`r = k \sin \
-0001bc50: 7468 6574 6160 0a20 2020 2020 2020 2020  theta`.         
-0001bc60: 2020 2065 7175 6973 6f6c 6964 2020 2020     equisolid    
-0001bc70: 2020 203a 6d61 7468 3a60 7220 3d20 6b20     :math:`r = k 
-0001bc80: 5c73 696e 205c 6672 6163 7b5c 7468 6574  \sin \frac{\thet
-0001bc90: 617d 7b32 7d60 0a20 2020 2020 2020 2020  a}{2}`.         
-0001bca0: 2020 2073 7465 7265 6f67 7261 7068 6963     stereographic
-0001bcb0: 2020 203a 6d61 7468 3a60 7220 3d20 6b20     :math:`r = k 
-0001bcc0: 5c74 616e 205c 6672 6163 7b5c 7468 6574  \tan \frac{\thet
-0001bcd0: 617d 7b32 7d60 0a20 2020 2020 2020 2020  a}{2}`.         
-0001bce0: 2020 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     =============
-0001bcf0: 2020 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     =============
-0001bd00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001bd10: 3d3d 3d3d 3d3d 3d3d 3d3d 0a20 2020 2020  ==========.     
-0001bd20: 2020 200a 2020 2020 2020 2020 576f 726c     .        Worl
-0001bd30: 6420 706f 696e 7473 2061 7265 2067 6976  d points are giv
-0001bd40: 656e 2061 7320 6120 3144 2061 7272 6179  en as a 1D array
-0001bd50: 206f 7220 7468 6520 636f 6c75 6d6e 7320   or the columns 
-0001bd60: 6f66 2061 2032 4420 6172 7261 7920 6f66  of a 2D array of
-0001bd70: 0a20 2020 2020 2020 2045 7563 6c69 6465  .        Euclide
-0001bd80: 616e 2063 6f6f 7264 696e 6174 6573 2e20  an coordinates. 
-0001bd90: 5468 6520 636f 6d70 7574 6564 2069 6d61  The computed ima
-0001bda0: 6765 2070 6c61 6e65 2063 6f6f 7264 696e  ge plane coordin
-0001bdb0: 6174 6573 2061 7265 0a20 2020 2020 2020  ates are.       
-0001bdc0: 2045 7563 6c69 6465 616e 2061 6e64 2067   Euclidean and g
-0001bdd0: 6976 656e 2061 7320 6120 3144 2061 7272  iven as a 1D arr
-0001bde0: 6179 206f 7220 7468 6520 636f 7272 6573  ay or the corres
-0001bdf0: 706f 6e64 696e 6720 636f 6c75 6d6e 7320  ponding columns 
-0001be00: 6f66 2061 2032 440a 2020 2020 2020 2020  of a 2D.        
-0001be10: 6172 7261 792e 0a0a 2020 2020 2020 2020  array...        
-0001be20: 4966 2060 6070 6f73 6560 6020 6973 2073  If ``pose`` is s
-0001be30: 7065 6369 6669 6564 2069 7420 6973 2075  pecified it is u
-0001be40: 7365 6420 666f 7220 7468 6520 6361 6d65  sed for the came
-0001be50: 7261 2070 6f73 6520 696e 7374 6561 6420  ra pose instead 
-0001be60: 6f66 2074 6865 0a20 2020 2020 2020 2061  of the.        a
-0001be70: 7474 7269 6275 7465 2060 6070 6f73 6560  ttribute ``pose`
-0001be80: 602e 2020 5468 6520 6f62 6a65 6374 2773  `.  The object's
-0001be90: 2061 7474 7269 6275 7465 2069 7320 6e6f   attribute is no
-0001bea0: 7420 7570 6461 7465 642e 0a0a 2020 2020  t updated...    
-0001beb0: 2020 2020 5468 6520 706f 696e 7473 2060      The points `
-0001bec0: 6050 6060 2061 7265 2062 7920 6465 6661  `P`` are by defa
-0001bed0: 756c 7420 7769 7468 2072 6573 7065 6374  ult with respect
-0001bee0: 2074 6f20 7468 6520 776f 726c 6420 6672   to the world fr
-0001bef0: 616d 652c 2062 7574 200a 2020 2020 2020  ame, but .      
-0001bf00: 2020 7468 6579 2063 616e 2062 6520 7472    they can be tr
-0001bf10: 616e 7366 6f72 6d65 6420 6279 2073 7065  ansformed by spe
-0001bf20: 6369 6679 696e 6720 6060 6f62 6a70 6f73  cifying ``objpos
-0001bf30: 6560 602e 0a0a 2020 2020 2020 2020 3a73  e``...        :s
-0001bf40: 6565 616c 736f 3a20 3a6d 6574 683a 6070  eealso: :meth:`p
-0001bf50: 6c6f 745f 706f 696e 7460 0a20 2020 2020  lot_point`.     
-0001bf60: 2020 2022 2222 0a20 2020 2020 2020 200a     """.        .
-0001bf70: 2020 2020 2020 2020 5020 3d20 6261 7365          P = base
-0001bf80: 2e67 6574 6d61 7472 6978 2850 2c20 2833  .getmatrix(P, (3
-0001bf90: 2c20 4e6f 6e65 2929 0a0a 2020 2020 2020  , None))..      
-0001bfa0: 2020 6966 2070 6f73 6520 6973 206e 6f74    if pose is not
-0001bfb0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-0001bfc0: 2020 2054 203d 2073 656c 662e 706f 7365     T = self.pose
-0001bfd0: 2e69 6e76 2829 0a20 2020 2020 2020 2065  .inv().        e
-0001bfe0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0001bff0: 2054 203d 2053 4533 2829 0a20 2020 2020   T = SE3().     
-0001c000: 2020 2069 6620 6f62 6a70 6f73 6520 6973     if objpose is
-0001c010: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
-0001c020: 2020 2020 2020 2054 202a 3d20 6f62 6a70         T *= objp
-0001c030: 6f73 650a 2020 2020 2020 2020 0a20 2020  ose.        .   
-0001c040: 2020 2020 2052 203d 206e 702e 7371 7274       R = np.sqrt
-0001c050: 286e 702e 7375 6d28 5020 2a2a 2032 2c20  (np.sum(P ** 2, 
-0001c060: 6178 6973 3d30 2929 0a20 2020 2020 2020  axis=0)).       
-0001c070: 2070 6869 203d 206e 702e 6172 6374 616e   phi = np.arctan
-0001c080: 3228 505b 312c 203a 5d2c 2050 5b30 2c20  2(P[1, :], P[0, 
-0001c090: 3a5d 290a 2020 2020 2020 2020 7468 6574  :]).        thet
-0001c0a0: 6120 3d20 6e70 2e61 7263 636f 7328 505b  a = np.arccos(P[
-0001c0b0: 322c 203a 5d20 2f20 5229 0a20 2020 2020  2, :] / R).     
-0001c0c0: 2020 200a 2020 2020 2020 2020 7220 3d20     .        r = 
-0001c0d0: 7365 6c66 2e72 6675 6e63 2874 6865 7461  self.rfunc(theta
-0001c0e0: 290a 2020 2020 2020 2020 7820 3d20 7220  ).        x = r 
-0001c0f0: 2a20 6e70 2e63 6f73 2870 6869 290a 2020  * np.cos(phi).  
-0001c100: 2020 2020 2020 7920 3d20 7220 2a20 6e70        y = r * np
-0001c110: 2e73 696e 2870 6869 290a 2020 2020 2020  .sin(phi).      
-0001c120: 2020 0a20 2020 2020 2020 2075 7620 3d20    .        uv = 
-0001c130: 6e70 2e61 7272 6179 285b 7820 2f20 7365  np.array([x / se
-0001c140: 6c66 2e72 686f 7520 2b20 7365 6c66 2e75  lf.rhou + self.u
-0001c150: 302c 2079 202f 2073 656c 662e 7268 6f76  0, y / self.rhov
-0001c160: 202b 2073 656c 662e 7630 5d29 0a20 2020   + self.v0]).   
-0001c170: 2020 2020 200a 2020 2020 2020 2020 7265       .        re
-0001c180: 7475 726e 2073 656c 662e 5f61 6464 5f6e  turn self._add_n
-0001c190: 6f69 7365 5f64 6973 746f 7274 696f 6e28  oise_distortion(
-0001c1a0: 7576 290a 0a23 202d 2d2d 2d2d 2d2d 2d2d  uv)..# ---------
-0001c1b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001c1c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001c1d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001c1e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
-0001c1f0: 230a 0a63 6c61 7373 2043 6174 6164 696f  #..class Catadio
-0001c200: 7074 7269 6343 616d 6572 6128 4361 6d65  ptricCamera(Came
-0001c210: 7261 4261 7365 293a 0a20 2020 2072 2222  raBase):.    r""
-0001c220: 220a 2020 2020 4372 6561 7465 2063 6174  ".    Create cat
-0001c230: 6164 696f 7074 7269 6320 6361 6d65 7261  adioptric camera
-0001c240: 2070 726f 6a65 6374 696f 6e20 6d6f 6465   projection mode
-0001c250: 6c0a 0a20 2020 202e 2e20 696e 6865 7269  l..    .. inheri
-0001c260: 7461 6e63 652d 6469 6167 7261 6d3a 3a20  tance-diagram:: 
-0001c270: 6d61 6368 696e 6576 6973 696f 6e74 6f6f  machinevisiontoo
-0001c280: 6c62 6f78 2e43 616d 6572 612e 4361 7461  lbox.Camera.Cata
-0001c290: 6469 6f70 7472 6963 4361 6d65 7261 0a20  dioptricCamera. 
-0001c2a0: 2020 2020 2020 203a 746f 702d 636c 6173         :top-clas
-0001c2b0: 7365 733a 206d 6163 6869 6e65 7669 7369  ses: machinevisi
-0001c2c0: 6f6e 746f 6f6c 626f 782e 4361 6d65 7261  ontoolbox.Camera
-0001c2d0: 2e43 616d 6572 610a 2020 2020 2020 2020  .Camera.        
-0001c2e0: 3a70 6172 7473 3a20 310a 0a20 2020 203a  :parts: 1..    :
-0001c2f0: 7061 7261 6d20 6b3a 2073 6361 6c65 2066  param k: scale f
-0001c300: 6163 746f 720a 2020 2020 3a74 7970 6520  actor.    :type 
-0001c310: 6b3a 2066 6c6f 6174 2c20 6f70 7469 6f6e  k: float, option
-0001c320: 616c 0a20 2020 203a 7061 7261 6d20 7072  al.    :param pr
-0001c330: 6f6a 6563 7469 6f6e 3a20 7072 6f6a 6563  ojection: projec
-0001c340: 7469 6f6e 206d 6f64 656c 3a20 6060 2765  tion model: ``'e
-0001c350: 7175 6961 6e67 756c 6172 2760 6020 5b64  quiangular'`` [d
-0001c360: 6566 6175 6c74 5d2c 2060 6027 7369 6e65  efault], ``'sine
-0001c370: 2760 602c 2060 6027 6571 7569 736f 6c69  '``, ``'equisoli
-0001c380: 6427 6060 206f 7220 6060 2773 7465 7265  d'`` or ``'stere
-0001c390: 6f67 7261 7068 6963 2760 600a 2020 2020  ographic'``.    
-0001c3a0: 3a74 7970 6520 7072 6f6a 6563 7469 6f6e  :type projection
-0001c3b0: 3a20 7374 722c 206f 7074 696f 6e61 6c0a  : str, optional.
-0001c3c0: 2020 2020 3a70 6172 616d 206b 7761 7267      :param kwarg
-0001c3d0: 733a 2061 7267 756d 656e 7473 2070 6173  s: arguments pas
-0001c3e0: 7365 6420 746f 203a 636c 6173 733a 6043  sed to :class:`C
-0001c3f0: 616d 6572 6142 6173 6560 2063 6f6e 7374  ameraBase` const
-0001c400: 7275 6374 6f72 0a0a 2020 2020 4120 6361  ructor..    A ca
-0001c410: 7461 6469 6f70 7472 6963 2063 616d 6572  tadioptric camer
-0001c420: 6120 636f 6d70 7269 7365 7320 6120 7065  a comprises a pe
-0001c430: 7273 7065 6374 6976 6520 6361 6d65 7261  rspective camera
-0001c440: 2070 6f69 6e74 6564 2061 7420 6120 0a20   pointed at a . 
-0001c450: 2020 2063 6f6e 7665 7820 6d69 7272 6f72     convex mirror
-0001c460: 2c20 7479 7069 6361 6c6c 7920 7061 7261  , typically para
-0001c470: 626f 6c6f 6964 616c 206f 7220 636f 6e69  boloidal or coni
-0001c480: 6361 6c2e 0a20 2020 200a 2020 2020 5468  cal..    .    Th
-0001c490: 6520 656c 6576 6174 696f 6e20 616e 676c  e elevation angl
-0001c4a0: 6520 7261 6e67 6520 6973 2066 726f 6d20  e range is from 
-0001c4b0: 3a6d 6174 683a 602d 5c70 692f 3260 2028  :math:`-\pi/2` (
-0001c4c0: 6265 6c6f 7720 7468 6520 6d69 7272 6f72  below the mirror
-0001c4d0: 2920 746f 0a20 2020 206d 6178 616e 676c  ) to.    maxangl
-0001c4e0: 6520 6162 6f76 6520 7468 6520 686f 7269  e above the hori
-0001c4f0: 7a6f 6e74 616c 2070 6c61 6e65 2e20 5468  zontal plane. Th
-0001c500: 6520 6d61 7070 696e 6720 6672 6f6d 2065  e mapping from e
-0001c510: 6c65 7661 7469 6f6e 2061 6e67 6c65 0a20  levation angle. 
-0001c520: 2020 203a 6d61 7468 3a60 5c74 6865 7461     :math:`\theta
-0001c530: 6020 746f 2069 6d61 6765 2070 6c61 6e65  ` to image plane
-0001c540: 2072 6164 6975 7320 6973 2067 6976 656e   radius is given
-0001c550: 2062 793a 0a0a 2020 2020 2020 2020 3d3d   by:..        ==
-0001c560: 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 2020 3d3d  ===========   ==
-0001c570: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001c580: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001c590: 3d3d 3d3d 3d0a 2020 2020 2020 2020 5072  =====.        Pr
-0001c5a0: 6f6a 6563 7469 6f6e 2020 2020 2020 3a6d  ojection      :m
-0001c5b0: 6174 683a 6072 285c 7468 6574 6129 600a  ath:`r(\theta)`.
-0001c5c0: 2020 2020 2020 2020 3d3d 3d3d 3d3d 3d3d          ========
-0001c5d0: 3d3d 3d3d 3d20 2020 3d3d 3d3d 3d3d 3d3d  =====   ========
-0001c5e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001c5f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
-0001c600: 2020 2020 2020 2020 6571 7569 616e 6775          equiangu
-0001c610: 6c61 7220 2020 2020 3a6d 6174 683a 6072  lar     :math:`r
-0001c620: 203d 206b 205c 7468 6574 6160 0a20 2020   = k \theta`.   
-0001c630: 2020 2020 2073 696e 6520 2020 2020 2020       sine       
-0001c640: 2020 2020 203a 6d61 7468 3a60 7220 3d20       :math:`r = 
-0001c650: 6b20 5c73 696e 205c 7468 6574 6160 0a20  k \sin \theta`. 
-0001c660: 2020 2020 2020 2065 7175 6973 6f6c 6964         equisolid
-0001c670: 2020 2020 2020 203a 6d61 7468 3a60 7220         :math:`r 
-0001c680: 3d20 6b20 5c73 696e 205c 6672 6163 7b5c  = k \sin \frac{\
-0001c690: 7468 6574 617d 7b32 7d60 0a20 2020 2020  theta}{2}`.     
-0001c6a0: 2020 2073 7465 7265 6f67 7261 7068 6963     stereographic
-0001c6b0: 2020 203a 6d61 7468 3a60 7220 3d20 6b20     :math:`r = k 
-0001c6c0: 5c74 616e 205c 6672 6163 7b5c 7468 6574  \tan \frac{\thet
-0001c6d0: 617d 7b32 7d60 0a20 2020 2020 2020 203d  a}{2}`.        =
-0001c6e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2020 203d  ============   =
-0001c6f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001c700: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001c710: 3d3d 3d3d 3d3d 0a0a 2020 2020 3a6e 6f74  ======..    :not
-0001c720: 653a 0a20 2020 2020 2020 202d 2049 6620  e:.        - If 
-0001c730: 6060 4b60 6020 6973 206e 6f74 2073 7065  ``K`` is not spe
-0001c740: 6369 6669 6564 2069 7420 6973 2063 6f6d  cified it is com
-0001c750: 7075 7465 6420 7375 6368 2074 6861 7420  puted such that 
-0001c760: 7468 6520 6369 7263 756c 6172 0a20 2020  the circular.   
-0001c770: 2020 2020 2020 2020 2069 6d61 6769 6e67           imaging
-0001c780: 2072 6567 696f 6e20 6d61 7869 6d61 6c6c   region maximall
-0001c790: 7920 6669 6c6c 7320 7468 6520 696d 6167  y fills the imag
-0001c7a0: 6520 706c 616e 652e 0a20 2020 2020 2020  e plane..       
-0001c7b0: 202d 2054 6869 7320 6361 6d65 7261 206d   - This camera m
-0001c7c0: 6f64 656c 2061 7373 756d 6573 2063 656e  odel assumes cen
-0001c7d0: 7472 616c 2070 726f 6a65 6374 696f 6e2c  tral projection,
-0001c7e0: 2074 6861 7420 6973 2c20 7468 6520 666f   that is, the fo
-0001c7f0: 6361 6c20 706f 696e 740a 2020 2020 2020  cal point.      
-0001c800: 2020 2020 2020 6973 2061 7420 3a6d 6174        is at :mat
-0001c810: 683a 607a 3d30 6020 616e 6420 7468 6520  h:`z=0` and the 
-0001c820: 696d 6167 6520 706c 616e 6520 6973 2061  image plane is a
-0001c830: 7420 3a6d 6174 683a 607a 3d66 602e 2020  t :math:`z=f`.  
-0001c840: 5468 6520 696d 6167 6520 6973 206e 6f74  The image is not
-0001c850: 2069 6e76 6572 7465 642e 0a0a 2020 2020   inverted...    
-0001c860: 3a72 6566 6572 656e 6365 733a 200a 2020  :references: .  
-0001c870: 2020 2020 2020 2d20 526f 626f 7469 6373        - Robotics
-0001c880: 2c20 5669 7369 6f6e 2026 2043 6f6e 7472  , Vision & Contr
-0001c890: 6f6c 2066 6f72 2050 7974 686f 6e2c 2053  ol for Python, S
-0001c8a0: 6563 7469 6f6e 2031 332e 332e 322c 2050  ection 13.3.2, P
-0001c8b0: 2e20 436f 726b 652c 2053 7072 696e 6765  . Corke, Springe
-0001c8c0: 7220 3230 3233 2e0a 0a20 2020 203a 7365  r 2023...    :se
-0001c8d0: 6561 6c73 6f3a 203a 636c 6173 733a 6043  ealso: :class:`C
-0001c8e0: 616d 6572 6142 6173 6560 203a 636c 6173  ameraBase` :clas
-0001c8f0: 733a 6043 656e 7472 616c 4361 6d65 7261  s:`CentralCamera
-0001c900: 6020 3a63 6c61 7373 3a60 4669 7368 4579  ` :class:`FishEy
-0001c910: 6543 616d 6572 6160 0a20 2020 2020 2020  eCamera`.       
-0001c920: 203a 636c 6173 733a 6053 7068 6572 6963   :class:`Spheric
-0001c930: 616c 4361 6d65 7261 600a 2020 2020 2222  alCamera`.    ""
-0001c940: 220a 0a20 2020 2064 6566 205f 5f69 6e69  "..    def __ini
-0001c950: 745f 5f28 7365 6c66 2c20 6b3d 4e6f 6e65  t__(self, k=None
-0001c960: 2c20 7072 6f6a 6563 7469 6f6e 3d27 6571  , projection='eq
-0001c970: 7569 616e 6775 6c61 7227 2c20 6d61 7861  uiangular', maxa
-0001c980: 6e67 6c65 3d4e 6f6e 652c 202a 2a6b 7761  ngle=None, **kwa
-0001c990: 7267 7329 3a0a 0a0a 2020 2020 2020 2020  rgs):...        
-0001c9a0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-0001c9b0: 2863 616d 7479 7065 3d27 6361 7461 6469  (camtype='catadi
-0001c9c0: 6f70 7472 6963 272c 202a 2a6b 7761 7267  optric', **kwarg
-0001c9d0: 7329 0a0a 2020 2020 2020 2020 7365 6c66  s)..        self
-0001c9e0: 2e70 726f 6a65 6374 696f 6e20 3d20 7072  .projection = pr
-0001c9f0: 6f6a 6563 7469 6f6e 0a20 2020 200a 2020  ojection.    .  
-0001ca00: 2020 2020 2020 6966 206b 2069 7320 4e6f        if k is No
-0001ca10: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0001ca20: 7220 3d20 6e70 2e6d 696e 2828 7365 6c66  r = np.min((self
-0001ca30: 2e69 6d61 6765 7369 7a65 202d 2073 656c  .imagesize - sel
-0001ca40: 662e 7070 2920 2a20 7365 6c66 2e72 686f  f.pp) * self.rho
-0001ca50: 290a 0a20 2020 2020 2020 2023 2063 6f6d  )..        # com
-0001ca60: 7075 7465 206b 2069 6620 6e6f 7420 7370  pute k if not sp
-0001ca70: 6563 6966 6965 642c 2073 6f20 7468 6174  ecified, so that
-0001ca80: 2068 656d 6973 7068 6572 6520 6669 7473   hemisphere fits
-0001ca90: 2069 6e74 6f0a 2020 2020 2020 2020 2320   into.        # 
-0001caa0: 696d 6167 6520 706c 616e 652c 2072 6571  image plane, req
-0001cab0: 7569 7265 7320 6d61 7861 6e67 6c65 2062  uires maxangle b
-0001cac0: 6569 6e67 2073 6574 0a0a 2020 2020 2020  eing set..      
-0001cad0: 2020 6966 2073 656c 662e 7072 6f6a 6563    if self.projec
-0001cae0: 7469 6f6e 203d 3d20 2765 7175 6961 6e67  tion == 'equiang
-0001caf0: 756c 6172 273a 0a20 2020 2020 2020 2020  ular':.         
-0001cb00: 2020 2069 6620 6b20 6973 204e 6f6e 653a     if k is None:
-0001cb10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001cb20: 2069 6620 6d61 7861 6e67 6c65 2069 7320   if maxangle is 
-0001cb30: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-0001cb40: 2020 2020 2020 2020 2020 2020 2020 6b20                k 
-0001cb50: 3d20 7220 2f20 2870 6920 2f20 3220 2b20  = r / (pi / 2 + 
-0001cb60: 6d61 7861 6e67 6c65 290a 2020 2020 2020  maxangle).      
-0001cb70: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0001cb80: 6c66 2e6d 6178 616e 676c 6520 3d20 6d61  lf.maxangle = ma
-0001cb90: 7861 6e67 6c65 0a20 2020 2020 2020 2020  xangle.         
-0001cba0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0001cbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cbc0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0001cbd0: 7228 276d 7573 7420 7370 6563 6966 7920  r('must specify 
-0001cbe0: 6569 7468 6572 206b 206f 7220 6d61 7861  either k or maxa
-0001cbf0: 6e67 6c65 2729 0a20 2020 2020 2020 2020  ngle').         
-0001cc00: 2020 2072 6675 6e63 203d 206c 616d 6264     rfunc = lambd
-0001cc10: 6120 7468 6574 613a 206b 202a 2074 6865  a theta: k * the
-0001cc20: 7461 0a20 2020 2020 2020 2065 6c69 6620  ta.        elif 
-0001cc30: 7365 6c66 2e70 726f 6a65 6374 696f 6e20  self.projection 
-0001cc40: 3d3d 2027 7369 6e65 273a 0a20 2020 2020  == 'sine':.     
-0001cc50: 2020 2020 2020 2069 6620 6b20 6973 204e         if k is N
-0001cc60: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0001cc70: 2020 2020 206b 203d 2072 0a20 2020 2020       k = r.     
-0001cc80: 2020 2020 2020 2072 6675 6e63 203d 206c         rfunc = l
-0001cc90: 616d 6264 6120 7468 6574 613a 206b 202a  ambda theta: k *
-0001cca0: 206e 702e 7369 6e28 7468 6574 6129 0a20   np.sin(theta). 
-0001ccb0: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-0001ccc0: 2e70 726f 6a65 6374 696f 6e20 3d3d 2027  .projection == '
-0001ccd0: 6571 7569 736f 6c69 6427 3a0a 2020 2020  equisolid':.    
-0001cce0: 2020 2020 2020 2020 6966 206b 2069 7320          if k is 
-0001ccf0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001cd00: 2020 2020 2020 6b20 3d20 7220 2f20 7369        k = r / si
-0001cd10: 6e28 7069 202f 2034 290a 2020 2020 2020  n(pi / 4).      
-0001cd20: 2020 2020 2020 7266 756e 6320 3d20 6c61        rfunc = la
-0001cd30: 6d62 6461 2074 6865 7461 3a20 6b20 2a20  mbda theta: k * 
-0001cd40: 6e70 2e73 696e 2874 6865 7461 202f 2032  np.sin(theta / 2
-0001cd50: 290a 2020 2020 2020 2020 656c 6966 2073  ).        elif s
-0001cd60: 656c 662e 7072 6f6a 6563 7469 6f6e 203d  elf.projection =
-0001cd70: 3d20 2773 7465 7265 6f67 7261 7068 6963  = 'stereographic
-0001cd80: 273a 0a20 2020 2020 2020 2020 2020 2069  ':.            i
-0001cd90: 6620 6b20 6973 204e 6f6e 653a 0a20 2020  f k is None:.   
-0001cda0: 2020 2020 2020 2020 2020 2020 206b 203d               k =
-0001cdb0: 2072 202f 2074 616e 2870 692f 3429 0a20   r / tan(pi/4). 
-0001cdc0: 2020 2020 2020 2020 2020 2072 6675 6e63             rfunc
-0001cdd0: 203d 206c 616d 6264 6120 7468 6574 613a   = lambda theta:
-0001cde0: 206b 202a 206e 702e 7461 6e28 7468 6574   k * np.tan(thet
-0001cdf0: 6120 2f20 3229 0a20 2020 2020 2020 2065  a / 2).        e
-0001ce00: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0001ce10: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0001ce20: 7228 2775 6e6b 6e6f 776e 2070 726f 6a65  r('unknown proje
-0001ce30: 6374 696f 6e20 6d6f 6465 6c27 290a 0a20  ction model').. 
-0001ce40: 2020 2020 2020 2073 656c 662e 6b20 3d20         self.k = 
-0001ce50: 6b0a 2020 2020 2020 2020 7365 6c66 2e72  k.        self.r
-0001ce60: 6675 6e63 203d 2072 6675 6e63 0a0a 2020  func = rfunc..  
-0001ce70: 2020 6465 6620 5f5f 7374 725f 5f28 7365    def __str__(se
-0001ce80: 6c66 293a 0a20 2020 2020 2020 2073 203d  lf):.        s =
-0001ce90: 2073 7570 6572 2829 2e5f 5f73 7472 5f5f   super().__str__
-0001cea0: 2829 0a20 2020 2020 2020 2073 202b 3d20  ().        s += 
-0001ceb0: 7365 6c66 2e66 6d74 2e66 6f72 6d61 7428  self.fmt.format(
-0001cec0: 276d 6f64 656c 272c 2073 656c 662e 7072  'model', self.pr
-0001ced0: 6f6a 6563 7469 6f6e 2c20 666d 743d 227b  ojection, fmt="{
-0001cee0: 7d22 290a 2020 2020 2020 2020 7320 2b3d  }").        s +=
-0001cef0: 2073 656c 662e 666d 742e 666f 726d 6174   self.fmt.format
-0001cf00: 2827 6b27 2c20 7365 6c66 2e6b 2c20 666d  ('k', self.k, fm
-0001cf10: 743d 227b 3a2e 3467 7d22 290a 2020 2020  t="{:.4g}").    
-0001cf20: 2020 2020 7265 7475 726e 2073 0a0a 2020      return s..  
-0001cf30: 2020 6465 6620 7072 6f6a 6563 745f 706f    def project_po
-0001cf40: 696e 7428 7365 6c66 2c20 502c 2070 6f73  int(self, P, pos
-0001cf50: 653d 4e6f 6e65 2c20 6f62 6a70 6f73 653d  e=None, objpose=
-0001cf60: 4e6f 6e65 293a 2020 2020 2020 2020 0a20  None):        . 
-0001cf70: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0001cf80: 2020 2050 726f 6a65 6374 2033 4420 706f     Project 3D po
-0001cf90: 696e 7473 2074 6f20 696d 6167 6520 706c  ints to image pl
-0001cfa0: 616e 650a 0a20 2020 2020 2020 203a 7061  ane..        :pa
-0001cfb0: 7261 6d20 503a 2033 4420 776f 726c 6420  ram P: 3D world 
-0001cfc0: 706f 696e 7420 6f72 2070 6f69 6e74 730a  point or points.
-0001cfd0: 2020 2020 2020 2020 3a74 7970 6520 503a          :type P:
-0001cfe0: 2061 7272 6179 5f6c 696b 6528 3329 2c20   array_like(3), 
-0001cff0: 6172 7261 795f 6c69 6b65 2833 2c6e 290a  array_like(3,n).
-0001d000: 2020 2020 2020 2020 3a70 6172 616d 2070          :param p
-0001d010: 6f73 653a 2063 616d 6572 6120 706f 7365  ose: camera pose
-0001d020: 2077 6974 6820 7265 7370 6563 7420 746f   with respect to
-0001d030: 2074 6865 2077 6f72 6c64 2066 7261 6d65   the world frame
-0001d040: 2c20 6465 6661 756c 7473 2074 6f0a 2020  , defaults to.  
-0001d050: 2020 2020 2020 2020 2020 6361 6d65 7261            camera
-0001d060: 2773 2060 6070 6f73 6560 6020 6174 7472  's ``pose`` attr
-0001d070: 6962 7574 650a 2020 2020 2020 2020 3a74  ibute.        :t
-0001d080: 7970 6520 706f 7365 3a20 3a63 6c61 7373  ype pose: :class
-0001d090: 3a60 7e73 7061 7469 616c 6d61 7468 2e2e  :`~spatialmath..
-0001d0a0: 706f 7365 3364 2e53 4533 602c 206f 7074  pose3d.SE3`, opt
-0001d0b0: 696f 6e61 6c0a 2020 2020 2020 2020 3a70  ional.        :p
-0001d0c0: 6172 616d 206f 626a 706f 7365 3a20 2033  aram objpose:  3
-0001d0d0: 4420 706f 696e 7420 7265 6665 7265 6e63  D point referenc
-0001d0e0: 6520 6672 616d 652c 2064 6566 6175 6c74  e frame, default
-0001d0f0: 7320 746f 2077 6f72 6c64 2066 7261 6d65  s to world frame
-0001d100: 0a20 2020 2020 2020 203a 7479 7065 206f  .        :type o
-0001d110: 626a 706f 7365 3a20 3a63 6c61 7373 3a60  bjpose: :class:`
-0001d120: 7e73 7061 7469 616c 6d61 7468 2e2e 706f  ~spatialmath..po
-0001d130: 7365 3364 2e53 4533 602c 206f 7074 696f  se3d.SE3`, optio
-0001d140: 6e61 6c0a 2020 2020 2020 2020 3a70 6172  nal.        :par
-0001d150: 616d 2076 6973 6962 696c 6974 793a 2074  am visibility: t
-0001d160: 6573 7420 6966 2070 6f69 6e74 7320 6172  est if points ar
-0001d170: 6520 7669 7369 626c 652c 2064 6566 6175  e visible, defau
-0001d180: 6c74 2046 616c 7365 0a20 2020 2020 2020  lt False.       
-0001d190: 203a 7479 7065 2076 6973 6962 696c 6974   :type visibilit
-0001d1a0: 793a 2062 6f6f 6c0a 2020 2020 2020 2020  y: bool.        
-0001d1b0: 3a72 6169 7365 7320 5661 6c75 6545 7272  :raises ValueErr
-0001d1c0: 6f72 3a20 5b64 6573 6372 6970 7469 6f6e  or: [description
-0001d1d0: 5d0a 2020 2020 2020 2020 3a72 6574 7572  ].        :retur
-0001d1e0: 6e3a 2069 6d61 6765 2070 6c61 6e65 2070  n: image plane p
-0001d1f0: 6f69 6e74 730a 2020 2020 2020 2020 3a72  oints.        :r
-0001d200: 7479 7065 3a20 6e64 6172 7261 7928 322c  type: ndarray(2,
-0001d210: 6e29 0a0a 2020 2020 2020 2020 5072 6f6a  n)..        Proj
-0001d220: 6563 7420 776f 726c 6420 706f 696e 7473  ect world points
-0001d230: 2074 6f20 7468 6520 6361 7461 6469 6f70   to the catadiop
-0001d240: 7472 6963 2063 616d 6572 6120 696d 6167  tric camera imag
-0001d250: 6520 706c 616e 652e 0a0a 2020 2020 2020  e plane...      
-0001d260: 2020 576f 726c 6420 706f 696e 7473 2061    World points a
-0001d270: 7265 2067 6976 656e 2061 7320 6120 3144  re given as a 1D
-0001d280: 2061 7272 6179 206f 7220 7468 6520 636f   array or the co
-0001d290: 6c75 6d6e 7320 6f66 2061 2032 4420 6172  lumns of a 2D ar
-0001d2a0: 7261 7920 6f66 0a20 2020 2020 2020 2045  ray of.        E
-0001d2b0: 7563 6c69 6465 616e 2063 6f6f 7264 696e  uclidean coordin
-0001d2c0: 6174 6573 2e20 5468 6520 636f 6d70 7574  ates. The comput
-0001d2d0: 6564 2069 6d61 6765 2070 6c61 6e65 2063  ed image plane c
-0001d2e0: 6f6f 7264 696e 6174 6573 2061 7265 0a20  oordinates are. 
-0001d2f0: 2020 2020 2020 2045 7563 6c69 6465 616e         Euclidean
-0001d300: 2061 6e64 2067 6976 656e 2061 7320 6120   and given as a 
-0001d310: 3144 2061 7272 6179 206f 7220 7468 6520  1D array or the 
-0001d320: 636f 7272 6573 706f 6e64 696e 6720 636f  corresponding co
-0001d330: 6c75 6d6e 7320 6f66 2061 2032 440a 2020  lumns of a 2D.  
-0001d340: 2020 2020 2020 6172 7261 792e 0a0a 2020        array...  
-0001d350: 2020 2020 2020 4966 2060 6070 6f73 6560        If ``pose`
-0001d360: 6020 6973 2073 7065 6369 6669 6564 2069  ` is specified i
-0001d370: 7420 6973 2075 7365 6420 666f 7220 7468  t is used for th
-0001d380: 6520 6361 6d65 7261 2070 6f73 6520 696e  e camera pose in
-0001d390: 7374 6561 6420 6f66 2074 6865 0a20 2020  stead of the.   
-0001d3a0: 2020 2020 2061 7474 7269 6275 7465 2060       attribute `
-0001d3b0: 6070 6f73 6560 602e 2020 5468 6520 6f62  `pose``.  The ob
-0001d3c0: 6a65 6374 2773 2061 7474 7269 6275 7465  ject's attribute
-0001d3d0: 2069 7320 6e6f 7420 7570 6461 7465 642e   is not updated.
-0001d3e0: 0a0a 2020 2020 2020 2020 5468 6520 706f  ..        The po
-0001d3f0: 696e 7473 2060 6050 6060 2061 7265 2062  ints ``P`` are b
-0001d400: 7920 6465 6661 756c 7420 7769 7468 2072  y default with r
-0001d410: 6573 7065 6374 2074 6f20 7468 6520 776f  espect to the wo
-0001d420: 726c 6420 6672 616d 652c 2062 7574 200a  rld frame, but .
-0001d430: 2020 2020 2020 2020 7468 6579 2063 616e          they can
-0001d440: 2062 6520 7472 616e 7366 6f72 6d65 6420   be transformed 
-0001d450: 6279 2073 7065 6369 6679 696e 6720 6060  by specifying ``
-0001d460: 6f62 6a70 6f73 6560 602e 0a0a 2020 2020  objpose``...    
-0001d470: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
-0001d480: 6574 683a 6070 6c6f 745f 706f 696e 7460  eth:`plot_point`
-0001d490: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0001d4a0: 2020 2020 2050 203d 2062 6173 652e 6765       P = base.ge
-0001d4b0: 746d 6174 7269 7828 502c 2028 332c 204e  tmatrix(P, (3, N
-0001d4c0: 6f6e 6529 290a 0a20 2020 2020 2020 2069  one))..        i
-0001d4d0: 6620 706f 7365 2069 7320 6e6f 7420 4e6f  f pose is not No
-0001d4e0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0001d4f0: 5420 3d20 7365 6c66 2e70 6f73 652e 696e  T = self.pose.in
-0001d500: 7628 290a 2020 2020 2020 2020 656c 7365  v().        else
-0001d510: 3a0a 2020 2020 2020 2020 2020 2020 5420  :.            T 
-0001d520: 3d20 5345 3328 290a 2020 2020 2020 2020  = SE3().        
-0001d530: 6966 206f 626a 706f 7365 2069 7320 6e6f  if objpose is no
-0001d540: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-0001d550: 2020 2020 5420 2a3d 206f 626a 706f 7365      T *= objpose
-0001d560: 0a0a 2020 2020 2020 2020 5020 3d20 5420  ..        P = T 
-0001d570: 2a20 5020 2023 2074 7261 6e73 666f 726d  * P  # transform
-0001d580: 2070 6f69 6e74 7320 746f 2063 616d 6572   points to camer
-0001d590: 6120 6672 616d 650a 2020 2020 0a20 2020  a frame.    .   
-0001d5a0: 2020 2020 2023 2070 726f 6a65 6374 2074       # project t
-0001d5b0: 6f20 7468 6520 696d 6167 6520 706c 616e  o the image plan
-0001d5c0: 650a 2020 2020 2020 2020 5220 3d20 6e70  e.        R = np
-0001d5d0: 2e73 7172 7428 6e70 2e73 756d 2850 202a  .sqrt(np.sum(P *
-0001d5e0: 2a20 322c 2061 7869 733d 3029 290a 2020  * 2, axis=0)).  
-0001d5f0: 2020 2020 2020 7068 6920 3d20 6e70 2e61        phi = np.a
-0001d600: 7263 7461 6e32 2850 5b31 2c20 3a5d 2c20  rctan2(P[1, :], 
-0001d610: 505b 302c 203a 5d29 0a20 2020 2020 2020  P[0, :]).       
-0001d620: 2074 6865 7461 203d 206e 702e 6172 6363   theta = np.arcc
-0001d630: 6f73 2850 5b32 2c20 3a5d 202f 2052 290a  os(P[2, :] / R).
-0001d640: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-0001d650: 2072 203d 2073 656c 662e 7266 756e 6328   r = self.rfunc(
-0001d660: 7468 6574 6129 2020 2320 6465 7065 6e64  theta)  # depend
-0001d670: 7320 6f6e 2070 726f 6a65 6374 696f 6e20  s on projection 
-0001d680: 6d6f 6465 6c0a 2020 2020 2020 2020 7820  model.        x 
-0001d690: 3d20 7220 2a20 6e70 2e63 6f73 2870 6869  = r * np.cos(phi
-0001d6a0: 290a 2020 2020 2020 2020 7920 3d20 7220  ).        y = r 
-0001d6b0: 2a20 6e70 2e73 696e 2870 6869 290a 2020  * np.sin(phi).  
-0001d6c0: 2020 2020 2020 0a20 2020 2020 2020 2075        .        u
-0001d6d0: 7620 3d20 6e70 2e61 7272 6179 285b 7820  v = np.array([x 
-0001d6e0: 2f20 7365 6c66 2e72 686f 7520 2b20 7365  / self.rhou + se
-0001d6f0: 6c66 2e75 302c 2079 202f 2073 656c 662e  lf.u0, y / self.
-0001d700: 7268 6f76 202b 2073 656c 662e 7630 5d29  rhov + self.v0])
-0001d710: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-0001d720: 2020 7265 7475 726e 2073 656c 662e 5f61    return self._a
-0001d730: 6464 5f6e 6f69 7365 5f64 6973 746f 7274  dd_noise_distort
-0001d740: 696f 6e28 7576 290a 0a23 202d 2d2d 2d2d  ion(uv)..# -----
-0001d750: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001d760: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001d770: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001d780: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001d790: 2d2d 2d20 230a 636c 6173 7320 5370 6865  --- #.class Sphe
-0001d7a0: 7269 6361 6c43 616d 6572 6128 4361 6d65  ricalCamera(Came
-0001d7b0: 7261 4261 7365 293a 0a20 2020 2022 2222  raBase):.    """
-0001d7c0: 0a20 2020 2043 7265 6174 6520 7370 6865  .    Create sphe
-0001d7d0: 7269 6361 6c20 6361 6d65 7261 2070 726f  rical camera pro
-0001d7e0: 6a65 6374 696f 6e20 6d6f 6465 6c0a 0a20  jection model.. 
-0001d7f0: 2020 202e 2e20 696e 6865 7269 7461 6e63     .. inheritanc
-0001d800: 652d 6469 6167 7261 6d3a 3a20 6d61 6368  e-diagram:: mach
-0001d810: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
-0001d820: 2e43 616d 6572 612e 5370 6865 7269 6361  .Camera.Spherica
-0001d830: 6c43 616d 6572 610a 2020 2020 2020 2020  lCamera.        
-0001d840: 3a74 6f70 2d63 6c61 7373 6573 3a20 6d61  :top-classes: ma
-0001d850: 6368 696e 6576 6973 696f 6e74 6f6f 6c62  chinevisiontoolb
-0001d860: 6f78 2e43 616d 6572 612e 4361 6d65 7261  ox.Camera.Camera
-0001d870: 0a20 2020 2020 2020 203a 7061 7274 733a  .        :parts:
-0001d880: 2031 0a0a 2020 2020 3a70 6172 616d 206b   1..    :param k
-0001d890: 7761 7267 733a 2061 7267 756d 656e 7473  wargs: arguments
-0001d8a0: 2070 6173 7365 6420 746f 203a 636c 6173   passed to :clas
-0001d8b0: 733a 6043 616d 6572 6142 6173 6560 2063  s:`CameraBase` c
-0001d8c0: 6f6e 7374 7275 6374 6f72 0a0a 2020 2020  onstructor..    
-0001d8d0: 5468 6520 7370 6865 7269 6361 6c20 6361  The spherical ca
-0001d8e0: 6d65 7261 2069 7320 616e 2069 6465 616c  mera is an ideal
-0001d8f0: 697a 6174 696f 6e20 7769 7468 2061 2063  ization with a c
-0001d900: 6f6d 706c 6574 6520 6669 656c 6420 6f66  omplete field of
-0001d910: 2076 6965 770a 2020 2020 7468 6174 2063   view.    that c
-0001d920: 616e 2062 6520 7573 6564 2074 6f20 6765  an be used to ge
-0001d930: 6e65 7261 6c69 7a65 2061 6c6c 2063 616d  neralize all cam
-0001d940: 6572 6120 7072 6f6a 6563 7469 6f6e 206d  era projection m
-0001d950: 6f64 656c 732e 0a0a 2020 2020 3a72 6566  odels...    :ref
-0001d960: 6572 656e 6365 733a 200a 2020 2020 2020  erences: .      
-0001d970: 2020 2d20 526f 626f 7469 6373 2c20 5669    - Robotics, Vi
-0001d980: 7369 6f6e 2026 2043 6f6e 7472 6f6c 2066  sion & Control f
-0001d990: 6f72 2050 7974 686f 6e2c 2053 6563 7469  or Python, Secti
-0001d9a0: 6f6e 2031 332e 332e 332c 2050 2e20 436f  on 13.3.3, P. Co
-0001d9b0: 726b 652c 2053 7072 696e 6765 7220 3230  rke, Springer 20
-0001d9c0: 3233 2e0a 0a20 2020 203a 7365 6561 6c73  23...    :seeals
-0001d9d0: 6f3a 203a 636c 6173 733a 6043 616d 6572  o: :class:`Camer
-0001d9e0: 6142 6173 6560 203a 636c 6173 733a 6043  aBase` :class:`C
-0001d9f0: 656e 7472 616c 4361 6d65 7261 6020 3a63  entralCamera` :c
-0001da00: 6c61 7373 3a60 4361 7461 6469 6f70 7472  lass:`Catadioptr
-0001da10: 6963 4361 6d65 7261 600a 2020 2020 2020  icCamera`.      
-0001da20: 2020 3a63 6c61 7373 3a60 4669 7368 4579    :class:`FishEy
-0001da30: 6543 616d 6572 6160 200a 2020 2020 2222  eCamera` .    ""
-0001da40: 220a 2020 2020 2020 2020 0a20 2020 2064  ".        .    d
-0001da50: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
-0001da60: 2c20 2a2a 6b77 6172 6773 293a 0a0a 2020  , **kwargs):..  
-0001da70: 2020 2020 2020 2320 696e 766f 6b65 2074        # invoke t
-0001da80: 6865 2073 7570 6572 636c 6173 7320 636f  he superclass co
-0001da90: 6e73 7472 7563 746f 720a 2020 2020 2020  nstructor.      
-0001daa0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-0001dab0: 5f5f 2863 616d 7479 7065 3d27 7370 6865  __(camtype='sphe
-0001dac0: 7269 6361 6c27 2c20 0a20 2020 2020 2020  rical', .       
-0001dad0: 2020 2020 206c 696d 6974 733d 5b2d 7069       limits=[-pi
-0001dae0: 2c70 692c 302c 7069 5d2c 0a20 2020 2020  ,pi,0,pi],.     
-0001daf0: 2020 2020 2020 206c 6162 656c 733d 5b27         labels=['
-0001db00: 4c6f 6e67 6974 7564 6520 cf86 2028 7261  Longitude .. (ra
-0001db10: 6429 272c 2027 436f 6c61 7469 7475 6465  d)', 'Colatitude
-0001db20: 20ce b820 2872 6164 2927 5d2c 0a20 2020   .. (rad)'],.   
-0001db30: 2020 2020 2020 2020 202a 2a6b 7761 7267           **kwarg
-0001db40: 7329 0a0a 2020 2020 2320 7265 7475 726e  s)..    # return
-0001db50: 2066 6965 6c64 2d6f 662d 7669 6577 2061   field-of-view a
-0001db60: 6e67 6c65 2066 6f72 2078 2061 6e64 2079  ngle for x and y
-0001db70: 2064 6972 6563 7469 6f6e 2028 7261 6429   direction (rad)
-0001db80: 0a20 2020 2064 6566 2066 6f76 2873 656c  .    def fov(sel
-0001db90: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-0001dba0: 2020 2020 2020 2020 4361 6d65 7261 2066          Camera f
-0001dbb0: 6965 6c64 2d6f 662d 7669 6577 2061 6e67  ield-of-view ang
-0001dbc0: 6c65 730a 0a20 2020 2020 2020 203a 7265  les..        :re
-0001dbd0: 7475 726e 3a20 6669 656c 6420 6f66 2076  turn: field of v
-0001dbe0: 6965 7720 616e 676c 6573 2069 6e20 7261  iew angles in ra
-0001dbf0: 6469 616e 730a 2020 2020 2020 2020 3a72  dians.        :r
-0001dc00: 7479 7065 3a20 6e64 6172 7261 7928 3229  type: ndarray(2)
-0001dc10: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-0001dc20: 2020 436f 6d70 7574 6573 2074 6865 2066    Computes the f
-0001dc30: 6965 6c64 206f 6620 7669 6577 2061 6e67  ield of view ang
-0001dc40: 6c65 7320 2832 7831 2920 696e 2072 6164  les (2x1) in rad
-0001dc50: 6961 6e73 2066 6f72 2074 6865 2063 616d  ians for the cam
-0001dc60: 6572 610a 2020 2020 2020 2020 686f 7269  era.        hori
-0001dc70: 7a6f 6e74 616c 2061 6e64 2076 6572 7469  zontal and verti
-0001dc80: 6361 6c20 6469 7265 6374 696f 6e73 2e0a  cal directions..
-0001dc90: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0001dca0: 2020 2020 7265 7475 726e 205b 3220 2a20      return [2 * 
-0001dcb0: 7069 2c20 3220 2a20 7069 5d0a 2020 2020  pi, 2 * pi].    
-0001dcc0: 0a20 2020 2064 6566 2070 726f 6a65 6374  .    def project
-0001dcd0: 5f70 6f69 6e74 2873 656c 662c 2050 2c20  _point(self, P, 
-0001dce0: 706f 7365 3d4e 6f6e 652c 206f 626a 706f  pose=None, objpo
-0001dcf0: 7365 3d4e 6f6e 6529 3a0a 2020 2020 2020  se=None):.      
-0001dd00: 2020 7222 2222 0a20 2020 2020 2020 2050    r""".        P
-0001dd10: 726f 6a65 6374 2033 4420 706f 696e 7473  roject 3D points
-0001dd20: 2074 6f20 696d 6167 6520 706c 616e 650a   to image plane.
-0001dd30: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-0001dd40: 503a 2033 4420 776f 726c 6420 706f 696e  P: 3D world poin
-0001dd50: 7420 6f72 2070 6f69 6e74 730a 2020 2020  t or points.    
-0001dd60: 2020 2020 3a74 7970 6520 503a 2061 7272      :type P: arr
-0001dd70: 6179 5f6c 696b 6528 3329 2c20 6172 7261  ay_like(3), arra
-0001dd80: 795f 6c69 6b65 2833 2c6e 290a 2020 2020  y_like(3,n).    
-0001dd90: 2020 2020 3a70 6172 616d 2070 6f73 653a      :param pose:
-0001dda0: 2063 616d 6572 6120 706f 7365 2077 6974   camera pose wit
-0001ddb0: 6820 7265 7370 6563 7420 746f 2074 6865  h respect to the
-0001ddc0: 2077 6f72 6c64 2066 7261 6d65 2c20 6465   world frame, de
-0001ddd0: 6661 756c 7473 2074 6f0a 2020 2020 2020  faults to.      
-0001dde0: 2020 2020 2020 6361 6d65 7261 2773 2060        camera's `
-0001ddf0: 6070 6f73 6560 6020 6174 7472 6962 7574  `pose`` attribut
-0001de00: 650a 2020 2020 2020 2020 3a74 7970 6520  e.        :type 
-0001de10: 706f 7365 3a20 3a63 6c61 7373 3a60 7e73  pose: :class:`~s
-0001de20: 7061 7469 616c 6d61 7468 2e2e 706f 7365  patialmath..pose
-0001de30: 3364 2e53 4533 602c 206f 7074 696f 6e61  3d.SE3`, optiona
-0001de40: 6c0a 2020 2020 2020 2020 3a70 6172 616d  l.        :param
-0001de50: 206f 626a 706f 7365 3a20 2033 4420 706f   objpose:  3D po
-0001de60: 696e 7420 7265 6665 7265 6e63 6520 6672  int reference fr
-0001de70: 616d 652c 2064 6566 6175 6c74 7320 746f  ame, defaults to
-0001de80: 2077 6f72 6c64 2066 7261 6d65 0a20 2020   world frame.   
-0001de90: 2020 2020 203a 7479 7065 206f 626a 706f       :type objpo
-0001dea0: 7365 3a20 3a63 6c61 7373 3a60 7e73 7061  se: :class:`~spa
-0001deb0: 7469 616c 6d61 7468 2e2e 706f 7365 3364  tialmath..pose3d
-0001dec0: 2e53 4533 602c 206f 7074 696f 6e61 6c0a  .SE3`, optional.
-0001ded0: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
-0001dee0: 2069 6d61 6765 2070 6c61 6e65 2070 6f69   image plane poi
-0001def0: 6e74 730a 2020 2020 2020 2020 3a72 7479  nts.        :rty
-0001df00: 7065 3a20 6e64 6172 7261 7928 322c 6e29  pe: ndarray(2,n)
-0001df10: 0a0a 2020 2020 2020 2020 5072 6f6a 6563  ..        Projec
-0001df20: 7420 776f 726c 6420 706f 696e 7473 2074  t world points t
-0001df30: 6f20 7468 6520 7370 6865 7269 6361 6c20  o the spherical 
-0001df40: 6361 6d65 7261 2069 6d61 6765 2070 6c61  camera image pla
-0001df50: 6e65 2e0a 2020 2020 2020 2020 0a20 2020  ne..        .   
-0001df60: 2020 2020 2057 6f72 6c64 2070 6f69 6e74       World point
-0001df70: 7320 6172 6520 6769 7665 6e20 6173 2061  s are given as a
-0001df80: 2031 4420 6172 7261 7920 6f72 2074 6865   1D array or the
-0001df90: 2063 6f6c 756d 6e73 206f 6620 6120 3244   columns of a 2D
-0001dfa0: 2061 7272 6179 206f 660a 2020 2020 2020   array of.      
-0001dfb0: 2020 4575 636c 6964 6561 6e20 636f 6f72    Euclidean coor
-0001dfc0: 6469 6e61 7465 732e 2054 6865 2063 6f6d  dinates. The com
-0001dfd0: 7075 7465 6420 696d 6167 6520 706c 616e  puted image plan
-0001dfe0: 6520 636f 6f72 6469 6e61 7465 7320 6172  e coordinates ar
-0001dff0: 650a 2020 2020 2020 2020 696e 2070 6f6c  e.        in pol
-0001e000: 6172 2066 6f72 6d20 3a6d 6174 683a 6028  ar form :math:`(
-0001e010: 5c70 6869 2c20 5c74 6865 7461 2960 2028  \phi, \theta)` (
-0001e020: 6c6f 6e67 6974 7564 652c 2063 6f6c 6174  longitude, colat
-0001e030: 6974 7564 6529 2c0a 2020 2020 2020 2020  itude),.        
-0001e040: 616e 6420 6769 7665 6e20 6173 2061 2031  and given as a 1
-0001e050: 4420 6172 7261 7920 6f72 2074 6865 2063  D array or the c
-0001e060: 6f72 7265 7370 6f6e 6469 6e67 2063 6f6c  orresponding col
-0001e070: 756d 6e73 206f 6620 6120 3244 0a20 2020  umns of a 2D.   
-0001e080: 2020 2020 2061 7272 6179 2e0a 0a20 2020       array...   
-0001e090: 2020 2020 2049 6620 6060 706f 7365 6060       If ``pose``
-0001e0a0: 2069 7320 7370 6563 6966 6965 6420 6974   is specified it
-0001e0b0: 2069 7320 7573 6564 2066 6f72 2074 6865   is used for the
-0001e0c0: 2063 616d 6572 6120 706f 7365 2069 6e73   camera pose ins
-0001e0d0: 7465 6164 206f 6620 7468 650a 2020 2020  tead of the.    
-0001e0e0: 2020 2020 6174 7472 6962 7574 6520 6060      attribute ``
-0001e0f0: 706f 7365 6060 2e20 2054 6865 206f 626a  pose``.  The obj
-0001e100: 6563 7427 7320 6174 7472 6962 7574 6520  ect's attribute 
-0001e110: 6973 206e 6f74 2075 7064 6174 6564 2e0a  is not updated..
-0001e120: 0a20 2020 2020 2020 2054 6865 2070 6f69  .        The poi
-0001e130: 6e74 7320 6060 5060 6020 6172 6520 6279  nts ``P`` are by
-0001e140: 2064 6566 6175 6c74 2077 6974 6820 7265   default with re
-0001e150: 7370 6563 7420 746f 2074 6865 2077 6f72  spect to the wor
-0001e160: 6c64 2066 7261 6d65 2c20 6275 7420 0a20  ld frame, but . 
-0001e170: 2020 2020 2020 2074 6865 7920 6361 6e20         they can 
-0001e180: 6265 2074 7261 6e73 666f 726d 6564 2062  be transformed b
-0001e190: 7920 7370 6563 6966 7969 6e67 2060 606f  y specifying ``o
-0001e1a0: 626a 706f 7365 6060 2e0a 0a20 2020 2020  bjpose``...     
-0001e1b0: 2020 203a 7365 6561 6c73 6f3a 203a 6d65     :seealso: :me
-0001e1c0: 7468 3a60 706c 6f74 5f70 6f69 6e74 600a  th:`plot_point`.
-0001e1d0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0001e1e0: 2020 2020 5020 3d20 6261 7365 2e67 6574      P = base.get
-0001e1f0: 6d61 7472 6978 2850 2c20 2833 2c20 4e6f  matrix(P, (3, No
-0001e200: 6e65 2929 0a0a 2020 2020 2020 2020 6966  ne))..        if
-0001e210: 2070 6f73 6520 6973 204e 6f6e 653a 0a20   pose is None:. 
-0001e220: 2020 2020 2020 2020 2020 2070 6f73 6520             pose 
-0001e230: 3d20 7365 6c66 2e70 6f73 650a 0a20 2020  = self.pose..   
-0001e240: 2020 2020 2070 6f73 6520 3d20 706f 7365       pose = pose
-0001e250: 2e69 6e76 2829 0a0a 2020 2020 2020 2020  .inv()..        
-0001e260: 6966 206f 626a 706f 7365 2069 7320 6e6f  if objpose is no
-0001e270: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-0001e280: 2020 2020 706f 7365 202a 3d20 6f62 6a70      pose *= objp
-0001e290: 6f73 650a 0a20 2020 2020 2020 2050 203d  ose..        P =
-0001e2a0: 2070 6f73 6520 2a20 5020 2020 2020 2020   pose * P       
-0001e2b0: 2020 2320 7472 616e 7366 6f72 6d20 706f    # transform po
-0001e2c0: 696e 7473 2074 6f20 6361 6d65 7261 2066  ints to camera f
-0001e2d0: 7261 6d65 0a20 2020 2020 2020 200a 2020  rame.        .  
-0001e2e0: 2020 2020 2020 5220 3d20 6e70 2e6c 696e        R = np.lin
-0001e2f0: 616c 672e 6e6f 726d 2850 2c20 6178 6973  alg.norm(P, axis
-0001e300: 3d30 290a 2020 2020 2020 2020 7820 3d20  =0).        x = 
-0001e310: 505b 302c 203a 5d20 2f20 520a 2020 2020  P[0, :] / R.    
-0001e320: 2020 2020 7920 3d20 505b 312c 203a 5d20      y = P[1, :] 
-0001e330: 2f20 520a 2020 2020 2020 2020 7a20 3d20  / R.        z = 
-0001e340: 505b 322c 203a 5d20 2f20 520a 0a20 2020  P[2, :] / R..   
-0001e350: 2020 2020 2070 6869 203d 206e 702e 6172       phi = np.ar
-0001e360: 6374 616e 3228 792c 2078 290a 2020 2020  ctan2(y, x).    
-0001e370: 2020 2020 7468 6574 6120 3d20 6e70 2e61      theta = np.a
-0001e380: 7263 636f 7328 7a29 0a20 2020 2020 2020  rccos(z).       
-0001e390: 2072 6574 7572 6e20 6e70 2e61 7272 6179   return np.array
-0001e3a0: 285b 7068 692c 2074 6865 7461 5d29 0a0a  ([phi, theta])..
-0001e3b0: 2020 2020 6465 6620 7669 736a 6163 5f70      def visjac_p
-0001e3c0: 2873 656c 662c 2070 2c20 6465 7074 683d  (self, p, depth=
-0001e3d0: 4e6f 6e65 293a 0a20 2020 2020 2020 2072  None):.        r
-0001e3e0: 2222 220a 2020 2020 2020 2020 5669 7375  """.        Visu
-0001e3f0: 616c 204a 6163 6f62 6961 6e20 666f 7220  al Jacobian for 
-0001e400: 706f 696e 7420 6665 6174 7572 6573 0a0a  point features..
-0001e410: 2020 2020 2020 2020 3a70 6172 616d 2070          :param p
-0001e420: 3a20 696d 6167 6520 706c 616e 6520 706f  : image plane po
-0001e430: 696e 7473 0a20 2020 2020 2020 203a 7479  ints.        :ty
-0001e440: 7065 2070 3a20 6172 7261 795f 6c69 6b65  pe p: array_like
-0001e450: 2832 2920 6f72 206e 6461 7272 6179 2832  (2) or ndarray(2
-0001e460: 2c4e 290a 2020 2020 2020 2020 3a70 6172  ,N).        :par
-0001e470: 616d 2064 6570 7468 3a20 706f 696e 7420  am depth: point 
-0001e480: 6465 7074 682c 2064 6566 6175 6c74 7320  depth, defaults 
-0001e490: 746f 204e 6f6e 650a 2020 2020 2020 2020  to None.        
-0001e4a0: 3a74 7970 6520 6465 7074 683a 2066 6c6f  :type depth: flo
-0001e4b0: 6174 206f 7220 6172 7261 795f 6c69 6b65  at or array_like
-0001e4c0: 284e 292c 206f 7074 696f 6e61 6c0a 2020  (N), optional.  
-0001e4d0: 2020 2020 2020 3a72 6574 7572 6e3a 2076        :return: v
-0001e4e0: 6973 7561 6c20 4a61 636f 6269 616e 0a20  isual Jacobian. 
-0001e4f0: 2020 2020 2020 203a 7274 7970 653a 206e         :rtype: n
-0001e500: 6461 7272 6179 2832 2c36 2920 6f72 206e  darray(2,6) or n
-0001e510: 6461 7272 6179 2832 4e2c 3629 0a0a 2020  darray(2N,6)..  
-0001e520: 2020 2020 2020 436f 6d70 7574 6520 7468        Compute th
-0001e530: 6520 696d 6167 6520 4a61 636f 6269 616e  e image Jacobian
-0001e540: 203a 6d61 7468 3a60 5c6d 6174 7b4a 7d60   :math:`\mat{J}`
-0001e550: 2077 6869 6368 206d 6170 730a 0a20 2020   which maps..   
-0001e560: 2020 2020 202e 2e20 6d61 7468 3a3a 0a0a       .. math::..
-0001e570: 2020 2020 2020 2020 2020 2020 5c64 7665              \dve
-0001e580: 637b 707d 203d 205c 6d61 747b 4a7d 285c  c{p} = \mat{J}(\
-0001e590: 7665 637b 707d 2c20 7a29 205c 7665 637b  vec{p}, z) \vec{
-0001e5a0: 5c6e 757d 0a0a 2020 2020 2020 2020 6361  \nu}..        ca
-0001e5b0: 6d65 7261 2073 7061 7469 616c 2076 656c  mera spatial vel
-0001e5c0: 6f63 6974 7920 3a6d 6174 683a 605c 7665  ocity :math:`\ve
-0001e5d0: 637b 5c6e 757d 6020 746f 2074 6865 2069  c{\nu}` to the i
-0001e5e0: 6d61 6765 2070 6c61 6e65 2076 656c 6f63  mage plane veloc
-0001e5f0: 6974 790a 2020 2020 2020 2020 3a6d 6174  ity.        :mat
-0001e600: 683a 605c 6476 6563 7b70 7d60 206f 6620  h:`\dvec{p}` of 
-0001e610: 7468 6520 706f 696e 7420 7768 6572 6520  the point where 
-0001e620: 3a6d 6174 683a 605c 7665 637b 707d 3d28  :math:`\vec{p}=(
-0001e630: 5c70 6869 2c20 5c74 6865 7461 2960 0a0a  \phi, \theta)`..
-0001e640: 2020 2020 2020 2020 4966 2060 6070 6060          If ``p``
-0001e650: 2064 6573 6372 6962 6573 206d 756c 7469   describes multi
-0001e660: 706c 6520 706f 696e 7473 2074 6865 6e20  ple points then 
-0001e670: 7265 7475 726e 2061 2073 7461 636b 206f  return a stack o
-0001e680: 6620 7468 6573 6520 0a20 2020 2020 2020  f these .       
-0001e690: 203a 6d61 7468 3a60 325c 7469 6d65 7320   :math:`2\times 
-0001e6a0: 3660 206d 6174 7269 6365 732c 206f 6e65  6` matrices, one
-0001e6b0: 2070 6572 2070 6f69 6e74 2e0a 2020 2020   per point..    
-0001e6c0: 2020 2020 0a20 2020 2020 2020 2044 6570      .        Dep
-0001e6d0: 7468 2069 7320 7468 6520 7a2d 636f 6d70  th is the z-comp
-0001e6e0: 6f6e 656e 7420 6f66 2074 6865 2070 6f69  onent of the poi
-0001e6f0: 6e74 2773 2063 6f6f 7264 696e 6174 6520  nt's coordinate 
-0001e700: 696e 2074 6865 2063 616d 6572 6120 6672  in the camera fr
-0001e710: 616d 652e 0a20 2020 2020 2020 2049 6620  ame..        If 
-0001e720: 6060 6465 7074 6860 6020 6973 2061 2073  ``depth`` is a s
-0001e730: 6361 6c61 7220 7468 656e 2069 7420 6973  calar then it is
-0001e740: 2074 6865 2064 6570 7468 2066 6f72 2061   the depth for a
-0001e750: 6c6c 2070 6f69 6e74 732e 200a 2020 2020  ll points. .    
-0001e760: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
-0001e770: 204a 203d 205b 5d0a 2020 2020 2020 2020   J = [].        
-0001e780: 6966 2073 6d62 6173 652e 6973 7363 616c  if smbase.isscal
-0001e790: 6172 2864 6570 7468 293a 0a20 2020 2020  ar(depth):.     
-0001e7a0: 2020 2020 2020 2064 6570 7468 203d 205b         depth = [
-0001e7b0: 6465 7074 685d 202a 2070 2e73 6861 7065  depth] * p.shape
-0001e7c0: 5b31 5d0a 0a20 2020 2020 2020 2066 6f72  [1]..        for
-0001e7d0: 2028 7068 692c 2074 6865 7461 292c 2052   (phi, theta), R
-0001e7e0: 2069 6e20 7a69 7028 702e 542c 2064 6570   in zip(p.T, dep
-0001e7f0: 7468 293a 0a20 2020 2020 2020 2020 2020  th):.           
-0001e800: 2073 7020 3d20 6e70 2e73 696e 2870 6869   sp = np.sin(phi
-0001e810: 290a 2020 2020 2020 2020 2020 2020 6370  ).            cp
-0001e820: 203d 206e 702e 636f 7328 7068 6929 0a20   = np.cos(phi). 
-0001e830: 2020 2020 2020 2020 2020 2073 7420 3d20             st = 
-0001e840: 6e70 2e73 696e 2874 6865 7461 290a 2020  np.sin(theta).  
-0001e850: 2020 2020 2020 2020 2020 6374 203d 206e            ct = n
-0001e860: 702e 636f 7328 7468 6574 6129 0a0a 2020  p.cos(theta)..  
-0001e870: 2020 2020 2020 2020 2020 4a6b 203d 206e            Jk = n
-0001e880: 702e 6172 7261 7928 5b0a 2020 2020 2020  p.array([.      
-0001e890: 2020 2020 2020 2020 2020 5b73 702f 522f            [sp/R/
-0001e8a0: 7374 2c20 2d63 702f 522f 7374 2c20 302c  st, -cp/R/st, 0,
-0001e8b0: 2063 702a 6374 2f73 742c 2073 702a 6374   cp*ct/st, sp*ct
-0001e8c0: 2f73 742c 202d 315d 2c0a 2020 2020 2020  /st, -1],.      
-0001e8d0: 2020 2020 2020 2020 2020 5b2d 6370 2a63            [-cp*c
-0001e8e0: 742f 522c 202d 7370 2a63 742f 522c 2073  t/R, -sp*ct/R, s
-0001e8f0: 742f 522c 2073 702c 202d 6370 2c20 305d  t/R, sp, -cp, 0]
-0001e900: 0a20 2020 2020 2020 2020 2020 205d 290a  .            ]).
-0001e910: 2020 2020 2020 2020 2020 2020 4a2e 6170              J.ap
-0001e920: 7065 6e64 284a 6b29 0a20 2020 2020 2020  pend(Jk).       
-0001e930: 2072 6574 7572 6e20 6e70 2e76 7374 6163   return np.vstac
-0001e940: 6b28 4a29 0a0a 2020 2020 6465 6620 706c  k(J)..    def pl
-0001e950: 6f74 2873 656c 662c 2066 7261 6d65 3d46  ot(self, frame=F
-0001e960: 616c 7365 2c20 2a2a 6b77 6172 6773 293a  alse, **kwargs):
-0001e970: 0a20 2020 2020 2020 2073 6d62 6173 652e  .        smbase.
-0001e980: 706c 6f74 5f73 7068 6572 6528 7261 6469  plot_sphere(radi
-0001e990: 7573 3d31 2c20 6669 6c6c 6564 3d54 7275  us=1, filled=Tru
-0001e9a0: 652c 2063 6f6c 6f72 3d27 6c69 6768 7479  e, color='lighty
-0001e9b0: 656c 6c6f 7727 2c20 616c 7068 613d 302e  ellow', alpha=0.
-0001e9c0: 332c 2072 6573 6f6c 7574 696f 6e3d 3230  3, resolution=20
-0001e9d0: 2c20 6365 6e74 7265 3d73 656c 662e 706f  , centre=self.po
-0001e9e0: 7365 2e74 290a 2020 2020 2020 2020 7365  se.t).        se
-0001e9f0: 6c66 2e70 6f73 652e 706c 6f74 2873 7479  lf.pose.plot(sty
-0001ea00: 6c65 3d27 6172 726f 7727 2c20 6178 6973  le='arrow', axis
-0001ea10: 6c61 6265 6c3d 5472 7565 2c20 6c65 6e67  label=True, leng
-0001ea20: 7468 3d31 2e34 290a 0a0a 2320 636c 6173  th=1.4)...# clas
-0001ea30: 7320 4365 6e74 7261 6c43 616d 6572 615f  s CentralCamera_
-0001ea40: 706f 6c61 7228 4361 6d65 7261 293a 0a23  polar(Camera):.#
-0001ea50: 2020 2020 2022 2222 0a23 2020 2020 2043       """.#     C
-0001ea60: 656e 7472 616c 2070 726f 6a65 6374 696f  entral projectio
-0001ea70: 6e20 6361 6d65 7261 2063 6c61 7373 0a23  n camera class.#
-0001ea80: 2020 2020 2022 2222 0a0a 2320 2020 2020       """..#     
-0001ea90: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-0001eaa0: 662c 0a23 2020 2020 2020 2020 2020 2020  f,.#            
-0001eab0: 2020 2020 2020 663d 312c 0a23 2020 2020        f=1,.#    
-0001eac0: 2020 2020 2020 2020 2020 2020 2020 6469                di
-0001ead0: 7374 6f72 7469 6f6e 3d4e 6f6e 652c 0a23  stortion=None,.#
-0001eae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eaf0: 2020 2a2a 6b77 6172 6773 293a 0a23 2020    **kwargs):.#  
-0001eb00: 2020 2020 2020 2022 2222 0a23 2020 2020         """.#    
-0001eb10: 2020 2020 2043 7265 6174 6520 6365 6e74       Create cent
-0001eb20: 7261 6c20 6361 6d65 7261 2070 726f 6a65  ral camera proje
-0001eb30: 6374 696f 6e20 6d6f 6465 6c20 696e 2070  ction model in p
-0001eb40: 6f6c 6172 2063 6f6f 7264 696e 6174 6573  olar coordinates
-0001eb50: 0a0a 2320 2020 2020 2020 2020 3a70 6172  ..#         :par
-0001eb60: 616d 2066 3a20 666f 6361 6c20 6c65 6e67  am f: focal leng
-0001eb70: 7468 2c20 6465 6661 756c 7473 2074 6f20  th, defaults to 
-0001eb80: 382a 3165 2d33 0a23 2020 2020 2020 2020  8*1e-3.#        
-0001eb90: 203a 7479 7065 2066 3a20 666c 6f61 742c   :type f: float,
-0001eba0: 206f 7074 696f 6e61 6c0a 2320 2020 2020   optional.#     
-0001ebb0: 2020 2020 3a70 6172 616d 2064 6973 746f      :param disto
-0001ebc0: 7274 696f 6e3a 2063 616d 6572 6120 6469  rtion: camera di
-0001ebd0: 7374 6f72 7469 6f6e 2070 6172 616d 6574  stortion paramet
-0001ebe0: 6572 732c 2064 6566 6175 6c74 7320 746f  ers, defaults to
-0001ebf0: 204e 6f6e 650a 2320 2020 2020 2020 2020   None.#         
-0001ec00: 3a74 7970 6520 6469 7374 6f72 7469 6f6e  :type distortion
-0001ec10: 3a20 6172 7261 795f 6c69 6b65 2835 292c  : array_like(5),
-0001ec20: 206f 7074 696f 6e61 6c0a 0a23 2020 2020   optional..#    
-0001ec30: 2020 2020 203a 7365 6561 6c73 6f3a 203a       :seealso: :
-0001ec40: 6d65 7468 3a60 6469 7374 6f72 7460 0a23  meth:`distort`.#
-0001ec50: 2020 2020 2020 2020 2022 2222 0a0a 2320           """..# 
-0001ec60: 2020 2020 2020 2020 7375 7065 7228 292e          super().
-0001ec70: 5f5f 696e 6974 5f5f 2874 7970 653d 2770  __init__(type='p
-0001ec80: 6572 7370 6563 7469 7665 272c 202a 2a6b  erspective', **k
-0001ec90: 7761 7267 7329 0a23 2020 2020 2020 2020  wargs).#        
-0001eca0: 2023 2054 4f44 4f20 736f 6d65 206f 6620   # TODO some of 
-0001ecb0: 7468 6973 206c 6f67 6963 2074 6f20 6620  this logic to f 
-0001ecc0: 616e 6420 7070 2073 6574 7465 7273 0a23  and pp setters.#
-0001ecd0: 2020 2020 2020 2020 2073 656c 662e 6620           self.f 
-0001ece0: 3d20 660a 0a23 2020 2020 2020 2020 2073  = f..#         s
-0001ecf0: 656c 662e 5f64 6973 746f 7274 696f 6e20  elf._distortion 
-0001ed00: 3d20 6469 7374 6f72 7469 6f6e 0a0a 2320  = distortion..# 
-0001ed10: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
-0001ed20: 0a23 2020 2020 2064 6566 2044 6566 6175  .#     def Defau
-0001ed30: 6c74 2863 6c73 2c20 2a2a 6b77 6172 6773  lt(cls, **kwargs
-0001ed40: 293a 0a23 2020 2020 2020 2020 2064 6566  ):.#         def
-0001ed50: 6175 6c74 203d 207b 0a23 2020 2020 2020  ault = {.#      
-0001ed60: 2020 2020 2020 2027 6627 3a20 302e 3030         'f': 0.00
-0001ed70: 382c 200a 2320 2020 2020 2020 2020 2020  8, .#           
-0001ed80: 2020 2772 686f 273a 2031 3065 2d36 2c0a    'rho': 10e-6,.
-0001ed90: 2320 2020 2020 2020 2020 2020 2020 2769  #             'i
-0001eda0: 6d61 6765 7369 7a65 273a 2031 3030 302c  magesize': 1000,
-0001edb0: 200a 2320 2020 2020 2020 2020 2020 2020   .#             
-0001edc0: 2770 7027 3a20 2835 3030 2c35 3030 292c  'pp': (500,500),
-0001edd0: 0a23 2020 2020 2020 2020 2020 2020 2027  .#             '
-0001ede0: 6e61 6d65 273a 2027 6465 6661 756c 7420  name': 'default 
-0001edf0: 7065 7273 7065 6374 6976 6520 6361 6d65  perspective came
-0001ee00: 7261 270a 2320 2020 2020 2020 2020 7d0a  ra'.#         }.
-0001ee10: 0a23 2020 2020 2020 2020 2072 6574 7572  .#         retur
-0001ee20: 6e20 4365 6e74 7261 6c43 616d 6572 615f  n CentralCamera_
-0001ee30: 706f 6c61 7228 2a2a 7b2a 2a64 6566 6175  polar(**{**defau
-0001ee40: 6c74 2c20 2a2a 6b77 6172 6773 7d29 0a20  lt, **kwargs}). 
-0001ee50: 2020 2020 2020 200a 2320 2020 2020 6465         .#     de
-0001ee60: 6620 5f5f 7374 725f 5f28 7365 6c66 293a  f __str__(self):
-0001ee70: 0a23 2020 2020 2020 2020 2073 203d 2073  .#         s = s
-0001ee80: 7570 6572 2829 2e5f 5f73 7472 5f5f 2829  uper().__str__()
-0001ee90: 0a23 2020 2020 2020 2020 2073 202b 3d20  .#         s += 
-0001eea0: 7365 6c66 2e66 6d74 2e66 6f72 6d61 7428  self.fmt.format(
-0001eeb0: 2770 7269 6e63 6970 616c 2070 7427 2c20  'principal pt', 
-0001eec0: 7365 6c66 2e70 7029 0a23 2020 2020 2020  self.pp).#      
-0001eed0: 2020 2073 202b 3d20 7365 6c66 2e66 6d74     s += self.fmt
-0001eee0: 2e66 6f72 6d61 7428 2766 6f63 616c 206c  .format('focal l
-0001eef0: 656e 6774 6827 2c20 7365 6c66 2e66 290a  ength', self.f).
-0001ef00: 0a23 2020 2020 2020 2020 2072 6574 7572  .#         retur
-0001ef10: 6e20 730a 0a0a 2320 2020 2020 6465 6620  n s...#     def 
-0001ef20: 7072 6f6a 6563 745f 706f 696e 7428 7365  project_point(se
-0001ef30: 6c66 2c20 502c 2070 6f73 653d 4e6f 6e65  lf, P, pose=None
-0001ef40: 2c20 6f62 6a70 6f73 653d 4e6f 6e65 2c20  , objpose=None, 
-0001ef50: 2a2a 6b77 6172 6773 293a 0a23 2020 2020  **kwargs):.#    
-0001ef60: 2020 2020 2072 2222 220a 2320 2020 2020       r""".#     
-0001ef70: 2020 2020 5072 6f6a 6563 7420 3344 2070      Project 3D p
-0001ef80: 6f69 6e74 7320 746f 2069 6d61 6765 2070  oints to image p
-0001ef90: 6c61 6e65 0a0a 2320 2020 2020 2020 2020  lane..#         
-0001efa0: 3a70 6172 616d 2050 3a20 3344 2070 6f69  :param P: 3D poi
-0001efb0: 6e74 7320 746f 2070 726f 6a65 6374 2069  nts to project i
-0001efc0: 6e74 6f20 6361 6d65 7261 2069 6d61 6765  nto camera image
-0001efd0: 2070 6c61 6e65 0a23 2020 2020 2020 2020   plane.#        
-0001efe0: 203a 7479 7065 2050 3a20 6172 7261 795f   :type P: array_
-0001eff0: 6c69 6b65 2833 292c 2061 7272 6179 5f6c  like(3), array_l
-0001f000: 696b 6528 332c 6e29 0a23 2020 2020 2020  ike(3,n).#      
-0001f010: 2020 203a 7061 7261 6d20 706f 7365 3a20     :param pose: 
-0001f020: 6361 6d65 7261 2070 6f73 6520 7769 7468  camera pose with
-0001f030: 2072 6573 7065 6374 2074 6f20 7468 6520   respect to the 
-0001f040: 776f 726c 6420 6672 616d 652c 2064 6566  world frame, def
-0001f050: 6175 6c74 7320 746f 0a23 2020 2020 2020  aults to.#      
-0001f060: 2020 2020 2020 2063 616d 6572 6127 7320         camera's 
-0001f070: 6060 706f 7365 6060 2061 7474 7269 6275  ``pose`` attribu
-0001f080: 7465 0a23 2020 2020 2020 2020 203a 7479  te.#         :ty
-0001f090: 7065 2070 6f73 653a 2053 4533 2c20 6f70  pe pose: SE3, op
-0001f0a0: 7469 6f6e 616c 0a23 2020 2020 2020 2020  tional.#        
-0001f0b0: 203a 7061 7261 6d20 6f62 6a70 6f73 653a   :param objpose:
-0001f0c0: 2020 3344 2070 6f69 6e74 2072 6566 6572    3D point refer
-0001f0d0: 656e 6365 2066 7261 6d65 2c20 6465 6661  ence frame, defa
-0001f0e0: 756c 7473 2074 6f20 776f 726c 6420 6672  ults to world fr
-0001f0f0: 616d 650a 2320 2020 2020 2020 2020 3a74  ame.#         :t
-0001f100: 7970 6520 6f62 6a70 6f73 653a 2053 4533  ype objpose: SE3
-0001f110: 2c20 6f70 7469 6f6e 616c 0a23 2020 2020  , optional.#    
-0001f120: 2020 2020 203a 7061 7261 6d20 7669 7369       :param visi
-0001f130: 6269 6c69 7479 3a20 7465 7374 2069 6620  bility: test if 
-0001f140: 706f 696e 7473 2061 7265 2076 6973 6962  points are visib
-0001f150: 6c65 2c20 6465 6661 756c 7420 4661 6c73  le, default Fals
-0001f160: 650a 2320 2020 2020 2020 2020 3a74 7970  e.#         :typ
-0001f170: 6520 7669 7369 6269 6c69 7479 3a20 626f  e visibility: bo
-0001f180: 6f6c 0a23 2020 2020 2020 2020 203a 7061  ol.#         :pa
-0001f190: 7261 6d20 7265 7469 6e61 6c3a 2074 7261  ram retinal: tra
-0001f1a0: 6e73 666f 726d 2074 6f20 7265 7469 6e61  nsform to retina
-0001f1b0: 6c20 636f 6f72 6469 6e61 7465 732c 2064  l coordinates, d
-0001f1c0: 6566 6175 6c74 2046 616c 7365 0a23 2020  efault False.#  
-0001f1d0: 2020 2020 2020 203a 7479 7065 2072 6574         :type ret
-0001f1e0: 696e 616c 3a20 626f 6f6c 2c20 6f70 7469  inal: bool, opti
-0001f1f0: 6f6e 616c 0a23 2020 2020 2020 2020 203a  onal.#         :
-0001f200: 7265 7475 726e 3a20 696d 6167 6520 706c  return: image pl
-0001f210: 616e 6520 706f 696e 7473 0a23 2020 2020  ane points.#    
-0001f220: 2020 2020 203a 7274 7970 653a 206e 6461       :rtype: nda
-0001f230: 7272 6179 2832 2c6e 290a 0a23 2020 2020  rray(2,n)..#    
-0001f240: 2020 2020 2050 726f 6a65 6374 2061 2033       Project a 3
-0001f250: 4420 706f 696e 7420 746f 2074 6865 2069  D point to the i
-0001f260: 6d61 6765 2070 6c61 6e65 0a0a 2320 2020  mage plane..#   
-0001f270: 2020 2020 2020 2e2e 206d 6174 683a 3a0a        .. math::.
-0001f280: 0a23 2020 2020 2020 2020 2020 2020 205c  .#             \
-0001f290: 6876 6563 7b70 7d20 3d20 5c6d 6174 7b43  hvec{p} = \mat{C
-0001f2a0: 7d20 5c68 7665 637b 507d 0a0a 2320 2020  } \hvec{P}..#   
-0001f2b0: 2020 2020 2020 7768 6572 6520 3a6d 6174        where :mat
-0001f2c0: 683a 605c 6d61 747b 437d 6020 6973 2074  h:`\mat{C}` is t
-0001f2d0: 6865 2063 616d 6572 6120 6361 6c69 6272  he camera calibr
-0001f2e0: 6174 696f 6e20 6d61 7472 6978 2061 6e64  ation matrix and
-0001f2f0: 203a 6d61 7468 3a60 5c68 7665 637b 707d   :math:`\hvec{p}
-0001f300: 6020 616e 6420 3a6d 6174 683a 605c 6876  ` and :math:`\hv
-0001f310: 6563 7b50 7d60 0a23 2020 2020 2020 2020  ec{P}`.#        
-0001f320: 2061 7265 2074 6865 2069 6d61 6765 2070   are the image p
-0001f330: 6c61 6e65 2061 6e64 2077 6f72 6c64 2066  lane and world f
-0001f340: 7261 6d65 2063 6f6f 7264 696e 6174 6573  rame coordinates
-0001f350: 2072 6573 7065 6374 6976 656c 792e 0a0a   respectively...
-0001f360: 2320 2020 2020 2020 2020 4578 616d 706c  #         Exampl
-0001f370: 653a 0a0a 2320 2020 2020 2020 2020 2e2e  e:..#         ..
-0001f380: 2072 756e 626c 6f63 6b3a 3a20 7079 636f   runblock:: pyco
-0001f390: 6e0a 0a23 2020 2020 2020 2020 2020 2020  n..#            
-0001f3a0: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
-0001f3b0: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
-0001f3c0: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
-0001f3d0: 6572 610a 2320 2020 2020 2020 2020 2020  era.#           
-0001f3e0: 2020 3e3e 3e20 6361 6d65 7261 203d 2043    >>> camera = C
-0001f3f0: 656e 7472 616c 4361 6d65 7261 2829 0a23  entralCamera().#
-0001f400: 2020 2020 2020 2020 2020 2020 203e 3e3e               >>>
-0001f410: 2063 616d 6572 612e 7072 6f6a 6563 745f   camera.project_
-0001f420: 706f 696e 7428 2830 2e33 2c20 302e 342c  point((0.3, 0.4,
-0001f430: 2032 2929 0a0a 2320 2020 2020 2020 2020   2))..#         
-0001f440: 4966 2060 6070 6f73 6560 6020 6973 2073  If ``pose`` is s
-0001f450: 7065 6369 6669 6564 2069 7420 6973 2075  pecified it is u
-0001f460: 7365 6420 666f 7220 7468 6520 6361 6d65  sed for the came
-0001f470: 7261 2066 7261 6d65 2070 6f73 652c 206f  ra frame pose, o
-0001f480: 7468 6572 7769 7365 0a23 2020 2020 2020  therwise.#      
-0001f490: 2020 2074 6865 2061 7474 7269 6275 7465     the attribute
-0001f4a0: 2060 6070 6f73 6560 602e 2020 5468 6520   ``pose``.  The 
-0001f4b0: 6f62 6a65 6374 2773 2060 6070 6f73 6560  object's ``pose`
-0001f4c0: 6020 6174 7472 6962 7574 6520 6973 206e  ` attribute is n
-0001f4d0: 6f74 2075 7064 6174 6564 0a23 2020 2020  ot updated.#    
-0001f4e0: 2020 2020 2069 6620 6060 706f 7365 6060       if ``pose``
-0001f4f0: 2069 7320 7370 6563 6966 6965 642e 0a0a   is specified...
-0001f500: 2320 2020 2020 2020 2020 4120 7369 6e67  #         A sing
-0001f510: 6c65 2070 6f69 6e74 2063 616e 2062 6520  le point can be 
-0001f520: 7370 6563 6966 6965 6420 6173 2061 2033  specified as a 3
-0001f530: 2d76 6563 746f 722c 206d 756c 7469 706c  -vector, multipl
-0001f540: 6520 706f 696e 7473 2061 7320 616e 0a23  e points as an.#
-0001f550: 2020 2020 2020 2020 2061 7272 6179 2077           array w
-0001f560: 6974 6820 7468 7265 6520 726f 7773 2061  ith three rows a
-0001f570: 6e64 206f 6e65 2063 6f6c 756d 6e20 2878  nd one column (x
-0001f580: 2c20 792c 207a 2920 7065 7220 706f 696e  , y, z) per poin
-0001f590: 742e 0a0a 2320 2020 2020 2020 2020 5468  t...#         Th
-0001f5a0: 6520 706f 696e 7473 2060 6050 6060 2061  e points ``P`` a
-0001f5b0: 7265 2062 7920 6465 6661 756c 7420 7769  re by default wi
-0001f5c0: 7468 2072 6573 7065 6374 2074 6f20 7468  th respect to th
-0001f5d0: 6520 776f 726c 6420 6672 616d 652c 2062  e world frame, b
-0001f5e0: 7574 200a 2320 2020 2020 2020 2020 7468  ut .#         th
-0001f5f0: 6579 2063 616e 2062 6520 7472 616e 7366  ey can be transf
-0001f600: 6f72 6d65 6420 6279 2073 7065 6369 6679  ormed by specify
-0001f610: 696e 6720 6060 6f62 6a70 6f73 6560 602e  ing ``objpose``.
-0001f620: 0a20 2020 2020 2020 200a 2320 2020 2020  .        .#     
-0001f630: 2020 2020 4966 2077 6f72 6c64 2070 6f69      If world poi
-0001f640: 6e74 7320 6172 6520 6265 6869 6e64 2074  nts are behind t
-0001f650: 6865 2063 616d 6572 612c 2074 6865 2069  he camera, the i
-0001f660: 6d61 6765 2070 6c61 6e65 2070 6f69 6e74  mage plane point
-0001f670: 7320 6172 6520 7365 7420 746f 0a23 2020  s are set to.#  
-0001f680: 2020 2020 2020 204e 614e 2e0a 2020 2020         NaN..    
-0001f690: 2020 2020 0a23 2020 2020 2020 2020 2069      .#         i
-0001f6a0: 6620 6060 7669 7369 6269 6c69 7479 6060  f ``visibility``
-0001f6b0: 2069 7320 5472 7565 2074 6865 6e20 6561   is True then ea
-0001f6c0: 6368 2070 726f 6a65 6374 6564 2070 6f69  ch projected poi
-0001f6d0: 6e74 2069 7320 6368 6563 6b65 6420 746f  nt is checked to
-0001f6e0: 2065 6e73 7572 650a 2320 2020 2020 2020   ensure.#       
-0001f6f0: 2020 6974 206c 6965 7320 696e 2074 6865    it lies in the
-0001f700: 2062 6f75 6e64 7320 6f66 2074 6865 2069   bounds of the i
-0001f710: 6d61 6765 2070 6c61 6e65 2e20 2049 6e20  mage plane.  In 
-0001f720: 7468 6973 2063 6173 6520 7468 6572 6520  this case there 
-0001f730: 6172 6520 7477 6f0a 2320 2020 2020 2020  are two.#       
-0001f740: 2020 7265 7475 726e 2076 616c 7565 733a    return values:
-0001f750: 2074 6865 2069 6d61 6765 2070 6c61 6e65   the image plane
-0001f760: 2063 6f6f 7264 696e 6174 6573 2061 6e64   coordinates and
-0001f770: 2061 6e20 6172 7261 7920 6f66 2062 6f6f   an array of boo
-0001f780: 6c65 616e 730a 2320 2020 2020 2020 2020  leans.#         
-0001f790: 696e 6469 6361 7469 6e67 2069 6620 7468  indicating if th
-0001f7a0: 6520 636f 7272 6573 706f 6e64 696e 6720  e corresponding 
-0001f7b0: 706f 696e 7420 6973 2076 6973 6962 6c65  point is visible
-0001f7c0: 2e0a 2320 2020 2020 2020 2020 2222 220a  ..#         """.
-0001f7d0: 2320 2020 2020 2020 2020 6966 2070 6f73  #         if pos
-0001f7e0: 6520 6973 204e 6f6e 653a 0a23 2020 2020  e is None:.#    
-0001f7f0: 2020 2020 2020 2020 2070 6f73 6520 3d20           pose = 
-0001f800: 7365 6c66 2e70 6f73 650a 0a23 2020 2020  self.pose..#    
-0001f810: 2020 2020 2043 203d 2073 656c 662e 4328       C = self.C(
-0001f820: 706f 7365 2c20 7265 7469 6e61 6c3d 7265  pose, retinal=re
-0001f830: 7469 6e61 6c29 0a0a 2320 2020 2020 2020  tinal)..#       
-0001f840: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-0001f850: 502c 206e 702e 6e64 6172 7261 7929 3a0a  P, np.ndarray):.
-0001f860: 2320 2020 2020 2020 2020 2020 2020 6966  #             if
-0001f870: 2050 2e6e 6469 6d20 3d3d 2031 3a0a 2320   P.ndim == 1:.# 
-0001f880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f890: 5020 3d20 502e 7265 7368 6170 6528 282d  P = P.reshape((-
-0001f8a0: 312c 2031 2929 2020 2320 6d61 6b65 2069  1, 1))  # make i
-0001f8b0: 7420 6120 636f 6c75 6d6e 0a23 2020 2020  t a column.#    
-0001f8c0: 2020 2020 2065 6c73 653a 0a23 2020 2020       else:.#    
-0001f8d0: 2020 2020 2020 2020 2050 203d 2062 6173           P = bas
-0001f8e0: 652e 6765 7476 6563 746f 7228 502c 206f  e.getvector(P, o
-0001f8f0: 7574 3d27 636f 6c27 290a 0a23 2020 2020  ut='col')..#    
-0001f900: 2020 2020 2023 206d 616b 6520 6974 2068       # make it h
-0001f910: 6f6d 6f67 656e 656f 7573 2069 6620 6e6f  omogeneous if no
-0001f920: 7420 616c 7265 6164 790a 2320 2020 2020  t already.#     
-0001f930: 2020 2020 6966 2050 2e73 6861 7065 5b30      if P.shape[0
-0001f940: 5d20 3d3d 2033 3a0a 2320 2020 2020 2020  ] == 3:.#       
-0001f950: 2020 2020 2020 5020 3d20 6261 7365 2e65        P = base.e
-0001f960: 3268 2850 290a 0a23 2020 2020 2020 2020  2h(P)..#        
-0001f970: 2023 2070 726f 6a65 6374 2033 4420 706f   # project 3D po
-0001f980: 696e 7473 0a0a 2320 2020 2020 2020 2020  ints..#         
-0001f990: 6966 206f 626a 706f 7365 2069 7320 6e6f  if objpose is no
-0001f9a0: 7420 4e6f 6e65 3a0a 2320 2020 2020 2020  t None:.#       
-0001f9b0: 2020 2020 2020 5020 3d20 6f62 6a70 6f73        P = objpos
-0001f9c0: 652e 4120 4020 500a 0a23 2020 2020 2020  e.A @ P..#      
-0001f9d0: 2020 2078 203d 2043 2040 2050 0a0a 2320     x = C @ P..# 
-0001f9e0: 2020 2020 2020 2020 6966 2062 6568 696e          if behin
-0001f9f0: 643a 0a23 2020 2020 2020 2020 2020 2020  d:.#            
-0001fa00: 2078 5b32 2c20 785b 322c 203a 5d20 3c20   x[2, x[2, :] < 
-0001fa10: 305d 203d 206e 702e 6e61 6e20 2023 2070  0] = np.nan  # p
-0001fa20: 6f69 6e74 7320 6265 6869 6e64 2074 6865  oints behind the
-0001fa30: 2063 616d 6572 6120 6172 6520 7365 7420   camera are set 
-0001fa40: 746f 204e 614e 0a0a 2320 2020 2020 2020  to NaN..#       
-0001fa50: 2020 7820 3d20 6261 7365 2e68 3265 2878    x = base.h2e(x
-0001fa60: 290a 0a23 2020 2020 2020 2020 2023 2061  )..#         # a
-0001fa70: 6464 2047 6175 7373 6961 6e20 6e6f 6973  dd Gaussian nois
-0001fa80: 6520 616e 6420 6469 7374 6f72 7469 6f6e  e and distortion
-0001fa90: 0a23 2020 2020 2020 2020 2078 203d 2073  .#         x = s
-0001faa0: 656c 662e 6164 645f 6e6f 6973 655f 6469  elf.add_noise_di
-0001fab0: 7374 6f72 7469 6f6e 2878 290a 0a23 2020  stortion(x)..#  
-0001fac0: 2020 2020 2020 2023 2020 646f 2076 6973         #  do vis
-0001fad0: 6962 696c 6974 7920 6368 6563 6b20 6966  ibility check if
-0001fae0: 2072 6571 7569 7265 640a 2320 2020 2020   required.#     
-0001faf0: 2020 2020 6966 2076 6973 6962 696c 6974      if visibilit
-0001fb00: 793a 0a23 2020 2020 2020 2020 2020 2020  y:.#            
-0001fb10: 2076 6973 6962 6c65 203d 207e 6e70 2e69   visible = ~np.i
-0001fb20: 736e 616e 2878 5b30 2c3a 5d29 205c 0a23  snan(x[0,:]) \.#
-0001fb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fb40: 2026 2028 785b 302c 203a 5d20 3e3d 2030   & (x[0, :] >= 0
-0001fb50: 2920 5c0a 2320 2020 2020 2020 2020 2020  ) \.#           
-0001fb60: 2020 2020 2020 2620 2878 5b31 2c20 3a5d        & (x[1, :]
-0001fb70: 203e 3d20 3029 205c 0a23 2020 2020 2020   >= 0) \.#      
-0001fb80: 2020 2020 2020 2020 2020 2026 2028 785b             & (x[
-0001fb90: 302c 203a 5d20 3c20 7365 6c66 2e6e 7529  0, :] < self.nu)
-0001fba0: 205c 0a23 2020 2020 2020 2020 2020 2020   \.#            
-0001fbb0: 2020 2020 2026 2028 785b 312c 203a 5d20       & (x[1, :] 
-0001fbc0: 3c20 7365 6c66 2e6e 7629 0a20 2020 2020  < self.nv).     
-0001fbd0: 2020 2020 2020 200a 2320 2020 2020 2020         .#       
-0001fbe0: 2020 2020 2020 7265 7475 726e 2078 2c20        return x, 
-0001fbf0: 7669 7369 626c 650a 2320 2020 2020 2020  visible.#       
-0001fc00: 2020 656c 7365 3a0a 2320 2020 2020 2020    else:.#       
-0001fc10: 2020 2020 2020 7265 7475 726e 2078 0a0a        return x..
-0001fc20: 2320 2020 2020 6465 6620 706c 6f74 5f70  #     def plot_p
-0001fc30: 6f69 6e74 2873 656c 662c 2050 700a 2320  oint(self, Pp.# 
-0001fc40: 2020 2020 2020 2020 6178 203d 205f 6e65          ax = _ne
-0001fc50: 7770 6c6f 7428 7365 6c66 2c20 6669 672c  wplot(self, fig,
-0001fc60: 2061 7829 0a0a 2320 2020 2020 2020 2020   ax)..#         
-0001fc70: 6966 2073 656c 662e 5f69 6d61 6765 2069  if self._image i
-0001fc80: 7320 6e6f 7420 4e6f 6e65 3a0a 2320 2020  s not None:.#   
-0001fc90: 2020 2020 2020 2020 2020 2320 6966 2063            # if c
-0001fca0: 616d 6572 6120 6861 7320 616e 2069 6d61  amera has an ima
-0001fcb0: 6765 2c20 6469 7370 6c61 7920 7361 6964  ge, display said
-0001fcc0: 2069 6d61 6765 0a23 2020 2020 2020 2020   image.#        
-0001fcd0: 2020 2020 2069 6469 7370 2873 656c 662e       idisp(self.
-0001fce0: 5f69 6d61 6765 2c0a 2320 2020 2020 2020  _image,.#       
-0001fcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fd00: 6669 673d 6669 672c 0a23 2020 2020 2020  fig=fig,.#      
-0001fd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fd20: 2061 783d 6178 2c0a 2320 2020 2020 2020   ax=ax,.#       
-0001fd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fd40: 7469 746c 653d 7365 6c66 2e5f 6e61 6d65  title=self._name
-0001fd50: 2c0a 2320 2020 2020 2020 2020 2020 2020  ,.#             
-0001fd60: 2020 2020 2020 2020 2020 6472 6177 6f6e            drawon
-0001fd70: 6c79 3d54 7275 6529 0a23 2020 2020 2020  ly=True).#      
-0001fd80: 2020 2065 6c73 653a 0a23 2020 2020 2020     else:.#      
-0001fd90: 2020 2020 2020 2069 6620 7365 6c66 2e6c         if self.l
-0001fda0: 696d 6974 7320 6973 204e 6f6e 653a 0a23  imits is None:.#
-0001fdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fdc0: 2061 782e 7365 745f 786c 696d 2830 2c20   ax.set_xlim(0, 
-0001fdd0: 7365 6c66 2e6e 7529 0a23 2020 2020 2020  self.nu).#      
-0001fde0: 2020 2020 2020 2020 2020 2061 782e 7365             ax.se
-0001fdf0: 745f 796c 696d 2830 2c20 7365 6c66 2e6e  t_ylim(0, self.n
-0001fe00: 7629 0a23 2020 2020 2020 2020 2020 2020  v).#            
-0001fe10: 2065 6c73 653a 0a23 2020 2020 2020 2020   else:.#        
-0001fe20: 2020 2020 2020 2020 2061 782e 7365 745f           ax.set_
-0001fe30: 786c 696d 2873 656c 662e 6c69 6d69 7473  xlim(self.limits
-0001fe40: 5b30 5d2c 2073 656c 662e 6c69 6d69 7473  [0], self.limits
-0001fe50: 5b31 5d29 0a23 2020 2020 2020 2020 2020  [1]).#          
-0001fe60: 2020 2020 2020 2061 782e 7365 745f 796c         ax.set_yl
-0001fe70: 696d 2873 656c 662e 6c69 6d69 7473 5b32  im(self.limits[2
-0001fe80: 5d2c 2073 656c 662e 6c69 6d69 7473 5b33  ], self.limits[3
-0001fe90: 5d29 0a23 2020 2020 2020 2020 2020 2020  ]).#            
-0001fea0: 2061 782e 6175 746f 7363 616c 6528 4661   ax.autoscale(Fa
-0001feb0: 6c73 6529 0a23 2020 2020 2020 2020 2020  lse).#          
-0001fec0: 2020 2061 782e 7365 745f 6173 7065 6374     ax.set_aspect
-0001fed0: 2827 6571 7561 6c27 290a 2320 2020 2020  ('equal').#     
-0001fee0: 2020 2020 2020 2020 6178 2e69 6e76 6572          ax.inver
-0001fef0: 745f 7961 7869 7328 290a 2320 2020 2020  t_yaxis().#     
-0001ff00: 2020 2020 2020 2020 6178 2e67 7269 6428          ax.grid(
-0001ff10: 5472 7565 290a 2320 2020 2020 2020 2020  True).#         
-0001ff20: 2020 2020 6966 2073 656c 662e 6c61 6265      if self.labe
-0001ff30: 6c73 2069 7320 4e6f 6e65 3a0a 2320 2020  ls is None:.#   
-0001ff40: 2020 2020 2020 2020 2020 2020 2020 6178                ax
-0001ff50: 2e73 6574 5f78 6c61 6265 6c28 2775 2028  .set_xlabel('u (
-0001ff60: 7069 7865 6c73 2927 290a 2320 2020 2020  pixels)').#     
-0001ff70: 2020 2020 2020 2020 2020 2020 6178 2e73              ax.s
-0001ff80: 6574 5f79 6c61 6265 6c28 2776 2028 7069  et_ylabel('v (pi
-0001ff90: 7865 6c73 2927 290a 2320 2020 2020 2020  xels)').#       
-0001ffa0: 2020 2020 2020 656c 7365 3a0a 2320 2020        else:.#   
-0001ffb0: 2020 2020 2020 2020 2020 2020 2020 6178                ax
-0001ffc0: 2e73 6574 5f78 6c61 6265 6c28 7365 6c66  .set_xlabel(self
-0001ffd0: 2e6c 6162 656c 735b 305d 290a 2320 2020  .labels[0]).#   
-0001ffe0: 2020 2020 2020 2020 2020 2020 2020 6178                ax
-0001fff0: 2e73 6574 5f79 6c61 6265 6c28 7365 6c66  .set_ylabel(self
-00020000: 2e6c 6162 656c 735b 315d 290a 2320 2020  .labels[1]).#   
-00020010: 2020 2020 2020 2020 2020 6178 2e73 6574            ax.set
-00020020: 5f74 6974 6c65 2873 656c 662e 6e61 6d65  _title(self.name
-00020030: 290a 2320 2020 2020 2020 2020 2020 2020  ).#             
-00020040: 6178 2e73 6574 5f66 6163 6563 6f6c 6f72  ax.set_facecolor
-00020050: 2827 6c69 6768 7479 656c 6c6f 7727 290a  ('lightyellow').
-00020060: 2320 2020 2020 2020 2020 2020 2020 6178  #             ax
-00020070: 2e66 6967 7572 652e 6361 6e76 6173 2e73  .figure.canvas.s
-00020080: 6574 5f77 696e 646f 775f 7469 746c 6528  et_window_title(
-00020090: 274d 6163 6869 6e65 2056 6973 696f 6e20  'Machine Vision 
-000200a0: 546f 6f6c 626f 7820 666f 7220 5079 7468  Toolbox for Pyth
-000200b0: 6f6e 2729 0a0a 2320 2020 2020 2020 2020  on')..#         
-000200c0: 2320 544f 444f 2066 6967 7572 6520 6f75  # TODO figure ou
-000200d0: 7420 6178 6573 2074 6963 6b73 2c20 6574  t axes ticks, et
-000200e0: 630a 2320 2020 2020 2020 2020 7265 7475  c.#         retu
-000200f0: 726e 2061 7820 2023 206c 696b 656c 7920  rn ax  # likely 
-00020100: 7468 6973 2072 6574 7572 6e20 6973 206e  this return is n
-00020110: 6f74 206e 6563 6573 7361 7279 0a0a 6966  ot necessary..if
-00020120: 205f 5f6e 616d 655f 5f20 3d3d 2022 5f5f   __name__ == "__
-00020130: 6d61 696e 5f5f 223a 0a20 2020 2066 726f  main__":.    fro
-00020140: 6d20 7370 6174 6961 6c6d 6174 6820 696d  m spatialmath im
-00020150: 706f 7274 2055 6e69 7451 7561 7465 726e  port UnitQuatern
-00020160: 696f 6e0a 0a20 2020 2023 2069 6d31 203d  ion..    # im1 =
-00020170: 2049 6d61 6765 2e52 6561 6428 2265 6966   Image.Read("eif
-00020180: 6665 6c32 2d31 2e70 6e67 222c 2067 7265  fel2-1.png", gre
-00020190: 793d 5472 7565 290a 2020 2020 2320 6361  y=True).    # ca
-000201a0: 6d65 7261 203d 2043 656e 7472 616c 4361  mera = CentralCa
-000201b0: 6d65 7261 2829 3b0a 2020 2020 2320 6361  mera();.    # ca
-000201c0: 6d65 7261 2e64 6973 7028 696d 3129 3b0a  mera.disp(im1);.
-000201d0: 0a0a 2020 2020 2320 6361 6d20 3d20 4365  ..    # cam = Ce
-000201e0: 6e74 7261 6c43 616d 6572 6128 663d 302e  ntralCamera(f=0.
-000201f0: 3038 290a 2020 2020 2320 7072 696e 7428  08).    # print(
-00020200: 6361 6d29 0a20 2020 2023 2050 203d 205b  cam).    # P = [
-00020210: 302e 312c 2030 2e32 2c20 335d 0a20 2020  0.1, 0.2, 3].   
-00020220: 2023 2070 7269 6e74 2863 616d 2e70 726f   # print(cam.pro
-00020230: 6a65 6374 5f70 6f69 6e74 2850 2929 0a0a  ject_point(P))..
-00020240: 2020 2020 6361 6d20 3d20 4365 6e74 7261      cam = Centra
-00020250: 6c43 616d 6572 6128 663d 302e 3038 2c20  lCamera(f=0.08, 
-00020260: 696d 6167 6573 697a 653d 3130 3030 2c20  imagesize=1000, 
-00020270: 7268 6f3d 3130 652d 3629 0a20 2020 2070  rho=10e-6).    p
-00020280: 7269 6e74 2863 616d 290a 0a20 2020 2063  rint(cam)..    c
-00020290: 616d 2e70 726f 6a65 6374 5f70 6f69 6e74  am.project_point
-000202a0: 285b 312c 322c 335d 290a 0a20 2020 2023  ([1,2,3])..    #
-000202b0: 2050 203d 206e 702e 6172 7261 7928 5b5b   P = np.array([[
-000202c0: 302c 2031 305d 2c20 5b30 2c20 3130 5d2c  0, 10], [0, 10],
-000202d0: 205b 3130 2c20 3130 5d5d 290a 2020 2020   [10, 10]]).    
-000202e0: 2320 702c 2076 6973 6962 6c65 203d 2063  # p, visible = c
-000202f0: 616d 2e70 726f 6a65 6374 5f70 6f69 6e74  am.project_point
-00020300: 2850 2c20 7669 7369 6269 6c69 7479 3d54  (P, visibility=T
-00020310: 7275 6529 0a20 2020 2023 2076 6973 6962  rue).    # visib
-00020320: 6c65 0a0a 2020 2020 2320 5020 3d20 5b30  le..    # P = [0
-00020330: 2e31 2c20 302e 322c 2033 5d0a 2020 2020  .1, 0.2, 3].    
-00020340: 2320 7072 696e 7428 6361 6d2e 7072 6f6a  # print(cam.proj
-00020350: 6563 745f 706f 696e 7428 5029 290a 0a0a  ect_point(P))...
-00020360: 2020 2020 2320 5431 203d 2053 4533 282d      # T1 = SE3(-
-00020370: 302e 312c 2030 2c20 3029 202a 2053 4533  0.1, 0, 0) * SE3
-00020380: 2e52 7928 302e 3429 3b0a 2020 2020 2320  .Ry(0.4);.    # 
-00020390: 6361 6d65 7261 3120 3d20 4365 6e74 7261  camera1 = Centra
-000203a0: 6c43 616d 6572 6128 6e61 6d65 3d22 6361  lCamera(name="ca
-000203b0: 6d65 7261 2031 222c 2066 3d30 2e30 3032  mera 1", f=0.002
-000203c0: 2c20 696d 6167 6573 697a 653d 3130 3030  , imagesize=1000
-000203d0: 2c20 7268 6f3d 3130 652d 362c 2070 6f73  , rho=10e-6, pos
-000203e0: 653d 5431 290a 2020 2020 2320 2320 7072  e=T1).    # # pr
-000203f0: 696e 7428 6361 6d65 7261 3129 0a0a 2020  int(camera1)..  
-00020400: 2020 2320 6361 6d65 7261 312e 6465 636f    # camera1.deco
-00020410: 6d70 6f73 6548 286e 702e 6579 6528 332c  mposeH(np.eye(3,
-00020420: 3329 290a 0a0a 2020 2020 2320 4c20 3d20  3))...    # L = 
-00020430: 4c69 6e65 332e 5477 6f50 6f69 6e74 7328  Line3.TwoPoints(
-00020440: 5b30 2c20 302c 2031 5d2c 205b 312c 2031  [0, 0, 1], [1, 1
-00020450: 2c20 315d 290a 2020 2020 2320 6361 6d65  , 1]).    # came
-00020460: 7261 203d 2043 656e 7472 616c 4361 6d65  ra = CentralCame
-00020470: 7261 2e44 6566 6175 6c74 2829 3b0a 2020  ra.Default();.  
-00020480: 2020 2320 6c20 3d20 6361 6d65 7261 2e70    # l = camera.p
-00020490: 726f 6a65 6374 5f6c 696e 6528 4c29 0a20  roject_line(L). 
-000204a0: 2020 2023 2063 616d 6572 612e 706c 6f74     # camera.plot
-000204b0: 5f6c 696e 6533 284c 290a 0a0a 2020 2020  _line3(L)...    
-000204c0: 2320 7820 3d20 6e70 2e72 5f5b 6361 6d2e  # x = np.r_[cam.
-000204d0: 706f 7365 2e74 2c20 556e 6974 5175 6174  pose.t, UnitQuat
-000204e0: 6572 6e69 6f6e 2863 616d 2e70 6f73 6529  ernion(cam.pose)
-000204f0: 2e76 6563 335d 0a20 2020 2023 2070 7269  .vec3].    # pri
-00020500: 6e74 2878 290a 2020 2020 2320 702c 204a  nt(x).    # p, J
-00020510: 412c 204a 4220 3d20 6361 6d2e 6465 7269  A, JB = cam.deri
-00020520: 7661 7469 7665 7328 782c 2050 290a 2020  vatives(x, P).  
-00020530: 2020 2320 7072 696e 7428 7029 0a20 2020    # print(p).   
-00020540: 2023 2070 7269 6e74 2863 616d 2e70 726f   # print(cam.pro
-00020550: 6a65 6374 5f70 6f69 6e74 2850 2929 0a20  ject_point(P)). 
-00020560: 2020 2023 2070 7269 6e74 284a 4129 0a20     # print(JA). 
-00020570: 2020 2023 2070 7269 6e74 284a 4229 0a0a     # print(JB)..
-00020580: 2020 2020 2320 736d 6261 7365 2e70 6c6f      # smbase.plo
-00020590: 7476 6f6c 3328 3229 0a0a 2020 2020 2320  tvol3(2)..    # 
-000205a0: 6361 6d2e 706c 6f74 5f63 616d 6572 6128  cam.plot_camera(
-000205b0: 7363 616c 653d 302e 352c 2073 6861 7065  scale=0.5, shape
-000205c0: 3d27 6361 6d65 7261 272c 2054 3d53 4533  ='camera', T=SE3
-000205d0: 2e52 7928 6e70 2e70 692f 3229 290a 0a20  .Ry(np.pi/2)).. 
-000205e0: 2020 2023 2070 6c74 2e73 686f 7728 626c     # plt.show(bl
-000205f0: 6f63 6b3d 5472 7565 290a 2020 2020 2320  ock=True).    # 
-00020600: 7072 696e 7428 6361 6d29 0a20 2020 2023  print(cam).    #
-00020610: 2023 2063 616d 2e70 6f73 6520 3d20 5345   # cam.pose = SE
-00020620: 3328 5b30 2e31 2c20 302e 322c 2030 2e33  3([0.1, 0.2, 0.3
-00020630: 5d29 0a20 2020 2023 2070 7269 6e74 2863  ]).    # print(c
-00020640: 616d 2e70 6f73 6529 0a20 2020 2023 2023  am.pose).    # #
-00020650: 2066 6967 2c20 6178 203d 2063 2e70 6c6f   fig, ax = c.plo
-00020660: 745f 6361 6d65 7261 2866 7275 7374 756d  t_camera(frustum
-00020670: 3d54 7275 6529 0a20 2020 2023 2023 2070  =True).    # # p
-00020680: 6c74 2e73 686f 7728 290a 2020 2020 2320  lt.show().    # 
-00020690: 6e70 2e73 6574 5f70 7269 6e74 6f70 7469  np.set_printopti
-000206a0: 6f6e 7328 6c69 6e65 7769 6474 683d 3132  ons(linewidth=12
-000206b0: 302c 2066 6f72 6d61 7474 6572 3d7b 2766  0, formatter={'f
-000206c0: 6c6f 6174 273a 206c 616d 6264 6120 783a  loat': lambda x:
-000206d0: 2066 227b 783a 382e 3467 7d22 2069 6620   f"{x:8.4g}" if 
-000206e0: 6162 7328 7829 203e 2031 652d 3130 2065  abs(x) > 1e-10 e
-000206f0: 6c73 6520 6622 7b30 3a38 2e34 677d 227d  lse f"{0:8.4g}"}
-00020700: 290a 0a0a 2020 2020 2320 7072 696e 7428  )...    # print(
-00020710: 6361 6d2e 7072 6f6a 6563 7428 5b31 2c32  cam.project([1,2
-00020720: 2c33 5d29 290a 0a20 2020 2023 2070 7269  ,3]))..    # pri
-00020730: 6e74 2863 616d 2e76 6973 6a61 635f 7028  nt(cam.visjac_p(
-00020740: 2833 3030 2c33 3030 292c 2031 2929 0a20  (300,300), 1)). 
-00020750: 2020 2023 2063 616d 2e66 6c6f 7766 6965     # cam.flowfie
-00020760: 6c64 285b 302c 302c 302c 2030 2c30 2c31  ld([0,0,0, 0,0,1
-00020770: 5d29 0a20 2020 2023 2023 2066 756e 6461  ]).    # # funda
-00020780: 6d65 6e74 616c 206d 6174 7269 780a 2020  mental matrix.  
-00020790: 2020 2320 2320 6372 6561 7465 202b 3820    # # create +8 
-000207a0: 776f 726c 6420 706f 696e 7473 2028 3230  world points (20
-000207b0: 2069 6e20 7468 6973 2063 6173 6529 0a20   in this case). 
-000207c0: 2020 2023 206e 782c 206e 7920 3d20 2834     # nx, ny = (4
-000207d0: 2c20 3529 0a20 2020 2023 2064 6570 7468  , 5).    # depth
-000207e0: 203d 2033 0a20 2020 2023 2078 203d 206e   = 3.    # x = n
-000207f0: 702e 6c69 6e73 7061 6365 282d 312c 2031  p.linspace(-1, 1
-00020800: 2c20 6e78 290a 2020 2020 2320 7920 3d20  , nx).    # y = 
-00020810: 6e70 2e6c 696e 7370 6163 6528 2d31 2c20  np.linspace(-1, 
-00020820: 312c 206e 7929 0a20 2020 2023 2058 2c20  1, ny).    # X, 
-00020830: 5920 3d20 6e70 2e6d 6573 6867 7269 6428  Y = np.meshgrid(
-00020840: 782c 2079 290a 2020 2020 2320 5a20 3d20  x, y).    # Z = 
-00020850: 6465 7074 6820 2a20 6e70 2e6f 6e65 7328  depth * np.ones(
-00020860: 582e 7368 6170 6529 0a20 2020 2023 2050  X.shape).    # P
-00020870: 203d 206e 702e 6473 7461 636b 2828 582c   = np.dstack((X,
-00020880: 2059 2c20 5a29 290a 2020 2020 2320 5043   Y, Z)).    # PC
-00020890: 203d 206e 702e 7261 7665 6c28 502c 206f   = np.ravel(P, o
-000208a0: 7264 6572 3d27 4327 290a 2020 2020 2320  rder='C').    # 
-000208b0: 5057 203d 206e 702e 7265 7368 6170 6528  PW = np.reshape(
-000208c0: 5043 2c20 2833 2c20 6e78 202a 206e 7929  PC, (3, nx * ny)
-000208d0: 2c20 6f72 6465 723d 2746 2729 0a0a 2020  , order='F')..  
-000208e0: 2020 2320 2320 6372 6561 7465 2070 726f    # # create pro
-000208f0: 6a65 6374 696f 6e73 2066 726f 6d20 706f  jections from po
-00020900: 7365 2031 3a0a 2020 2020 2320 7072 696e  se 1:.    # prin
-00020910: 7428 632e 5429 0a20 2020 2023 2070 3120  t(c.T).    # p1 
-00020920: 3d20 632e 7072 6f6a 6563 7428 5057 2920  = c.project(PW) 
-00020930: 2023 2070 3120 7772 7420 6327 7320 540a   # p1 wrt c's T.
-00020940: 2020 2020 2320 7072 696e 7428 7031 290a      # print(p1).
-00020950: 2020 2020 2320 632e 706c 6f74 2850 5729      # c.plot(PW)
-00020960: 0a0a 2020 2020 2320 2320 6465 6669 6e65  ..    # # define
-00020970: 2070 6f73 6520 323a 0a20 2020 2023 2054   pose 2:.    # T
-00020980: 3220 3d20 5345 3328 5b30 2e34 2c20 302e  2 = SE3([0.4, 0.
-00020990: 322c 2030 2e33 5d29 2020 2320 6a75 7374  2, 0.3])  # just
-000209a0: 2070 7572 6520 782d 7472 616e 736c 6174   pure x-translat
-000209b0: 696f 6e0a 2020 2020 2320 7032 203d 2063  ion.    # p2 = c
-000209c0: 2e70 726f 6a65 6374 2850 572c 2054 3229  .project(PW, T2)
-000209d0: 0a20 2020 2023 2070 7269 6e74 2870 3229  .    # print(p2)
-000209e0: 0a20 2020 2023 2063 2e70 6c6f 7428 7032  .    # c.plot(p2
-000209f0: 290a 0a20 2020 2023 2023 2063 6f6e 7665  )..    # # conve
-00020a00: 7274 2070 312c 2070 3220 696e 746f 206c  rt p1, p2 into l
-00020a10: 6973 7473 206f 6620 706f 696e 7473 3f0a  ists of points?.
-00020a20: 2020 2020 2320 7031 203d 206e 702e 666c      # p1 = np.fl
-00020a30: 6f61 7433 3228 6e70 2e74 7261 6e73 706f  oat32(np.transpo
-00020a40: 7365 2870 3129 290a 2020 2020 2320 7032  se(p1)).    # p2
-00020a50: 203d 206e 702e 666c 6f61 7433 3228 6e70   = np.float32(np
-00020a60: 2e74 7261 6e73 706f 7365 2870 3229 290a  .transpose(p2)).
-00020a70: 2020 2020 2320 4620 3d20 632e 4666 726f      # F = c.Ffro
-00020a80: 6d50 6f69 6e74 7328 7031 2c0a 2020 2020  mPoints(p1,.    
-00020a90: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-00020aa0: 2020 2020 7032 2c0a 2020 2020 2320 2020      p2,.    #   
-00020ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020ac0: 6d65 7468 6f64 3d27 3870 272c 0a20 2020  method='8p',.   
-00020ad0: 2023 2020 2020 2020 2020 2020 2020 2020   #              
-00020ae0: 2020 2020 2072 616e 7361 6354 6872 6573       ransacThres
-00020af0: 683d 332c 0a20 2020 2023 2020 2020 2020  h=3,.    #      
-00020b00: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00020b10: 6669 6465 6e63 653d 302e 3939 2c0a 2020  fidence=0.99,.  
-00020b20: 2020 2320 2020 2020 2020 2020 2020 2020    #             
-00020b30: 2020 2020 2020 6d61 7869 7465 7273 3d31        maxiters=1
-00020b40: 3029 0a0a 2020 2020 2320 2320 746f 2063  0)..    # # to c
-00020b50: 6865 636b 2046 3a0a 2020 2020 2320 7031  heck F:.    # p1
-00020b60: 6820 3d20 6532 6828 7031 2e54 290a 2020  h = e2h(p1.T).  
-00020b70: 2020 2320 7032 6820 3d20 6532 6828 7032    # p2h = e2h(p2
-00020b80: 2e54 290a 2020 2020 2320 7066 7020 3d20  .T).    # pfp = 
-00020b90: 5b70 3268 5b3a 2c20 695d 2e54 2040 2046  [p2h[:, i].T @ F
-00020ba0: 2040 2070 3168 5b3a 2c20 695d 2066 6f72   @ p1h[:, i] for
-00020bb0: 2069 2069 6e20 7261 6e67 6528 7031 682e   i in range(p1h.
-00020bc0: 7368 6170 655b 315d 295d 0a20 2020 2023  shape[1])].    #
-00020bd0: 2023 205b 7072 696e 7428 7066 7069 2920   # [print(pfpi) 
-00020be0: 666f 7220 7066 7069 2069 6e20 7066 705d  for pfpi in pfp]
-00020bf0: 0a20 2020 2023 2066 6f72 2070 6670 6920  .    # for pfpi 
-00020c00: 696e 2070 6670 3a0a 2020 2020 2320 2020  in pfp:.    #   
-00020c10: 2020 7072 696e 7428 7066 7069 290a 2020    print(pfpi).  
-00020c20: 2020 2320 2320 7368 6f75 6c64 2062 6520    # # should be 
-00020c30: 616c 6c20 636c 6f73 6520 746f 207a 6572  all close to zer
-00020c40: 6f2c 2077 6869 6368 2074 6865 7920 6172  o, which they ar
-00020c50: 6521 0a0a 2020 2020 2320 2320 6573 7365  e!..    # # esse
-00020c60: 6e74 6961 6c20 6d61 7472 6978 2066 726f  ntial matrix fro
-00020c70: 6d20 706f 696e 7473 3a0a 2020 2020 2320  m points:.    # 
-00020c80: 4520 3d20 632e 4566 726f 6d50 6f69 6e74  E = c.EfromPoint
-00020c90: 7328 7031 2c20 7032 2c20 632e 4329 0a0a  s(p1, p2, c.C)..
-00020ca0: 2020 2020 2320 2320 544f 444f 2076 6572      # # TODO ver
-00020cb0: 6966 7920 450a 0a20 2020 2023 2069 6d70  ify E..    # imp
-00020cc0: 6f72 7420 636f 6465 0a20 2020 2023 2063  ort code.    # c
-00020cd0: 6f64 652e 696e 7465 7261 6374 286c 6f63  ode.interact(loc
-00020ce0: 616c 3d64 6963 7428 676c 6f62 616c 7328  al=dict(globals(
-00020cf0: 292c 202a 2a6c 6f63 616c 7328 2929 290a  ), **locals())).
+00010440: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
+00010450: 2020 2020 2020 2020 696d 6167 6520 2020          image   
+00010460: 203a 636c 6173 733a 6049 6d61 6765 6020   :class:`Image` 
+00010470: 2020 2020 2020 2020 6361 6c69 6272 6174          calibrat
+00010480: 696f 6e20 696d 6167 6520 7769 7468 206f  ion image with o
+00010490: 7665 726c 6169 6420 616e 6e6f 7461 7469  verlaid annotati
+000104a0: 6f6e 0a20 2020 2020 2020 2070 6f73 6520  on.        pose 
+000104b0: 2020 2020 3a63 6c61 7373 3a60 5345 3360      :class:`SE3`
+000104c0: 2069 6e73 7461 6e63 6520 2070 6f73 6520   instance  pose 
+000104d0: 6f66 2074 6865 2063 616d 6572 6120 7769  of the camera wi
+000104e0: 7468 2072 6573 7065 6374 2074 6f20 7468  th respect to th
+000104f0: 6520 6f72 6967 696e 206f 6620 7468 6973  e origin of this
+00010500: 2069 6d61 6765 0a20 2020 2020 2020 2069   image.        i
+00010510: 6420 2020 2020 2020 696e 7420 2020 2020  d       int     
+00010520: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00010530: 6571 7565 6e63 6520 6e75 6d62 6572 206f  equence number o
+00010540: 6620 7468 6973 2069 6d61 6765 2069 6e20  f this image in 
+00010550: 6060 696d 6167 6573 6060 0a20 2020 2020  ``images``.     
+00010560: 2020 203d 3d3d 3d3d 3d3d 2020 3d3d 3d3d     =======  ====
+00010570: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00010580: 3d20 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  =  =============
+00010590: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000105a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000105b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a  ==============..
+000105c0: 2020 2020 2020 2020 3a6e 6f74 653a 2054          :note: T
+000105d0: 6865 2075 6e69 7473 2075 7365 6420 666f  he units used fo
+000105e0: 7220 6060 7371 7561 7265 7369 7a65 6060  r ``squaresize``
+000105f0: 206d 7573 7420 6d61 7463 6820 7468 6520   must match the 
+00010600: 756e 6974 7320 7573 6564 0a20 2020 2020  units used.     
+00010610: 2020 2020 2020 2066 6f72 2064 6566 696e         for defin
+00010620: 696e 6720 3344 2070 6f69 6e74 7320 696e  ing 3D points in
+00010630: 2073 7061 6365 2e0a 0a20 2020 2020 2020   space...       
+00010640: 203a 7265 6665 7265 6e63 6573 3a0a 2020   :references:.  
+00010650: 2020 2020 2020 2020 2020 2d20 526f 626f            - Robo
+00010660: 7469 6373 2c20 5669 7369 6f6e 2026 2043  tics, Vision & C
+00010670: 6f6e 7472 6f6c 2066 6f72 2050 7974 686f  ontrol for Pytho
+00010680: 6e2c 2053 6563 7469 6f6e 2031 332e 372c  n, Section 13.7,
+00010690: 2050 2e20 436f 726b 652c 0a20 2020 2020   P. Corke,.     
+000106a0: 2020 2020 2020 2020 2053 7072 696e 6765           Springe
+000106b0: 7220 3230 3233 2e0a 0a20 2020 2020 2020  r 2023...       
+000106c0: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
+000106d0: 3a60 4360 203a 6d65 7468 3a60 706f 696e  :`C` :meth:`poin
+000106e0: 7473 3243 6020 3a6d 6574 683a 6064 6563  ts2C` :meth:`dec
+000106f0: 6f6d 706f 7365 4360 203a 636c 6173 733a  omposeC` :class:
+00010700: 607e 7370 6174 6961 6c6d 6174 682e 2e70  `~spatialmath..p
+00010710: 6f73 6533 642e 5345 3360 0a20 2020 2020  ose3d.SE3`.     
+00010720: 2020 2022 2222 0a0a 2020 2020 2020 2020     """..        
+00010730: 6372 6974 6572 6961 203d 2028 6376 2e54  criteria = (cv.T
+00010740: 4552 4d5f 4352 4954 4552 4941 5f45 5053  ERM_CRITERIA_EPS
+00010750: 202b 2063 762e 5445 524d 5f43 5249 5445   + cv.TERM_CRITE
+00010760: 5249 415f 4d41 585f 4954 4552 2c20 3330  RIA_MAX_ITER, 30
+00010770: 2c20 302e 3030 3129 0a20 2020 2020 2020  , 0.001).       
+00010780: 2023 2063 7265 6174 6520 7365 7420 6f66   # create set of
+00010790: 2066 6561 7475 7265 2070 6f69 6e74 732c   feature points,
+000107a0: 206c 696b 6520 2830 2c30 2c30 292c 2028   like (0,0,0), (
+000107b0: 312c 302c 3029 2c20 2832 2c30 2c30 2920  1,0,0), (2,0,0) 
+000107c0: 2e2e 2e2e 2c28 362c 352c 3029 0a20 2020  ....,(6,5,0).   
+000107d0: 2020 2020 2023 2074 6865 7365 2061 6c6c       # these all
+000107e0: 2068 6176 6520 5a3d 3020 7369 6e63 6520   have Z=0 since 
+000107f0: 7468 6579 2061 7265 2072 656c 6174 6976  they are relativ
+00010800: 6520 746f 2074 6865 2063 616c 6962 7261  e to the calibra
+00010810: 7469 6f6e 2074 6172 6765 7420 6672 616d  tion target fram
+00010820: 650a 2020 2020 2020 2020 6f62 6a70 203d  e.        objp =
+00010830: 206e 702e 7a65 726f 7328 2867 7269 6473   np.zeros((grids
+00010840: 6861 7065 5b30 5d20 2a20 6772 6964 7368  hape[0] * gridsh
+00010850: 6170 655b 315d 2c20 3329 2c20 6e70 2e66  ape[1], 3), np.f
+00010860: 6c6f 6174 3332 290a 2020 2020 2020 2020  loat32).        
+00010870: 6f62 6a70 5b3a 2c20 3a32 5d20 3d20 280a  objp[:, :2] = (.
+00010880: 2020 2020 2020 2020 2020 2020 6e70 2e6d              np.m
+00010890: 6772 6964 5b30 203a 2067 7269 6473 6861  grid[0 : gridsha
+000108a0: 7065 5b30 5d2c 2030 203a 2067 7269 6473  pe[0], 0 : grids
+000108b0: 6861 7065 5b31 5d5d 2e54 2e72 6573 6861  hape[1]].T.resha
+000108c0: 7065 282d 312c 2032 2920 2a20 7371 7561  pe(-1, 2) * squa
+000108d0: 7265 7369 7a65 0a20 2020 2020 2020 2029  resize.        )
+000108e0: 0a0a 2020 2020 2020 2020 2320 6c69 7374  ..        # list
+000108f0: 7320 746f 2073 746f 7265 206f 626a 6563  s to store objec
+00010900: 7420 706f 696e 7473 2061 6e64 2069 6d61  t points and ima
+00010910: 6765 2070 6f69 6e74 7320 6672 6f6d 2061  ge points from a
+00010920: 6c6c 2074 6865 2069 6d61 6765 730a 2020  ll the images.  
+00010930: 2020 2020 2020 6f62 6a70 6f69 6e74 7320        objpoints 
+00010940: 3d20 5b5d 2020 2320 3364 2070 6f69 6e74  = []  # 3d point
+00010950: 2069 6e20 7265 616c 2077 6f72 6c64 2073   in real world s
+00010960: 7061 6365 0a20 2020 2020 2020 2069 6d67  pace.        img
+00010970: 706f 696e 7473 203d 205b 5d20 2023 2032  points = []  # 2
+00010980: 6420 706f 696e 7473 2069 6e20 696d 6167  d points in imag
+00010990: 6520 706c 616e 652e 0a20 2020 2020 2020  e plane..       
+000109a0: 2063 6f72 6e65 725f 696d 6167 6573 203d   corner_images =
+000109b0: 205b 5d0a 2020 2020 2020 2020 7661 6c69   [].        vali
+000109c0: 6420 3d20 5b5d 0a0a 2020 2020 2020 2020  d = []..        
+000109d0: 666f 7220 692c 2069 6d61 6765 2069 6e20  for i, image in 
+000109e0: 656e 756d 6572 6174 6528 696d 6167 6573  enumerate(images
+000109f0: 293a 0a0a 2020 2020 2020 2020 2020 2020  ):..            
+00010a00: 6772 6179 203d 2069 6d61 6765 2e6d 6f6e  gray = image.mon
+00010a10: 6f28 292e 410a 2020 2020 2020 2020 2020  o().A.          
+00010a20: 2020 2320 4669 6e64 2074 6865 2063 6865    # Find the che
+00010a30: 7373 2062 6f61 7264 2063 6f72 6e65 7273  ss board corners
+00010a40: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00010a50: 2c20 636f 726e 6572 7320 3d20 6376 2e66  , corners = cv.f
+00010a60: 696e 6443 6865 7373 626f 6172 6443 6f72  indChessboardCor
+00010a70: 6e65 7273 2867 7261 792c 2067 7269 6473  ners(gray, grids
+00010a80: 6861 7065 2c20 4e6f 6e65 290a 2020 2020  hape, None).    
+00010a90: 2020 2020 2020 2020 2320 4966 2066 6f75          # If fou
+00010aa0: 6e64 2c20 6164 6420 6f62 6a65 6374 2070  nd, add object p
+00010ab0: 6f69 6e74 732c 2069 6d61 6765 2070 6f69  oints, image poi
+00010ac0: 6e74 7320 2861 6674 6572 2072 6566 696e  nts (after refin
+00010ad0: 696e 6720 7468 656d 290a 2020 2020 2020  ing them).      
+00010ae0: 2020 2020 2020 6966 2072 6574 3a0a 2020        if ret:.  
+00010af0: 2020 2020 2020 2020 2020 2020 2020 6f62                ob
+00010b00: 6a70 6f69 6e74 732e 6170 7065 6e64 286f  jpoints.append(o
+00010b10: 626a 7029 0a20 2020 2020 2020 2020 2020  bjp).           
+00010b20: 2020 2020 2063 6f72 6e65 7273 3220 3d20       corners2 = 
+00010b30: 6376 2e63 6f72 6e65 7253 7562 5069 7828  cv.cornerSubPix(
+00010b40: 6772 6179 2c20 636f 726e 6572 732c 2028  gray, corners, (
+00010b50: 3131 2c20 3131 292c 2028 2d31 2c20 2d31  11, 11), (-1, -1
+00010b60: 292c 2063 7269 7465 7269 6129 0a20 2020  ), criteria).   
+00010b70: 2020 2020 2020 2020 2020 2020 2069 6d67               img
+00010b80: 706f 696e 7473 2e61 7070 656e 6428 636f  points.append(co
+00010b90: 726e 6572 7329 0a20 2020 2020 2020 2020  rners).         
+00010ba0: 2020 2020 2020 2023 2044 7261 7720 7468         # Draw th
+00010bb0: 6520 636f 726e 6572 730a 2020 2020 2020  e corners.      
+00010bc0: 2020 2020 2020 2020 2020 696d 6167 6520            image 
+00010bd0: 3d20 496d 6167 6528 696d 6167 652c 2063  = Image(image, c
+00010be0: 6f70 793d 5472 7565 290a 2020 2020 2020  opy=True).      
+00010bf0: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
+00010c00: 2069 6d61 6765 2e69 7363 6f6c 6f72 3a0a   image.iscolor:.
+00010c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010c20: 2020 2020 696d 6167 6520 3d20 696d 6167      image = imag
+00010c30: 652e 636f 6c6f 7269 7a65 2829 0a20 2020  e.colorize().   
+00010c40: 2020 2020 2020 2020 2020 2020 2063 6f72               cor
+00010c50: 6e65 725f 696d 6167 6573 2e61 7070 656e  ner_images.appen
+00010c60: 6428 0a20 2020 2020 2020 2020 2020 2020  d(.             
+00010c70: 2020 2020 2020 2063 762e 6472 6177 4368         cv.drawCh
+00010c80: 6573 7362 6f61 7264 436f 726e 6572 7328  essboardCorners(
+00010c90: 696d 6167 652e 412c 2067 7269 6473 6861  image.A, gridsha
+00010ca0: 7065 2c20 636f 726e 6572 7332 2c20 7265  pe, corners2, re
+00010cb0: 7429 0a20 2020 2020 2020 2020 2020 2020  t).             
+00010cc0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00010cd0: 2020 2020 2076 616c 6964 2e61 7070 656e       valid.appen
+00010ce0: 6428 6929 0a0a 2020 2020 2020 2020 7265  d(i)..        re
+00010cf0: 742c 2043 2c20 6469 7374 6f72 7469 6f6e  t, C, distortion
+00010d00: 2c20 7276 6563 732c 2074 7665 6373 203d  , rvecs, tvecs =
+00010d10: 2063 762e 6361 6c69 6272 6174 6543 616d   cv.calibrateCam
+00010d20: 6572 6128 0a20 2020 2020 2020 2020 2020  era(.           
+00010d30: 206f 626a 706f 696e 7473 2c20 696d 6770   objpoints, imgp
+00010d40: 6f69 6e74 732c 2067 7261 792e 7368 6170  oints, gray.shap
+00010d50: 655b 3a3a 2d31 5d2c 204e 6f6e 652c 204e  e[::-1], None, N
+00010d60: 6f6e 650a 2020 2020 2020 2020 290a 0a20  one.        ).. 
+00010d70: 2020 2020 2020 2043 616c 6962 7261 7469         Calibrati
+00010d80: 6f6e 4672 616d 6520 3d20 6e61 6d65 6474  onFrame = namedt
+00010d90: 7570 6c65 2822 4361 6c69 6272 6174 696f  uple("Calibratio
+00010da0: 6e46 7261 6d65 222c 2022 696d 6167 6520  nFrame", "image 
+00010db0: 706f 7365 2069 6422 290a 2020 2020 2020  pose id").      
+00010dc0: 2020 6966 2072 6574 3a0a 2020 2020 2020    if ret:.      
+00010dd0: 2020 2020 2020 6672 616d 6573 203d 205b        frames = [
+00010de0: 5d0a 2020 2020 2020 2020 2020 2020 666f  ].            fo
+00010df0: 7220 7276 6563 2c20 7476 6563 2c20 636f  r rvec, tvec, co
+00010e00: 726e 6572 5f69 6d61 6765 2c20 6964 2069  rner_image, id i
+00010e10: 6e20 7a69 7028 7276 6563 732c 2074 7665  n zip(rvecs, tve
+00010e20: 6373 2c20 636f 726e 6572 5f69 6d61 6765  cs, corner_image
+00010e30: 732c 2076 616c 6964 293a 0a20 2020 2020  s, valid):.     
+00010e40: 2020 2020 2020 2020 2020 2066 7261 6d65             frame
+00010e50: 203d 2043 616c 6962 7261 7469 6f6e 4672   = CalibrationFr
+00010e60: 616d 6528 0a20 2020 2020 2020 2020 2020  ame(.           
+00010e70: 2020 2020 2020 2020 2049 6d61 6765 2863           Image(c
+00010e80: 6f72 6e65 725f 696d 6167 652c 2063 6f6c  orner_image, col
+00010e90: 6f72 6f72 6465 723d 2242 4752 2229 2c0a  ororder="BGR"),.
+00010ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010eb0: 2020 2020 2853 4533 2874 7665 6329 202a      (SE3(tvec) *
+00010ec0: 2053 4533 2e45 756c 6572 5665 6328 7276   SE3.EulerVec(rv
+00010ed0: 6563 2e66 6c61 7474 656e 2829 2929 2e69  ec.flatten())).i
+00010ee0: 6e76 2829 2c0a 2020 2020 2020 2020 2020  nv(),.          
+00010ef0: 2020 2020 2020 2020 2020 6964 2c0a 2020            id,.  
+00010f00: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00010f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010f20: 6672 616d 6573 2e61 7070 656e 6428 6672  frames.append(fr
+00010f30: 616d 6529 0a20 2020 2020 2020 2020 2020  ame).           
+00010f40: 2072 6574 7572 6e20 432c 2064 6973 746f   return C, disto
+00010f50: 7274 696f 6e5b 305d 2c20 6672 616d 6573  rtion[0], frames
+00010f60: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00010f70: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00010f80: 6e20 4e6f 6e65 0a0a 2020 2020 4063 6c61  n None..    @cla
+00010f90: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
+00010fa0: 2064 6563 6f6d 706f 7365 4328 636c 732c   decomposeC(cls,
+00010fb0: 2043 293a 0a20 2020 2020 2020 2072 2222   C):.        r""
+00010fc0: 220a 2020 2020 2020 2020 4465 636f 6d70  ".        Decomp
+00010fd0: 6f73 6520 6361 6d65 7261 2063 616c 6962  ose camera calib
+00010fe0: 7261 7469 6f6e 206d 6174 7269 780a 0a20  ration matrix.. 
+00010ff0: 2020 2020 2020 203a 7061 7261 6d20 433a         :param C:
+00011000: 2063 616d 6572 6120 6361 6c69 6272 6174   camera calibrat
+00011010: 696f 6e20 6d61 7472 6978 0a20 2020 2020  ion matrix.     
+00011020: 2020 203a 7479 7065 2043 3a20 6e64 6172     :type C: ndar
+00011030: 7261 7928 332c 3429 0a20 2020 2020 2020  ray(3,4).       
+00011040: 203a 7265 7475 726e 3a20 6361 6d65 7261   :return: camera
+00011050: 206d 6f64 656c 2070 6172 616d 6574 6572   model parameter
+00011060: 730a 2020 2020 2020 2020 3a72 7479 7065  s.        :rtype
+00011070: 3a20 3a63 6c61 7373 3a60 4365 6e74 7261  : :class:`Centra
+00011080: 6c43 616d 6572 6160 0a0a 2020 2020 2020  lCamera`..      
+00011090: 2020 4465 636f 6d70 6f73 6520 6120 3a6d    Decompose a :m
+000110a0: 6174 683a 6033 5c74 696d 6573 2034 6020  ath:`3\times 4` 
+000110b0: 6361 6d65 7261 2063 616c 6962 7261 7469  camera calibrati
+000110c0: 6f6e 206d 6174 7269 7820 6060 4360 6020  on matrix ``C`` 
+000110d0: 746f 0a20 2020 2020 2020 2064 6574 6572  to.        deter
+000110e0: 6d69 6e65 2066 6561 7369 626c 6520 696e  mine feasible in
+000110f0: 7472 696e 7369 6320 616e 6420 6578 7472  trinsic and extr
+00011100: 696e 7369 6320 7061 7261 6d65 7465 7273  insic parameters
+00011110: 2e20 5468 6520 7265 7375 6c74 2069 7320  . The result is 
+00011120: 610a 2020 2020 2020 2020 6060 4365 6e74  a.        ``Cent
+00011130: 7261 6c43 616d 6572 6160 6020 696e 7374  ralCamera`` inst
+00011140: 616e 6365 2077 6974 6820 7468 6520 666f  ance with the fo
+00011150: 6c6c 6f77 696e 6720 7061 7261 6d65 7465  llowing paramete
+00011160: 7273 2073 6574 3a0a 0a20 2020 2020 2020  rs set:..       
+00011170: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+00011180: 3d20 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  =  =============
+00011190: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000111a0: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+000111b0: 5061 7261 6d65 7465 7220 2020 2020 2020  Parameter       
+000111c0: 2020 4d65 616e 696e 670a 2020 2020 2020    Meaning.      
+000111d0: 2020 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d    ==============
+000111e0: 3d3d 2020 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ==  ============
+000111f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00011200: 3d3d 3d3d 3d3d 3d3d 0a20 2020 2020 2020  ========.       
+00011210: 2060 6066 6060 2020 2020 2020 2020 2020   ``f``          
+00011220: 2020 2066 6f63 616c 206c 656e 6774 6820     focal length 
+00011230: 696e 2070 6978 656c 730a 2020 2020 2020  in pixels.      
+00011240: 2020 6060 7378 6060 2c20 6060 7379 6060    ``sx``, ``sy``
+00011250: 2020 2020 7069 7865 6c20 7369 7a65 2077      pixel size w
+00011260: 6865 7265 2060 6073 7860 6020 3d31 0a20  here ``sx`` =1. 
+00011270: 2020 2020 2020 2028 6060 7530 6060 2c20         (``u0``, 
+00011280: 6060 7630 6060 2920 2070 7269 6e63 6970  ``v0``)  princip
+00011290: 616c 2070 6f69 6e74 0a20 2020 2020 2020  al point.       
+000112a0: 2060 6070 6f73 6560 6020 2020 2020 2020   ``pose``       
+000112b0: 2020 2070 6f73 6520 6f66 2074 6865 2063     pose of the c
+000112c0: 616d 6572 6120 6672 616d 6520 7772 7420  amera frame wrt 
+000112d0: 776f 726c 640a 2020 2020 2020 2020 3d3d  world.        ==
+000112e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2020  ==============  
+000112f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00011300: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00011310: 3d3d 3d3d 0a0a 2020 2020 2020 2020 4578  ====..        Ex
+00011320: 616d 706c 653a 0a0a 2020 2020 2020 2020  ample:..        
+00011330: 2e2e 2072 756e 626c 6f63 6b3a 3a20 7079  .. runblock:: py
+00011340: 636f 6e0a 0a20 2020 2020 2020 2020 2020  con..           
+00011350: 203e 3e3e 2066 726f 6d20 6d61 6368 696e   >>> from machin
+00011360: 6576 6973 696f 6e74 6f6f 6c62 6f78 2069  evisiontoolbox i
+00011370: 6d70 6f72 7420 4365 6e74 7261 6c43 616d  mport CentralCam
+00011380: 6572 610a 2020 2020 2020 2020 2020 2020  era.            
+00011390: 3e3e 3e20 6672 6f6d 2073 7061 7469 616c  >>> from spatial
+000113a0: 6d61 7468 2069 6d70 6f72 7420 5345 330a  math import SE3.
+000113b0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+000113c0: 6361 6d65 7261 203d 2043 656e 7472 616c  camera = Central
+000113d0: 4361 6d65 7261 286e 616d 653d 2763 616d  Camera(name='cam
+000113e0: 6572 6131 2729 0a20 2020 2020 2020 2020  era1').         
+000113f0: 2020 203e 3e3e 2043 203d 2063 616d 6572     >>> C = camer
+00011400: 612e 4328 5345 3328 302e 312c 2030 2c20  a.C(SE3(0.1, 0, 
+00011410: 3029 290a 2020 2020 2020 2020 2020 2020  0)).            
+00011420: 3e3e 3e20 4365 6e74 7261 6c43 616d 6572  >>> CentralCamer
+00011430: 612e 6465 636f 6d70 6f73 6543 2843 290a  a.decomposeC(C).
+00011440: 0a20 2020 2020 2020 203a 6e6f 7465 3a20  .        :note: 
+00011450: 5369 6e63 6520 6f6e 6c79 203a 6d61 7468  Since only :math
+00011460: 3a60 6620 735f 7860 2061 6e64 203a 6d61  :`f s_x` and :ma
+00011470: 7468 3a60 6620 735f 7960 2063 616e 2062  th:`f s_y` can b
+00011480: 6520 6573 7469 6d61 7465 6420 7765 0a20  e estimated we. 
+00011490: 2020 2020 2020 2020 2020 2073 6574 203a             set :
+000114a0: 6d61 7468 3a60 735f 7820 3d20 3160 2e0a  math:`s_x = 1`..
+000114b0: 0a20 2020 2020 2020 203a 7265 6665 7265  .        :refere
+000114c0: 6e63 653a 0a20 2020 2020 2020 2020 2020  nce:.           
+000114d0: 202d 204d 756c 7469 706c 6520 5669 6577   - Multiple View
+000114e0: 2047 656f 6d65 7472 792c 2048 6172 746c   Geometry, Hartl
+000114f0: 6579 265a 6973 7365 726d 616e 2c20 7020  ey&Zisserman, p 
+00011500: 3136 332d 3136 340a 2020 2020 2020 2020  163-164.        
+00011510: 2020 2020 2d20 526f 626f 7469 6373 2c20      - Robotics, 
+00011520: 5669 7369 6f6e 2026 2043 6f6e 7472 6f6c  Vision & Control
+00011530: 2066 6f72 2050 7974 686f 6e2c 2053 6563   for Python, Sec
+00011540: 7469 6f6e 2031 332e 322e 332c 2050 2e20  tion 13.2.3, P. 
+00011550: 436f 726b 652c 0a20 2020 2020 2020 2020  Corke,.         
+00011560: 2020 2020 2053 7072 696e 6765 7220 3230       Springer 20
+00011570: 3233 2e0a 0a20 2020 2020 2020 203a 7365  23...        :se
+00011580: 6561 6c73 6f3a 203a 6d65 7468 3a60 4360  ealso: :meth:`C`
+00011590: 203a 6d65 7468 3a60 706f 696e 7473 3243   :meth:`points2C
+000115a0: 600a 2020 2020 2020 2020 2222 220a 0a20  `.        """.. 
+000115b0: 2020 2020 2020 2064 6566 2072 7128 5329         def rq(S)
+000115c0: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+000115d0: 6672 6f6d 2076 6767 5f72 712e 6d0a 2020  from vgg_rq.m.  
+000115e0: 2020 2020 2020 2020 2020 2320 5b52 2c51            # [R,Q
+000115f0: 5d20 3d20 7667 675f 7271 2853 2920 204a  ] = vgg_rq(S)  J
+00011600: 7573 7420 6c69 6b65 2071 7220 6275 7420  ust like qr but 
+00011610: 7468 6520 6f74 6865 7220 7761 7920 6172  the other way ar
+00011620: 6f75 6e64 2e0a 2020 2020 2020 2020 2020  ound..          
+00011630: 2020 2320 4966 205b 522c 515d 203d 2076    # If [R,Q] = v
+00011640: 6767 5f72 7128 5829 2c20 7468 656e 2052  gg_rq(X), then R
+00011650: 2069 7320 7570 7065 722d 7472 6961 6e67   is upper-triang
+00011660: 756c 6172 2c20 5120 6973 206f 7274 686f  ular, Q is ortho
+00011670: 676f 6e61 6c2c 2061 6e64 2058 3d3d 522a  gonal, and X==R*
+00011680: 512e 0a20 2020 2020 2020 2020 2020 2023  Q..            #
+00011690: 204d 6f72 656f 7665 722c 2069 6620 5320   Moreover, if S 
+000116a0: 6973 2061 2072 6561 6c20 6d61 7472 6978  is a real matrix
+000116b0: 2c20 7468 656e 2064 6574 2851 293e 302e  , then det(Q)>0.
+000116c0: 0a20 2020 2020 2020 2020 2020 2023 2042  .            # B
+000116d0: 7920 6177 660a 0a20 2020 2020 2020 2020  y awf..         
+000116e0: 2020 2053 203d 2053 2e54 0a20 2020 2020     S = S.T.     
+000116f0: 2020 2020 2020 2051 2c20 5520 3d20 6e70         Q, U = np
+00011700: 2e6c 696e 616c 672e 7172 2853 5b3a 3a2d  .linalg.qr(S[::-
+00011710: 312c 203a 3a2d 315d 290a 2020 2020 2020  1, ::-1]).      
+00011720: 2020 2020 2020 5120 3d20 512e 540a 2020        Q = Q.T.  
+00011730: 2020 2020 2020 2020 2020 5120 3d20 515b            Q = Q[
+00011740: 3a3a 2d31 2c20 3a3a 2d31 5d0a 2020 2020  ::-1, ::-1].    
+00011750: 2020 2020 2020 2020 5520 3d20 552e 540a          U = U.T.
+00011760: 2020 2020 2020 2020 2020 2020 5520 3d20              U = 
+00011770: 555b 3a3a 2d31 2c20 3a3a 2d31 5d0a 0a20  U[::-1, ::-1].. 
+00011780: 2020 2020 2020 2020 2020 2069 6620 6e70             if np
+00011790: 2e6c 696e 616c 672e 6465 7428 5129 203c  .linalg.det(Q) <
+000117a0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+000117b0: 2020 2020 555b 3a2c 2030 5d20 3d20 2d55      U[:, 0] = -U
+000117c0: 5b3a 2c20 305d 0a20 2020 2020 2020 2020  [:, 0].         
+000117d0: 2020 2020 2020 2051 5b30 2c20 3a5d 203d         Q[0, :] =
+000117e0: 202d 515b 302c 203a 5d0a 2020 2020 2020   -Q[0, :].      
+000117f0: 2020 2020 2020 7265 7475 726e 2055 2c20        return U, 
+00011800: 510a 0a20 2020 2020 2020 2069 6620 6e6f  Q..        if no
+00011810: 7420 432e 7368 6170 6520 3d3d 2028 332c  t C.shape == (3,
+00011820: 2034 293a 0a20 2020 2020 2020 2020 2020   4):.           
+00011830: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+00011840: 7228 2261 7267 756d 656e 7420 6973 206e  r("argument is n
+00011850: 6f74 2061 2033 7834 206d 6174 7269 7822  ot a 3x4 matrix"
+00011860: 290a 0a20 2020 2020 2020 2075 2c20 732c  )..        u, s,
+00011870: 2076 203d 206e 702e 6c69 6e61 6c67 2e73   v = np.linalg.s
+00011880: 7664 2843 290a 2020 2020 2020 2020 7620  vd(C).        v 
+00011890: 3d20 762e 540a 0a20 2020 2020 2020 2023  = v.T..        #
+000118a0: 2064 6574 6572 6d69 6e65 2063 616d 6572   determine camer
+000118b0: 6120 706f 7369 7469 6f6e 0a20 2020 2020  a position.     
+000118c0: 2020 2074 203d 2076 5b3a 2c20 335d 2020     t = v[:, 3]  
+000118d0: 2320 6c61 7374 2063 6f6c 756d 6e0a 2020  # last column.  
+000118e0: 2020 2020 2020 7420 3d20 7420 2f20 745b        t = t / t[
+000118f0: 335d 0a20 2020 2020 2020 2074 203d 2074  3].        t = t
+00011900: 5b3a 335d 0a0a 2020 2020 2020 2020 2320  [:3]..        # 
+00011910: 6465 7465 726d 696e 6520 6361 6d65 7261  determine camera
+00011920: 206f 7269 656e 7461 7469 6f6e 0a20 2020   orientation.   
+00011930: 2020 2020 204d 203d 2043 5b3a 332c 203a       M = C[:3, :
+00011940: 335d 0a20 2020 2020 2020 2023 204b 2c20  3].        # K, 
+00011950: 5220 3d20 7271 284d 290a 2020 2020 2020  R = rq(M).      
+00011960: 2020 4b2c 2052 203d 2073 6369 7079 2e6c    K, R = scipy.l
+00011970: 696e 616c 672e 7271 284d 290a 0a20 2020  inalg.rq(M)..   
+00011980: 2020 2020 2023 2064 6561 6c20 7769 7468       # deal with
+00011990: 204b 2068 6176 696e 6720 6e65 6761 7469   K having negati
+000119a0: 7665 2065 6c65 6d65 6e74 7320 6f6e 2074  ve elements on t
+000119b0: 6865 2064 6961 676f 6e61 6c0a 2020 2020  he diagonal.    
+000119c0: 2020 2020 2320 6d61 6b65 2061 206d 6174      # make a mat
+000119d0: 7269 7820 746f 2066 6978 2074 6869 732c  rix to fix this,
+000119e0: 204b 2a43 2068 6173 2070 6f73 6974 6976   K*C has positiv
+000119f0: 6520 6469 6167 6f6e 616c 0a20 2020 2020  e diagonal.     
+00011a00: 2020 2043 203d 206e 702e 6469 6167 286e     C = np.diag(n
+00011a10: 702e 7369 676e 286e 702e 6469 6167 284b  p.sign(np.diag(K
+00011a20: 2929 290a 0a20 2020 2020 2020 2023 206e  )))..        # n
+00011a30: 6f77 2020 4b2a 5220 3d20 284b 2a43 2920  ow  K*R = (K*C) 
+00011a40: 2a20 2869 6e76 2843 292a 5229 2c20 736f  * (inv(C)*R), so
+00011a50: 2077 6520 6e65 6564 2074 6f20 6368 6563   we need to chec
+00011a60: 6b20 4320 6973 2061 2070 726f 7065 7220  k C is a proper 
+00011a70: 726f 7461 7469 6f6e 0a20 2020 2020 2020  rotation.       
+00011a80: 2023 206d 6174 7269 782e 2020 4966 2069   # matrix.  If i
+00011a90: 736e 2774 2074 6865 6e20 7468 6520 7369  sn't then the si
+00011aa0: 7475 6174 696f 6e20 6973 2075 6e66 6978  tuation is unfix
+00011ab0: 6162 6c65 0a0a 2020 2020 2020 2020 6966  able..        if
+00011ac0: 206e 6f74 206e 702e 6973 636c 6f73 6528   not np.isclose(
+00011ad0: 6e70 2e6c 696e 616c 672e 6465 7428 4329  np.linalg.det(C)
+00011ae0: 2c20 3129 3a0a 2020 2020 2020 2020 2020  , 1):.          
+00011af0: 2020 7261 6973 6520 5275 6e74 696d 6545    raise RuntimeE
+00011b00: 7272 6f72 2822 6361 6e6e 6f74 2063 6f72  rror("cannot cor
+00011b10: 7265 6374 2073 6967 6e73 2069 6e20 7468  rect signs in th
+00011b20: 6520 696e 7472 696e 7369 6320 6d61 7472  e intrinsic matr
+00011b30: 6978 2229 0a0a 2020 2020 2020 2020 2320  ix")..        # 
+00011b40: 616c 6c20 676f 6f64 2c20 6c65 7427 7320  all good, let's 
+00011b50: 6669 7820 6974 0a20 2020 2020 2020 204b  fix it.        K
+00011b60: 203d 204b 2040 2043 0a20 2020 2020 2020   = K @ C.       
+00011b70: 2052 203d 2043 2e54 2040 2052 0a0a 2020   R = C.T @ R..  
+00011b80: 2020 2020 2020 2320 6e6f 726d 616c 697a        # normaliz
+00011b90: 6520 4b20 736f 2074 6861 7420 6c6f 7765  e K so that lowe
+00011ba0: 7220 6c65 6674 2069 7320 310a 2020 2020  r left is 1.    
+00011bb0: 2020 2020 4b20 3d20 4b20 2f20 4b5b 322c      K = K / K[2,
+00011bc0: 2032 5d0a 0a20 2020 2020 2020 2023 2070   2]..        # p
+00011bd0: 756c 6c20 6f75 7420 666f 6361 6c20 6c65  ull out focal le
+00011be0: 6e67 7468 2061 6e64 2073 6361 6c65 2066  ngth and scale f
+00011bf0: 6163 746f 7273 0a20 2020 2020 2020 2066  actors.        f
+00011c00: 203d 204b 5b30 2c20 305d 0a20 2020 2020   = K[0, 0].     
+00011c10: 2020 2073 203d 206e 702e 725f 5b31 2c20     s = np.r_[1, 
+00011c20: 4b5b 312c 2031 5d20 2f20 4b5b 302c 2030  K[1, 1] / K[0, 0
+00011c30: 5d5d 0a0a 2020 2020 2020 2020 2320 6275  ]]..        # bu
+00011c40: 696c 6420 616e 2065 7175 6976 616c 656e  ild an equivalen
+00011c50: 7420 6361 6d65 7261 206d 6f64 656c 0a20  t camera model. 
+00011c60: 2020 2020 2020 2072 6574 7572 6e20 636c         return cl
+00011c70: 7328 6e61 6d65 3d22 696e 7643 222c 2066  s(name="invC", f
+00011c80: 3d66 2c20 7070 3d4b 5b3a 322c 2032 5d2c  =f, pp=K[:2, 2],
+00011c90: 2072 686f 3d73 2c20 706f 7365 3d53 4533   rho=s, pose=SE3
+00011ca0: 2e52 7428 522e 542c 2074 2929 0a0a 2020  .Rt(R.T, t))..  
+00011cb0: 2020 2320 6874 7470 733a 2f2f 646f 6373    # https://docs
+00011cc0: 2e6f 7065 6e63 762e 6f72 672f 332e 312e  .opencv.org/3.1.
+00011cd0: 302f 6439 2f64 3063 2f67 726f 7570 5f5f  0/d9/d0c/group__
+00011ce0: 6361 6c69 6233 642e 6874 6d6c 2367 6161  calib3d.html#gaa
+00011cf0: 6165 3561 3738 3939 6661 6131 6666 6466  ae5a7899faa1ffdf
+00011d00: 3236 3863 6439 3038 3839 3430 3234 380a  268cd9088940248.
+00011d10: 0a20 2020 2023 203d 3d3d 3d3d 3d3d 3d3d  .    # =========
+00011d20: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2068  ============== h
+00011d30: 6f6d 6f67 7261 7068 7920 3d3d 3d3d 3d3d  omography ======
+00011d40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00011d50: 3d3d 3d3d 3d3d 3d3d 3d20 230a 0a20 2020  ========= #..   
+00011d60: 2064 6566 2048 2873 656c 662c 2054 2c20   def H(self, T, 
+00011d70: 6e2c 2064 293a 0a20 2020 2020 2020 2022  n, d):.        "
+00011d80: 2222 0a20 2020 2020 2020 2043 6f6d 7075  "".        Compu
+00011d90: 7465 2068 6f6d 6f67 7261 7068 7920 6672  te homography fr
+00011da0: 6f6d 2070 6c61 6e65 2061 6e64 2063 616d  om plane and cam
+00011db0: 6572 6120 706f 7365 0a0a 2020 2020 2020  era pose..      
+00011dc0: 2020 3a70 6172 616d 2054 3a20 7265 6c61    :param T: rela
+00011dd0: 7469 7665 2063 616d 6572 6120 6d6f 7469  tive camera moti
+00011de0: 6f6e 0a20 2020 2020 2020 203a 7479 7065  on.        :type
+00011df0: 2054 3a20 3a63 6c61 7373 3a60 7e73 7061   T: :class:`~spa
+00011e00: 7469 616c 6d61 7468 2e2e 706f 7365 3364  tialmath..pose3d
+00011e10: 2e53 4533 600a 2020 2020 2020 2020 3a70  .SE3`.        :p
+00011e20: 6172 616d 206e 3a20 706c 616e 6520 6e6f  aram n: plane no
+00011e30: 726d 616c 2077 6974 6820 7265 7370 6563  rmal with respec
+00011e40: 7420 746f 2077 6f72 6c64 2066 7261 6d65  t to world frame
+00011e50: 0a20 2020 2020 2020 203a 7479 7065 206e  .        :type n
+00011e60: 3a20 6172 7261 795f 6c69 6b65 2833 290a  : array_like(3).
+00011e70: 2020 2020 2020 2020 3a70 6172 616d 2064          :param d
+00011e80: 3a20 706c 616e 6520 6f66 6673 6574 2066  : plane offset f
+00011e90: 726f 6d20 776f 726c 6420 6672 616d 6520  rom world frame 
+00011ea0: 6f72 6967 696e 0a20 2020 2020 2020 203a  origin.        :
+00011eb0: 7479 7065 2064 3a20 666c 6f61 740a 2020  type d: float.  
+00011ec0: 2020 2020 2020 3a72 6574 7572 6e3a 2068        :return: h
+00011ed0: 6f6d 6f67 7261 7068 7920 6d61 7472 6978  omography matrix
+00011ee0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+00011ef0: 206e 6461 7272 6179 2833 2c33 290a 0a20   ndarray(3,3).. 
+00011f00: 2020 2020 2020 2043 6f6d 7075 7465 7320         Computes 
+00011f10: 7468 6520 686f 6d6f 6772 6170 6879 206d  the homography m
+00011f20: 6174 7269 7820 666f 7220 7468 6520 6361  atrix for the ca
+00011f30: 6d65 7261 206f 6273 6572 7669 6e67 2070  mera observing p
+00011f40: 6f69 6e74 7320 6f6e 2061 0a20 2020 2020  oints on a.     
+00011f50: 2020 2070 6c61 6e65 2066 726f 6d20 7477     plane from tw
+00011f60: 6f20 7669 6577 706f 696e 7473 2e20 5468  o viewpoints. Th
+00011f70: 6520 6669 7273 7420 7669 6577 2069 7320  e first view is 
+00011f80: 6672 6f6d 2074 6865 2063 7572 7265 6e74  from the current
+00011f90: 2063 616d 6572 610a 2020 2020 2020 2020   camera.        
+00011fa0: 706f 7365 2028 6060 7365 6c66 2e70 6f73  pose (``self.pos
+00011fb0: 6560 6029 2c20 616e 6420 7468 6520 7365  e``), and the se
+00011fc0: 636f 6e64 2069 7320 6166 7465 7220 6120  cond is after a 
+00011fd0: 7265 6c61 7469 7665 206d 6f74 696f 6e0a  relative motion.
+00011fe0: 2020 2020 2020 2020 7265 7072 6573 656e          represen
+00011ff0: 7465 6420 6279 2074 6865 2072 6967 6964  ted by the rigid
+00012000: 2d62 6f64 7920 6d6f 7469 6f6e 2060 6054  -body motion ``T
+00012010: 6060 2e20 5468 6520 706c 616e 6520 6861  ``. The plane ha
+00012020: 7320 6e6f 726d 616c 2060 606e 6060 0a20  s normal ``n``. 
+00012030: 2020 2020 2020 2061 6e64 2061 7420 6469         and at di
+00012040: 7374 616e 6365 2060 6064 6060 2077 6974  stance ``d`` wit
+00012050: 6820 7265 7370 6563 7420 746f 2074 6865  h respect to the
+00012060: 2077 6f72 6c64 2066 7261 6d65 2e0a 0a20   world frame... 
+00012070: 2020 2020 2020 2045 7861 6d70 6c65 3a0a         Example:.
+00012080: 0a20 2020 2020 2020 202e 2e20 7275 6e62  .        .. runb
+00012090: 6c6f 636b 3a3a 2070 7963 6f6e 0a0a 2020  lock:: pycon..  
+000120a0: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
+000120b0: 6f6d 206d 6163 6869 6e65 7669 7369 6f6e  om machinevision
+000120c0: 746f 6f6c 626f 7820 696d 706f 7274 2043  toolbox import C
+000120d0: 656e 7472 616c 4361 6d65 7261 0a20 2020  entralCamera.   
+000120e0: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
+000120f0: 6d20 7370 6174 6961 6c6d 6174 6820 696d  m spatialmath im
+00012100: 706f 7274 2053 4533 0a20 2020 2020 2020  port SE3.       
+00012110: 2020 2020 203e 3e3e 2063 616d 6572 6120       >>> camera 
+00012120: 3d20 4365 6e74 7261 6c43 616d 6572 612e  = CentralCamera.
+00012130: 4465 6661 756c 7428 6e61 6d65 3d27 6361  Default(name='ca
+00012140: 6d65 7261 3127 2920 2320 6c6f 6f6b 696e  mera1') # lookin
+00012150: 6720 616c 6f6e 6720 7a2d 6178 6973 0a20  g along z-axis. 
+00012160: 2020 2020 2020 2020 2020 203e 3e3e 2070             >>> p
+00012170: 6c61 6e65 203d 205b 302c 2031 2c20 315d  lane = [0, 1, 1]
+00012180: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00012190: 2048 203d 2063 616d 6572 612e 4828 5345   H = camera.H(SE
+000121a0: 332e 5478 2830 2e32 292c 2070 6c61 6e65  3.Tx(0.2), plane
+000121b0: 2c20 3529 0a20 2020 2020 2020 2020 2020  , 5).           
+000121c0: 203e 3e3e 2048 0a0a 2020 2020 2020 2020   >>> H..        
+000121d0: 3a73 6565 616c 736f 3a20 3a6d 6574 683a  :seealso: :meth:
+000121e0: 6070 6f69 6e74 7332 4860 203a 6d65 7468  `points2H` :meth
+000121f0: 3a60 6465 636f 6d70 6f73 6548 600a 2020  :`decomposeH`.  
+00012200: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00012210: 2020 6966 2064 203c 2030 3a0a 2020 2020    if d < 0:.    
+00012220: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00012230: 6c75 6545 7272 6f72 2864 2c20 2270 6c61  lueError(d, "pla
+00012240: 6e65 2064 6973 7461 6e63 6520 6420 6d75  ne distance d mu
+00012250: 7374 2062 6520 3e20 3022 290a 0a20 2020  st be > 0")..   
+00012260: 2020 2020 206e 203d 2062 6173 652e 6765       n = base.ge
+00012270: 7476 6563 746f 7228 6e29 0a20 2020 2020  tvector(n).     
+00012280: 2020 2069 6620 6e5b 325d 203c 2030 3a0a     if n[2] < 0:.
+00012290: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+000122a0: 6520 5661 6c75 6545 7272 6f72 286e 2c20  e ValueError(n, 
+000122b0: 226e 6f72 6d61 6c20 6d75 7374 2062 6520  "normal must be 
+000122c0: 6177 6179 2066 726f 6d20 6361 6d65 7261  away from camera
+000122d0: 2028 6e5b 325d 203e 3d20 3029 2229 0a0a   (n[2] >= 0)")..
+000122e0: 2020 2020 2020 2020 2320 5420 7472 616e          # T tran
+000122f0: 7366 6f72 6d20 7669 6577 2031 2074 6f20  sform view 1 to 
+00012300: 7669 6577 2032 0a20 2020 2020 2020 2054  view 2.        T
+00012310: 203d 2053 4533 2854 292e 696e 7628 290a   = SE3(T).inv().
+00012320: 0a20 2020 2020 2020 2048 4820 3d20 542e  .        HH = T.
+00012330: 5220 2b20 312e 3020 2f20 6420 2a20 542e  R + 1.0 / d * T.
+00012340: 7420 4020 6e20 2023 206e 6565 6420 746f  t @ n  # need to
+00012350: 2065 6e73 7572 6520 636f 6c75 6d6e 2074   ensure column t
+00012360: 6865 6e20 726f 7720 3d20 3378 330a 0a20  hen row = 3x3.. 
+00012370: 2020 2020 2020 2023 2061 7070 6c79 2063         # apply c
+00012380: 616d 6572 6120 696e 7472 696e 7369 6373  amera intrinsics
+00012390: 0a20 2020 2020 2020 2048 4820 3d20 7365  .        HH = se
+000123a0: 6c66 2e4b 2040 2048 4820 4020 6e70 2e6c  lf.K @ HH @ np.l
+000123b0: 696e 616c 672e 696e 7628 7365 6c66 2e4b  inalg.inv(self.K
+000123c0: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+000123d0: 6e20 4848 202f 2048 485b 322c 2032 5d20  n HH / HH[2, 2] 
+000123e0: 2023 206e 6f72 6d61 6c69 7365 640a 0a20   # normalised.. 
+000123f0: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
+00012400: 0a20 2020 2064 6566 2070 6f69 6e74 7332  .    def points2
+00012410: 4828 7031 2c20 7032 2c20 6d65 7468 6f64  H(p1, p2, method
+00012420: 3d22 6c65 6173 7473 7175 6172 6573 222c  ="leastsquares",
+00012430: 2073 6565 643d 4e6f 6e65 2c20 2a2a 6b77   seed=None, **kw
+00012440: 6172 6773 293a 0a20 2020 2020 2020 2022  args):.        "
+00012450: 2222 0a20 2020 2020 2020 2045 7374 696d  "".        Estim
+00012460: 6174 6520 686f 6d6f 6772 6170 6879 2066  ate homography f
+00012470: 726f 6d20 636f 7272 6573 706f 6e64 696e  rom correspondin
+00012480: 6720 706f 696e 7473 0a0a 2020 2020 2020  g points..      
+00012490: 2020 3a70 6172 616d 2070 313a 2069 6d61    :param p1: ima
+000124a0: 6765 2070 6c61 6e65 2070 6f69 6e74 7320  ge plane points 
+000124b0: 6672 6f6d 2066 6972 7374 2063 616d 6572  from first camer
+000124c0: 610a 2020 2020 2020 2020 3a74 7970 6520  a.        :type 
+000124d0: 7031 3a20 6e64 6172 7261 7928 322c 4e29  p1: ndarray(2,N)
+000124e0: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+000124f0: 7032 3a20 696d 6167 6520 706c 616e 6520  p2: image plane 
+00012500: 706f 696e 7473 2066 726f 6d20 7365 636f  points from seco
+00012510: 6e64 2063 616d 6572 610a 2020 2020 2020  nd camera.      
+00012520: 2020 3a74 7970 6520 7032 3a20 6e64 6172    :type p2: ndar
+00012530: 7261 7928 322c 4e29 0a20 2020 2020 2020  ray(2,N).       
+00012540: 203a 7061 7261 6d20 6d65 7468 6f64 3a20   :param method: 
+00012550: 616c 676f 7269 7468 6d3a 2027 6c65 6173  algorithm: 'leas
+00012560: 7473 7175 6172 6573 2720 5b64 6566 6175  tsquares' [defau
+00012570: 6c74 5d2c 2027 7261 6e73 6163 272c 2027  lt], 'ransac', '
+00012580: 6c6d 6564 7327 2c20 2770 726f 7361 6327  lmeds', 'prosac'
+00012590: 0a20 2020 2020 2020 203a 7479 7065 206d  .        :type m
+000125a0: 6574 686f 643a 2073 7472 0a20 2020 2020  ethod: str.     
+000125b0: 2020 203a 7061 7261 6d20 6b77 6172 6773     :param kwargs
+000125c0: 3a20 6f70 7469 6f6e 616c 2061 7267 756d  : optional argum
+000125d0: 656e 7473 2061 7320 7265 7175 6972 6564  ents as required
+000125e0: 2066 6f72 2072 616e 7361 6327 2061 6e64   for ransac' and
+000125f0: 2027 6c6d 6564 7327 0a20 2020 2020 2020   'lmeds'.       
+00012600: 2020 2020 206d 6574 686f 6473 0a20 2020       methods.   
+00012610: 2020 2020 203a 7265 7475 726e 3a20 686f       :return: ho
+00012620: 6d6f 6772 6170 6879 2c20 7265 7369 6475  mography, residu
+00012630: 616c 2061 6e64 206f 7074 696f 6e61 6c20  al and optional 
+00012640: 696e 6c69 6572 730a 2020 2020 2020 2020  inliers.        
+00012650: 3a72 7479 7065 3a20 6e64 6172 7261 7928  :rtype: ndarray(
+00012660: 332c 3329 2c20 666c 6f61 742c 206e 6461  3,3), float, nda
+00012670: 7272 6179 284e 2c62 6f6f 6c29 0a0a 2020  rray(N,bool)..  
+00012680: 2020 2020 2020 436f 6d70 7574 6520 6120        Compute a 
+00012690: 686f 6d6f 6772 6170 6879 2066 726f 6d20  homography from 
+000126a0: 7477 6f20 7365 7473 206f 6620 636f 7272  two sets of corr
+000126b0: 6573 706f 6e64 696e 6720 696d 6167 6520  esponding image 
+000126c0: 706c 616e 6520 706f 696e 7473 0a20 2020  plane points.   
+000126d0: 2020 2020 2077 686f 7365 2077 6f72 6c64       whose world
+000126e0: 2070 6f69 6e74 7320 6c69 6520 6f6e 2061   points lie on a
+000126f0: 2070 6c61 6e65 2e0a 0a20 2020 2020 2020   plane...       
+00012700: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
+00012710: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
+00012720: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
+00012730: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
+00012740: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
+00012750: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
+00012760: 4361 6d65 7261 2c20 6d6b 6772 6964 0a20  Camera, mkgrid. 
+00012770: 2020 2020 2020 2020 2020 203e 3e3e 2066             >>> f
+00012780: 726f 6d20 7370 6174 6961 6c6d 6174 6820  rom spatialmath 
+00012790: 696d 706f 7274 2053 4533 0a20 2020 2020  import SE3.     
+000127a0: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+000127b0: 6131 203d 2043 656e 7472 616c 4361 6d65  a1 = CentralCame
+000127c0: 7261 286e 616d 653d 2263 616d 6572 6120  ra(name="camera 
+000127d0: 3122 2c20 663d 302e 3030 322c 2069 6d61  1", f=0.002, ima
+000127e0: 6765 7369 7a65 3d31 3030 302c 2072 686f  gesize=1000, rho
+000127f0: 3d31 3065 2d36 2c20 706f 7365 3d53 4533  =10e-6, pose=SE3
+00012800: 2e54 7828 2d30 2e31 292a 5345 332e 5279  .Tx(-0.1)*SE3.Ry
+00012810: 2830 2e34 2929 0a20 2020 2020 2020 2020  (0.4)).         
+00012820: 2020 203e 3e3e 2063 616d 6572 6132 203d     >>> camera2 =
+00012830: 2043 656e 7472 616c 4361 6d65 7261 286e   CentralCamera(n
+00012840: 616d 653d 2263 616d 6572 6120 3222 2c20  ame="camera 2", 
+00012850: 663d 302e 3030 322c 2069 6d61 6765 7369  f=0.002, imagesi
+00012860: 7a65 3d31 3030 302c 2072 686f 3d31 3065  ze=1000, rho=10e
+00012870: 2d36 2c20 706f 7365 3d53 4533 2e54 7828  -6, pose=SE3.Tx(
+00012880: 302e 3129 2a53 4533 2e52 7928 2d30 2e34  0.1)*SE3.Ry(-0.4
+00012890: 2929 0a20 2020 2020 2020 2020 2020 203e  )).            >
+000128a0: 3e3e 2054 5f67 7269 6420 3d20 5345 332e  >> T_grid = SE3.
+000128b0: 547a 2831 2920 2a20 5345 332e 5278 2830  Tz(1) * SE3.Rx(0
+000128c0: 2e31 2920 2a20 5345 332e 5279 2830 2e32  .1) * SE3.Ry(0.2
+000128d0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+000128e0: 3e20 5020 3d20 6d6b 6772 6964 2833 2c20  > P = mkgrid(3, 
+000128f0: 312e 302c 2070 6f73 653d 545f 6772 6964  1.0, pose=T_grid
+00012900: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+00012910: 3e20 7031 203d 2063 616d 6572 6131 2e70  > p1 = camera1.p
+00012920: 726f 6a65 6374 5f70 6f69 6e74 2850 290a  roject_point(P).
+00012930: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00012940: 7032 203d 2063 616d 6572 6132 2e70 726f  p2 = camera2.pro
+00012950: 6a65 6374 5f70 6f69 6e74 2850 293b 0a20  ject_point(P);. 
+00012960: 2020 2020 2020 2020 2020 203e 3e3e 2048             >>> H
+00012970: 2c20 7265 7369 6420 3d20 4365 6e74 7261  , resid = Centra
+00012980: 6c43 616d 6572 612e 706f 696e 7473 3248  lCamera.points2H
+00012990: 2870 312c 2070 3229 0a20 2020 2020 2020  (p1, p2).       
+000129a0: 2020 2020 203e 3e3e 2048 0a20 2020 2020       >>> H.     
+000129b0: 2020 2020 2020 203e 3e3e 2072 6573 6964         >>> resid
+000129c0: 0a0a 2020 2020 2020 2020 3a6e 6f74 653a  ..        :note:
+000129d0: 2049 6620 7468 6520 6d65 7468 6f64 2069   If the method i
+000129e0: 7320 2772 616e 7361 6327 206f 7220 276c  s 'ransac' or 'l
+000129f0: 6d65 6473 2720 7468 656e 2061 2062 6f6f  meds' then a boo
+00012a00: 6c65 616e 2061 7272 6179 0a20 2020 2020  lean array.     
+00012a10: 2020 2020 2020 206f 6620 696e 6c69 6572         of inlier
+00012a20: 7320 6973 2061 6c73 6f20 7265 7475 726e  s is also return
+00012a30: 6564 2c20 5472 7565 206d 6561 6e73 2074  ed, True means t
+00012a40: 6865 2063 6f72 7265 7370 6f6e 6469 6e67  he corresponding
+00012a50: 2069 6e70 7574 0a20 2020 2020 2020 2020   input.         
+00012a60: 2020 2070 6f69 6e74 2070 6169 7220 6973     point pair is
+00012a70: 2061 6e20 696e 6c69 6572 2e0a 0a20 2020   an inlier...   
+00012a80: 2020 2020 203a 7265 6665 7265 6e63 653a       :reference:
+00012a90: 0a20 2020 2020 2020 2020 2020 202d 2052  .            - R
+00012aa0: 6f62 6f74 6963 732c 2056 6973 696f 6e20  obotics, Vision 
+00012ab0: 2620 436f 6e74 726f 6c20 666f 7220 5079  & Control for Py
+00012ac0: 7468 6f6e 2c20 5365 6374 696f 6e20 3134  thon, Section 14
+00012ad0: 2e32 2e34 2c20 502e 2043 6f72 6b65 2c0a  .2.4, P. Corke,.
+00012ae0: 2020 2020 2020 2020 2020 2020 2020 5370                Sp
+00012af0: 7269 6e67 6572 2032 3032 332e 0a0a 2020  ringer 2023...  
+00012b00: 2020 2020 2020 3a73 6565 616c 736f 3a20        :seealso: 
+00012b10: 3a6d 6574 683a 6048 6020 3a6d 6574 683a  :meth:`H` :meth:
+00012b20: 6064 6563 6f6d 706f 7365 4860 0a20 2020  `decomposeH`.   
+00012b30: 2020 2020 2020 2020 2060 6f70 656e 6376           `opencv
+00012b40: 2e66 696e 6448 6f6d 6f67 7261 7068 7920  .findHomography 
+00012b50: 3c68 7474 7073 3a2f 2f64 6f63 732e 6f70  <https://docs.op
+00012b60: 656e 6376 2e6f 7267 2f6d 6173 7465 722f  encv.org/master/
+00012b70: 6439 2f64 3063 2f67 726f 7570 5f5f 6361  d9/d0c/group__ca
+00012b80: 6c69 6233 642e 6874 6d6c 2367 6134 6162  lib3d.html#ga4ab
+00012b90: 6332 6563 6539 6661 6239 3339 3866 3265  c2ece9fab9398f2e
+00012ba0: 3536 3064 3533 6338 6339 3738 303e 605f  560d53c8c9780>`_
+00012bb0: 0a20 2020 2020 2020 2022 2222 0a0a 2020  .        """..  
+00012bc0: 2020 2020 2020 706f 696e 7473 3248 5f64        points2H_d
+00012bd0: 6963 7420 3d20 7b0a 2020 2020 2020 2020  ict = {.        
+00012be0: 2020 2020 226c 6561 7374 7371 7561 7265      "leastsquare
+00012bf0: 7322 3a20 302c 0a20 2020 2020 2020 2020  s": 0,.         
+00012c00: 2020 2022 7261 6e73 6163 223a 2063 762e     "ransac": cv.
+00012c10: 5241 4e53 4143 2c0a 2020 2020 2020 2020  RANSAC,.        
+00012c20: 2020 2020 226c 6d65 6473 223a 2063 762e      "lmeds": cv.
+00012c30: 4c4d 4544 532c 0a20 2020 2020 2020 2020  LMEDS,.         
+00012c40: 2020 2022 7072 6f73 6163 223a 2063 762e     "prosac": cv.
+00012c50: 5248 4f2c 0a20 2020 2020 2020 207d 0a20  RHO,.        }. 
+00012c60: 2020 2020 2020 2069 6620 7365 6564 2069         if seed i
+00012c70: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00012c80: 2020 2020 2020 2020 6376 2e73 6574 524e          cv.setRN
+00012c90: 4753 6565 6428 7365 6564 290a 0a20 2020  GSeed(seed)..   
+00012ca0: 2020 2020 2048 2c20 6d61 736b 203d 2063       H, mask = c
+00012cb0: 762e 6669 6e64 486f 6d6f 6772 6170 6879  v.findHomography
+00012cc0: 280a 2020 2020 2020 2020 2020 2020 7372  (.            sr
+00012cd0: 6350 6f69 6e74 733d 7031 2e54 2c20 6473  cPoints=p1.T, ds
+00012ce0: 7450 6f69 6e74 733d 7032 2e54 2c20 6d65  tPoints=p2.T, me
+00012cf0: 7468 6f64 3d70 6f69 6e74 7332 485f 6469  thod=points2H_di
+00012d00: 6374 5b6d 6574 686f 645d 2c20 2a2a 6b77  ct[method], **kw
+00012d10: 6172 6773 0a20 2020 2020 2020 2029 0a0a  args.        )..
+00012d20: 2020 2020 2020 2020 6d61 736b 203d 206d          mask = m
+00012d30: 6173 6b2e 7261 7665 6c28 292e 6173 7479  ask.ravel().asty
+00012d40: 7065 2862 6f6f 6c29 0a20 2020 2020 2020  pe(bool).       
+00012d50: 2065 203d 2062 6173 652e 686f 6d74 7261   e = base.homtra
+00012d60: 6e73 2848 2c20 7031 5b3a 2c20 6d61 736b  ns(H, p1[:, mask
+00012d70: 5d29 202d 2070 325b 3a2c 206d 6173 6b5d  ]) - p2[:, mask]
+00012d80: 0a20 2020 2020 2020 2072 6573 6964 203d  .        resid =
+00012d90: 206e 702e 6c69 6e61 6c67 2e6e 6f72 6d28   np.linalg.norm(
+00012da0: 6529 0a0a 2020 2020 2020 2020 6966 206d  e)..        if m
+00012db0: 6574 686f 6420 696e 2028 2272 616e 7361  ethod in ("ransa
+00012dc0: 6322 2c20 226c 6d65 6473 2229 3a0a 2020  c", "lmeds"):.  
+00012dd0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00012de0: 2048 2c20 7265 7369 642c 206d 6173 6b0a   H, resid, mask.
+00012df0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00012e00: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00012e10: 2048 2c20 7265 7369 640a 0a20 2020 2023   H, resid..    #
+00012e20: 2068 7474 7073 3a2f 2f64 6f63 732e 6f70   https://docs.op
+00012e30: 656e 6376 2e6f 7267 2f33 2e31 2e30 2f64  encv.org/3.1.0/d
+00012e40: 392f 6430 632f 6772 6f75 705f 5f63 616c  9/d0c/group__cal
+00012e50: 6962 3364 2e68 746d 6c23 6761 3766 3630  ib3d.html#ga7f60
+00012e60: 6264 6666 3738 3833 3364 3165 3366 6436  bdff78833d1e3fd6
+00012e70: 6439 6430 6664 3533 3864 3932 0a20 2020  d9d0fd538d92.   
+00012e80: 2064 6566 2064 6563 6f6d 706f 7365 4828   def decomposeH(
+00012e90: 7365 6c66 2c20 482c 204b 3d4e 6f6e 6529  self, H, K=None)
+00012ea0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00012eb0: 2020 2020 2020 4465 636f 6d70 6f73 6520        Decompose 
+00012ec0: 686f 6d6f 6772 6170 6879 206d 6174 7269  homography matri
+00012ed0: 780a 0a20 2020 2020 2020 203a 7061 7261  x..        :para
+00012ee0: 6d20 483a 2068 6f6d 6f67 7261 7068 7920  m H: homography 
+00012ef0: 6d61 7472 6978 0a20 2020 2020 2020 203a  matrix.        :
+00012f00: 7479 7065 2048 3a20 6e64 6172 7261 7928  type H: ndarray(
+00012f10: 332c 3329 0a20 2020 2020 2020 203a 7061  3,3).        :pa
+00012f20: 7261 6d20 4b3a 2063 616d 6572 6120 696e  ram K: camera in
+00012f30: 7472 696e 7369 6373 2c20 6465 6661 756c  trinsics, defaul
+00012f40: 7473 2074 6f20 7061 7261 6d65 7465 7273  ts to parameters
+00012f50: 2066 726f 6d20 6f62 6a65 6374 0a20 2020   from object.   
+00012f60: 2020 2020 203a 7479 7065 204b 3a20 6e64       :type K: nd
+00012f70: 6172 7261 7928 332c 3329 2c20 6f70 7469  array(3,3), opti
+00012f80: 6f6e 616c 0a20 2020 2020 2020 203a 7265  onal.        :re
+00012f90: 7475 726e 3a20 6361 6d65 7261 2070 6f73  turn: camera pos
+00012fa0: 6573 2c20 706c 616e 6520 6e6f 726d 616c  es, plane normal
+00012fb0: 730a 2020 2020 2020 2020 3a72 7479 7065  s.        :rtype
+00012fc0: 3a20 3a63 6c61 7373 3a60 7e73 7061 7469  : :class:`~spati
+00012fd0: 616c 6d61 7468 2e2e 706f 7365 3364 2e53  almath..pose3d.S
+00012fe0: 4533 602c 206c 6973 7420 6f66 206e 6461  E3`, list of nda
+00012ff0: 7272 6179 2833 2c31 290a 0a20 2020 2020  rray(3,1)..     
+00013000: 2020 2044 6563 6f6d 706f 7365 7320 7468     Decomposes th
+00013010: 6520 686f 6d6f 6772 6170 6879 206d 6174  e homography mat
+00013020: 7269 7820 696e 746f 2074 6865 2063 616d  rix into the cam
+00013030: 6572 6120 6d6f 7469 6f6e 2061 6e64 2074  era motion and t
+00013040: 6865 206e 6f72 6d61 6c0a 2020 2020 2020  he normal.      
+00013050: 2020 746f 2074 6865 2070 6c61 6e65 2e20    to the plane. 
+00013060: 496e 2070 7261 6374 6963 652c 2074 6865  In practice, the
+00013070: 7265 2061 7265 206d 756c 7469 706c 6520  re are multiple 
+00013080: 736f 6c75 7469 6f6e 732e 2054 6865 2074  solutions. The t
+00013090: 7261 6e73 6c61 7469 6f6e 0a20 2020 2020  ranslation.     
+000130a0: 2020 206e 6f74 2074 6f20 7363 616c 652e     not to scale.
+000130b0: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
+000130c0: 653a 0a0a 2020 2020 2020 2020 2e2e 2072  e:..        .. r
+000130d0: 756e 626c 6f63 6b3a 3a20 7079 636f 6e0a  unblock:: pycon.
+000130e0: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+000130f0: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
+00013100: 696f 6e74 6f6f 6c62 6f78 2069 6d70 6f72  iontoolbox impor
+00013110: 7420 4365 6e74 7261 6c43 616d 6572 612c  t CentralCamera,
+00013120: 206d 6b67 7269 640a 2020 2020 2020 2020   mkgrid.        
+00013130: 2020 2020 3e3e 3e20 6672 6f6d 2073 7061      >>> from spa
+00013140: 7469 616c 6d61 7468 2069 6d70 6f72 7420  tialmath import 
+00013150: 5345 330a 2020 2020 2020 2020 2020 2020  SE3.            
+00013160: 3e3e 3e20 6361 6d65 7261 3120 3d20 4365  >>> camera1 = Ce
+00013170: 6e74 7261 6c43 616d 6572 6128 6e61 6d65  ntralCamera(name
+00013180: 3d22 6361 6d65 7261 2031 222c 2066 3d30  ="camera 1", f=0
+00013190: 2e30 3032 2c20 696d 6167 6573 697a 653d  .002, imagesize=
+000131a0: 3130 3030 2c20 7268 6f3d 3130 652d 362c  1000, rho=10e-6,
+000131b0: 2070 6f73 653d 5345 332e 5478 282d 302e   pose=SE3.Tx(-0.
+000131c0: 3129 2a53 4533 2e52 7928 302e 3429 290a  1)*SE3.Ry(0.4)).
+000131d0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+000131e0: 6361 6d65 7261 3220 3d20 4365 6e74 7261  camera2 = Centra
+000131f0: 6c43 616d 6572 6128 6e61 6d65 3d22 6361  lCamera(name="ca
+00013200: 6d65 7261 2032 222c 2066 3d30 2e30 3032  mera 2", f=0.002
+00013210: 2c20 696d 6167 6573 697a 653d 3130 3030  , imagesize=1000
+00013220: 2c20 7268 6f3d 3130 652d 362c 2070 6f73  , rho=10e-6, pos
+00013230: 653d 5345 332e 5478 2830 2e31 292a 5345  e=SE3.Tx(0.1)*SE
+00013240: 332e 5279 282d 302e 3429 290a 2020 2020  3.Ry(-0.4)).    
+00013250: 2020 2020 2020 2020 3e3e 3e20 545f 6772          >>> T_gr
+00013260: 6964 203d 2053 4533 2e54 7a28 3129 202a  id = SE3.Tz(1) *
+00013270: 2053 4533 2e52 7828 302e 3129 202a 2053   SE3.Rx(0.1) * S
+00013280: 4533 2e52 7928 302e 3229 0a20 2020 2020  E3.Ry(0.2).     
+00013290: 2020 2020 2020 203e 3e3e 2050 203d 206d         >>> P = m
+000132a0: 6b67 7269 6428 332c 2031 2e30 2c20 706f  kgrid(3, 1.0, po
+000132b0: 7365 3d54 5f67 7269 6429 0a20 2020 2020  se=T_grid).     
+000132c0: 2020 2020 2020 203e 3e3e 2070 3120 3d20         >>> p1 = 
+000132d0: 6361 6d65 7261 312e 7072 6f6a 6563 745f  camera1.project_
+000132e0: 706f 696e 7428 5029 0a20 2020 2020 2020  point(P).       
+000132f0: 2020 2020 203e 3e3e 2070 3220 3d20 6361       >>> p2 = ca
+00013300: 6d65 7261 322e 7072 6f6a 6563 745f 706f  mera2.project_po
+00013310: 696e 7428 5029 3b0a 2020 2020 2020 2020  int(P);.        
+00013320: 2020 2020 3e3e 3e20 482c 2072 6573 6964      >>> H, resid
+00013330: 203d 2043 656e 7472 616c 4361 6d65 7261   = CentralCamera
+00013340: 2e70 6f69 6e74 7332 4828 7031 2c20 7032  .points2H(p1, p2
+00013350: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+00013360: 3e20 542c 206e 6f72 6d61 6c73 203d 2063  > T, normals = c
+00013370: 616d 6572 6131 2e64 6563 6f6d 706f 7365  amera1.decompose
+00013380: 4828 4829 0a20 2020 2020 2020 2020 2020  H(H).           
+00013390: 203e 3e3e 2054 2e70 7269 6e74 6c69 6e65   >>> T.printline
+000133a0: 286f 7269 656e 743d 2263 616d 6572 6122  (orient="camera"
+000133b0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+000133c0: 3e20 6e6f 726d 616c 730a 0a20 2020 2020  > normals..     
+000133d0: 2020 203a 7265 6665 7265 6e63 653a 0a20     :reference:. 
+000133e0: 2020 2020 2020 2020 2020 202d 2052 6f62             - Rob
+000133f0: 6f74 6963 732c 2056 6973 696f 6e20 2620  otics, Vision & 
+00013400: 436f 6e74 726f 6c20 666f 7220 5079 7468  Control for Pyth
+00013410: 6f6e 2c20 5365 6374 696f 6e20 3134 2e32  on, Section 14.2
+00013420: 2e34 2c20 502e 2043 6f72 6b65 2c0a 2020  .4, P. Corke,.  
+00013430: 2020 2020 2020 2020 2020 2020 5370 7269              Spri
+00013440: 6e67 6572 2032 3032 332e 0a0a 2020 2020  nger 2023...    
+00013450: 2020 2020 3a73 6565 616c 736f 3a20 3a6d      :seealso: :m
+00013460: 6574 683a 6070 6f69 6e74 7332 4860 203a  eth:`points2H` :
+00013470: 6d65 7468 3a60 4860 0a20 2020 2020 2020  meth:`H`.       
+00013480: 2020 2020 2060 6f70 656e 6376 2e64 6563       `opencv.dec
+00013490: 6f6d 706f 7365 486f 6d6f 6772 6170 6879  omposeHomography
+000134a0: 4d61 7420 3c68 7474 7073 3a2f 2f64 6f63  Mat <https://doc
+000134b0: 732e 6f70 656e 6376 2e6f 7267 2f33 2e34  s.opencv.org/3.4
+000134c0: 2f64 392f 6430 632f 6772 6f75 705f 5f63  /d9/d0c/group__c
+000134d0: 616c 6962 3364 2e68 746d 6c23 6761 3766  alib3d.html#ga7f
+000134e0: 3630 6264 6666 3738 3833 3364 3165 3366  60bdff78833d1e3f
+000134f0: 6436 6439 6430 6664 3533 3864 3932 3e60  d6d9d0fd538d92>`
+00013500: 5f0a 2020 2020 2020 2020 2222 220a 0a20  _.        """.. 
+00013510: 2020 2020 2020 2072 6574 7661 6c2c 2072         retval, r
+00013520: 6f74 6174 696f 6e73 2c20 7472 616e 736c  otations, transl
+00013530: 6174 696f 6e73 2c20 6e6f 726d 616c 7320  ations, normals 
+00013540: 3d20 6376 2e64 6563 6f6d 706f 7365 486f  = cv.decomposeHo
+00013550: 6d6f 6772 6170 6879 4d61 7428 482c 2073  mographyMat(H, s
+00013560: 656c 662e 4b29 0a0a 2020 2020 2020 2020  elf.K)..        
+00013570: 5420 3d20 5345 332e 456d 7074 7928 290a  T = SE3.Empty().
+00013580: 2020 2020 2020 2020 666f 7220 522c 2074          for R, t
+00013590: 2069 6e20 7a69 7028 726f 7461 7469 6f6e   in zip(rotation
+000135a0: 732c 2074 7261 6e73 6c61 7469 6f6e 7329  s, translations)
+000135b0: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+000135c0: 7765 206e 6f72 6d61 6c69 7a65 2074 6865  we normalize the
+000135d0: 2072 6f74 6174 696f 6e20 6d61 7472 6978   rotation matrix
+000135e0: 2c20 7468 6f73 6520 7265 7475 726e 6564  , those returned
+000135f0: 2062 7920 6f70 656e 4356 2063 616e 0a20   by openCV can. 
+00013600: 2020 2020 2020 2020 2020 2023 206e 6f74             # not
+00013610: 2071 7569 7465 2070 726f 7065 7220 534f   quite proper SO
+00013620: 2833 2920 7661 6c75 6573 0a20 2020 2020  (3) values.     
+00013630: 2020 2020 2020 2070 6f73 6520 3d20 5345         pose = SE
+00013640: 332e 5274 2873 6d62 6173 652e 7472 6e6f  3.Rt(smbase.trno
+00013650: 726d 2852 292c 2074 292e 696e 7628 290a  rm(R), t).inv().
+00013660: 2020 2020 2020 2020 2020 2020 542e 6170              T.ap
+00013670: 7065 6e64 2870 6f73 6529 0a20 2020 2020  pend(pose).     
+00013680: 2020 2072 6574 7572 6e20 542c 206e 6f72     return T, nor
+00013690: 6d61 6c73 0a0a 2020 2020 2020 2020 2320  mals..        # 
+000136a0: 6966 204b 2069 7320 4e6f 6e65 3a0a 2020  if K is None:.  
+000136b0: 2020 2020 2020 2320 2020 2020 4b20 3d20        #     K = 
+000136c0: 6e70 2e69 6465 6e74 6974 7928 3329 0a20  np.identity(3). 
+000136d0: 2020 2020 2020 2023 2020 2020 2023 2061         #     # a
+000136e0: 6c73 6f20 6861 7665 204b 203d 2073 656c  lso have K = sel
+000136f0: 662e 4b0a 0a20 2020 2020 2020 2023 2048  f.K..        # H
+00013700: 203d 206e 702e 6c69 6e61 6c67 2e69 6e76   = np.linalg.inv
+00013710: 284b 2920 4020 4820 4020 4b0a 0a20 2020  (K) @ H @ K..   
+00013720: 2020 2020 2023 2023 206e 6f72 6d61 6c69       # # normali
+00013730: 7365 2073 6f20 7468 6174 2074 6865 2073  se so that the s
+00013740: 6563 6f6e 6420 7369 6e67 756c 6172 2076  econd singular v
+00013750: 616c 7565 2069 7320 6f6e 650a 2020 2020  alue is one.    
+00013760: 2020 2020 2320 552c 2053 2c20 5620 3d20      # U, S, V = 
+00013770: 6e70 2e6c 696e 616c 672e 7376 6428 482c  np.linalg.svd(H,
+00013780: 2063 6f6d 7075 7465 5f75 763d 5472 7565   compute_uv=True
+00013790: 290a 2020 2020 2020 2020 2320 4820 3d20  ).        # H = 
+000137a0: 4820 2f20 535b 315d 0a0a 2020 2020 2020  H / S[1]..      
+000137b0: 2020 2320 2320 636f 6d70 7574 6520 7468    # # compute th
+000137c0: 6520 5356 4420 6f66 2074 6865 2073 796d  e SVD of the sym
+000137d0: 6d65 7472 6963 206d 6174 7269 7820 4827  metric matrix H'
+000137e0: 2a48 203d 2056 5356 270a 2020 2020 2020  *H = VSV'.      
+000137f0: 2020 2320 552c 2053 2c20 5620 3d20 6e70    # U, S, V = np
+00013800: 2e6c 696e 616c 672e 7376 6428 6e70 2e74  .linalg.svd(np.t
+00013810: 7261 6e73 706f 7365 2848 2920 4020 4829  ranspose(H) @ H)
+00013820: 0a0a 2020 2020 2020 2020 2320 2320 656e  ..        # # en
+00013830: 7375 7265 2056 2069 7320 7269 6768 742d  sure V is right-
+00013840: 6861 6e64 6564 0a20 2020 2020 2020 2023  handed.        #
+00013850: 2069 6620 6e70 2e6c 696e 616c 672e 6465   if np.linalg.de
+00013860: 7428 5629 203c 2030 3a0a 2020 2020 2020  t(V) < 0:.      
+00013870: 2020 2320 2020 2020 7072 696e 7428 2764    #     print('d
+00013880: 6574 2856 2920 7761 7320 3c20 3027 290a  et(V) was < 0').
+00013890: 2020 2020 2020 2020 2320 2020 2020 5620          #     V 
+000138a0: 3d20 2d56 0a0a 2020 2020 2020 2020 2320  = -V..        # 
+000138b0: 2320 6765 7420 7371 7561 7265 6420 7369  # get squared si
+000138c0: 6e67 756c 6172 2076 616c 7565 730a 2020  ngular values.  
+000138d0: 2020 2020 2020 2320 7330 203d 2053 5b30        # s0 = S[0
+000138e0: 5d0a 2020 2020 2020 2020 2320 7332 203d  ].        # s2 =
+000138f0: 2053 5b32 5d0a 0a20 2020 2020 2020 2023   S[2]..        #
+00013900: 2023 2076 3020 3d20 565b 303a 2c20 305d   # v0 = V[0:, 0]
+00013910: 0a20 2020 2020 2020 2023 2023 2076 3120  .        # # v1 
+00013920: 3d20 565b 303a 2c20 315d 0a20 2020 2020  = V[0:, 1].     
+00013930: 2020 2023 2023 2076 3220 3d20 565b 303a     # # v2 = V[0:
+00013940: 2c20 325d 0a0a 2020 2020 2020 2020 2320  , 2]..        # 
+00013950: 2320 7075 7265 2072 6f74 6174 696f 6e20  # pure rotation 
+00013960: 2d20 7768 6572 6520 616c 6c20 7369 6e67  - where all sing
+00013970: 756c 6172 2076 616c 7565 7320 3d3d 2031  ular values == 1
+00013980: 0a20 2020 2020 2020 2023 2069 6620 6e70  .        # if np
+00013990: 2e61 6273 2873 3020 2d20 7332 2920 3c20  .abs(s0 - s2) < 
+000139a0: 2831 3030 202a 206e 702e 7370 6163 696e  (100 * np.spacin
+000139b0: 6728 3129 293a 0a20 2020 2020 2020 2023  g(1)):.        #
+000139c0: 2020 2020 2070 7269 6e74 2827 5761 726e       print('Warn
+000139d0: 696e 673a 2048 6f6d 6f67 7261 7068 7920  ing: Homography 
+000139e0: 6475 6520 746f 2070 7572 6520 726f 7461  due to pure rota
+000139f0: 7469 6f6e 2729 0a20 2020 2020 2020 2023  tion').        #
+00013a00: 2020 2020 2069 6620 6e70 2e6c 696e 616c       if np.linal
+00013a10: 672e 6465 7428 4829 203c 2030 3a0a 2020  g.det(H) < 0:.  
+00013a20: 2020 2020 2020 2320 2020 2020 2020 2020        #         
+00013a30: 4820 3d20 2d48 0a20 2020 2020 2020 2023  H = -H.        #
+00013a40: 2020 2020 2023 2073 6f6c 203d 206e 616d       # sol = nam
+00013a50: 6564 7475 706c 6528 2754 272c 2054 2c20  edtuple('T', T, 
+00013a60: 2727 0a20 2020 2020 2020 2023 2023 2054  ''.        # # T
+00013a70: 4f44 4f20 6669 6e69 7368 2066 726f 6d20  ODO finish from 
+00013a80: 696e 7668 6f6d 6f67 2e6d 0a20 2020 2020  invhomog.m.     
+00013a90: 2020 2023 2070 7269 6e74 2827 556e 6669     # print('Unfi
+00013aa0: 6e69 7368 6564 2729 0a20 2020 2020 2020  nished').       
+00013ab0: 2023 2072 6574 7572 6e20 4661 6c73 650a   # return False.
+00013ac0: 0a20 2020 2023 203d 3d3d 3d3d 3d3d 3d3d  .    # =========
+00013ad0: 3d3d 3d3d 3d3d 3d3d 3d3d 2066 756e 6461  ========== funda
+00013ae0: 6d65 6e74 616c 206d 6174 7269 7820 3d3d  mental matrix ==
+00013af0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00013b00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 230a  ============= #.
+00013b10: 0a20 2020 2064 6566 2046 2873 656c 662c  .    def F(self,
+00013b20: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
+00013b30: 2022 2222 0a20 2020 2020 2020 2046 756e   """.        Fun
+00013b40: 6461 6d65 6e74 616c 206d 6174 7269 780a  damental matrix.
+00013b50: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+00013b60: 6f74 6865 723a 2073 6563 6f6e 6420 6361  other: second ca
+00013b70: 6d65 7261 2076 6965 770a 2020 2020 2020  mera view.      
+00013b80: 2020 3a74 7970 6520 6f74 6865 723a 203a    :type other: :
+00013b90: 636c 6173 733a 6043 656e 7472 616c 4361  class:`CentralCa
+00013ba0: 6d65 7261 602c 203a 636c 6173 733a 607e  mera`, :class:`~
+00013bb0: 7370 6174 6961 6c6d 6174 682e 2e70 6f73  spatialmath..pos
+00013bc0: 6533 642e 5345 3360 0a20 2020 2020 2020  e3d.SE3`.       
+00013bd0: 203a 7265 7475 726e 3a20 6675 6e64 616d   :return: fundam
+00013be0: 656e 7461 6c20 6d61 7472 6978 0a20 2020  ental matrix.   
+00013bf0: 2020 2020 203a 7274 7970 653a 206e 756d       :rtype: num
+00013c00: 7079 2833 2c33 290a 0a20 2020 2020 2020  py(3,3)..       
+00013c10: 2043 6f6d 7075 7465 2074 6865 2066 756e   Compute the fun
+00013c20: 6461 6d65 6e74 616c 206d 6174 7269 7820  damental matrix 
+00013c30: 7265 6c61 7469 6e67 2074 776f 2063 616d  relating two cam
+00013c40: 6572 6120 7669 6577 732e 2020 5468 650a  era views.  The.
+00013c50: 2020 2020 2020 2020 6669 7273 7420 7669          first vi
+00013c60: 6577 2069 7320 6465 6669 6e65 6420 6279  ew is defined by
+00013c70: 2074 6865 2069 6e73 7461 6e63 652e 2020   the instance.  
+00013c80: 5468 6520 7365 636f 6e64 0a20 2020 2020  The second.     
+00013c90: 2020 2069 7320 6465 6669 6e65 6420 6279     is defined by
+00013ca0: 3a0a 0a20 2020 2020 2020 202a 2061 6e6f  :..        * ano
+00013cb0: 7468 6572 203a 636c 6173 733a 6043 656e  ther :class:`Cen
+00013cc0: 7472 616c 4361 6d65 7261 6020 696e 7374  tralCamera` inst
+00013cd0: 616e 6365 0a20 2020 2020 2020 202a 2061  ance.        * a
+00013ce0: 6e20 5345 3320 706f 7365 2064 6573 6372  n SE3 pose descr
+00013cf0: 6962 696e 6720 7468 6520 706f 7365 206f  ibing the pose o
+00013d00: 6620 7468 6520 7365 636f 6e64 2076 6965  f the second vie
+00013d10: 7720 7769 7468 2072 6573 7065 6374 2074  w with respect t
+00013d20: 6f0a 2020 2020 2020 2020 2020 7468 6520  o.          the 
+00013d30: 6669 7273 742c 2061 7373 756d 696e 6720  first, assuming 
+00013d40: 7468 6520 7361 6d65 2063 616d 6572 6120  the same camera 
+00013d50: 696e 7472 696e 7369 6320 7061 7261 6d65  intrinsic parame
+00013d60: 7465 7273 2e0a 0a20 2020 2020 2020 2045  ters...        E
+00013d70: 7861 6d70 6c65 3a0a 0a20 2020 2020 2020  xample:..       
+00013d80: 202e 2e20 7275 6e62 6c6f 636b 3a3a 2070   .. runblock:: p
+00013d90: 7963 6f6e 0a0a 2020 2020 2020 2020 2020  ycon..          
+00013da0: 2020 3e3e 3e20 6672 6f6d 206d 6163 6869    >>> from machi
+00013db0: 6e65 7669 7369 6f6e 746f 6f6c 626f 7820  nevisiontoolbox 
+00013dc0: 696d 706f 7274 2043 656e 7472 616c 4361  import CentralCa
+00013dd0: 6d65 7261 0a20 2020 2020 2020 2020 2020  mera.           
+00013de0: 203e 3e3e 2066 726f 6d20 7370 6174 6961   >>> from spatia
+00013df0: 6c6d 6174 6820 696d 706f 7274 2053 4533  lmath import SE3
+00013e00: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00013e10: 2063 616d 6572 6131 203d 2043 656e 7472   camera1 = Centr
+00013e20: 616c 4361 6d65 7261 286e 616d 653d 2263  alCamera(name="c
+00013e30: 616d 6572 6120 3122 2c20 663d 302e 3030  amera 1", f=0.00
+00013e40: 322c 2069 6d61 6765 7369 7a65 3d31 3030  2, imagesize=100
+00013e50: 302c 2072 686f 3d31 3065 2d36 2c20 706f  0, rho=10e-6, po
+00013e60: 7365 3d53 4533 2e54 7828 2d30 2e31 292a  se=SE3.Tx(-0.1)*
+00013e70: 5345 332e 5279 2830 2e34 2929 0a20 2020  SE3.Ry(0.4)).   
+00013e80: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+00013e90: 6572 6132 203d 2043 656e 7472 616c 4361  era2 = CentralCa
+00013ea0: 6d65 7261 286e 616d 653d 2263 616d 6572  mera(name="camer
+00013eb0: 6120 3222 2c20 663d 302e 3030 322c 2069  a 2", f=0.002, i
+00013ec0: 6d61 6765 7369 7a65 3d31 3030 302c 2072  magesize=1000, r
+00013ed0: 686f 3d31 3065 2d36 2c20 706f 7365 3d53  ho=10e-6, pose=S
+00013ee0: 4533 2e54 7828 302e 3129 2a53 4533 2e52  E3.Tx(0.1)*SE3.R
+00013ef0: 7928 2d30 2e34 2929 0a20 2020 2020 2020  y(-0.4)).       
+00013f00: 2020 2020 203e 3e3e 2046 203d 2063 616d       >>> F = cam
+00013f10: 6572 6131 2e46 2863 616d 6572 6132 290a  era1.F(camera2).
+00013f20: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00013f30: 460a 2020 2020 2020 2020 2020 2020 3e3e  F.            >>
+00013f40: 3e20 4620 3d20 6361 6d65 7261 312e 4628  > F = camera1.F(
+00013f50: 5345 332e 5478 2830 2e32 2929 0a20 2020  SE3.Tx(0.2)).   
+00013f60: 2020 2020 2020 2020 203e 3e3e 2046 0a0a           >>> F..
+00013f70: 2020 2020 2020 2020 3a72 6566 6572 656e          :referen
+00013f80: 6365 3a0a 2020 2020 2020 2020 2020 2020  ce:.            
+00013f90: 2d20 592e 4d61 2c20 4a2e 4b6f 7365 636b  - Y.Ma, J.Koseck
+00013fa0: 612c 2053 2e53 6f61 7474 6f2c 2053 2e53  a, S.Soatto, S.S
+00013fb0: 6173 7472 792c 2022 416e 2069 6e76 6974  astry, "An invit
+00013fc0: 6174 696f 6e20 746f 2033 4422 2c0a 2020  ation to 3D",.  
+00013fd0: 2020 2020 2020 2020 2020 2020 5370 7269              Spri
+00013fe0: 6e67 6572 2c20 3230 3033 2e20 702e 3137  nger, 2003. p.17
+00013ff0: 370a 2020 2020 2020 2020 2020 2020 2d20  7.            - 
+00014000: 526f 626f 7469 6373 2c20 5669 7369 6f6e  Robotics, Vision
+00014010: 2026 2043 6f6e 7472 6f6c 2066 6f72 2050   & Control for P
+00014020: 7974 686f 6e2c 2053 6563 7469 6f6e 2031  ython, Section 1
+00014030: 342e 322e 312c 2050 2e20 436f 726b 652c  4.2.1, P. Corke,
+00014040: 0a20 2020 2020 2020 2020 2020 2020 2053  .              S
+00014050: 7072 696e 6765 7220 3230 3233 2e0a 0a20  pringer 2023... 
+00014060: 2020 2020 2020 203a 7365 6561 6c73 6f3a         :seealso:
+00014070: 203a 6d65 7468 3a60 706f 696e 7473 3246   :meth:`points2F
+00014080: 6020 3a6d 6574 683a 6045 600a 2020 2020  ` :meth:`E`.    
+00014090: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
+000140a0: 2069 6620 6973 696e 7374 616e 6365 286f   if isinstance(o
+000140b0: 7468 6572 2c20 5345 3329 3a0a 2020 2020  ther, SE3):.    
+000140c0: 2020 2020 2020 2020 4520 3d20 7365 6c66          E = self
+000140d0: 2e45 286f 7468 6572 290a 2020 2020 2020  .E(other).      
+000140e0: 2020 2020 2020 4b20 3d20 7365 6c66 2e4b        K = self.K
+000140f0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00014100: 7572 6e20 6e70 2e6c 696e 616c 672e 696e  urn np.linalg.in
+00014110: 7628 4b29 2e54 2040 2045 2040 206e 702e  v(K).T @ E @ np.
+00014120: 6c69 6e61 6c67 2e69 6e76 284b 290a 0a20  linalg.inv(K).. 
+00014130: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
+00014140: 7374 616e 6365 286f 7468 6572 2c20 4365  stance(other, Ce
+00014150: 6e74 7261 6c43 616d 6572 6129 3a0a 2020  ntralCamera):.  
+00014160: 2020 2020 2020 2020 2020 2320 7573 6520            # use 
+00014170: 7265 6c61 7469 7665 2070 6f73 6520 616e  relative pose an
+00014180: 6420 6361 6d65 7261 2070 6172 616d 6574  d camera paramet
+00014190: 6572 7320 6f66 0a20 2020 2020 2020 2020  ers of.         
+000141a0: 2020 2045 203d 2073 656c 662e 4528 6f74     E = self.E(ot
+000141b0: 6865 7229 0a20 2020 2020 2020 2020 2020  her).           
+000141c0: 204b 3120 3d20 7365 6c66 2e4b 0a20 2020   K1 = self.K.   
+000141d0: 2020 2020 2020 2020 204b 3220 3d20 6f74           K2 = ot
+000141e0: 6865 722e 4b0a 2020 2020 2020 2020 2020  her.K.          
+000141f0: 2020 7265 7475 726e 206e 702e 6c69 6e61    return np.lina
+00014200: 6c67 2e69 6e76 284b 3229 2e54 2040 2045  lg.inv(K2).T @ E
+00014210: 2040 206e 702e 6c69 6e61 6c67 2e69 6e76   @ np.linalg.inv
+00014220: 284b 3129 0a0a 2020 2020 2020 2020 656c  (K1)..        el
+00014230: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00014240: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00014250: 2822 6261 6420 7479 7065 2229 0a0a 2020  ("bad type")..  
+00014260: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
+00014270: 2020 2020 6465 6620 706f 696e 7473 3246      def points2F
+00014280: 2870 312c 2070 322c 206d 6574 686f 643d  (p1, p2, method=
+00014290: 2238 7022 2c20 7265 7369 6475 616c 3d54  "8p", residual=T
+000142a0: 7275 652c 2073 6565 643d 4e6f 6e65 2c20  rue, seed=None, 
+000142b0: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+000142c0: 2020 2022 2222 0a20 2020 2020 2020 2045     """.        E
+000142d0: 7374 696d 6174 6520 6675 6e64 616d 656e  stimate fundamen
+000142e0: 7461 6c20 6d61 7472 6978 2066 726f 6d20  tal matrix from 
+000142f0: 636f 7272 6573 706f 6e64 696e 6720 706f  corresponding po
+00014300: 696e 7473 0a0a 2020 2020 2020 2020 3a70  ints..        :p
+00014310: 6172 616d 2070 313a 2069 6d61 6765 2070  aram p1: image p
+00014320: 6c61 6e65 2070 6f69 6e74 7320 6672 6f6d  lane points from
+00014330: 2066 6972 7374 2063 616d 6572 610a 2020   first camera.  
+00014340: 2020 2020 2020 3a74 7970 6520 7031 3a20        :type p1: 
+00014350: 6e64 6172 7261 7928 322c 4e29 0a20 2020  ndarray(2,N).   
+00014360: 2020 2020 203a 7061 7261 6d20 7032 3a20       :param p2: 
+00014370: 696d 6167 6520 706c 616e 6520 706f 696e  image plane poin
+00014380: 7473 2066 726f 6d20 7365 636f 6e64 2063  ts from second c
+00014390: 616d 6572 610a 2020 2020 2020 2020 3a74  amera.        :t
+000143a0: 7970 6520 7032 3a20 6e64 6172 7261 7928  ype p2: ndarray(
+000143b0: 322c 4e29 0a20 2020 2020 2020 203a 7061  2,N).        :pa
+000143c0: 7261 6d20 6d65 7468 6f64 3a20 616c 676f  ram method: algo
+000143d0: 7269 7468 6d20 2737 7027 2c20 2738 7027  rithm '7p', '8p'
+000143e0: 205b 6465 6661 756c 745d 2c20 2772 616e   [default], 'ran
+000143f0: 7361 6327 2c20 276c 6d65 6473 270a 2020  sac', 'lmeds'.  
+00014400: 2020 2020 2020 3a74 7970 6520 6d65 7468        :type meth
+00014410: 6f64 3a20 7374 722c 206f 7074 696f 6e61  od: str, optiona
+00014420: 6c0a 2020 2020 2020 2020 3a70 6172 616d  l.        :param
+00014430: 206b 7761 7267 733a 206f 7074 696f 6e61   kwargs: optiona
+00014440: 6c20 6172 6775 6d65 6e74 7320 6173 2072  l arguments as r
+00014450: 6571 7569 7265 6420 666f 7220 7261 6e73  equired for rans
+00014460: 6163 272c 2027 6c6d 6564 7327 0a20 2020  ac', 'lmeds'.   
+00014470: 2020 2020 2020 2020 206d 6574 686f 6473           methods
+00014480: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
+00014490: 3a20 6675 6e64 616d 656e 7461 6c20 6d61  : fundamental ma
+000144a0: 7472 6978 2061 6e64 2072 6573 6964 7561  trix and residua
+000144b0: 6c0a 2020 2020 2020 2020 3a72 7479 7065  l.        :rtype
+000144c0: 3a20 6e64 6172 7261 7928 332c 3329 2c20  : ndarray(3,3), 
+000144d0: 666c 6f61 740a 0a20 2020 2020 2020 2043  float..        C
+000144e0: 6f6d 7075 7465 7320 7468 6520 6675 6e64  omputes the fund
+000144f0: 616d 656e 7461 6c20 6d61 7472 6978 2066  amental matrix f
+00014500: 726f 6d20 7477 6f20 7365 7473 206f 6620  rom two sets of 
+00014510: 636f 7272 6573 706f 6e64 696e 670a 2020  corresponding.  
+00014520: 2020 2020 2020 696d 6167 652d 706c 616e        image-plan
+00014530: 6520 706f 696e 7473 2e20 436f 7272 6573  e points. Corres
+00014540: 706f 6e64 696e 6720 706f 696e 7473 2061  ponding points a
+00014550: 7265 2067 6976 656e 2062 7920 636f 7272  re given by corr
+00014560: 6573 706f 6e64 696e 670a 2020 2020 2020  esponding.      
+00014570: 2020 636f 6c75 6d6e 7320 6f66 2060 6070    columns of ``p
+00014580: 3160 6020 616e 6420 6060 7032 6060 2e0a  1`` and ``p2``..
+00014590: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+000145a0: 3a0a 0a20 2020 2020 2020 202e 2e20 7275  :..        .. ru
+000145b0: 6e62 6c6f 636b 3a3a 2070 7963 6f6e 0a0a  nblock:: pycon..
+000145c0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+000145d0: 6672 6f6d 206d 6163 6869 6e65 7669 7369  from machinevisi
+000145e0: 6f6e 746f 6f6c 626f 7820 696d 706f 7274  ontoolbox import
+000145f0: 2043 656e 7472 616c 4361 6d65 7261 2c20   CentralCamera, 
+00014600: 6d6b 6772 6964 0a20 2020 2020 2020 2020  mkgrid.         
+00014610: 2020 203e 3e3e 2066 726f 6d20 7370 6174     >>> from spat
+00014620: 6961 6c6d 6174 6820 696d 706f 7274 2053  ialmath import S
+00014630: 4533 0a20 2020 2020 2020 2020 2020 203e  E3.            >
+00014640: 3e3e 2063 616d 6572 6131 203d 2043 656e  >> camera1 = Cen
+00014650: 7472 616c 4361 6d65 7261 286e 616d 653d  tralCamera(name=
+00014660: 2263 616d 6572 6120 3122 2c20 663d 302e  "camera 1", f=0.
+00014670: 3030 322c 2069 6d61 6765 7369 7a65 3d31  002, imagesize=1
+00014680: 3030 302c 2072 686f 3d31 3065 2d36 2c20  000, rho=10e-6, 
+00014690: 706f 7365 3d53 4533 2e54 7828 2d30 2e31  pose=SE3.Tx(-0.1
+000146a0: 292a 5345 332e 5279 2830 2e34 2929 0a20  )*SE3.Ry(0.4)). 
+000146b0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
+000146c0: 616d 6572 6132 203d 2043 656e 7472 616c  amera2 = Central
+000146d0: 4361 6d65 7261 286e 616d 653d 2263 616d  Camera(name="cam
+000146e0: 6572 6120 3222 2c20 663d 302e 3030 322c  era 2", f=0.002,
+000146f0: 2069 6d61 6765 7369 7a65 3d31 3030 302c   imagesize=1000,
+00014700: 2072 686f 3d31 3065 2d36 2c20 706f 7365   rho=10e-6, pose
+00014710: 3d53 4533 2e54 7828 302e 3129 2a53 4533  =SE3.Tx(0.1)*SE3
+00014720: 2e52 7928 2d30 2e34 2929 0a20 2020 2020  .Ry(-0.4)).     
+00014730: 2020 2020 2020 203e 3e3e 2054 5f67 7269         >>> T_gri
+00014740: 6420 3d20 5345 332e 547a 2831 2920 2a20  d = SE3.Tz(1) * 
+00014750: 5345 332e 5278 2830 2e31 2920 2a20 5345  SE3.Rx(0.1) * SE
+00014760: 332e 5279 2830 2e32 290a 2020 2020 2020  3.Ry(0.2).      
+00014770: 2020 2020 2020 3e3e 3e20 5020 3d20 6d6b        >>> P = mk
+00014780: 6772 6964 2833 2c20 312e 302c 2070 6f73  grid(3, 1.0, pos
+00014790: 653d 545f 6772 6964 290a 2020 2020 2020  e=T_grid).      
+000147a0: 2020 2020 2020 3e3e 3e20 7031 203d 2063        >>> p1 = c
+000147b0: 616d 6572 6131 2e70 726f 6a65 6374 5f70  amera1.project_p
+000147c0: 6f69 6e74 2850 290a 2020 2020 2020 2020  oint(P).        
+000147d0: 2020 2020 3e3e 3e20 7032 203d 2063 616d      >>> p2 = cam
+000147e0: 6572 6132 2e70 726f 6a65 6374 5f70 6f69  era2.project_poi
+000147f0: 6e74 2850 293b 0a20 2020 2020 2020 2020  nt(P);.         
+00014800: 2020 203e 3e3e 2046 2c20 7265 7369 6420     >>> F, resid 
+00014810: 3d20 4365 6e74 7261 6c43 616d 6572 612e  = CentralCamera.
+00014820: 706f 696e 7473 3246 2870 312c 2070 3229  points2F(p1, p2)
+00014830: 0a20 2020 2020 2020 2020 2020 203e 3e3e  .            >>>
+00014840: 2046 0a20 2020 2020 2020 2020 2020 203e   F.            >
+00014850: 3e3e 2072 6573 6964 0a0a 2020 2020 2020  >> resid..      
+00014860: 2020 3a73 6565 616c 736f 3a20 3a6d 6574    :seealso: :met
+00014870: 683a 6046 6020 3a6d 6574 683a 6045 600a  h:`F` :meth:`E`.
+00014880: 2020 2020 2020 2020 2020 2020 606f 7065              `ope
+00014890: 6e63 762e 6669 6e64 4675 6e64 616d 656e  ncv.findFundamen
+000148a0: 7461 6c4d 6174 203c 6874 7470 733a 2f2f  talMat <https://
+000148b0: 646f 6373 2e6f 7065 6e63 762e 6f72 672f  docs.opencv.org/
+000148c0: 6d61 7374 6572 2f64 392f 6430 632f 6772  master/d9/d0c/gr
+000148d0: 6f75 705f 5f63 616c 6962 3364 2e68 746d  oup__calib3d.htm
+000148e0: 6c23 6761 3539 6230 6435 3766 3436 6638  l#ga59b0d57f46f8
+000148f0: 3637 3766 6235 3930 3432 3934 6132 3364  677fb5904294a23d
+00014900: 3430 3461 3e60 5f0a 2020 2020 2020 2020  404a>`_.        
+00014910: 2222 220a 0a20 2020 2020 2020 2070 6f69  """..        poi
+00014920: 6e74 7332 465f 6469 6374 203d 207b 0a20  nts2F_dict = {. 
+00014930: 2020 2020 2020 2020 2020 2022 3770 223a             "7p":
+00014940: 2063 762e 464d 5f37 504f 494e 542c 0a20   cv.FM_7POINT,. 
+00014950: 2020 2020 2020 2020 2020 2022 3870 223a             "8p":
+00014960: 2063 762e 464d 5f38 504f 494e 542c 0a20   cv.FM_8POINT,. 
+00014970: 2020 2020 2020 2020 2020 2022 7261 6e73             "rans
+00014980: 6163 223a 2063 762e 464d 5f52 414e 5341  ac": cv.FM_RANSA
+00014990: 432c 0a20 2020 2020 2020 2020 2020 2022  C,.            "
+000149a0: 6c6d 6564 7322 3a20 6376 2e46 4d5f 4c4d  lmeds": cv.FM_LM
+000149b0: 4544 532c 0a20 2020 2020 2020 207d 0a0a  EDS,.        }..
+000149c0: 2020 2020 2020 2020 6966 2073 6565 6420          if seed 
+000149d0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+000149e0: 2020 2020 2020 2020 2063 762e 7365 7452           cv.setR
+000149f0: 4e47 5365 6564 2873 6565 6429 0a0a 2020  NGSeed(seed)..  
+00014a00: 2020 2020 2020 462c 206d 6173 6b20 3d20        F, mask = 
+00014a10: 6376 2e66 696e 6446 756e 6461 6d65 6e74  cv.findFundament
+00014a20: 616c 4d61 7428 0a20 2020 2020 2020 2020  alMat(.         
+00014a30: 2020 2070 312e 542c 2070 322e 542c 206d     p1.T, p2.T, m
+00014a40: 6574 686f 643d 706f 696e 7473 3246 5f64  ethod=points2F_d
+00014a50: 6963 745b 6d65 7468 6f64 5d2c 202a 2a6b  ict[method], **k
+00014a60: 7761 7267 730a 2020 2020 2020 2020 290a  wargs.        ).
+00014a70: 0a20 2020 2020 2020 206d 6173 6b20 3d20  .        mask = 
+00014a80: 6d61 736b 2e72 6176 656c 2829 2e61 7374  mask.ravel().ast
+00014a90: 7970 6528 626f 6f6c 290a 0a20 2020 2020  ype(bool)..     
+00014aa0: 2020 2023 2061 6464 2076 6172 696f 7573     # add various
+00014ab0: 2072 6574 7572 6e20 7661 6c75 6573 0a20   return values. 
+00014ac0: 2020 2020 2020 2072 6574 7661 6c20 3d20         retval = 
+00014ad0: 5b46 5d0a 2020 2020 2020 2020 6966 2072  [F].        if r
+00014ae0: 6573 6964 7561 6c3a 0a20 2020 2020 2020  esidual:.       
+00014af0: 2020 2020 2065 203d 2062 6173 652e 6532       e = base.e2
+00014b00: 6828 7032 5b3a 2c20 6d61 736b 5d29 2e54  h(p2[:, mask]).T
+00014b10: 2040 2046 2040 2062 6173 652e 6532 6828   @ F @ base.e2h(
+00014b20: 7031 5b3a 2c20 6d61 736b 5d29 0a20 2020  p1[:, mask]).   
+00014b30: 2020 2020 2020 2020 2072 6573 6964 203d           resid =
+00014b40: 206e 702e 6c69 6e61 6c67 2e6e 6f72 6d28   np.linalg.norm(
+00014b50: 6e70 2e64 6961 676f 6e61 6c28 6529 290a  np.diagonal(e)).
+00014b60: 2020 2020 2020 2020 2020 2020 7265 7476              retv
+00014b70: 616c 2e61 7070 656e 6428 7265 7369 6429  al.append(resid)
+00014b80: 0a20 2020 2020 2020 2069 6620 6d65 7468  .        if meth
+00014b90: 6f64 2069 6e20 2822 7261 6e73 6163 222c  od in ("ransac",
+00014ba0: 2022 6c6d 6564 7322 293a 0a20 2020 2020   "lmeds"):.     
+00014bb0: 2020 2020 2020 2072 6574 7661 6c2e 6170         retval.ap
+00014bc0: 7065 6e64 286d 6173 6b29 0a0a 2020 2020  pend(mask)..    
+00014bd0: 2020 2020 7265 7475 726e 2072 6574 7661      return retva
+00014be0: 6c0a 2020 2020 2020 2020 2320 656c 696e  l.        # elin
+00014bf0: 6573 203d 2062 6173 652e 6532 6828 7032  es = base.e2h(p2
+00014c00: 292e 5420 4020 4620 2320 686f 6d6f 6720  ).T @ F # homog 
+00014c10: 6c69 6e65 732c 206f 6e65 2070 6572 2072  lines, one per r
+00014c20: 6f77 0a20 2020 2020 2020 2023 2070 3168  ow.        # p1h
+00014c30: 203d 2062 6173 652e 6532 6828 7031 290a   = base.e2h(p1).
+00014c40: 2020 2020 2020 2020 2320 7265 7369 6475          # residu
+00014c50: 616c 7320 3d20 5b5d 0a20 2020 2020 2020  als = [].       
+00014c60: 2023 2066 6f72 2069 2c20 6c69 6e65 2069   # for i, line i
+00014c70: 6e20 656e 756d 6572 6174 6528 656c 696e  n enumerate(elin
+00014c80: 6573 293a 0a20 2020 2020 2020 2023 2020  es):.        #  
+00014c90: 2020 2064 203d 206c 696e 6520 4020 7031     d = line @ p1
+00014ca0: 685b 3a2c 2069 5d20 2f20 6e70 2e73 7172  h[:, i] / np.sqr
+00014cb0: 7428 6c69 6e65 5b30 5d20 2a2a 2032 202b  t(line[0] ** 2 +
+00014cc0: 206c 696e 655b 315d 202a 2a20 3229 0a20   line[1] ** 2). 
+00014cd0: 2020 2020 2020 2023 2020 2020 2072 6573         #     res
+00014ce0: 6964 7561 6c73 2e61 7070 656e 6428 6429  iduals.append(d)
+00014cf0: 0a20 2020 2020 2020 2023 2072 6573 6964  .        # resid
+00014d00: 203d 206e 702e 6172 7261 7928 7265 7369   = np.array(resi
+00014d10: 6475 616c 7329 2e6d 6561 6e28 290a 0a20  duals).mean().. 
+00014d20: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
+00014d30: 0a20 2020 2064 6566 2065 7069 6469 7374  .    def epidist
+00014d40: 2846 2c20 7031 2c20 7032 293a 0a20 2020  (F, p1, p2):.   
+00014d50: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00014d60: 2045 7069 706f 6c61 7220 6469 7374 616e   Epipolar distan
+00014d70: 6365 0a0a 2020 2020 2020 2020 3a70 6172  ce..        :par
+00014d80: 616d 2046 3a20 6675 6e64 616d 656e 7461  am F: fundamenta
+00014d90: 6c20 6d61 7472 6978 0a20 2020 2020 2020  l matrix.       
+00014da0: 203a 7479 7065 2046 3a20 6e64 6172 7261   :type F: ndarra
+00014db0: 7928 332c 3329 0a20 2020 2020 2020 203a  y(3,3).        :
+00014dc0: 7061 7261 6d20 7031 3a20 696d 6167 6520  param p1: image 
+00014dd0: 706c 616e 6520 706f 696e 7420 6f72 2070  plane point or p
+00014de0: 6f69 6e74 7320 6672 6f6d 2066 6972 7374  oints from first
+00014df0: 2063 616d 6572 610a 2020 2020 2020 2020   camera.        
+00014e00: 3a74 7970 6520 7031 3a20 6e64 6172 7261  :type p1: ndarra
+00014e10: 7928 3229 206f 7220 6e64 6172 7261 7928  y(2) or ndarray(
+00014e20: 322c 4e29 0a20 2020 2020 2020 203a 7061  2,N).        :pa
+00014e30: 7261 6d20 7032 3a20 696d 6167 6520 706c  ram p2: image pl
+00014e40: 616e 6520 706f 696e 7420 6f72 2070 6f69  ane point or poi
+00014e50: 6e74 7320 6672 6f6d 2073 6563 6f6e 6420  nts from second 
+00014e60: 6361 6d65 7261 0a20 2020 2020 2020 203a  camera.        :
+00014e70: 7479 7065 2070 323a 206e 6461 7272 6179  type p2: ndarray
+00014e80: 2832 2920 6f72 206e 6461 7272 6179 2832  (2) or ndarray(2
+00014e90: 2c4d 290a 2020 2020 2020 2020 3a72 6574  ,M).        :ret
+00014ea0: 7572 6e3a 2064 6973 7461 6e63 6520 6d61  urn: distance ma
+00014eb0: 7472 6978 0a20 2020 2020 2020 203a 7274  trix.        :rt
+00014ec0: 7970 653a 206e 6461 7272 6179 284e 2c4d  ype: ndarray(N,M
+00014ed0: 290a 0a20 2020 2020 2020 2043 6f6d 7075  )..        Compu
+00014ee0: 7465 7320 7468 6520 6469 7374 616e 6365  tes the distance
+00014ef0: 206f 6620 7468 6520 706f 696e 7473 2060   of the points `
+00014f00: 6070 3260 6020 6672 6f6d 2074 6865 0a20  `p2`` from the. 
+00014f10: 2020 2020 2020 2065 7069 706f 6c61 7220         epipolar 
+00014f20: 6c69 6e65 7320 696e 6475 6365 6420 6279  lines induced by
+00014f30: 2070 6f69 6e74 7320 6060 7031 6060 2e20   points ``p1``. 
+00014f40: 2045 6c65 6d65 6e74 205b 692c 6a5d 206f   Element [i,j] o
+00014f50: 6620 7468 6520 7265 7475 726e 0a20 2020  f the return.   
+00014f60: 2020 2020 2076 616c 7565 2069 7320 7468       value is th
+00014f70: 6520 6973 7461 6e63 6520 6f66 2070 6f69  e istance of poi
+00014f80: 6e74 206a 2069 6e20 6361 6d65 7261 2032  nt j in camera 2
+00014f90: 2066 726f 6d20 7468 6520 6570 6970 6f6c   from the epipol
+00014fa0: 6172 206c 696e 650a 2020 2020 2020 2020  ar line.        
+00014fb0: 696e 6475 6365 6420 6279 2070 6f69 6e74  induced by point
+00014fc0: 2069 2069 6e20 6361 6d65 7261 2031 2e0a   i in camera 1..
+00014fd0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00014fe0: 2020 2020 6966 2070 312e 6e64 696d 203d      if p1.ndim =
+00014ff0: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+00015000: 2070 3120 3d20 6e70 2e63 5f5b 7031 5d0a   p1 = np.c_[p1].
+00015010: 2020 2020 2020 2020 6966 2070 322e 6e64          if p2.nd
+00015020: 696d 203d 3d20 313a 0a20 2020 2020 2020  im == 1:.       
+00015030: 2020 2020 2070 3220 3d20 6e70 2e63 5f5b       p2 = np.c_[
+00015040: 7032 5d0a 0a20 2020 2020 2020 2044 203d  p2]..        D =
+00015050: 206e 702e 656d 7074 7928 2870 312e 7368   np.empty((p1.sh
+00015060: 6170 655b 315d 2c20 7032 2e73 6861 7065  ape[1], p2.shape
+00015070: 5b31 5d29 290a 0a20 2020 2020 2020 2023  [1]))..        #
+00015080: 2063 6f6d 7075 7465 2065 7069 706f 6c61   compute epipola
+00015090: 7220 6c69 6e65 7320 636f 7272 6573 706f  r lines correspo
+000150a0: 6e64 696e 6720 746f 2070 310a 2020 2020  nding to p1.    
+000150b0: 2020 2020 6c20 3d20 4620 4020 6261 7365      l = F @ base
+000150c0: 2e65 3268 2870 3129 0a20 2020 2020 2020  .e2h(p1).       
+000150d0: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
+000150e0: 7031 2e73 6861 7065 5b31 5d29 3a0a 2020  p1.shape[1]):.  
+000150f0: 2020 2020 2020 2020 2020 666f 7220 6a20            for j 
+00015100: 696e 2072 616e 6765 2870 322e 7368 6170  in range(p2.shap
+00015110: 655b 315d 293a 0a20 2020 2020 2020 2020  e[1]):.         
+00015120: 2020 2020 2020 2044 5b69 2c20 6a5d 203d         D[i, j] =
+00015130: 206e 702e 6162 7328 0a20 2020 2020 2020   np.abs(.       
+00015140: 2020 2020 2020 2020 2020 2020 206c 5b30               l[0
+00015150: 2c20 695d 202a 2070 325b 302c 206a 5d20  , i] * p2[0, j] 
+00015160: 2b20 6c5b 312c 2069 5d20 2a20 7032 5b31  + l[1, i] * p2[1
+00015170: 2c20 6a5d 202b 206c 5b32 2c20 695d 0a20  , j] + l[2, i]. 
+00015180: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00015190: 202f 206e 702e 7371 7274 286c 5b30 2c20   / np.sqrt(l[0, 
+000151a0: 695d 202a 2a20 3220 2b20 6c5b 312c 2069  i] ** 2 + l[1, i
+000151b0: 5d20 2a2a 2032 290a 2020 2020 2020 2020  ] ** 2).        
+000151c0: 7265 7475 726e 2044 0a0a 2020 2020 2320  return D..    # 
+000151d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000151e0: 3d3d 3d3d 3d20 6573 7365 6e74 6961 6c20  ===== essential 
+000151f0: 6d61 7472 6978 203d 3d3d 3d3d 3d3d 3d3d  matrix =========
+00015200: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00015210: 3d3d 3d3d 3d3d 2023 0a0a 2020 2020 6465  ====== #..    de
+00015220: 6620 4528 7365 6c66 2c20 6f74 6865 7229  f E(self, other)
+00015230: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00015240: 2020 2020 2020 4573 7365 6e74 6961 6c20        Essential 
+00015250: 6d61 7472 6978 2066 726f 6d20 7477 6f20  matrix from two 
+00015260: 6361 6d65 7261 2076 6965 7773 0a0a 2020  camera views..  
+00015270: 2020 2020 2020 3a70 6172 616d 206f 7468        :param oth
+00015280: 6572 3a20 7365 636f 6e64 2063 616d 6572  er: second camer
+00015290: 6120 7669 6577 2c20 6361 6d65 7261 2070  a view, camera p
+000152a0: 6f73 6520 6f72 2066 756e 6461 6d65 6e74  ose or fundament
+000152b0: 616c 206d 6174 7269 780a 2020 2020 2020  al matrix.      
+000152c0: 2020 3a74 7970 6520 6f74 6865 723a 203a    :type other: :
+000152d0: 636c 6173 733a 6043 656e 7472 616c 4361  class:`CentralCa
+000152e0: 6d65 7261 602c 203a 636c 6173 733a 607e  mera`, :class:`~
+000152f0: 7370 6174 6961 6c6d 6174 682e 2e70 6f73  spatialmath..pos
+00015300: 6533 642e 5345 3360 2c20 6e64 6172 7261  e3d.SE3`, ndarra
+00015310: 7928 332c 3329 0a20 2020 2020 2020 203a  y(3,3).        :
+00015320: 7265 7475 726e 3a20 6573 7365 6e74 6961  return: essentia
+00015330: 6c20 6d61 7472 6978 0a20 2020 2020 2020  l matrix.       
+00015340: 203a 7274 7970 653a 206e 6461 7272 6179   :rtype: ndarray
+00015350: 2833 2c33 290a 0a20 2020 2020 2020 2043  (3,3)..        C
+00015360: 6f6d 7075 7465 2074 6865 2065 7373 656e  ompute the essen
+00015370: 7469 616c 206d 6174 7269 7820 7265 6c61  tial matrix rela
+00015380: 7469 6e67 2074 776f 2063 616d 6572 6120  ting two camera 
+00015390: 7669 6577 732e 2054 6865 2066 6972 7374  views. The first
+000153a0: 2076 6965 770a 2020 2020 2020 2020 6973   view.        is
+000153b0: 2064 6566 696e 6564 2062 7920 7468 6520   defined by the 
+000153c0: 696e 7374 616e 6365 2c20 616e 6420 7365  instance, and se
+000153d0: 636f 6e64 2076 6965 7720 6973 2073 7065  cond view is spe
+000153e0: 6369 6669 6564 2062 793a 0a0a 2020 2020  cified by:..    
+000153f0: 2020 2020 2a20 6120 6361 6d65 7261 2069      * a camera i
+00015400: 6e73 7461 6e63 6520 7265 7072 6573 656e  nstance represen
+00015410: 7465 6420 6279 2061 203a 636c 6173 733a  ted by a :class:
+00015420: 6043 656e 7472 616c 4361 6d65 7261 602e  `CentralCamera`.
+00015430: 2041 7373 756d 6573 2074 6865 0a20 2020   Assumes the.   
+00015440: 2020 2020 2020 2063 616d 6572 6173 2068         cameras h
+00015450: 6176 6520 7468 6520 7361 6d65 2069 6e74  ave the same int
+00015460: 7269 6e73 6963 732e 0a20 2020 2020 2020  rinsics..       
+00015470: 202a 2061 2072 656c 6174 6976 6520 6d6f   * a relative mo
+00015480: 7469 6f6e 2072 6570 7265 7365 6e74 6564  tion represented
+00015490: 2062 7920 6120 3a63 6c61 7373 3a60 7e73   by a :class:`~s
+000154a0: 7061 7469 616c 6d61 7468 2e2e 706f 7365  patialmath..pose
+000154b0: 3364 2e53 4533 600a 2020 2020 2020 2020  3d.SE3`.        
+000154c0: 2a20 6120 6675 6e64 616d 656e 7461 6c20  * a fundamental 
+000154d0: 6d61 7472 6978 0a0a 2020 2020 2020 2020  matrix..        
+000154e0: 3a72 6566 6572 656e 6365 3a0a 2020 2020  :reference:.    
+000154f0: 2020 2020 2020 2020 2d20 592e 4d61 2c20          - Y.Ma, 
+00015500: 4a2e 4b6f 7365 636b 612c 2053 2e53 6f61  J.Kosecka, S.Soa
+00015510: 7474 6f2c 2053 2e53 6173 7472 792c 2022  tto, S.Sastry, "
+00015520: 416e 2069 6e76 6974 6174 696f 6e20 746f  An invitation to
+00015530: 2033 4422 2c0a 2020 2020 2020 2020 2020   3D",.          
+00015540: 2020 2020 5370 7269 6e67 6572 2c20 3230      Springer, 20
+00015550: 3033 2e20 702e 3137 370a 0a20 2020 2020  03. p.177..     
+00015560: 2020 203a 7365 6561 6c73 6f3a 203a 6d65     :seealso: :me
+00015570: 7468 3a60 4660 203a 6d65 7468 3a60 6465  th:`F` :meth:`de
+00015580: 636f 6d70 6f73 6545 6020 3a6d 6574 683a  composeE` :meth:
+00015590: 6070 6f69 6e74 7332 4560 0a20 2020 2020  `points2E`.     
+000155a0: 2020 2022 2222 0a0a 2020 2020 2020 2020     """..        
+000155b0: 6966 2069 7369 6e73 7461 6e63 6528 6f74  if isinstance(ot
+000155c0: 6865 722c 206e 702e 6e64 6172 7261 7929  her, np.ndarray)
+000155d0: 2061 6e64 206f 7468 6572 2e73 6861 7065   and other.shape
+000155e0: 203d 3d20 2833 2c20 3329 3a0a 2020 2020   == (3, 3):.    
+000155f0: 2020 2020 2020 2020 2320 6573 7365 6e74          # essent
+00015600: 6961 6c20 6d61 7472 6978 2066 726f 6d20  ial matrix from 
+00015610: 4620 6d61 7472 6978 2061 6e64 2069 6e74  F matrix and int
+00015620: 7269 6e73 6963 730a 2020 2020 2020 2020  rinsics.        
+00015630: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00015640: 4b2e 5420 4020 6f74 6865 7220 4020 7365  K.T @ other @ se
+00015650: 6c66 2e4b 0a0a 2020 2020 2020 2020 656c  lf.K..        el
+00015660: 6966 2069 7369 6e73 7461 6e63 6528 6f74  if isinstance(ot
+00015670: 6865 722c 2043 656e 7472 616c 4361 6d65  her, CentralCame
+00015680: 7261 293a 0a20 2020 2020 2020 2020 2020  ra):.           
+00015690: 2023 2063 616d 6572 6120 7265 6c61 7469   # camera relati
+000156a0: 7665 2070 6f73 650a 2020 2020 2020 2020  ve pose.        
+000156b0: 2020 2020 5432 3120 3d20 6f74 6865 722e      T21 = other.
+000156c0: 706f 7365 2e69 6e76 2829 202a 2073 656c  pose.inv() * sel
+000156d0: 662e 706f 7365 0a0a 2020 2020 2020 2020  f.pose..        
+000156e0: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
+000156f0: 6f74 6865 722c 2053 4533 293a 0a20 2020  other, SE3):.   
+00015700: 2020 2020 2020 2020 2023 2072 656c 6174           # relat
+00015710: 6976 6520 706f 7365 2067 6976 656e 2065  ive pose given e
+00015720: 7870 6c69 6369 746c 790a 2020 2020 2020  xplicitly.      
+00015730: 2020 2020 2020 5432 3120 3d20 6f74 6865        T21 = othe
+00015740: 722e 696e 7628 290a 0a20 2020 2020 2020  r.inv()..       
+00015750: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00015760: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00015770: 726f 7228 2262 6164 2074 7970 6522 290a  ror("bad type").
+00015780: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00015790: 6261 7365 2e73 6b65 7728 5432 312e 7429  base.skew(T21.t)
+000157a0: 2040 2054 3231 2e52 0a0a 2020 2020 6465   @ T21.R..    de
+000157b0: 6620 706f 696e 7473 3245 2873 656c 662c  f points2E(self,
+000157c0: 2070 312c 2070 322c 206d 6574 686f 643d   p1, p2, method=
+000157d0: 4e6f 6e65 2c20 4b3d 4e6f 6e65 2c20 2a2a  None, K=None, **
+000157e0: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+000157f0: 2022 2222 0a20 2020 2020 2020 2045 7373   """.        Ess
+00015800: 656e 7469 616c 206d 6174 7269 7820 6672  ential matrix fr
+00015810: 6f6d 2070 6f69 6e74 730a 0a20 2020 2020  om points..     
+00015820: 2020 203a 7061 7261 6d20 5031 3a20 696d     :param P1: im
+00015830: 6167 6520 706c 616e 6520 706f 696e 7473  age plane points
+00015840: 0a20 2020 2020 2020 203a 7479 7065 2050  .        :type P
+00015850: 313a 206e 6461 7272 6179 2832 2c4e 290a  1: ndarray(2,N).
+00015860: 2020 2020 2020 2020 3a70 6172 616d 2050          :param P
+00015870: 323a 2069 6d61 6765 2070 6c61 6e65 2070  2: image plane p
+00015880: 6f69 6e74 730a 2020 2020 2020 2020 3a74  oints.        :t
+00015890: 7970 6520 5032 3a20 6e64 6172 7261 7928  ype P2: ndarray(
+000158a0: 322c 4e29 0a20 2020 2020 2020 203a 7061  2,N).        :pa
+000158b0: 7261 6d20 6d65 7468 6f64 3a20 6d65 7468  ram method: meth
+000158c0: 6f64 2c20 6361 6e20 6265 2027 7261 6e73  od, can be 'rans
+000158d0: 6163 2720 6f72 2027 6c6d 6564 7327 0a20  ac' or 'lmeds'. 
+000158e0: 2020 2020 2020 203a 7479 7065 206d 6574         :type met
+000158f0: 686f 643a 2073 7472 0a20 2020 2020 2020  hod: str.       
+00015900: 203a 7061 7261 6d20 4b3a 2063 616d 6572   :param K: camer
+00015910: 6120 696e 7472 696e 7369 6320 6d61 7472  a intrinsic matr
+00015920: 6978 2c20 6465 6661 756c 7473 2074 6f20  ix, defaults to 
+00015930: 7468 6174 206f 6620 6361 6d65 7261 206f  that of camera o
+00015940: 626a 6563 740a 2020 2020 2020 2020 3a74  bject.        :t
+00015950: 7970 6520 4b3a 206e 6461 7272 6179 2833  ype K: ndarray(3
+00015960: 2c33 292c 206f 7074 696f 6e61 6c0a 2020  ,3), optional.  
+00015970: 2020 2020 2020 3a70 6172 616d 206b 7761        :param kwa
+00015980: 7267 733a 2061 6464 6974 696f 6e61 6c20  rgs: additional 
+00015990: 6172 6775 6d65 6e74 7320 7265 7175 6972  arguments requir
+000159a0: 6564 2066 6f72 2027 7261 6e73 6163 2720  ed for 'ransac' 
+000159b0: 6f72 2027 6c6d 6564 7327 0a20 2020 2020  or 'lmeds'.     
+000159c0: 2020 2020 2020 206f 7074 696f 6e73 0a20         options. 
+000159d0: 2020 2020 2020 203a 7265 7475 726e 3a20         :return: 
+000159e0: 6573 7365 6e74 6961 6c20 6d61 7472 6978  essential matrix
+000159f0: 2061 6e64 206f 7074 696f 6e61 6c20 696e   and optional in
+00015a00: 6c69 6572 2076 6576 746f 720a 2020 2020  lier vevtor.    
+00015a10: 2020 2020 3a72 7479 7065 3a20 6e64 6172      :rtype: ndar
+00015a20: 7261 7928 332c 3329 2c20 6e64 6172 7261  ray(3,3), ndarra
+00015a30: 7928 4e2c 2062 6f6f 6c29 0a0a 2020 2020  y(N, bool)..    
+00015a40: 2020 2020 436f 6d70 7574 6520 7468 6520      Compute the 
+00015a50: 6573 7365 6e74 6961 6c20 6d61 7472 6978  essential matrix
+00015a60: 2066 726f 6d20 7477 6f20 7365 7473 206f   from two sets o
+00015a70: 6620 636f 7272 6573 706f 6e64 696e 6720  f corresponding 
+00015a80: 706f 696e 7473 2e0a 2020 2020 2020 2020  points..        
+00015a90: 4561 6368 2073 6574 206f 6620 706f 696e  Each set of poin
+00015aa0: 7473 2069 7320 7265 7072 6573 656e 7465  ts is represente
+00015ab0: 6420 6279 2074 6865 2063 6f6c 756d 6e73  d by the columns
+00015ac0: 206f 6620 7468 6520 6172 7261 7920 6060   of the array ``
+00015ad0: 7031 6060 0a20 2020 2020 2020 206f 7220  p1``.        or 
+00015ae0: 6060 7032 6060 2e0a 0a20 2020 2020 2020  ``p2``...       
+00015af0: 2045 7861 6d70 6c65 3a0a 0a20 2020 2020   Example:..     
+00015b00: 2020 202e 2e20 7275 6e62 6c6f 636b 3a3a     .. runblock::
+00015b10: 2070 7963 6f6e 0a0a 2020 2020 2020 2020   pycon..        
+00015b20: 2020 2020 3e3e 3e20 6672 6f6d 206d 6163      >>> from mac
+00015b30: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
+00015b40: 7820 696d 706f 7274 2043 656e 7472 616c  x import Central
+00015b50: 4361 6d65 7261 2c20 6d6b 6772 6964 0a20  Camera, mkgrid. 
+00015b60: 2020 2020 2020 2020 2020 203e 3e3e 2066             >>> f
+00015b70: 726f 6d20 7370 6174 6961 6c6d 6174 6820  rom spatialmath 
+00015b80: 696d 706f 7274 2053 4533 0a20 2020 2020  import SE3.     
+00015b90: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+00015ba0: 6131 203d 2043 656e 7472 616c 4361 6d65  a1 = CentralCame
+00015bb0: 7261 286e 616d 653d 2263 616d 6572 6120  ra(name="camera 
+00015bc0: 3122 2c20 663d 302e 3030 322c 2069 6d61  1", f=0.002, ima
+00015bd0: 6765 7369 7a65 3d31 3030 302c 2072 686f  gesize=1000, rho
+00015be0: 3d31 3065 2d36 2c20 706f 7365 3d53 4533  =10e-6, pose=SE3
+00015bf0: 2e54 7828 2d30 2e31 292a 5345 332e 5279  .Tx(-0.1)*SE3.Ry
+00015c00: 2830 2e34 2929 0a20 2020 2020 2020 2020  (0.4)).         
+00015c10: 2020 203e 3e3e 2063 616d 6572 6132 203d     >>> camera2 =
+00015c20: 2043 656e 7472 616c 4361 6d65 7261 286e   CentralCamera(n
+00015c30: 616d 653d 2263 616d 6572 6120 3222 2c20  ame="camera 2", 
+00015c40: 663d 302e 3030 322c 2069 6d61 6765 7369  f=0.002, imagesi
+00015c50: 7a65 3d31 3030 302c 2072 686f 3d31 3065  ze=1000, rho=10e
+00015c60: 2d36 2c20 706f 7365 3d53 4533 2e54 7828  -6, pose=SE3.Tx(
+00015c70: 302e 3129 2a53 4533 2e52 7928 2d30 2e34  0.1)*SE3.Ry(-0.4
+00015c80: 2929 0a20 2020 2020 2020 2020 2020 203e  )).            >
+00015c90: 3e3e 2054 5f67 7269 6420 3d20 5345 332e  >> T_grid = SE3.
+00015ca0: 547a 2831 2920 2a20 5345 332e 5278 2830  Tz(1) * SE3.Rx(0
+00015cb0: 2e31 2920 2a20 5345 332e 5279 2830 2e32  .1) * SE3.Ry(0.2
+00015cc0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+00015cd0: 3e20 5020 3d20 6d6b 6772 6964 2833 2c20  > P = mkgrid(3, 
+00015ce0: 312e 302c 2070 6f73 653d 545f 6772 6964  1.0, pose=T_grid
+00015cf0: 290a 2020 2020 2020 2020 2020 2020 3e3e  ).            >>
+00015d00: 3e20 7031 203d 2063 616d 6572 6131 2e70  > p1 = camera1.p
+00015d10: 726f 6a65 6374 5f70 6f69 6e74 2850 290a  roject_point(P).
+00015d20: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00015d30: 7032 203d 2063 616d 6572 6132 2e70 726f  p2 = camera2.pro
+00015d40: 6a65 6374 5f70 6f69 6e74 2850 293b 0a20  ject_point(P);. 
+00015d50: 2020 2020 2020 2020 2020 203e 3e3e 2045             >>> E
+00015d60: 2c20 696e 6c69 6572 7320 3d20 6361 6d65  , inliers = came
+00015d70: 7261 312e 706f 696e 7473 3245 2870 312c  ra1.points2E(p1,
+00015d80: 2070 3229 0a20 2020 2020 2020 2020 2020   p2).           
+00015d90: 203e 3e3e 2045 0a20 2020 2020 2020 2020   >>> E.         
+00015da0: 2020 203e 3e3e 2069 6e6c 6965 7273 0a0a     >>> inliers..
+00015db0: 2020 2020 2020 2020 3a6e 6f74 653a 2049          :note: I
+00015dc0: 6620 7468 6520 6d65 7468 6f64 2069 7320  f the method is 
+00015dd0: 2772 616e 7361 6327 206f 7220 276c 6d65  'ransac' or 'lme
+00015de0: 6473 2720 7468 656e 2061 2062 6f6f 6c65  ds' then a boole
+00015df0: 616e 2061 7272 6179 0a20 2020 2020 2020  an array.       
+00015e00: 2020 2020 206f 6620 696e 6c69 6572 7320       of inliers 
+00015e10: 6973 2061 6c73 6f20 7265 7475 726e 6564  is also returned
+00015e20: 2c20 5472 7565 206d 6561 6e73 2074 6865  , True means the
+00015e30: 2063 6f72 7265 7370 6f6e 6469 6e67 2069   corresponding i
+00015e40: 6e70 7574 0a20 2020 2020 2020 2020 2020  nput.           
+00015e50: 2070 6f69 6e74 2070 6169 7220 6973 2061   point pair is a
+00015e60: 6e20 696e 6c69 6572 2e0a 0a20 2020 2020  n inlier...     
+00015e70: 2020 203a 7365 6561 6c73 6f3a 203a 6d65     :seealso: :me
+00015e80: 7468 3a60 4560 203a 6d65 7468 3a60 6465  th:`E` :meth:`de
+00015e90: 636f 6d70 6f73 6545 600a 2020 2020 2020  composeE`.      
+00015ea0: 2020 2020 2020 606f 7065 6e63 762e 6669        `opencv.fi
+00015eb0: 6e64 4573 7365 6e74 6961 6c4d 6174 203c  ndEssentialMat <
+00015ec0: 6874 7470 733a 2f2f 646f 6373 2e6f 7065  https://docs.ope
+00015ed0: 6e63 762e 6f72 672f 6d61 7374 6572 2f64  ncv.org/master/d
+00015ee0: 392f 6430 632f 6772 6f75 705f 5f63 616c  9/d0c/group__cal
+00015ef0: 6962 3364 2e68 746d 6c23 6761 6432 3435  ib3d.html#gad245
+00015f00: 6436 3065 3634 6430 6331 3237 3064 6266  d60e64d0c1270dbf
+00015f10: 6430 3532 3038 3437 6262 3837 3e60 5f0a  d0520847bb87>`_.
+00015f20: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00015f30: 2020 2020 2069 6620 4b20 6973 204e 6f6e       if K is Non
+00015f40: 653a 0a20 2020 2020 2020 2020 2020 204b  e:.            K
+00015f50: 203d 2073 656c 662e 4b0a 0a20 2020 2020   = self.K..     
+00015f60: 2020 2070 6f69 6e74 7332 455f 6469 6374     points2E_dict
+00015f70: 203d 207b 2272 616e 7361 6322 3a20 6376   = {"ransac": cv
+00015f80: 2e52 414e 5341 432c 2022 6c6d 6564 7322  .RANSAC, "lmeds"
+00015f90: 3a20 6376 2e4c 4d45 4453 7d0a 2020 2020  : cv.LMEDS}.    
+00015fa0: 2020 2020 6966 206d 6574 686f 6420 6973      if method is
+00015fb0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00015fc0: 2020 2020 2020 206d 6574 686f 6420 3d20         method = 
+00015fd0: 706f 696e 7473 3245 5f64 6963 745b 6d65  points2E_dict[me
+00015fe0: 7468 6f64 5d0a 0a20 2020 2020 2020 2045  thod]..        E
+00015ff0: 2c20 6d61 736b 203d 2063 762e 6669 6e64  , mask = cv.find
+00016000: 4573 7365 6e74 6961 6c4d 6174 280a 2020  EssentialMat(.  
+00016010: 2020 2020 2020 2020 2020 7031 2e54 2c20            p1.T, 
+00016020: 7032 2e54 2c20 6361 6d65 7261 4d61 7472  p2.T, cameraMatr
+00016030: 6978 3d4b 2c20 6d65 7468 6f64 3d6d 6574  ix=K, method=met
+00016040: 686f 642c 202a 2a6b 7761 7267 730a 2020  hod, **kwargs.  
+00016050: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00016060: 6966 206d 6173 6b20 6973 206e 6f74 204e  if mask is not N
+00016070: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00016080: 206d 6173 6b20 3d20 6d61 736b 2e66 6c61   mask = mask.fla
+00016090: 7474 656e 2829 2e61 7374 7970 6528 626f  tten().astype(bo
+000160a0: 6f6c 290a 2020 2020 2020 2020 2020 2020  ol).            
+000160b0: 7265 7475 726e 2045 2c20 6d61 736b 0a20  return E, mask. 
+000160c0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+000160d0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000160e0: 450a 0a20 2020 2064 6566 2064 6563 6f6d  E..    def decom
+000160f0: 706f 7365 4528 7365 6c66 2c20 452c 2050  poseE(self, E, P
+00016100: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
+00016110: 2222 220a 2020 2020 2020 2020 4465 636f  """.        Deco
+00016120: 6d70 6f73 6520 6573 7365 6e74 6961 6c20  mpose essential 
+00016130: 6d61 7472 6978 0a0a 2020 2020 2020 2020  matrix..        
+00016140: 3a70 6172 616d 2045 3a20 6573 7365 6e74  :param E: essent
+00016150: 6961 6c20 6d61 7472 6978 0a20 2020 2020  ial matrix.     
+00016160: 2020 203a 7479 7065 2045 3a20 6e64 6172     :type E: ndar
+00016170: 7261 7928 332c 3329 0a20 2020 2020 2020  ray(3,3).       
+00016180: 203a 7061 7261 6d20 503a 2077 6f72 6c64   :param P: world
+00016190: 2070 6f69 6e74 206f 7220 6665 6174 7572   point or featur
+000161a0: 6520 6d61 7463 6820 6f62 6a65 6374 2074  e match object t
+000161b0: 6f20 7265 736f 6c76 6520 616d 6269 6775  o resolve ambigu
+000161c0: 6974 790a 2020 2020 2020 2020 3a74 7970  ity.        :typ
+000161d0: 6520 503a 2061 7272 6179 5f6c 696b 6528  e P: array_like(
+000161e0: 3329 2c20 3a63 6c61 7373 3a60 7e6d 6163  3), :class:`~mac
+000161f0: 6869 6e65 7669 7369 6f6e 746f 6f6c 626f  hinevisiontoolbo
+00016200: 782e 496d 6167 6550 6f69 6e74 4665 6174  x.ImagePointFeat
+00016210: 7572 6573 2e46 6561 7475 7265 4d61 7463  ures.FeatureMatc
+00016220: 6860 0a20 2020 2020 2020 203a 7265 7475  h`.        :retu
+00016230: 726e 3a20 6361 6d65 7261 2072 656c 6174  rn: camera relat
+00016240: 6976 6520 706f 7365 0a20 2020 2020 2020  ive pose.       
+00016250: 203a 7274 7970 653a 203a 636c 6173 733a   :rtype: :class:
+00016260: 607e 7370 6174 6961 6c6d 6174 682e 2e70  `~spatialmath..p
+00016270: 6f73 6533 642e 5345 3360 0a0a 2020 2020  ose3d.SE3`..    
+00016280: 2020 2020 4465 7465 726d 696e 6573 2072      Determines r
+00016290: 656c 6174 6976 6520 706f 7365 2066 726f  elative pose fro
+000162a0: 6d20 6573 7365 6e74 6961 6c20 6d61 7472  m essential matr
+000162b0: 6978 2e20 5468 6973 206f 7065 7261 7469  ix. This operati
+000162c0: 6f6e 2068 6173 0a20 2020 2020 2020 206d  on has.        m
+000162d0: 756c 7469 706c 6520 736f 6c75 7469 6f6e  ultiple solution
+000162e0: 7320 7768 6963 6820 6973 2072 6573 6f6c  s which is resol
+000162f0: 7665 6420 6279 2070 6173 7369 6e67 2069  ved by passing i
+00016300: 6e3a 0a0a 2020 2020 2020 2020 2d20 6120  n:..        - a 
+00016310: 7369 6e67 6c65 2033 4420 776f 726c 6420  single 3D world 
+00016320: 706f 696e 7420 696e 2066 726f 6e74 206f  point in front o
+00016330: 6620 7468 6520 6361 6d65 7261 0a20 2020  f the camera.   
+00016340: 2020 2020 202d 2061 203a 636c 6173 733a       - a :class:
+00016350: 607e 6d61 6368 696e 6576 6973 696f 6e74  `~machinevisiont
+00016360: 6f6f 6c62 6f78 2e49 6d61 6765 506f 696e  oolbox.ImagePoin
+00016370: 7446 6561 7475 7265 732e 4665 6174 7572  tFeatures.Featur
+00016380: 654d 6174 6368 6020 6f62 6a65 6374 0a0a  eMatch` object..
+00016390: 2020 2020 2020 2020 3a72 6566 6572 656e          :referen
+000163a0: 6365 3a0a 2020 2020 2020 2020 2020 2020  ce:.            
+000163b0: 2d20 526f 626f 7469 6373 2c20 5669 7369  - Robotics, Visi
+000163c0: 6f6e 2026 2043 6f6e 7472 6f6c 2066 6f72  on & Control for
+000163d0: 2050 7974 686f 6e2c 2053 6563 7469 6f6e   Python, Section
+000163e0: 2031 342e 322e 3220 502e 2043 6f72 6b65   14.2.2 P. Corke
+000163f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00016400: 5370 7269 6e67 6572 2032 3032 332e 0a0a  Springer 2023...
+00016410: 2020 2020 2020 2020 3a73 6565 616c 736f          :seealso
+00016420: 3a20 3a6d 6574 683a 6045 6020 3a6d 6574  : :meth:`E` :met
+00016430: 683a 6070 6f69 6e74 7332 4560 0a20 2020  h:`points2E`.   
+00016440: 2020 2020 2020 2020 203a 636c 6173 733a           :class:
+00016450: 607e 6d61 6368 696e 6576 6973 696f 6e74  `~machinevisiont
+00016460: 6f6f 6c62 6f78 2e49 6d61 6765 506f 696e  oolbox.ImagePoin
+00016470: 7446 6561 7475 7265 732e 4665 6174 7572  tFeatures.Featur
+00016480: 654d 6174 6368 600a 2020 2020 2020 2020  eMatch`.        
+00016490: 2020 2020 606f 7065 6e63 762e 6465 636f      `opencv.deco
+000164a0: 6d70 6f73 6545 7373 656e 7469 616c 4d61  mposeEssentialMa
+000164b0: 7420 3c68 7474 7073 3a2f 2f64 6f63 732e  t <https://docs.
+000164c0: 6f70 656e 6376 2e6f 7267 2f6d 6173 7465  opencv.org/maste
+000164d0: 722f 6439 2f64 3063 2f67 726f 7570 5f5f  r/d9/d0c/group__
+000164e0: 6361 6c69 6233 642e 6874 6d6c 2367 6135  calib3d.html#ga5
+000164f0: 3461 3266 3562 3366 3861 6561 6636 6337  4a2f5b3f8aeaf6c7
+00016500: 3664 3461 3331 6465 6365 3835 6435 643e  6d4a31dece85d5d>
+00016510: 605f 0a20 2020 2020 2020 2020 2020 2060  `_.            `
+00016520: 6f70 656e 6376 2e72 6563 6f76 6572 506f  opencv.recoverPo
+00016530: 7365 203c 6874 7470 733a 2f2f 646f 6373  se <https://docs
+00016540: 2e6f 7065 6e63 762e 6f72 672f 6d61 7374  .opencv.org/mast
+00016550: 6572 2f64 392f 6430 632f 6772 6f75 705f  er/d9/d0c/group_
+00016560: 5f63 616c 6962 3364 2e68 746d 6c23 6761  _calib3d.html#ga
+00016570: 6462 3764 3264 6663 6331 3834 6331 6432  db7d2dfcc184c1d2
+00016580: 6634 3936 6438 3633 3966 3433 3731 6330  f496d8639f4371c0
+00016590: 3e60 5f0a 2020 2020 2020 2020 2222 220a  >`_.        """.
+000165a0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+000165b0: 7461 6e63 6528 502c 2046 6561 7475 7265  tance(P, Feature
+000165c0: 4d61 7463 6829 3a0a 2020 2020 2020 2020  Match):.        
+000165d0: 2020 2020 2320 7061 7373 6564 2061 204d      # passed a M
+000165e0: 6174 6368 206f 626a 6563 740a 2020 2020  atch object.    
+000165f0: 2020 2020 2020 2020 6d61 7463 6820 3d20          match = 
+00016600: 500a 0a20 2020 2020 2020 2020 2020 2072  P..            r
+00016610: 6574 7661 6c2c 2052 2c20 742c 206d 6173  etval, R, t, mas
+00016620: 6b20 3d20 6376 2e72 6563 6f76 6572 506f  k = cv.recoverPo
+00016630: 7365 280a 2020 2020 2020 2020 2020 2020  se(.            
+00016640: 2020 2020 453d 452c 0a20 2020 2020 2020      E=E,.       
+00016650: 2020 2020 2020 2020 2070 6f69 6e74 7331           points1
+00016660: 3d6d 6174 6368 2e70 312e 542c 0a20 2020  =match.p1.T,.   
+00016670: 2020 2020 2020 2020 2020 2020 2070 6f69               poi
+00016680: 6e74 7332 3d6d 6174 6368 2e70 322e 542c  nts2=match.p2.T,
+00016690: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000166a0: 2063 616d 6572 614d 6174 7269 783d 7365   cameraMatrix=se
+000166b0: 6c66 2e43 2829 5b3a 332c 203a 335d 2c0a  lf.C()[:3, :3],.
+000166c0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+000166d0: 2020 2020 2020 2020 2020 2320 6e6f 7420            # not 
+000166e0: 6578 706c 6963 6974 6c79 2073 7461 7465  explicitly state
+000166f0: 642c 2062 7574 2073 6565 6d73 2074 6861  d, but seems tha
+00016700: 7420 7468 6973 2072 6574 7572 6e73 2028  t this returns (
+00016710: 522c 2074 2920 6672 6f6d 0a20 2020 2020  R, t) from.     
+00016720: 2020 2020 2020 2023 2063 616d 6572 6120         # camera 
+00016730: 746f 2077 6f72 6c64 0a0a 2020 2020 2020  to world..      
+00016740: 2020 2020 2020 7265 7475 726e 2053 4533        return SE3
+00016750: 2e52 7428 522c 2074 292e 696e 7628 290a  .Rt(R, t).inv().
+00016760: 0a20 2020 2020 2020 2065 6c73 653a 0a0a  .        else:..
+00016770: 2020 2020 2020 2020 2020 2020 5231 2c20              R1, 
+00016780: 5232 2c20 7420 3d20 6376 2e64 6563 6f6d  R2, t = cv.decom
+00016790: 706f 7365 4573 7365 6e74 6961 6c4d 6174  poseEssentialMat
+000167a0: 2845 3d45 290a 2020 2020 2020 2020 2020  (E=E).          
+000167b0: 2020 2320 6e6f 7420 6578 706c 6963 6974    # not explicit
+000167c0: 6c79 2073 7461 7465 642c 2062 7574 2073  ly stated, but s
+000167d0: 6565 6d73 2074 6861 7420 7468 6973 2072  eems that this r
+000167e0: 6574 7572 6e73 2028 522c 2074 2920 6672  eturns (R, t) fr
+000167f0: 6f6d 0a20 2020 2020 2020 2020 2020 2023  om.            #
+00016800: 2063 616d 6572 6120 746f 2077 6f72 6c64   camera to world
+00016810: 0a0a 2020 2020 2020 2020 2020 2020 706f  ..            po
+00016820: 7373 6962 6c65 7320 3d20 5b28 5231 2c20  ssibles = [(R1, 
+00016830: 7429 2c20 2852 312c 202d 7429 2c20 2852  t), (R1, -t), (R
+00016840: 322c 2074 292c 2028 5232 2c20 2d74 295d  2, t), (R2, -t)]
+00016850: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
+00016860: 2062 6173 652e 6973 7665 6374 6f72 2850   base.isvector(P
+00016870: 2c20 3329 3a0a 2020 2020 2020 2020 2020  , 3):.          
+00016880: 2020 2020 2020 666f 7220 5274 2069 6e20        for Rt in 
+00016890: 706f 7373 6962 6c65 733a 0a20 2020 2020  possibles:.     
+000168a0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+000168b0: 6f73 6520 3d20 5345 332e 5274 2852 745b  ose = SE3.Rt(Rt[
+000168c0: 305d 2c20 5274 5b31 5d29 2e69 6e76 2829  0], Rt[1]).inv()
+000168d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000168e0: 2020 2020 2070 203d 2073 656c 662e 7072       p = self.pr
+000168f0: 6f6a 6563 745f 706f 696e 7428 502c 2070  oject_point(P, p
+00016900: 6f73 653d 706f 7365 2c20 6265 6869 6e64  ose=pose, behind
+00016910: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
+00016920: 2020 2020 2020 2020 2020 2023 2063 6865             # che
+00016930: 636b 2069 6620 706f 696e 7420 6973 2070  ck if point is p
+00016940: 726f 6a65 6374 6564 2062 6568 696e 6420  rojected behind 
+00016950: 7468 6520 6361 6d65 7261 2c20 696e 6469  the camera, indi
+00016960: 6361 7465 640a 2020 2020 2020 2020 2020  cated.          
+00016970: 2020 2020 2020 2020 2020 2320 6279 206e            # by n
+00016980: 616e 2076 616c 7565 730a 2020 2020 2020  an values.      
+00016990: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000169a0: 206e 6f74 206e 702e 6973 6e61 6e28 705b   not np.isnan(p[
+000169b0: 305d 293a 0a20 2020 2020 2020 2020 2020  0]):.           
+000169c0: 2020 2020 2020 2020 2020 2020 2023 2072               # r
+000169d0: 6574 7572 6e20 7468 6520 6669 7273 7420  eturn the first 
+000169e0: 676f 6f64 206f 6e65 0a20 2020 2020 2020  good one.       
+000169f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016a00: 2072 6574 7572 6e20 706f 7365 0a20 2020   return pose.   
+00016a10: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00016a20: 2020 2020 2020 2020 2020 2020 2020 2054                 T
+00016a30: 203d 2053 4533 2e45 6d70 7479 2829 0a20   = SE3.Empty(). 
+00016a40: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00016a50: 6f72 2052 7420 696e 2070 6f73 7369 626c  or Rt in possibl
+00016a60: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
+00016a70: 2020 2020 2020 2020 706f 7365 203d 2053          pose = S
+00016a80: 4533 2e52 7428 5274 5b30 5d2c 2052 745b  E3.Rt(Rt[0], Rt[
+00016a90: 315d 292e 696e 7628 290a 2020 2020 2020  1]).inv().      
+00016aa0: 2020 2020 2020 2020 2020 2020 2020 542e                T.
+00016ab0: 6170 7065 6e64 2870 6f73 6529 0a20 2020  append(pose).   
+00016ac0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00016ad0: 7572 6e20 540a 0a20 2020 2023 203d 3d3d  urn T..    # ===
+00016ae0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00016af0: 3d3d 2069 6d61 6765 2070 6c61 6e65 206d  == image plane m
+00016b00: 6f74 696f 6e20 3d3d 3d3d 3d3d 3d3d 3d3d  otion ==========
+00016b10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00016b20: 3d3d 3d20 230a 0a20 2020 2064 6566 2076  === #..    def v
+00016b30: 6973 6a61 635f 7028 7365 6c66 2c20 7576  isjac_p(self, uv
+00016b40: 2c20 6465 7074 6829 3a0a 2020 2020 2020  , depth):.      
+00016b50: 2020 7222 2222 0a20 2020 2020 2020 2056    r""".        V
+00016b60: 6973 7561 6c20 4a61 636f 6269 616e 2066  isual Jacobian f
+00016b70: 6f72 2070 6f69 6e74 2066 6561 7475 7265  or point feature
+00016b80: 730a 0a20 2020 2020 2020 203a 7061 7261  s..        :para
+00016b90: 6d20 703a 2069 6d61 6765 2070 6c61 6e65  m p: image plane
+00016ba0: 2070 6f69 6e74 206f 7220 706f 696e 7473   point or points
+00016bb0: 0a20 2020 2020 2020 203a 7479 7065 2070  .        :type p
+00016bc0: 3a20 6172 7261 795f 6c69 6b65 2832 292c  : array_like(2),
+00016bd0: 206e 6461 7272 6179 2832 2c4e 290a 2020   ndarray(2,N).  
+00016be0: 2020 2020 2020 3a70 6172 616d 2064 6570        :param dep
+00016bf0: 7468 3a20 706f 696e 7420 6465 7074 680a  th: point depth.
+00016c00: 2020 2020 2020 2020 3a74 7970 6520 6465          :type de
+00016c10: 7074 683a 2066 6c6f 6174 2c20 6172 7261  pth: float, arra
+00016c20: 795f 6c69 6b65 284e 290a 2020 2020 2020  y_like(N).      
+00016c30: 2020 3a72 6574 7572 6e3a 2076 6973 7561    :return: visua
+00016c40: 6c20 4a61 636f 6269 616e 206d 6174 7269  l Jacobian matri
+00016c50: 780a 2020 2020 2020 2020 3a72 7479 7065  x.        :rtype
+00016c60: 3a20 6e64 6172 7261 7928 322c 3629 2c20  : ndarray(2,6), 
+00016c70: 6e64 6172 7261 7928 324e 2c36 290a 0a20  ndarray(2N,6).. 
+00016c80: 2020 2020 2020 2043 6f6d 7075 7465 2074         Compute t
+00016c90: 6865 2069 6d61 6765 204a 6163 6f62 6961  he image Jacobia
+00016ca0: 6e20 3a6d 6174 683a 605c 6d61 747b 4a7d  n :math:`\mat{J}
+00016cb0: 6020 7768 6963 6820 6d61 7073 0a0a 2020  ` which maps..  
+00016cc0: 2020 2020 2020 2e2e 206d 6174 683a 3a0a        .. math::.
+00016cd0: 0a20 2020 2020 2020 2020 2020 205c 6476  .            \dv
+00016ce0: 6563 7b70 7d20 3d20 5c6d 6174 7b4a 7d28  ec{p} = \mat{J}(
+00016cf0: 5c76 6563 7b70 7d2c 207a 2920 5c76 6563  \vec{p}, z) \vec
+00016d00: 7b5c 6e75 7d0a 0a20 2020 2020 2020 2063  {\nu}..        c
+00016d10: 616d 6572 6120 7370 6174 6961 6c20 7665  amera spatial ve
+00016d20: 6c6f 6369 7479 203a 6d61 7468 3a60 5c76  locity :math:`\v
+00016d30: 6563 7b5c 6e75 7d60 2074 6f20 7468 6520  ec{\nu}` to the 
+00016d40: 696d 6167 6520 706c 616e 6520 7665 6c6f  image plane velo
+00016d50: 6369 7479 0a20 2020 2020 2020 203a 6d61  city.        :ma
+00016d60: 7468 3a60 5c64 7665 637b 707d 6020 6f66  th:`\dvec{p}` of
+00016d70: 2074 6865 2070 6f69 6e74 2e0a 0a20 2020   the point...   
+00016d80: 2020 2020 2049 6620 6060 7060 6020 6465       If ``p`` de
+00016d90: 7363 7269 6265 7320 6d75 6c74 6970 6c65  scribes multiple
+00016da0: 2070 6f69 6e74 7320 7468 656e 2072 6574   points then ret
+00016db0: 7572 6e20 6120 7374 6163 6b20 6f66 2074  urn a stack of t
+00016dc0: 6865 7365 0a20 2020 2020 2020 203a 6d61  hese.        :ma
+00016dd0: 7468 3a60 325c 7469 6d65 7320 3660 206d  th:`2\times 6` m
+00016de0: 6174 7269 6365 732c 206f 6e65 2070 6572  atrices, one per
+00016df0: 2070 6f69 6e74 2e0a 0a20 2020 2020 2020   point...       
+00016e00: 2044 6570 7468 2069 7320 7468 6520 7a2d   Depth is the z-
+00016e10: 636f 6d70 6f6e 656e 7420 6f66 2074 6865  component of the
+00016e20: 2070 6f69 6e74 2773 2063 6f6f 7264 696e   point's coordin
+00016e30: 6174 6520 696e 2074 6865 2063 616d 6572  ate in the camer
+00016e40: 6120 6672 616d 652e 0a20 2020 2020 2020  a frame..       
+00016e50: 2049 6620 6060 6465 7074 6860 6020 6973   If ``depth`` is
+00016e60: 2061 2073 6361 6c61 7220 7468 656e 2069   a scalar then i
+00016e70: 7420 6973 2074 6865 2064 6570 7468 2066  t is the depth f
+00016e80: 6f72 2061 6c6c 2070 6f69 6e74 732e 0a0a  or all points...
+00016e90: 2020 2020 2020 2020 4578 616d 706c 653a          Example:
+00016ea0: 0a0a 2020 2020 2020 2020 2e2e 2072 756e  ..        .. run
+00016eb0: 626c 6f63 6b3a 3a20 7079 636f 6e0a 0a20  block:: pycon.. 
+00016ec0: 2020 2020 2020 2020 2020 203e 3e3e 2066             >>> f
+00016ed0: 726f 6d20 6d61 6368 696e 6576 6973 696f  rom machinevisio
+00016ee0: 6e74 6f6f 6c62 6f78 2069 6d70 6f72 7420  ntoolbox import 
+00016ef0: 4365 6e74 7261 6c43 616d 6572 610a 2020  CentralCamera.  
+00016f00: 2020 2020 2020 2020 2020 3e3e 3e20 6672            >>> fr
+00016f10: 6f6d 2073 7061 7469 616c 6d61 7468 2069  om spatialmath i
+00016f20: 6d70 6f72 7420 5345 330a 2020 2020 2020  mport SE3.      
+00016f30: 2020 2020 2020 3e3e 3e20 6361 6d65 7261        >>> camera
+00016f40: 203d 2043 656e 7472 616c 4361 6d65 7261   = CentralCamera
+00016f50: 2e44 6566 6175 6c74 2829 0a20 2020 2020  .Default().     
+00016f60: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+00016f70: 612e 7669 736a 6163 5f70 2828 3230 302c  a.visjac_p((200,
+00016f80: 2033 3030 292c 2032 290a 0a20 2020 2020   300), 2)..     
+00016f90: 2020 203a 7265 6665 7265 6e63 6573 3a0a     :references:.
+00016fa0: 2020 2020 2020 2020 2020 2020 2d20 4120              - A 
+00016fb0: 7475 746f 7269 616c 206f 6e20 5669 7375  tutorial on Visu
+00016fc0: 616c 2053 6572 766f 2043 6f6e 7472 6f6c  al Servo Control
+00016fd0: 2c20 4875 7463 6869 6e73 6f6e 2c20 4861  , Hutchinson, Ha
+00016fe0: 6765 7220 2620 436f 726b 652c 0a20 2020  ger & Corke,.   
+00016ff0: 2020 2020 2020 2020 2020 2049 4545 4520             IEEE 
+00017000: 5472 616e 732e 2052 2641 2c20 566f 6c20  Trans. R&A, Vol 
+00017010: 3132 2835 292c 204f 6374 2c20 3139 3936  12(5), Oct, 1996
+00017020: 2c20 7070 2036 3531 2d36 3730 2e0a 2020  , pp 651-670..  
+00017030: 2020 2020 2020 2020 2020 2d20 526f 626f            - Robo
+00017040: 7469 6373 2c20 5669 7369 6f6e 2026 2043  tics, Vision & C
+00017050: 6f6e 7472 6f6c 2066 6f72 2050 7974 686f  ontrol for Pytho
+00017060: 6e2c 2053 6563 7469 6f6e 2031 352e 322e  n, Section 15.2.
+00017070: 312c 2050 2e20 436f 726b 652c 0a20 2020  1, P. Corke,.   
+00017080: 2020 2020 2020 2020 2020 2053 7072 696e             Sprin
+00017090: 6765 7220 3230 3233 2e0a 0a20 2020 2020  ger 2023...     
+000170a0: 2020 203a 7365 6561 6c73 6f3a 203a 6d65     :seealso: :me
+000170b0: 7468 3a60 666c 6f77 6669 656c 6460 203a  th:`flowfield` :
+000170c0: 6d65 7468 3a60 7669 736a 6163 5f70 5f70  meth:`visjac_p_p
+000170d0: 6f6c 6172 6020 3a6d 6574 683a 6076 6973  olar` :meth:`vis
+000170e0: 6a61 635f 6c60 203a 6d65 7468 3a60 7669  jac_l` :meth:`vi
+000170f0: 736a 6163 5f65 600a 2020 2020 2020 2020  sjac_e`.        
+00017100: 2222 220a 0a20 2020 2020 2020 2075 7620  """..        uv 
+00017110: 3d20 6261 7365 2e67 6574 6d61 7472 6978  = base.getmatrix
+00017120: 2875 762c 2028 322c 204e 6f6e 6529 290a  (uv, (2, None)).
+00017130: 2020 2020 2020 2020 5a20 3d20 6465 7074          Z = dept
+00017140: 680a 0a20 2020 2020 2020 205a 203d 2062  h..        Z = b
+00017150: 6173 652e 6765 7476 6563 746f 7228 5a29  ase.getvector(Z)
+00017160: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
+00017170: 5a29 203d 3d20 313a 0a20 2020 2020 2020  Z) == 1:.       
+00017180: 2020 2020 205a 203d 206e 702e 7265 7065       Z = np.repe
+00017190: 6174 285a 2c20 7576 2e73 6861 7065 5b31  at(Z, uv.shape[1
+000171a0: 5d29 0a20 2020 2020 2020 2065 6c69 6620  ]).        elif 
+000171b0: 6c65 6e28 5a29 2021 3d20 7576 2e73 6861  len(Z) != uv.sha
+000171c0: 7065 5b31 5d3a 0a20 2020 2020 2020 2020  pe[1]:.         
+000171d0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+000171e0: 726f 7228 225a 206d 7573 7420 6265 2061  ror("Z must be a
+000171f0: 2073 6361 6c61 7220 6f72 2068 6176 6520   scalar or have 
+00017200: 7361 6d65 206e 756d 6265 7220 6f66 2063  same number of c
+00017210: 6f6c 756d 6e73 2061 7320 7576 2229 0a0a  olumns as uv")..
+00017220: 2020 2020 2020 2020 4c20 3d20 6e70 2e65          L = np.e
+00017230: 6d70 7479 2828 302c 2036 2929 2020 2320  mpty((0, 6))  # 
+00017240: 656d 7074 7920 6d61 7472 6978 0a0a 2020  empty matrix..  
+00017250: 2020 2020 2020 4b20 3d20 7365 6c66 2e4b        K = self.K
+00017260: 0a20 2020 2020 2020 204b 696e 7620 3d20  .        Kinv = 
+00017270: 6e70 2e6c 696e 616c 672e 696e 7628 4b29  np.linalg.inv(K)
+00017280: 0a0a 2020 2020 2020 2020 666f 7220 7a2c  ..        for z,
+00017290: 2070 2069 6e20 7a69 7028 5a2c 2075 762e   p in zip(Z, uv.
+000172a0: 5429 3a20 2023 2069 7465 7261 7465 206f  T):  # iterate o
+000172b0: 7665 7220 6561 6368 2063 6f6c 756d 6e20  ver each column 
+000172c0: 2870 6f69 6e74 290a 0a20 2020 2020 2020  (point)..       
+000172d0: 2020 2020 2023 2063 6f6e 7665 7274 2074       # convert t
+000172e0: 6f20 6e6f 726d 616c 697a 6564 2069 6d61  o normalized ima
+000172f0: 6765 2d70 6c61 6e65 2063 6f6f 7264 696e  ge-plane coordin
+00017300: 6174 6573 0a20 2020 2020 2020 2020 2020  ates.           
+00017310: 2078 7920 3d20 4b69 6e76 2040 2062 6173   xy = Kinv @ bas
+00017320: 652e 6532 6828 7029 0a20 2020 2020 2020  e.e2h(p).       
+00017330: 2020 2020 2078 203d 2078 795b 302c 2030       x = xy[0, 0
+00017340: 5d0a 2020 2020 2020 2020 2020 2020 7920  ].            y 
+00017350: 3d20 7879 5b31 2c20 305d 0a0a 2020 2020  = xy[1, 0]..    
+00017360: 2020 2020 2020 2020 2320 3278 3620 4a61          # 2x6 Ja
+00017370: 636f 6269 616e 2066 6f72 2074 6869 7320  cobian for this 
+00017380: 706f 696e 740a 2020 2020 2020 2020 2020  point.          
+00017390: 2020 2320 666d 743a 206f 6666 0a20 2020    # fmt: off.   
+000173a0: 2020 2020 2020 2020 204c 7020 3d20 4b5b           Lp = K[
+000173b0: 3a32 2c3a 325d 2040 206e 702e 6172 7261  :2,:2] @ np.arra
+000173c0: 7928 0a20 2020 2020 2020 2020 2020 2020  y(.             
+000173d0: 2020 205b 205b 2d31 2f7a 2c20 2030 2c20     [ [-1/z,  0, 
+000173e0: 2020 2020 782f 7a2c 2078 202a 2079 2c20      x/z, x * y, 
+000173f0: 2020 2020 202d 2831 202b 2078 2a2a 3229       -(1 + x**2)
+00017400: 2c20 795d 2c0a 2020 2020 2020 2020 2020  , y],.          
+00017410: 2020 2020 2020 2020 5b20 302c 2020 202d          [ 0,   -
+00017420: 312f 7a2c 2020 2079 2f7a 2c20 2831 202b  1/z,   y/z, (1 +
+00017430: 2079 2a2a 3229 2c20 2d78 2a79 2c20 2020   y**2), -x*y,   
+00017440: 2020 2020 2d78 5d20 5d29 0a20 2020 2020      -x] ]).     
+00017450: 2020 2020 2020 2023 2066 6d74 3a20 6f6e         # fmt: on
+00017460: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
+00017470: 7461 636b 2074 6865 6d20 7665 7274 6963  tack them vertic
+00017480: 616c 6c79 0a20 2020 2020 2020 2020 2020  ally.           
+00017490: 204c 203d 206e 702e 7673 7461 636b 285b   L = np.vstack([
+000174a0: 4c2c 204c 705d 290a 0a20 2020 2020 2020  L, Lp])..       
+000174b0: 2072 6574 7572 6e20 4c0a 0a20 2020 2064   return L..    d
+000174c0: 6566 2076 6973 6a61 635f 705f 706f 6c61  ef visjac_p_pola
+000174d0: 7228 7365 6c66 2c20 702c 205a 293a 0a20  r(self, p, Z):. 
+000174e0: 2020 2020 2020 2072 2222 220a 2020 2020         r""".    
+000174f0: 2020 2020 5669 7375 616c 204a 6163 6f62      Visual Jacob
+00017500: 6961 6e20 666f 7220 706f 696e 7420 6665  ian for point fe
+00017510: 6174 7572 6573 2069 6e20 706f 6c61 7220  atures in polar 
+00017520: 636f 6f72 6469 6e61 7465 730a 0a20 2020  coordinates..   
+00017530: 2020 2020 203a 7061 7261 6d20 703a 2069       :param p: i
+00017540: 6d61 6765 2070 6c61 6e65 2070 6f69 6e74  mage plane point
+00017550: 206f 7220 706f 696e 7473 0a20 2020 2020   or points.     
+00017560: 2020 203a 7479 7065 2070 3a20 6172 7261     :type p: arra
+00017570: 795f 6c69 6b65 2832 292c 206e 6461 7272  y_like(2), ndarr
+00017580: 6179 2832 2c4e 290a 2020 2020 2020 2020  ay(2,N).        
+00017590: 3a70 6172 616d 2064 6570 7468 3a20 706f  :param depth: po
+000175a0: 696e 7420 6465 7074 680a 2020 2020 2020  int depth.      
+000175b0: 2020 3a74 7970 6520 6465 7074 683a 2066    :type depth: f
+000175c0: 6c6f 6174 2c20 6172 7261 795f 6c69 6b65  loat, array_like
+000175d0: 284e 290a 2020 2020 2020 2020 3a72 6574  (N).        :ret
+000175e0: 7572 6e3a 2076 6973 7561 6c20 4a61 636f  urn: visual Jaco
+000175f0: 6269 616e 206d 6174 7269 7820 696e 2070  bian matrix in p
+00017600: 6f6c 6172 2063 6f6f 7264 696e 6174 6573  olar coordinates
+00017610: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+00017620: 206e 6461 7272 6179 2832 2c36 292c 206e   ndarray(2,6), n
+00017630: 6461 7272 6179 2832 4e2c 3629 0a0a 2020  darray(2N,6)..  
+00017640: 2020 2020 2020 436f 6d70 7574 6520 7468        Compute th
+00017650: 6520 696d 6167 6520 4a61 636f 6269 616e  e image Jacobian
+00017660: 203a 6d61 7468 3a60 5c6d 6174 7b4a 7d60   :math:`\mat{J}`
+00017670: 2077 6869 6368 206d 6170 730a 0a20 2020   which maps..   
+00017680: 2020 2020 202e 2e20 6d61 7468 3a3a 0a0a       .. math::..
+00017690: 2020 2020 2020 2020 2020 2020 5c62 6567              \beg
+000176a0: 696e 7b70 6d61 7472 6978 7d20 5c64 6f74  in{pmatrix} \dot
+000176b0: 7b5c 7068 697d 205c 5c20 5c64 6f74 7b72  {\phi} \\ \dot{r
+000176c0: 7d20 5c65 6e64 7b70 6d61 7472 6978 7d20  } \end{pmatrix} 
+000176d0: 3d20 5c6d 6174 7b4a 7d28 5c76 6563 7b70  = \mat{J}(\vec{p
+000176e0: 7d2c 207a 2920 5c76 6563 7b5c 6e75 7d0a  }, z) \vec{\nu}.
+000176f0: 0a20 2020 2020 2020 2063 616d 6572 6120  .        camera 
+00017700: 7370 6174 6961 6c20 7665 6c6f 6369 7479  spatial velocity
+00017710: 203a 6d61 7468 3a60 5c76 6563 7b5c 6e75   :math:`\vec{\nu
+00017720: 7d60 2074 6f20 7468 6520 696d 6167 6520  }` to the image 
+00017730: 706c 616e 6520 7665 6c6f 6369 7479 0a20  plane velocity. 
+00017740: 2020 2020 2020 206f 6620 7468 6520 706f         of the po
+00017750: 696e 7420 6578 7072 6573 7365 6420 696e  int expressed in
+00017760: 2070 6f6c 6172 2063 6f6f 7264 696e 6174   polar coordinat
+00017770: 6520 666f 726d 203a 6d61 7468 3a60 285c  e form :math:`(\
+00017780: 7068 692c 2072 2960 2e0a 0a20 2020 2020  phi, r)`...     
+00017790: 2020 2049 6620 6060 7060 6020 6465 7363     If ``p`` desc
+000177a0: 7269 6265 7320 6d75 6c74 6970 6c65 2070  ribes multiple p
+000177b0: 6f69 6e74 7320 7468 656e 2072 6574 7572  oints then retur
+000177c0: 6e20 6120 7374 6163 6b20 6f66 2074 6865  n a stack of the
+000177d0: 7365 0a20 2020 2020 2020 203a 6d61 7468  se.        :math
+000177e0: 3a60 325c 7469 6d65 7320 3660 206d 6174  :`2\times 6` mat
+000177f0: 7269 6365 732c 206f 6e65 2070 6572 2070  rices, one per p
+00017800: 6f69 6e74 2e0a 0a20 2020 2020 2020 2044  oint...        D
+00017810: 6570 7468 2069 7320 7468 6520 7a2d 636f  epth is the z-co
+00017820: 6d70 6f6e 656e 7420 6f66 2074 6865 2070  mponent of the p
+00017830: 6f69 6e74 2773 2063 6f6f 7264 696e 6174  oint's coordinat
+00017840: 6520 696e 2074 6865 2063 616d 6572 6120  e in the camera 
+00017850: 6672 616d 652e 0a20 2020 2020 2020 2049  frame..        I
+00017860: 6620 6060 6465 7074 6860 6020 6973 2061  f ``depth`` is a
+00017870: 2073 6361 6c61 7220 7468 656e 2069 7420   scalar then it 
+00017880: 6973 2074 6865 2064 6570 7468 2066 6f72  is the depth for
+00017890: 2061 6c6c 2070 6f69 6e74 732e 0a0a 2020   all points...  
+000178a0: 2020 2020 2020 4578 616d 706c 653a 0a0a        Example:..
+000178b0: 2020 2020 2020 2020 2e2e 2072 756e 626c          .. runbl
+000178c0: 6f63 6b3a 3a20 7079 636f 6e0a 0a20 2020  ock:: pycon..   
+000178d0: 2020 2020 2020 2020 203e 3e3e 2066 726f           >>> fro
+000178e0: 6d20 6d61 6368 696e 6576 6973 696f 6e74  m machinevisiont
+000178f0: 6f6f 6c62 6f78 2069 6d70 6f72 7420 4365  oolbox import Ce
+00017900: 6e74 7261 6c43 616d 6572 610a 2020 2020  ntralCamera.    
+00017910: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
+00017920: 2073 7061 7469 616c 6d61 7468 2069 6d70   spatialmath imp
+00017930: 6f72 7420 5345 330a 2020 2020 2020 2020  ort SE3.        
+00017940: 2020 2020 3e3e 3e20 6361 6d65 7261 203d      >>> camera =
+00017950: 2043 656e 7472 616c 4361 6d65 7261 2e44   CentralCamera.D
+00017960: 6566 6175 6c74 2829 0a20 2020 2020 2020  efault().       
+00017970: 2020 2020 203e 3e3e 2063 616d 6572 612e       >>> camera.
+00017980: 7669 736a 6163 5f70 5f70 6f6c 6172 2828  visjac_p_polar((
+00017990: 3230 302c 2033 3030 292c 2032 290a 0a20  200, 300), 2).. 
+000179a0: 2020 2020 2020 203a 7265 6665 7265 6e63         :referenc
+000179b0: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
+000179c0: 2d20 436f 6d62 696e 696e 6720 4361 7274  - Combining Cart
+000179d0: 6573 6961 6e20 616e 6420 706f 6c61 7220  esian and polar 
+000179e0: 636f 6f72 6469 6e61 7465 7320 696e 2049  coordinates in I
+000179f0: 4256 532e 0a20 2020 2020 2020 2020 2020  BVS..           
+00017a00: 2020 2043 6f72 6b65 2050 492c 2053 7069     Corke PI, Spi
+00017a10: 6e64 6c65 7220 462c 2043 6861 756d 6574  ndler F, Chaumet
+00017a20: 7465 2046 0a20 2020 2020 2020 2020 2020  te F.           
+00017a30: 2020 2049 524f 5320 3230 3039 2c20 7070     IROS 2009, pp
+00017a40: 2035 3936 32e2 8093 3539 3637 0a20 2020   5962...5967.   
+00017a50: 2020 2020 2020 2020 202d 2052 6f62 6f74           - Robot
+00017a60: 6963 732c 2056 6973 696f 6e20 2620 436f  ics, Vision & Co
+00017a70: 6e74 726f 6c20 666f 7220 5079 7468 6f6e  ntrol for Python
+00017a80: 2c20 5365 6374 696f 6e20 3136 2e32 2050  , Section 16.2 P
+00017a90: 2e20 436f 726b 652c 0a20 2020 2020 2020  . Corke,.       
+00017aa0: 2020 2020 2020 2053 7072 696e 6765 7220         Springer 
+00017ab0: 3230 3233 2e0a 0a20 2020 2020 2020 203a  2023...        :
+00017ac0: 7365 6561 6c73 6f3a 203a 6d65 7468 3a60  seealso: :meth:`
+00017ad0: 7669 736a 6163 5f70 6020 3a6d 6574 683a  visjac_p` :meth:
+00017ae0: 6076 6973 6a61 635f 6c60 203a 6d65 7468  `visjac_l` :meth
+00017af0: 3a60 7669 736a 6163 5f65 600a 2020 2020  :`visjac_e`.    
+00017b00: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
+00017b10: 204a 203d 205b 5d0a 2020 2020 2020 2020   J = [].        
+00017b20: 7020 3d20 736d 6261 7365 2e67 6574 6d61  p = smbase.getma
+00017b30: 7472 6978 2870 2c20 2832 2c20 4e6f 6e65  trix(p, (2, None
+00017b40: 2929 0a20 2020 2020 2020 2066 203d 2073  )).        f = s
+00017b50: 656c 662e 665b 305d 0a0a 2020 2020 2020  elf.f[0]..      
+00017b60: 2020 6966 2073 6d62 6173 652e 6973 7363    if smbase.issc
+00017b70: 616c 6172 285a 293a 0a20 2020 2020 2020  alar(Z):.       
+00017b80: 2020 2020 205a 203d 205b 5a5d 202a 2070       Z = [Z] * p
+00017b90: 2e73 6861 7065 5b31 5d0a 0a20 2020 2020  .shape[1]..     
+00017ba0: 2020 2066 6f72 2028 7068 692c 2072 292c     for (phi, r),
+00017bb0: 205a 6b20 696e 207a 6970 2870 2e54 2c20   Zk in zip(p.T, 
+00017bc0: 5a29 3a0a 0a20 2020 2020 2020 2020 2020  Z):..           
+00017bd0: 2023 206b 203d 2028 662a 2a32 202b 2072   # k = (f**2 + r
+00017be0: 2a2a 3229 202f 2066 0a20 2020 2020 2020  **2) / f.       
+00017bf0: 2020 2020 2023 206b 3220 3d20 6620 2f20       # k2 = f / 
+00017c00: 2872 202a 205a 6b29 0a0a 2020 2020 2020  (r * Zk)..      
+00017c10: 2020 2020 2020 6320 3d20 6e70 2e63 6f73        c = np.cos
+00017c20: 2870 6869 290a 2020 2020 2020 2020 2020  (phi).          
+00017c30: 2020 7320 3d20 6e70 2e73 696e 2870 6869    s = np.sin(phi
+00017c40: 290a 0a20 2020 2020 2020 2020 2020 2072  )..            r
+00017c50: 203d 206d 6178 2872 2c20 302e 3035 290a   = max(r, 0.05).
+00017c60: 2020 2020 2020 2020 2020 2020 4a6b 203d              Jk =
+00017c70: 206e 702e 6172 7261 7928 0a20 2020 2020   np.array(.     
+00017c80: 2020 2020 2020 2020 2020 205b 0a20 2020             [.   
+00017c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017ca0: 205b 2d73 202f 2072 202f 205a 6b2c 2063   [-s / r / Zk, c
+00017cb0: 202f 2072 202f 205a 6b2c 2030 2c20 2d63   / r / Zk, 0, -c
+00017cc0: 202f 2072 2c20 2d73 202f 2072 2c20 315d   / r, -s / r, 1]
+00017cd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00017ce0: 2020 2020 2020 5b63 202f 205a 6b2c 2073        [c / Zk, s
+00017cf0: 202f 205a 6b2c 202d 7220 2f20 5a6b 2c20   / Zk, -r / Zk, 
+00017d00: 2d28 3120 2b20 722a 2a32 2920 2a20 732c  -(1 + r**2) * s,
+00017d10: 2028 3120 2b20 722a 2a32 2920 2a20 632c   (1 + r**2) * c,
+00017d20: 2030 5d2c 0a20 2020 2020 2020 2020 2020   0],.           
+00017d30: 2020 2020 205d 0a20 2020 2020 2020 2020       ].         
+00017d40: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+00017d50: 2020 2320 4a6b 203d 206e 702e 6172 7261    # Jk = np.arra
+00017d60: 7928 5b0a 2020 2020 2020 2020 2020 2020  y([.            
+00017d70: 2320 2020 2020 5b20 2020 2020 6b32 202a  #     [     k2 *
+00017d80: 2073 7468 2c20 2020 2020 2d6b 3220 2a20   sth,     -k2 * 
+00017d90: 6374 682c 2020 2020 2020 302c 2066 202f  cth,      0, f /
+00017da0: 2072 202a 2063 7468 2c20 6620 2f20 7220   r * cth, f / r 
+00017db0: 2a20 7374 6820 2c20 2d31 5d2c 0a20 2020  * sth , -1],.   
+00017dc0: 2020 2020 2020 2020 2023 2020 2020 205b           #     [
+00017dd0: 2d66 202f 205a 6b20 2a20 6374 682c 202d  -f / Zk * cth, -
+00017de0: 6620 2f20 5a6b 202a 2073 7468 2c20 7220  f / Zk * sth, r 
+00017df0: 2f20 5a6b 2c20 2020 2020 6b20 2a20 7374  / Zk,     k * st
+00017e00: 682c 2020 2020 202d 6b20 2a20 6374 682c  h,     -k * cth,
+00017e10: 2020 305d 2c0a 2020 2020 2020 2020 2020    0],.          
+00017e20: 2020 2320 2020 2020 5d29 0a20 2020 2020    #     ]).     
+00017e30: 2020 2020 2020 2023 204a 6b20 3d20 6e70         # Jk = np
+00017e40: 2e61 7272 6179 285b 0a20 2020 2020 2020  .array([.       
+00017e50: 2020 2020 2023 2020 2020 205b 6374 682f       #     [cth/
+00017e60: 5a6b 202c 2073 7468 202f 205a 6b2c 202d  Zk , sth / Zk, -
+00017e70: 7220 2f20 5a6b 2c20 2020 2d28 312b 722a  r / Zk,   -(1+r*
+00017e80: 2a32 2920 2a20 7374 682c 2020 2020 202d  *2) * sth,     -
+00017e90: 6b20 2a20 6374 682c 2020 305d 2c0a 2020  k * cth,  0],.  
+00017ea0: 2020 2020 2020 2020 2020 2320 2020 2020            #     
+00017eb0: 5b20 2020 2020 6b32 202a 2073 7468 2c20  [     k2 * sth, 
+00017ec0: 2020 2020 2d6b 3220 2a20 6374 682c 2020      -k2 * cth,  
+00017ed0: 2020 2020 302c 2066 202f 2072 202a 2063      0, f / r * c
+00017ee0: 7468 2c20 6620 2f20 7220 2a20 7374 6820  th, f / r * sth 
+00017ef0: 2c20 2d31 5d5d 290a 0a20 2020 2020 2020  , -1]])..       
+00017f00: 2020 2020 204a 2e61 7070 656e 6428 4a6b       J.append(Jk
+00017f10: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00017f20: 6e20 6e70 2e76 7374 6163 6b28 4a29 0a0a  n np.vstack(J)..
+00017f30: 2020 2020 2020 2020 2320 6966 2030 0a20          # if 0. 
+00017f40: 2020 2020 2020 2023 2072 203d 2072 7428         # r = rt(
+00017f50: 3129 3b20 7468 6574 6120 3d20 7274 2832  1); theta = rt(2
+00017f60: 293b 0a0a 2020 2020 2020 2020 2320 2520  );..        # % 
+00017f70: 636f 6d70 7574 6520 7468 6520 6d61 7070  compute the mapp
+00017f80: 696e 6720 6672 6f6d 2075 762d 646f 7420  ing from uv-dot 
+00017f90: 746f 2072 2d74 6865 7461 2064 6f74 0a20  to r-theta dot. 
+00017fa0: 2020 2020 2020 2023 204d 203d 2031 2f72         # M = 1/r
+00017fb0: 202a 205b 722a 636f 7328 7468 6574 6129   * [r*cos(theta)
+00017fc0: 2072 2a73 696e 2874 6865 7461 293b 202d   r*sin(theta); -
+00017fd0: 7369 6e28 7468 6574 6129 2063 6f73 2874  sin(theta) cos(t
+00017fe0: 6865 7461 295d 3b0a 0a20 2020 2020 2020  heta)];..       
+00017ff0: 2023 2025 2063 6f6e 7665 7274 2072 2d74   # % convert r-t
+00018000: 6865 7461 2066 6f72 6d20 746f 2075 7620  heta form to uv 
+00018010: 666f 726d 0a20 2020 2020 2020 2023 2075  form.        # u
+00018020: 203d 2072 202a 2063 6f73 2874 6865 7461   = r * cos(theta
+00018030: 293b 2076 203d 2072 202a 2073 696e 2874  ); v = r * sin(t
+00018040: 6865 7461 293b 0a0a 2020 2020 2020 2020  heta);..        
+00018050: 2320 2520 636f 6d70 7574 6520 7468 6520  # % compute the 
+00018060: 4a61 636f 6269 616e 0a20 2020 2020 2020  Jacobian.       
+00018070: 2023 204a 203d 204d 202a 2063 616d 2e76   # J = M * cam.v
+00018080: 6973 6a61 635f 7028 5b75 3b20 765d 2c20  isjac_p([u; v], 
+00018090: 5a29 3b0a 0a20 2020 2064 6566 2076 6973  Z);..    def vis
+000180a0: 6a61 635f 6c28 7365 6c66 2c20 6c69 6e65  jac_l(self, line
+000180b0: 732c 2070 6c61 6e65 293a 0a20 2020 2020  s, plane):.     
+000180c0: 2020 2072 2222 220a 2020 2020 2020 2020     r""".        
+000180d0: 5669 7375 616c 204a 6163 6f62 6961 6e20  Visual Jacobian 
+000180e0: 666f 7220 6c69 6e65 2066 6561 7475 7265  for line feature
+000180f0: 730a 0a20 2020 2020 2020 203a 7061 7261  s..        :para
+00018100: 6d20 6c69 6e65 733a 2069 6d61 6765 2070  m lines: image p
+00018110: 6c61 6e65 206c 696e 6520 7061 7261 6d65  lane line parame
+00018120: 7465 7273 0a20 2020 2020 2020 203a 7479  ters.        :ty
+00018130: 7065 2070 3a20 6172 7261 795f 6c69 6b65  pe p: array_like
+00018140: 2832 292c 206e 6461 7272 6179 2832 2c4e  (2), ndarray(2,N
+00018150: 290a 2020 2020 2020 2020 3a70 6172 616d  ).        :param
+00018160: 2070 6c61 6e65 3a20 706c 616e 6520 636f   plane: plane co
+00018170: 6e74 6169 6e69 6e67 2074 6865 206c 696e  ntaining the lin
+00018180: 650a 2020 2020 2020 2020 3a74 7970 6520  e.        :type 
+00018190: 706c 616e 653a 2061 7272 6179 5f6c 696b  plane: array_lik
+000181a0: 6528 3429 0a20 2020 2020 2020 203a 7265  e(4).        :re
+000181b0: 7475 726e 3a20 7669 7375 616c 204a 6163  turn: visual Jac
+000181c0: 6f62 6961 6e20 6d61 7472 6978 2066 6f72  obian matrix for
+000181d0: 206c 696e 6520 6665 6174 7572 650a 2020   line feature.  
+000181e0: 2020 2020 2020 3a72 7479 7065 3a20 6e64        :rtype: nd
+000181f0: 6172 7261 7928 322c 3629 2c20 6e64 6172  array(2,6), ndar
+00018200: 7261 7928 324e 2c36 290a 0a20 2020 2020  ray(2N,6)..     
+00018210: 2020 2043 6f6d 7075 7465 2074 6865 204a     Compute the J
+00018220: 6163 6f62 6961 6e20 7768 6963 6820 6769  acobian which gi
+00018230: 7665 7320 7468 6520 7261 7465 7320 6f66  ves the rates of
+00018240: 2063 6861 6e67 6520 6f66 2074 6865 206c   change of the l
+00018250: 696e 650a 2020 2020 2020 2020 7061 7261  ine.        para
+00018260: 6d65 7465 7273 2069 6e20 7465 726d 7320  meters in terms 
+00018270: 6f66 2063 616d 6572 6120 7370 6174 6961  of camera spatia
+00018280: 6c20 7665 6c6f 6369 7479 2e0a 0a20 2020  l velocity...   
+00018290: 2020 2020 2046 6f72 2069 6d61 6765 2070       For image p
+000182a0: 6c61 6e65 7320 6c69 6e65 730a 0a20 2020  lanes lines..   
+000182b0: 2020 2020 202e 2e20 6d61 7468 3a3a 2075       .. math:: u
+000182c0: 205c 636f 7320 5c74 6865 7461 202b 2076   \cos \theta + v
+000182d0: 205c 7369 6e20 5c74 6865 7461 203d 205c   \sin \theta = \
+000182e0: 7268 6f0a 0a20 2020 2020 2020 2074 6865  rho..        the
+000182f0: 2069 6d61 6765 204a 6163 6f62 6961 6e20   image Jacobian 
+00018300: 3a6d 6174 683a 605c 6d61 747b 4a7d 6020  :math:`\mat{J}` 
+00018310: 6d61 7073 0a0a 2020 2020 2020 2020 2e2e  maps..        ..
+00018320: 206d 6174 683a 3a0a 0a20 2020 2020 2020   math::..       
+00018330: 2020 2020 205c 6265 6769 6e7b 706d 6174       \begin{pmat
+00018340: 7269 787d 205c 646f 747b 5c74 6865 7461  rix} \dot{\theta
+00018350: 7d20 5c5c 205c 646f 747b 5c72 686f 7d20  } \\ \dot{\rho} 
+00018360: 5c65 6e64 7b70 6d61 7472 6978 7d20 3d20  \end{pmatrix} = 
+00018370: 5c6d 6174 7b4a 7d28 5c76 6563 7b70 7d2c  \mat{J}(\vec{p},
+00018380: 207a 2920 5c76 6563 7b5c 6e75 7d0a 0a20   z) \vec{\nu}.. 
+00018390: 2020 2020 2020 2063 616d 6572 6120 7370         camera sp
+000183a0: 6174 6961 6c20 7665 6c6f 6369 7479 203a  atial velocity :
+000183b0: 6d61 7468 3a60 5c76 6563 7b5c 6e75 7d60  math:`\vec{\nu}`
+000183c0: 2074 6f20 7468 6520 696d 6167 6520 706c   to the image pl
+000183d0: 616e 6520 7665 6c6f 6369 7479 0a20 2020  ane velocity.   
+000183e0: 2020 2020 206f 6620 7468 6520 6c69 6e65       of the line
+000183f0: 2070 6172 616d 6574 6572 7320 3a6d 6174   parameters :mat
+00018400: 683a 6028 5c74 6865 7461 2c20 5c72 686f  h:`(\theta, \rho
+00018410: 2960 2e0a 0a20 2020 2020 2020 2054 6865  )`...        The
+00018420: 2077 6f72 6c64 2070 6c61 6e65 2063 6f6e   world plane con
+00018430: 7461 696e 696e 6720 7468 6520 6c69 6e65  taining the line
+00018440: 2069 7320 616c 736f 2072 6571 7569 7265   is also require
+00018450: 642c 2061 6e64 2069 7320 7072 6f76 6964  d, and is provid
+00018460: 6564 0a20 2020 2020 2020 2061 7320 6120  ed.        as a 
+00018470: 7665 6374 6f72 203a 6d61 7468 3a60 2861  vector :math:`(a
+00018480: 2c62 2c63 2c64 2960 2073 7563 6820 7468  ,b,c,d)` such th
+00018490: 6174 0a0a 2020 2020 2020 2020 2e2e 206d  at..        .. m
+000184a0: 6174 683a 2061 5820 2b20 6259 202b 635a  ath: aX + bY +cZ
+000184b0: 202b 2064 203d 2030 0a0a 2020 2020 2020   + d = 0..      
+000184c0: 2020 4966 2060 606c 696e 6573 6060 2064    If ``lines`` d
+000184d0: 6573 6372 6962 6573 206d 756c 7469 706c  escribes multipl
+000184e0: 6520 706f 696e 7473 2074 6865 6e20 7265  e points then re
+000184f0: 7475 726e 2061 2073 7461 636b 206f 6620  turn a stack of 
+00018500: 7468 6573 650a 2020 2020 2020 2020 3a6d  these.        :m
+00018510: 6174 683a 6032 5c74 696d 6573 2036 6020  ath:`2\times 6` 
+00018520: 6d61 7472 6963 6573 2c20 6f6e 6520 7065  matrices, one pe
+00018530: 7220 706f 696e 742e 0a0a 2020 2020 2020  r point...      
+00018540: 2020 4465 7074 6820 6973 2074 6865 207a    Depth is the z
+00018550: 2d63 6f6d 706f 6e65 6e74 206f 6620 7468  -component of th
+00018560: 6520 706f 696e 7427 7320 636f 6f72 6469  e point's coordi
+00018570: 6e61 7465 2069 6e20 7468 6520 6361 6d65  nate in the came
+00018580: 7261 2066 7261 6d65 2e0a 2020 2020 2020  ra frame..      
+00018590: 2020 4966 2060 6064 6570 7468 6060 2069    If ``depth`` i
+000185a0: 7320 6120 7363 616c 6172 2074 6865 6e20  s a scalar then 
+000185b0: 6974 2069 7320 7468 6520 6465 7074 6820  it is the depth 
+000185c0: 666f 7220 616c 6c20 706f 696e 7473 2e0a  for all points..
+000185d0: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+000185e0: 3a0a 0a20 2020 2020 2020 202e 2e20 7275  :..        .. ru
+000185f0: 6e62 6c6f 636b 3a3a 2070 7963 6f6e 0a0a  nblock:: pycon..
+00018600: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00018610: 6672 6f6d 206d 6163 6869 6e65 7669 7369  from machinevisi
+00018620: 6f6e 746f 6f6c 626f 7820 696d 706f 7274  ontoolbox import
+00018630: 2043 656e 7472 616c 4361 6d65 7261 0a20   CentralCamera. 
+00018640: 2020 2020 2020 2020 2020 203e 3e3e 2066             >>> f
+00018650: 726f 6d20 7370 6174 6961 6c6d 6174 6820  rom spatialmath 
+00018660: 696d 706f 7274 2053 4533 0a20 2020 2020  import SE3.     
+00018670: 2020 2020 2020 203e 3e3e 2063 616d 6572         >>> camer
+00018680: 6120 3d20 4365 6e74 7261 6c43 616d 6572  a = CentralCamer
+00018690: 612e 4465 6661 756c 7428 290a 2020 2020  a.Default().    
+000186a0: 2020 2020 2020 2020 3e3e 3e20 6361 6d65          >>> came
+000186b0: 7261 2e76 6973 6a61 635f 6c28 2830 2e32  ra.visjac_l((0.2
+000186c0: 2c20 3530 3029 2c20 2830 2c20 302c 2031  , 500), (0, 0, 1
+000186d0: 2c20 2d33 2929 0a0a 2020 2020 2020 2020  , -3))..        
+000186e0: 3a72 6566 6572 656e 6365 733a 0a20 2020  :references:.   
+000186f0: 2020 2020 2020 2020 202d 2041 204e 6577           - A New
+00018700: 2041 7070 726f 6163 6820 746f 2056 6973   Approach to Vis
+00018710: 7561 6c20 5365 7276 6f69 6e67 2069 6e20  ual Servoing in 
+00018720: 526f 626f 7469 6373 2c0a 2020 2020 2020  Robotics,.      
+00018730: 2020 2020 2020 2020 422e 2045 7370 6961          B. Espia
+00018740: 752c 2046 2e20 4368 6175 6d65 7474 652c  u, F. Chaumette,
+00018750: 2061 6e64 2050 2e20 5269 7665 732c 0a20   and P. Rives,. 
+00018760: 2020 2020 2020 2020 2020 2020 2049 4545               IEE
+00018770: 4520 5472 616e 7361 6374 696f 6e73 206f  E Transactions o
+00018780: 6e20 526f 626f 7469 6373 2061 6e64 2041  n Robotics and A
+00018790: 7574 6f6d 6174 696f 6e2c 0a20 2020 2020  utomation,.     
+000187a0: 2020 2020 2020 2020 2076 6f6c 2e20 382c           vol. 8,
+000187b0: 2070 702e 2033 3133 2d33 3236 2c20 4a75   pp. 313-326, Ju
+000187c0: 6e65 2031 3939 322e 0a20 2020 2020 2020  ne 1992..       
+000187d0: 2020 2020 202d 2056 6973 7561 6c20 7365       - Visual se
+000187e0: 7276 6f20 636f 6e74 726f 6c20 323a 2041  rvo control 2: A
+000187f0: 6476 616e 6365 6420 6170 7072 6f61 6368  dvanced approach
+00018800: 6573 0a20 2020 2020 2020 2020 2020 2020  es.             
+00018810: 2043 6861 756d 6574 7465 2046 2c20 4875   Chaumette F, Hu
+00018820: 7463 6869 6e73 6f6e 2053 2c0a 2020 2020  tchinson S,.    
+00018830: 2020 2020 2020 2020 2020 4945 4545 2052            IEEE R
+00018840: 6f62 6f74 2041 7574 6f6d 204d 6167 2031  obot Autom Mag 1
+00018850: 3428 3129 3a31 3039 e280 9331 3138 2028  4(1):109...118 (
+00018860: 3230 3037 290a 2020 2020 2020 2020 2020  2007).          
+00018870: 2020 2d20 526f 626f 7469 6373 2c20 5669    - Robotics, Vi
+00018880: 7369 6f6e 2026 2043 6f6e 7472 6f6c 2066  sion & Control f
+00018890: 6f72 2050 7974 686f 6e2c 2053 6563 7469  or Python, Secti
+000188a0: 6f6e 2031 352e 332e 312c 2050 2e20 436f  on 15.3.1, P. Co
+000188b0: 726b 652c 0a20 2020 2020 2020 2020 2020  rke,.           
+000188c0: 2020 2053 7072 696e 6765 7220 3230 3233     Springer 2023
+000188d0: 2e0a 0a20 2020 2020 2020 203a 7365 6561  ...        :seea
+000188e0: 6c73 6f3a 203a 6d65 7468 3a60 7669 736a  lso: :meth:`visj
+000188f0: 6163 5f70 6020 3a6d 6574 683a 6076 6973  ac_p` :meth:`vis
+00018900: 6a61 635f 705f 706f 6c61 7260 203a 6d65  jac_p_polar` :me
+00018910: 7468 3a60 7669 736a 6163 5f65 600a 2020  th:`visjac_e`.  
+00018920: 2020 2020 2020 2222 220a 0a20 2020 2020        """..     
+00018930: 2020 2061 2c20 622c 2063 2c20 6420 3d20     a, b, c, d = 
+00018940: 706c 616e 650a 0a20 2020 2020 2020 206c  plane..        l
+00018950: 696e 6573 203d 2073 6d62 6173 652e 6765  ines = smbase.ge
+00018960: 746d 6174 7269 7828 6c69 6e65 732c 2028  tmatrix(lines, (
+00018970: 322c 204e 6f6e 6529 290a 2020 2020 2020  2, None)).      
+00018980: 2020 6a61 6320 3d20 5b5d 0a20 2020 2020    jac = [].     
+00018990: 2020 2066 6f72 2074 6865 7461 2c20 7268     for theta, rh
+000189a0: 6f20 696e 206c 696e 6573 2e54 3a0a 2020  o in lines.T:.  
+000189b0: 2020 2020 2020 2020 2020 7374 6820 3d20            sth = 
+000189c0: 6e70 2e73 696e 2874 6865 7461 290a 2020  np.sin(theta).  
+000189d0: 2020 2020 2020 2020 2020 6374 6820 3d20            cth = 
+000189e0: 6e70 2e63 6f73 2874 6865 7461 290a 0a20  np.cos(theta).. 
+000189f0: 2020 2020 2020 2020 2020 206c 616d 5f74             lam_t
+00018a00: 6820 3d20 2861 202a 2073 7468 202d 2062  h = (a * sth - b
+00018a10: 202a 2063 7468 2920 2f20 640a 2020 2020   * cth) / d.    
+00018a20: 2020 2020 2020 2020 6c61 6d5f 7268 6f20          lam_rho 
+00018a30: 3d20 2861 202a 2072 686f 202a 2063 7468  = (a * rho * cth
+00018a40: 202b 2062 202a 2072 686f 202a 2073 7468   + b * rho * sth
+00018a50: 202b 2063 2920 2f20 640a 0a20 2020 2020   + c) / d..     
+00018a60: 2020 2020 2020 204c 203d 206e 702e 6172         L = np.ar
+00018a70: 7261 7928 0a20 2020 2020 2020 2020 2020  ray(.           
+00018a80: 2020 2020 205b 0a20 2020 2020 2020 2020       [.         
+00018a90: 2020 2020 2020 2020 2020 205b 0a20 2020             [.   
+00018aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018ab0: 2020 2020 206c 616d 5f74 6820 2a20 6374       lam_th * ct
+00018ac0: 682c 0a20 2020 2020 2020 2020 2020 2020  h,.             
+00018ad0: 2020 2020 2020 2020 2020 206c 616d 5f74             lam_t
+00018ae0: 6820 2a20 7374 682c 0a20 2020 2020 2020  h * sth,.       
+00018af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018b00: 202d 6c61 6d5f 7468 202a 2072 686f 2c0a   -lam_th * rho,.
+00018b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018b20: 2020 2020 2020 2020 2d72 686f 202a 2063          -rho * c
+00018b30: 7468 2c0a 2020 2020 2020 2020 2020 2020  th,.            
+00018b40: 2020 2020 2020 2020 2020 2020 2d72 686f              -rho
+00018b50: 202a 2073 7468 2c0a 2020 2020 2020 2020   * sth,.        
+00018b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018b70: 2d31 2c0a 2020 2020 2020 2020 2020 2020  -1,.            
+00018b80: 2020 2020 2020 2020 5d2c 0a20 2020 2020          ],.     
+00018b90: 2020 2020 2020 2020 2020 2020 2020 205b                 [
+00018ba0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018bb0: 2020 2020 2020 2020 206c 616d 5f72 686f           lam_rho
+00018bc0: 202a 2063 7468 2c0a 2020 2020 2020 2020   * cth,.        
+00018bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018be0: 6c61 6d5f 7268 6f20 2a20 7374 682c 0a20  lam_rho * sth,. 
+00018bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018c00: 2020 2020 2020 202d 6c61 6d5f 7268 6f20         -lam_rho 
+00018c10: 2a20 7268 6f2c 0a20 2020 2020 2020 2020  * rho,.         
+00018c20: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+00018c30: 3120 2b20 7268 6f2a 2a32 2920 2a20 7374  1 + rho**2) * st
+00018c40: 682c 0a20 2020 2020 2020 2020 2020 2020  h,.             
+00018c50: 2020 2020 2020 2020 2020 202d 2831 202b             -(1 +
+00018c60: 2072 686f 2a2a 3229 202a 2063 7468 2c0a   rho**2) * cth,.
+00018c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018c80: 2020 2020 2020 2020 302c 0a20 2020 2020          0,.     
+00018c90: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
+00018ca0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00018cb0: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
+00018cc0: 290a 2020 2020 2020 2020 2020 2020 6a61  ).            ja
+00018cd0: 632e 6170 7065 6e64 284c 290a 0a20 2020  c.append(L)..   
+00018ce0: 2020 2020 2072 6574 7572 6e20 6e70 2e76       return np.v
+00018cf0: 7374 6163 6b28 6a61 6329 0a0a 2020 2020  stack(jac)..    
+00018d00: 6465 6620 7669 736a 6163 5f65 2873 656c  def visjac_e(sel
+00018d10: 662c 2045 2c20 706c 616e 6529 3a0a 2020  f, E, plane):.  
+00018d20: 2020 2020 2020 7222 2222 0a20 2020 2020        r""".     
+00018d30: 2020 2056 6973 7561 6c20 4a61 636f 6269     Visual Jacobi
+00018d40: 616e 2066 6f72 2065 6c6c 6970 7365 2066  an for ellipse f
+00018d50: 6561 7475 7265 730a 0a20 2020 2020 2020  eatures..       
+00018d60: 203a 7061 7261 6d20 453a 2069 6d61 6765   :param E: image
+00018d70: 2070 6c61 6e65 2065 6c6c 6970 7365 2070   plane ellipse p
+00018d80: 6172 616d 6574 6572 730a 2020 2020 2020  arameters.      
+00018d90: 2020 3a74 7970 6520 453a 2061 7272 6179    :type E: array
+00018da0: 5f6c 696b 6528 3529 2c20 6e64 6172 7261  _like(5), ndarra
+00018db0: 7928 352c 4e29 0a20 2020 2020 2020 203a  y(5,N).        :
+00018dc0: 7061 7261 6d20 706c 616e 653a 2070 6c61  param plane: pla
+00018dd0: 6e65 2063 6f6e 7461 696e 696e 6720 7468  ne containing th
+00018de0: 6520 656c 6c69 7073 650a 2020 2020 2020  e ellipse.      
+00018df0: 2020 3a74 7970 6520 706c 616e 653a 2061    :type plane: a
+00018e00: 7272 6179 5f6c 696b 6528 3429 0a20 2020  rray_like(4).   
+00018e10: 2020 2020 203a 7265 7475 726e 3a20 7669       :return: vi
+00018e20: 7375 616c 204a 6163 6f62 6961 6e20 6d61  sual Jacobian ma
+00018e30: 7472 6978 2066 6f72 2065 6c6c 6970 7365  trix for ellipse
+00018e40: 2066 6561 7475 7265 0a20 2020 2020 2020   feature.       
+00018e50: 203a 7274 7970 653a 206e 6461 7272 6179   :rtype: ndarray
+00018e60: 2832 2c36 292c 206e 6461 7272 6179 2832  (2,6), ndarray(2
+00018e70: 4e2c 3629 0a0a 2020 2020 2020 2020 436f  N,6)..        Co
+00018e80: 6d70 7574 6520 7468 6520 4a61 636f 6269  mpute the Jacobi
+00018e90: 616e 2067 6976 6573 2074 6865 2072 6174  an gives the rat
+00018ea0: 6573 206f 6620 6368 616e 6765 206f 6620  es of change of 
+00018eb0: 7468 6520 656c 6c69 7073 6520 7061 7261  the ellipse para
+00018ec0: 6d65 7465 7273 0a20 2020 2020 2020 2069  meters.        i
+00018ed0: 6e20 7465 726d 7320 6f66 2063 616d 6572  n terms of camer
+00018ee0: 6120 7370 6174 6961 6c20 7665 6c6f 6369  a spatial veloci
+00018ef0: 7479 2e0a 0a20 2020 2020 2020 2046 6f72  ty...        For
+00018f00: 2069 6d61 6765 2070 6c61 6e65 2065 6c6c   image plane ell
+00018f10: 6970 7365 730a 0a20 2020 2020 2020 202e  ipses..        .
+00018f20: 2e20 6d61 7468 3a3a 2075 5e32 202b 2045  . math:: u^2 + E
+00018f30: 5f30 2076 5e32 202d 3220 455f 3120 7520  _0 v^2 -2 E_1 u 
+00018f40: 7620 2b20 3220 455f 3220 7520 2b20 3220  v + 2 E_2 u + 2 
+00018f50: 455f 3320 7620 2b20 455f 3420 3d20 300a  E_3 v + E_4 = 0.
+00018f60: 0a20 2020 2020 2020 2074 6865 2069 6d61  .        the ima
+00018f70: 6765 204a 6163 6f62 6961 6e20 3a6d 6174  ge Jacobian :mat
+00018f80: 683a 605c 6d61 747b 4a7d 6020 6d61 7073  h:`\mat{J}` maps
+00018f90: 0a0a 2020 2020 2020 2020 2e2e 206d 6174  ..        .. mat
+00018fa0: 683a 3a0a 0a20 2020 2020 2020 2020 2020  h::..           
+00018fb0: 205c 6265 6769 6e7b 706d 6174 7269 787d   \begin{pmatrix}
+00018fc0: 205c 646f 747b 455f 307d 205c 5c20 5c76   \dot{E_0} \\ \v
+00018fd0: 646f 7473 205c 5c20 5c64 6f74 7b45 5f34  dots \\ \dot{E_4
+00018fe0: 7d20 5c65 6e64 7b70 6d61 7472 6978 7d20  } \end{pmatrix} 
+00018ff0: 3d20 5c6d 6174 7b4a 7d28 5c76 6563 7b70  = \mat{J}(\vec{p
+00019000: 7d2c 207a 2920 5c76 6563 7b5c 6e75 7d0a  }, z) \vec{\nu}.
+00019010: 0a20 2020 2020 2020 2063 616d 6572 6120  .        camera 
+00019020: 7370 6174 6961 6c20 7665 6c6f 6369 7479  spatial velocity
+00019030: 203a 6d61 7468 3a60 5c76 6563 7b5c 6e75   :math:`\vec{\nu
+00019040: 7d60 2074 6f20 7468 6520 7665 6c6f 6369  }` to the veloci
+00019050: 7479 0a20 2020 2020 2020 206f 6620 7468  ty.        of th
+00019060: 6520 656c 6c69 7073 6520 7061 7261 6d65  e ellipse parame
+00019070: 7465 7273 203a 6d61 7468 3a60 2845 5f30  ters :math:`(E_0
+00019080: 205c 6c64 6f74 7320 455f 3429 602e 0a0a   \ldots E_4)`...
+00019090: 2020 2020 2020 2020 5468 6520 776f 726c          The worl
+000190a0: 6420 706c 616e 6520 636f 6e74 6169 6e69  d plane containi
+000190b0: 6e67 2074 6865 2065 6c6c 6970 7365 2069  ng the ellipse i
+000190c0: 7320 616c 736f 2072 6571 7569 7265 642c  s also required,
+000190d0: 2061 6e64 2069 7320 7072 6f76 6964 6564   and is provided
+000190e0: 0a20 2020 2020 2020 2061 7320 6120 7665  .        as a ve
+000190f0: 6374 6f72 203a 6d61 7468 3a60 2861 2c62  ctor :math:`(a,b
+00019100: 2c63 2c64 2960 2073 7563 6820 7468 6174  ,c,d)` such that
+00019110: 0a0a 2020 2020 2020 2020 2e2e 206d 6174  ..        .. mat
+00019120: 683a 2061 5820 2b20 6259 202b 635a 202b  h: aX + bY +cZ +
+00019130: 2064 203d 2030 0a0a 2020 2020 2020 2020   d = 0..        
+00019140: 4578 616d 706c 653a 0a0a 2020 2020 2020  Example:..      
+00019150: 2020 2e2e 2072 756e 626c 6f63 6b3a 3a20    .. runblock:: 
+00019160: 7079 636f 6e0a 0a20 2020 2020 2020 2020  pycon..         
+00019170: 2020 203e 3e3e 2066 726f 6d20 6d61 6368     >>> from mach
+00019180: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+00019190: 2069 6d70 6f72 7420 4365 6e74 7261 6c43   import CentralC
+000191a0: 616d 6572 610a 2020 2020 2020 2020 2020  amera.          
+000191b0: 2020 3e3e 3e20 6672 6f6d 2073 7061 7469    >>> from spati
+000191c0: 616c 6d61 7468 2069 6d70 6f72 7420 5345  almath import SE
+000191d0: 330a 2020 2020 2020 2020 2020 2020 3e3e  3.            >>
+000191e0: 3e20 6361 6d65 7261 203d 2043 656e 7472  > camera = Centr
+000191f0: 616c 4361 6d65 7261 2e44 6566 6175 6c74  alCamera.Default
+00019200: 2829 0a20 2020 2020 2020 2020 2020 203e  ().            >
+00019210: 3e3e 2063 616d 6572 612e 7669 736a 6163  >> camera.visjac
+00019220: 5f65 2828 2830 2e35 2c20 302c 202d 3130  _e(((0.5, 0, -10
+00019230: 3030 2c20 2d35 3030 2c20 3337 3439 3030  00, -500, 374900
+00019240: 2929 2c20 2830 2c20 302c 2031 2c20 2d31  )), (0, 0, 1, -1
+00019250: 290a 0a20 2020 2020 2020 203a 7265 6665  )..        :refe
+00019260: 7265 6e63 6573 3a0a 2020 2020 2020 2020  rences:.        
+00019270: 2020 2020 2d20 4120 4e65 7720 4170 7072      - A New Appr
+00019280: 6f61 6368 2074 6f20 5669 7375 616c 2053  oach to Visual S
+00019290: 6572 766f 696e 6720 696e 2052 6f62 6f74  ervoing in Robot
+000192a0: 6963 732c 0a20 2020 2020 2020 2020 2020  ics,.           
+000192b0: 2020 2042 2e20 4573 7069 6175 2c20 462e     B. Espiau, F.
+000192c0: 2043 6861 756d 6574 7465 2c20 616e 6420   Chaumette, and 
+000192d0: 502e 2052 6976 6573 2c0a 2020 2020 2020  P. Rives,.      
+000192e0: 2020 2020 2020 2020 4945 4545 2054 7261          IEEE Tra
+000192f0: 6e73 6163 7469 6f6e 7320 6f6e 2052 6f62  nsactions on Rob
+00019300: 6f74 6963 7320 616e 6420 4175 746f 6d61  otics and Automa
+00019310: 7469 6f6e 2c0a 2020 2020 2020 2020 2020  tion,.          
+00019320: 2020 2020 766f 6c2e 2038 2c20 7070 2e20      vol. 8, pp. 
+00019330: 3331 332d 3332 362c 204a 756e 6520 3139  313-326, June 19
+00019340: 3932 2e0a 2020 2020 2020 2020 2020 2020  92..            
+00019350: 2d20 5669 7375 616c 2073 6572 766f 2063  - Visual servo c
+00019360: 6f6e 7472 6f6c 2032 3a20 4164 7661 6e63  ontrol 2: Advanc
+00019370: 6564 2061 7070 726f 6163 6865 730a 2020  ed approaches.  
+00019380: 2020 2020 2020 2020 2020 2020 4368 6175              Chau
+00019390: 6d65 7474 6520 462c 2048 7574 6368 696e  mette F, Hutchin
+000193a0: 736f 6e20 532c 0a20 2020 2020 2020 2020  son S,.         
+000193b0: 2020 2020 2049 4545 4520 526f 626f 7420       IEEE Robot 
+000193c0: 4175 746f 6d20 4d61 6720 3134 2831 293a  Autom Mag 14(1):
+000193d0: 3130 39e2 8093 3131 3820 2832 3030 3729  109...118 (2007)
+000193e0: 0a20 2020 2020 2020 2020 2020 202d 2052  .            - R
+000193f0: 6f62 6f74 6963 732c 2056 6973 696f 6e20  obotics, Vision 
+00019400: 2620 436f 6e74 726f 6c20 666f 7220 5079  & Control for Py
+00019410: 7468 6f6e 2c20 5365 6374 696f 6e20 3135  thon, Section 15
+00019420: 2e33 2e32 2c20 502e 2043 6f72 6b65 2c0a  .3.2, P. Corke,.
+00019430: 2020 2020 2020 2020 2020 2020 2020 5370                Sp
+00019440: 7269 6e67 6572 2032 3032 332e 0a0a 2020  ringer 2023...  
+00019450: 2020 2020 2020 3a73 6565 616c 736f 3a20        :seealso: 
+00019460: 3a6d 6574 683a 6076 6973 6a61 635f 7060  :meth:`visjac_p`
+00019470: 203a 6d65 7468 3a60 7669 736a 6163 5f70   :meth:`visjac_p
+00019480: 5f70 6f6c 6172 6020 3a6d 6574 683a 6076  _polar` :meth:`v
+00019490: 6973 6a61 635f 6c60 0a20 2020 2020 2020  isjac_l`.       
+000194a0: 2022 2222 0a0a 2020 2020 2020 2020 6120   """..        a 
+000194b0: 3d20 2d70 6c61 6e65 5b30 5d20 2f20 706c  = -plane[0] / pl
+000194c0: 616e 655b 335d 0a20 2020 2020 2020 2062  ane[3].        b
+000194d0: 203d 202d 706c 616e 655b 315d 202f 2070   = -plane[1] / p
+000194e0: 6c61 6e65 5b33 5d0a 2020 2020 2020 2020  lane[3].        
+000194f0: 6320 3d20 2d70 6c61 6e65 5b32 5d20 2f20  c = -plane[2] / 
+00019500: 706c 616e 655b 335d 0a20 2020 2020 2020  plane[3].       
+00019510: 204c 203d 206e 702e 6172 7261 7928 0a20   L = np.array(. 
+00019520: 2020 2020 2020 2020 2020 205b 0a20 2020             [.   
+00019530: 2020 2020 2020 2020 2020 2020 205b 0a20               [. 
+00019540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019550: 2020 2032 202a 2062 202a 2045 5b31 5d20     2 * b * E[1] 
+00019560: 2d20 3220 2a20 6120 2a20 455b 305d 2c0a  - 2 * a * E[0],.
+00019570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019580: 2020 2020 3220 2a20 455b 305d 202a 2028      2 * E[0] * (
+00019590: 6220 2d20 6120 2a20 455b 315d 292c 0a20  b - a * E[1]),. 
+000195a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000195b0: 2020 2032 202a 2062 202a 2045 5b33 5d20     2 * b * E[3] 
+000195c0: 2d20 3220 2a20 6120 2a20 455b 305d 202a  - 2 * a * E[0] *
+000195d0: 2045 5b32 5d2c 0a20 2020 2020 2020 2020   E[2],.         
+000195e0: 2020 2020 2020 2020 2020 2032 202a 2045             2 * E
+000195f0: 5b33 5d2c 0a20 2020 2020 2020 2020 2020  [3],.           
+00019600: 2020 2020 2020 2020 2032 202a 2045 5b30           2 * E[0
+00019610: 5d20 2a20 455b 325d 2c0a 2020 2020 2020  ] * E[2],.      
+00019620: 2020 2020 2020 2020 2020 2020 2020 2d32                -2
+00019630: 202a 2045 5b31 5d20 2a20 2845 5b30 5d20   * E[1] * (E[0] 
+00019640: 2b20 3129 2c0a 2020 2020 2020 2020 2020  + 1),.          
+00019650: 2020 2020 2020 5d2c 0a20 2020 2020 2020        ],.       
+00019660: 2020 2020 2020 2020 205b 0a20 2020 2020           [.     
+00019670: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00019680: 202d 2061 202a 2045 5b31 5d2c 0a20 2020   - a * E[1],.   
+00019690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000196a0: 2062 202a 2045 5b31 5d20 2d20 6120 2a20   b * E[1] - a * 
+000196b0: 2832 202a 2045 5b31 5d20 2a2a 2032 202d  (2 * E[1] ** 2 -
+000196c0: 2045 5b30 5d29 2c0a 2020 2020 2020 2020   E[0]),.        
+000196d0: 2020 2020 2020 2020 2020 2020 6120 2a20              a * 
+000196e0: 2845 5b33 5d20 2d20 3220 2a20 455b 315d  (E[3] - 2 * E[1]
+000196f0: 202a 2045 5b32 5d29 202b 2062 202a 2045   * E[2]) + b * E
+00019700: 5b32 5d2c 0a20 2020 2020 2020 2020 2020  [2],.           
+00019710: 2020 2020 2020 2020 202d 455b 325d 2c0a           -E[2],.
+00019720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019730: 2020 2020 2d28 3220 2a20 455b 315d 202a      -(2 * E[1] *
+00019740: 2045 5b32 5d20 2d20 455b 335d 292c 0a20   E[2] - E[3]),. 
+00019750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019760: 2020 2045 5b30 5d20 2d20 3220 2a20 455b     E[0] - 2 * E[
+00019770: 315d 202a 2a20 3220 2d20 312c 0a20 2020  1] ** 2 - 1,.   
+00019780: 2020 2020 2020 2020 2020 2020 205d 2c0a               ],.
+00019790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000197a0: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+000197b0: 2020 2020 2020 6320 2d20 6120 2a20 455b        c - a * E[
+000197c0: 325d 2c0a 2020 2020 2020 2020 2020 2020  2],.            
+000197d0: 2020 2020 2020 2020 6120 2a20 2845 5b33          a * (E[3
+000197e0: 5d20 2d20 3220 2a20 455b 315d 202a 2045  ] - 2 * E[1] * E
+000197f0: 5b32 5d29 202b 2063 202a 2045 5b31 5d2c  [2]) + c * E[1],
+00019800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019810: 2020 2020 2063 202a 2045 5b32 5d20 2d20       c * E[2] - 
+00019820: 6120 2a20 2832 202a 2045 5b32 5d20 2a2a  a * (2 * E[2] **
+00019830: 2032 202d 2045 5b34 5d29 2c0a 2020 2020   2 - E[4]),.    
+00019840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019850: 2d45 5b31 5d2c 0a20 2020 2020 2020 2020  -E[1],.         
+00019860: 2020 2020 2020 2020 2020 2031 202b 2032             1 + 2
+00019870: 202a 2045 5b32 5d20 2a2a 2032 202d 2045   * E[2] ** 2 - E
+00019880: 5b34 5d2c 0a20 2020 2020 2020 2020 2020  [4],.           
+00019890: 2020 2020 2020 2020 2045 5b33 5d20 2d20           E[3] - 
+000198a0: 3220 2a20 455b 315d 202a 2045 5b32 5d2c  2 * E[1] * E[2],
+000198b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000198c0: 205d 2c0a 2020 2020 2020 2020 2020 2020   ],.            
+000198d0: 2020 2020 5b0a 2020 2020 2020 2020 2020      [.          
+000198e0: 2020 2020 2020 2020 2020 455b 325d 202a            E[2] *
+000198f0: 2062 202b 2045 5b31 5d20 2a20 6320 2d20   b + E[1] * c - 
+00019900: 3220 2a20 6120 2a20 455b 335d 2c0a 2020  2 * a * E[3],.  
+00019910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019920: 2020 455b 335d 202a 2062 202b 2045 5b30    E[3] * b + E[0
+00019930: 5d20 2a20 6320 2d20 3220 2a20 6120 2a20  ] * c - 2 * a * 
+00019940: 455b 315d 202a 2045 5b33 5d2c 0a20 2020  E[1] * E[3],.   
+00019950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019960: 2062 202a 2045 5b34 5d20 2b20 6320 2a20   b * E[4] + c * 
+00019970: 455b 335d 202d 2032 202a 2061 202a 2045  E[3] - 2 * a * E
+00019980: 5b32 5d20 2a20 455b 335d 2c0a 2020 2020  [2] * E[3],.    
+00019990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000199a0: 455b 345d 202d 2045 5b30 5d2c 0a20 2020  E[4] - E[0],.   
+000199b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000199c0: 2032 202a 2045 5b32 5d20 2a20 455b 335d   2 * E[2] * E[3]
+000199d0: 202b 2045 5b31 5d2c 0a20 2020 2020 2020   + E[1],.       
+000199e0: 2020 2020 2020 2020 2020 2020 202d 3220               -2 
+000199f0: 2a20 455b 315d 202a 2045 5b33 5d20 2d20  * E[1] * E[3] - 
+00019a00: 455b 325d 2c0a 2020 2020 2020 2020 2020  E[2],.          
+00019a10: 2020 2020 2020 5d2c 0a20 2020 2020 2020        ],.       
+00019a20: 2020 2020 2020 2020 205b 0a20 2020 2020           [.     
+00019a30: 2020 2020 2020 2020 2020 2020 2020 2032                 2
+00019a40: 202a 2063 202a 2045 5b32 5d20 2d20 3220   * c * E[2] - 2 
+00019a50: 2a20 6120 2a20 455b 345d 2c0a 2020 2020  * a * E[4],.    
+00019a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019a70: 3220 2a20 6320 2a20 455b 335d 202d 2032  2 * c * E[3] - 2
+00019a80: 202a 2061 202a 2045 5b31 5d20 2a20 455b   * a * E[1] * E[
+00019a90: 345d 2c0a 2020 2020 2020 2020 2020 2020  4],.            
+00019aa0: 2020 2020 2020 2020 3220 2a20 6320 2a20          2 * c * 
+00019ab0: 455b 345d 202d 2032 202a 2061 202a 2045  E[4] - 2 * a * E
+00019ac0: 5b32 5d20 2a20 455b 345d 2c0a 2020 2020  [2] * E[4],.    
+00019ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019ae0: 2d32 202a 2045 5b33 5d2c 0a20 2020 2020  -2 * E[3],.     
+00019af0: 2020 2020 2020 2020 2020 2020 2020 2032                 2
+00019b00: 202a 2045 5b32 5d20 2a20 455b 345d 202b   * E[2] * E[4] +
+00019b10: 2032 202a 2045 5b32 5d2c 0a20 2020 2020   2 * E[2],.     
+00019b20: 2020 2020 2020 2020 2020 2020 2020 202d                 -
+00019b30: 3220 2a20 455b 315d 202a 2045 5b34 5d2c  2 * E[1] * E[4],
+00019b40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019b50: 205d 2c0a 2020 2020 2020 2020 2020 2020   ],.            
+00019b60: 5d0a 2020 2020 2020 2020 290a 0a20 2020  ].        )..   
+00019b70: 2020 2020 204c 203d 204c 2040 206e 702e       L = L @ np.
+00019b80: 6469 6167 285b 302e 352c 2030 2e35 2c20  diag([0.5, 0.5, 
+00019b90: 302e 352c 2031 2c20 312c 2031 5d29 2020  0.5, 1, 1, 1])  
+00019ba0: 2320 6e6f 7420 7375 7265 2077 6879 2e2e  # not sure why..
+00019bb0: 2e0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+00019bc0: 204c 0a0a 2020 2020 6465 6620 666c 6f77   L..    def flow
+00019bd0: 6669 656c 6428 7365 6c66 2c20 7665 6c2c  field(self, vel,
+00019be0: 205a 3d32 293a 0a20 2020 2020 2020 2022   Z=2):.        "
+00019bf0: 2222 0a20 2020 2020 2020 2044 6973 706c  "".        Displ
+00019c00: 6179 206f 7074 6963 616c 2066 6c6f 7720  ay optical flow 
+00019c10: 6669 656c 640a 0a20 2020 2020 2020 203a  field..        :
+00019c20: 7061 7261 6d20 7665 6c3a 2063 616d 6572  param vel: camer
+00019c30: 6120 7370 6174 6961 6c20 7665 6c6f 6369  a spatial veloci
+00019c40: 7479 0a20 2020 2020 2020 203a 7479 7065  ty.        :type
+00019c50: 2076 656c 3a20 6172 7261 795f 6c69 6b65   vel: array_like
+00019c60: 2836 290a 2020 2020 2020 2020 3a70 6172  (6).        :par
+00019c70: 616d 205a 3a20 5f64 6573 6372 6970 7469  am Z: _descripti
+00019c80: 6f6e 5f2c 2064 6566 6175 6c74 7320 746f  on_, defaults to
+00019c90: 2032 0a20 2020 2020 2020 203a 7479 7065   2.        :type
+00019ca0: 205a 3a20 7363 616c 6172 2c20 6f70 7469   Z: scalar, opti
+00019cb0: 6f6e 616c 0a0a 2020 2020 2020 2020 4469  onal..        Di
+00019cc0: 7370 6c61 7920 7468 6520 6f70 7469 6361  splay the optica
+00019cd0: 6c20 666c 6f77 2066 6965 6c64 2075 7369  l flow field usi
+00019ce0: 6e67 204d 6174 706c 6f74 6c69 622c 2066  ng Matplotlib, f
+00019cf0: 6f72 2061 2067 7269 6420 6f66 2070 6f69  or a grid of poi
+00019d00: 6e74 7320 6174 0a20 2020 2020 2020 2064  nts at.        d
+00019d10: 6973 7461 6e63 6520 6060 5a60 6020 666f  istance ``Z`` fo
+00019d20: 7220 6120 6361 6d65 7261 2076 656c 6f63  r a camera veloc
+00019d30: 6974 7920 6f66 2060 6076 656c 6060 2e0a  ity of ``vel``..
+00019d40: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+00019d50: 3a0a 0a20 2020 2020 2020 202e 2e20 7275  :..        .. ru
+00019d60: 6e62 6c6f 636b 3a3a 2070 7963 6f6e 0a0a  nblock:: pycon..
+00019d70: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00019d80: 6672 6f6d 206d 6163 6869 6e65 7669 7369  from machinevisi
+00019d90: 6f6e 746f 6f6c 626f 7820 696d 706f 7274  ontoolbox import
+00019da0: 2043 656e 7472 616c 4361 6d65 7261 0a20   CentralCamera. 
+00019db0: 2020 2020 2020 2020 2020 203e 3e3e 2063             >>> c
+00019dc0: 616d 6572 6120 3d20 4365 6e74 7261 6c43  amera = CentralC
+00019dd0: 616d 6572 612e 4465 6661 756c 7428 290a  amera.Default().
+00019de0: 2020 2020 2020 2020 2020 2020 3e3e 3e20              >>> 
+00019df0: 6361 6d65 7261 2e66 6c6f 7766 6965 6c64  camera.flowfield
+00019e00: 285b 302c 2030 2c20 302c 2030 2c20 312c  ([0, 0, 0, 0, 1,
+00019e10: 2030 5d29 0a0a 2020 2020 2020 2020 3a73   0])..        :s
+00019e20: 6565 616c 736f 3a20 3a6d 6574 683a 6076  eealso: :meth:`v
+00019e30: 6973 6a61 635f 7060 0a20 2020 2020 2020  isjac_p`.       
+00019e40: 2022 2222 0a20 2020 2020 2020 2076 656c   """.        vel
+00019e50: 203d 2062 6173 652e 6765 7476 6563 746f   = base.getvecto
+00019e60: 7228 7665 6c2c 2036 290a 0a20 2020 2020  r(vel, 6)..     
+00019e70: 2020 2075 203d 206e 702e 6172 616e 6765     u = np.arange
+00019e80: 2830 2c20 7365 6c66 2e6e 752c 2035 3029  (0, self.nu, 50)
+00019e90: 0a20 2020 2020 2020 2076 203d 206e 702e  .        v = np.
+00019ea0: 6172 616e 6765 2830 2c20 7365 6c66 2e6e  arange(0, self.n
+00019eb0: 762c 2035 3029 0a20 2020 2020 2020 205b  v, 50).        [
+00019ec0: 552c 2056 5d20 3d20 6e70 2e6d 6573 6867  U, V] = np.meshg
+00019ed0: 7269 6428 752c 2076 2c20 696e 6465 7869  rid(u, v, indexi
+00019ee0: 6e67 3d22 696a 2229 0a20 2020 2020 2020  ng="ij").       
+00019ef0: 2064 7520 3d20 6e70 2e65 6d70 7479 2873   du = np.empty(s
+00019f00: 6861 7065 3d55 2e73 6861 7065 290a 2020  hape=U.shape).  
+00019f10: 2020 2020 2020 6476 203d 206e 702e 656d        dv = np.em
+00019f20: 7074 7928 7368 6170 653d 552e 7368 6170  pty(shape=U.shap
+00019f30: 6529 0a20 2020 2020 2020 2066 6f72 2072  e).        for r
+00019f40: 2069 6e20 7261 6e67 6528 552e 7368 6170   in range(U.shap
+00019f50: 655b 305d 293a 0a20 2020 2020 2020 2020  e[0]):.         
+00019f60: 2020 2066 6f72 2063 2069 6e20 7261 6e67     for c in rang
+00019f70: 6528 552e 7368 6170 655b 315d 293a 0a20  e(U.shape[1]):. 
+00019f80: 2020 2020 2020 2020 2020 2020 2020 204a                 J
+00019f90: 203d 2073 656c 662e 7669 736a 6163 5f70   = self.visjac_p
+00019fa0: 2828 555b 722c 2063 5d2c 2056 5b72 2c20  ((U[r, c], V[r, 
+00019fb0: 635d 292c 205a 290a 2020 2020 2020 2020  c]), Z).        
+00019fc0: 2020 2020 2020 2020 7564 2c20 7664 203d          ud, vd =
+00019fd0: 204a 2040 2076 656c 0a20 2020 2020 2020   J @ vel.       
+00019fe0: 2020 2020 2020 2020 2064 755b 722c 2063           du[r, c
+00019ff0: 5d20 3d20 7564 0a20 2020 2020 2020 2020  ] = ud.         
+0001a000: 2020 2020 2020 2064 765b 722c 2063 5d20         dv[r, c] 
+0001a010: 3d20 2d76 640a 0a20 2020 2020 2020 2073  = -vd..        s
+0001a020: 656c 662e 636c 6628 290a 2020 2020 2020  elf.clf().      
+0001a030: 2020 6178 203d 2073 656c 662e 5f69 6e69    ax = self._ini
+0001a040: 745f 696d 6167 6570 6c61 6e65 2829 0a20  t_imageplane(). 
+0001a050: 2020 2020 2020 2061 782e 7175 6976 6572         ax.quiver
+0001a060: 2855 2c20 562c 2064 752c 2064 762c 2030  (U, V, du, dv, 0
+0001a070: 2e34 2c20 7a6f 7264 6572 3d32 3029 0a0a  .4, zorder=20)..
+0001a080: 2020 2020 6465 6620 6465 7269 7661 7469      def derivati
+0001a090: 7665 7328 7365 6c66 2c20 782c 2050 293a  ves(self, x, P):
+0001a0a0: 0a20 2020 2020 2020 2072 2222 220a 2020  .        r""".  
+0001a0b0: 2020 2020 2020 436f 6d70 7574 6520 7072        Compute pr
+0001a0c0: 6f6a 6563 7469 6f6e 2061 6e64 2064 6572  ojection and der
+0001a0d0: 6976 6174 6976 6573 2066 6f72 2062 756e  ivatives for bun
+0001a0e0: 646c 6520 6164 6a75 7374 6d65 6e74 0a0a  dle adjustment..
+0001a0f0: 2020 2020 2020 2020 3a70 6172 616d 2078          :param x
+0001a100: 3a20 6361 6d65 7261 2070 6f73 6520 6173  : camera pose as
+0001a110: 2074 7261 6e73 6c61 7469 6f6e 2061 6e64   translation and
+0001a120: 2071 7561 7465 726e 696f 6e20 7665 6374   quaternion vect
+0001a130: 6f72 2070 6172 740a 2020 2020 2020 2020  or part.        
+0001a140: 3a74 7970 6520 783a 2061 7272 6179 5f6c  :type x: array_l
+0001a150: 696b 6528 3629 0a20 2020 2020 2020 203a  ike(6).        :
+0001a160: 7061 7261 6d20 503a 2033 4420 776f 726c  param P: 3D worl
+0001a170: 6420 706f 696e 740a 2020 2020 2020 2020  d point.        
+0001a180: 3a74 7970 6520 503a 2061 7272 6179 5f6c  :type P: array_l
+0001a190: 696b 6528 3329 0a20 2020 2020 2020 203a  ike(3).        :
+0001a1a0: 7265 7475 726e 3a20 702c 2041 2c20 420a  return: p, A, B.
+0001a1b0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+0001a1c0: 6e64 6172 7261 7928 3229 2c20 6e64 6172  ndarray(2), ndar
+0001a1d0: 7261 7928 322c 3629 2c20 6e64 6172 7261  ray(2,6), ndarra
+0001a1e0: 7928 322c 3329 0a0a 2020 2020 2020 2020  y(2,3)..        
+0001a1f0: 466f 7220 6120 776f 726c 6420 706f 696e  For a world poin
+0001a200: 7420 3a6d 6174 683a 605c 7665 637b 787d  t :math:`\vec{x}
+0001a210: 6020 636f 6d70 7574 6520 7468 6520 696d  ` compute the im
+0001a220: 6167 6520 706c 616e 6520 7072 6f6a 6563  age plane projec
+0001a230: 7469 6f6e 2061 6e64 2074 6865 0a20 2020  tion and the.   
+0001a240: 2020 2020 2073 656e 7369 7469 7669 7479       sensitivity
+0001a250: 2074 6f20 6361 6d65 7261 2061 6e64 2070   to camera and p
+0001a260: 6f69 6e74 2063 6861 6e67 650a 0a20 2020  oint change..   
+0001a270: 2020 2020 202e 2e20 6d61 7468 3a3a 205c       .. math:: \
+0001a280: 6d61 747b 417d 203d 205c 6672 6163 7b5c  mat{A} = \frac{\
+0001a290: 7061 7274 6961 6c20 5c76 6563 7b66 7d28  partial \vec{f}(
+0001a2a0: 5c76 6563 7b78 7d29 7d7b 5c70 6172 7469  \vec{x})}{\parti
+0001a2b0: 616c 205c 706f 7365 7d2c 205c 6d61 747b  al \pose}, \mat{
+0001a2c0: 427d 203d 205c 6672 6163 7b5c 7061 7274  B} = \frac{\part
+0001a2d0: 6961 6c20 5c76 6563 7b66 7d28 5c76 6563  ial \vec{f}(\vec
+0001a2e0: 7b78 7d29 7d7b 5c70 6172 7469 616c 205c  {x})}{\partial \
+0001a2f0: 7665 637b 507d 7d0a 0a20 2020 2020 2020  vec{P}}..       
+0001a300: 2077 6865 7265 203a 6d61 7468 3a60 5c76   where :math:`\v
+0001a310: 6563 7b66 7d28 5c76 6563 7b78 7d29 6020  ec{f}(\vec{x})` 
+0001a320: 6973 2074 6865 2070 6572 7370 6563 7469  is the perspecti
+0001a330: 7665 2070 726f 6a65 6374 696f 6e20 6675  ve projection fu
+0001a340: 6e63 7469 6f6e 2e0a 0a20 2020 2020 2020  nction...       
+0001a350: 203a 7365 6561 6c73 6f3a 203a 6d65 7468   :seealso: :meth
+0001a360: 3a60 7072 6f6a 6563 745f 706f 696e 7460  :`project_point`
+0001a370: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001a380: 2020 2020 2023 2063 6f6d 7075 7465 204a       # compute J
+0001a390: 6163 6f62 6961 6e73 2061 6e64 2070 726f  acobians and pro
+0001a3a0: 6a65 6374 696f 6e0a 0a20 2020 2020 2020  jection..       
+0001a3b0: 2066 726f 6d20 6d61 6368 696e 6576 6973   from machinevis
+0001a3c0: 696f 6e74 6f6f 6c62 6f78 2e63 616d 6572  iontoolbox.camer
+0001a3d0: 615f 6465 7269 7661 7469 7665 7320 696d  a_derivatives im
+0001a3e0: 706f 7274 2063 616d 6572 614d 6f64 656c  port cameraModel
+0001a3f0: 0a0a 2020 2020 2020 2020 4b70 203d 205b  ..        Kp = [
+0001a400: 7365 6c66 2e66 5b30 5d2c 2073 656c 662e  self.f[0], self.
+0001a410: 7268 6f75 2c20 7365 6c66 2e72 686f 762c  rhou, self.rhov,
+0001a420: 2073 656c 662e 7530 2c20 7365 6c66 2e76   self.u0, self.v
+0001a430: 305d 0a0a 2020 2020 2020 2020 7265 7475  0]..        retu
+0001a440: 726e 2063 616d 6572 614d 6f64 656c 282a  rn cameraModel(*
+0001a450: 782c 202a 502c 202a 4b70 290a 0a20 2020  x, *P, *Kp)..   
+0001a460: 2064 6566 2065 7374 706f 7365 2873 656c   def estpose(sel
+0001a470: 662c 2050 2c20 702c 206d 6574 686f 643d  f, P, p, method=
+0001a480: 2269 7465 7261 7469 7665 222c 2066 7261  "iterative", fra
+0001a490: 6d65 3d22 776f 726c 6422 293a 0a20 2020  me="world"):.   
+0001a4a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0001a4b0: 2045 7374 696d 6174 6520 6f62 6a65 6374   Estimate object
+0001a4c0: 2070 6f73 650a 0a20 2020 2020 2020 203a   pose..        :
+0001a4d0: 7061 7261 6d20 503a 2041 2073 6574 206f  param P: A set o
+0001a4e0: 6620 3344 2070 6f69 6e74 7320 6465 6669  f 3D points defi
+0001a4f0: 6e69 6e67 2074 6865 206f 626a 6563 7420  ning the object 
+0001a500: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
+0001a510: 6974 7320 6f77 6e20 6672 616d 650a 2020  its own frame.  
+0001a520: 2020 2020 2020 3a74 7970 6520 503a 206e        :type P: n
+0001a530: 6461 7272 6179 2833 2c20 4e29 0a20 2020  darray(3, N).   
+0001a540: 2020 2020 203a 7061 7261 6d20 703a 2049       :param p: I
+0001a550: 6d61 6765 2070 6c61 6e65 2070 726f 6a65  mage plane proje
+0001a560: 6374 696f 6e20 6f66 2074 6865 206f 626a  ction of the obj
+0001a570: 6563 7420 706f 696e 7473 0a20 2020 2020  ect points.     
+0001a580: 2020 203a 7479 7065 2070 3a20 6e64 6172     :type p: ndar
+0001a590: 7261 7928 322c 204e 290a 2020 2020 2020  ray(2, N).      
+0001a5a0: 2020 3a70 6172 616d 206d 6574 686f 643a    :param method:
+0001a5b0: 2070 6f73 6520 6573 7469 6d61 7469 6f6e   pose estimation
+0001a5c0: 2061 6c67 6f72 6974 686d 2c20 7365 6520   algorithm, see 
+0001a5d0: 4f70 656e 4356 2073 6f6c 7665 506e 502c  OpenCV solvePnP,
+0001a5e0: 2064 6566 6175 6c74 7320 746f 2027 6974   defaults to 'it
+0001a5f0: 6572 6174 6976 6527 0a20 2020 2020 2020  erative'.       
+0001a600: 203a 7479 7065 206d 6574 686f 643a 2073   :type method: s
+0001a610: 7472 2c20 6f70 7469 6f6e 616c 0a20 2020  tr, optional.   
+0001a620: 2020 2020 203a 7061 7261 6d20 6672 616d       :param fram
+0001a630: 653a 2065 7374 696d 6174 6520 706f 7365  e: estimate pose
+0001a640: 2077 6974 6820 7265 7370 6563 7420 746f   with respect to
+0001a650: 2066 7261 6d65 2022 776f 726c 6422 205b   frame "world" [
+0001a660: 6465 6661 756c 745d 206f 7220 2263 616d  default] or "cam
+0001a670: 6572 6122 0a20 2020 2020 2020 203a 7479  era".        :ty
+0001a680: 7065 2066 7261 6d65 3a20 7374 722c 206f  pe frame: str, o
+0001a690: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
+0001a6a0: 3a72 6574 7572 6e3a 2070 6f73 6520 6f66  :return: pose of
+0001a6b0: 2074 6172 6765 7420 6672 616d 6520 7265   target frame re
+0001a6c0: 6c61 7469 7665 2074 6f20 7468 6520 776f  lative to the wo
+0001a6d0: 726c 6420 6672 616d 650a 2020 2020 2020  rld frame.      
+0001a6e0: 2020 3a72 7479 7065 3a20 3a63 6c61 7373    :rtype: :class
+0001a6f0: 3a60 7e73 7061 7469 616c 6d61 7468 2e2e  :`~spatialmath..
+0001a700: 706f 7365 3364 2e53 4533 600a 0a20 2020  pose3d.SE3`..   
+0001a710: 2020 2020 2055 7369 6e67 2061 2073 6574       Using a set
+0001a720: 206f 6620 706f 696e 7473 2064 6566 696e   of points defin
+0001a730: 696e 6720 736f 6d65 206f 626a 6563 7420  ing some object 
+0001a740: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
+0001a750: 6974 7320 6f77 6e20 6672 616d 6520 7b42  its own frame {B
+0001a760: 7d2c 2061 6e64 0a20 2020 2020 2020 2061  }, and.        a
+0001a770: 2073 6574 206f 6620 696d 6167 652d 706c   set of image-pl
+0001a780: 616e 6520 7072 6f6a 6563 7469 6f6e 732c  ane projections,
+0001a790: 2065 7374 696d 6174 6520 7468 6520 706f   estimate the po
+0001a7a0: 7365 206f 6620 7b42 7d20 7769 7468 2072  se of {B} with r
+0001a7b0: 6573 7065 6374 2074 6f20 7468 6520 776f  espect to the wo
+0001a7c0: 726c 640a 2020 2020 2020 2020 6f72 2063  rld.        or c
+0001a7d0: 616d 6572 6120 6672 616d 652e 0a0a 2020  amera frame...  
+0001a7e0: 2020 2020 2020 546f 2065 7374 696d 6174        To estimat
+0001a7f0: 6520 7468 6520 6361 6d65 7261 2773 2070  e the camera's p
+0001a800: 6f73 6520 7769 7468 2072 6573 7065 6374  ose with respect
+0001a810: 2074 6f20 7468 6520 776f 726c 6420 6672   to the world fr
+0001a820: 616d 6520 7468 6520 6361 6d65 7261 2773  ame the camera's
+0001a830: 2070 6f73 650a 2020 2020 2020 2020 6060   pose.        ``
+0001a840: 7365 6c66 2e70 6f73 6560 6020 6973 2075  self.pose`` is u
+0001a850: 7365 642e 0a0a 2020 2020 2020 2020 3a6e  sed...        :n
+0001a860: 6f74 653a 0a0a 2020 2020 2020 2020 2020  ote:..          
+0001a870: 2020 2a20 416c 6c20 6f66 2074 6865 204f    * All of the O
+0001a880: 7065 6e43 5620 6573 7469 6d61 7469 6f6e  penCV estimation
+0001a890: 2061 6c67 6f72 6974 686d 7320 6172 6520   algorithms are 
+0001a8a0: 7375 7070 6f72 7465 642e 0a20 2020 2020  supported..     
+0001a8b0: 2020 2020 2020 202a 2041 6c67 6f72 6974         * Algorit
+0001a8c0: 686d 2060 6022 6970 7065 2d73 7175 6172  hm ``"ippe-squar
+0001a8d0: 6522 6060 2072 6571 7569 7265 7320 6578  e"`` requires ex
+0001a8e0: 6163 746c 7920 666f 7572 2070 6f69 6e74  actly four point
+0001a8f0: 7320 6174 2074 6865 2063 6f72 6e65 7273  s at the corners
+0001a900: 206f 6620 610a 2020 2020 2020 2020 2020   of a.          
+0001a910: 2020 2020 7371 7561 7265 2061 6e64 2069      square and i
+0001a920: 6e20 7468 6520 6f72 6465 723a 2028 2d78  n the order: (-x
+0001a930: 2c20 7929 2c20 2878 2c20 7929 2c20 2878  , y), (x, y), (x
+0001a940: 2c20 2d79 292c 2028 2d78 2c20 2d79 292e  , -y), (-x, -y).
+0001a950: 0a0a 2020 2020 2020 2020 3a73 6565 616c  ..        :seeal
+0001a960: 736f 3a20 3a6d 6574 683a 6070 726f 6a65  so: :meth:`proje
+0001a970: 6374 5f70 6f69 6e74 600a 2020 2020 2020  ct_point`.      
+0001a980: 2020 2020 2020 606f 7065 6e63 762e 736f        `opencv.so
+0001a990: 6c76 6550 6e50 203c 6874 7470 733a 2f2f  lvePnP <https://
+0001a9a0: 646f 6373 2e6f 7065 6e63 762e 6f72 672f  docs.opencv.org/
+0001a9b0: 332e 342f 6439 2f64 3063 2f67 726f 7570  3.4/d9/d0c/group
+0001a9c0: 5f5f 6361 6c69 6233 642e 6874 6d6c 2367  __calib3d.html#g
+0001a9d0: 6135 3439 6332 3037 3566 6163 3134 3832  a549c2075fac1482
+0001a9e0: 3966 6634 6135 3862 6339 3331 6330 3333  9ff4a58bc931c033
+0001a9f0: 643e 605f 0a20 2020 2020 2020 2022 2222  d>`_.        """
+0001aa00: 0a0a 2020 2020 2020 2020 6d65 7468 6f64  ..        method
+0001aa10: 5f64 6963 7420 3d20 7b0a 2020 2020 2020  _dict = {.      
+0001aa20: 2020 2020 2020 2269 7465 7261 7469 7665        "iterative
+0001aa30: 223a 2063 762e 534f 4c56 4550 4e50 5f49  ": cv.SOLVEPNP_I
+0001aa40: 5445 5241 5449 5645 2c0a 2020 2020 2020  TERATIVE,.      
+0001aa50: 2020 2020 2020 2265 706e 7022 3a20 6376        "epnp": cv
+0001aa60: 2e53 4f4c 5645 504e 505f 4550 4e50 2c0a  .SOLVEPNP_EPNP,.
+0001aa70: 2020 2020 2020 2020 2020 2020 2270 3370              "p3p
+0001aa80: 223a 2063 762e 534f 4c56 4550 4e50 5f50  ": cv.SOLVEPNP_P
+0001aa90: 3350 2c0a 2020 2020 2020 2020 2020 2020  3P,.            
+0001aaa0: 2261 7033 7022 3a20 6376 2e53 4f4c 5645  "ap3p": cv.SOLVE
+0001aab0: 504e 505f 4150 3350 2c0a 2020 2020 2020  PNP_AP3P,.      
+0001aac0: 2020 2020 2020 2269 7070 6522 3a20 6376        "ippe": cv
+0001aad0: 2e53 4f4c 5645 504e 505f 4950 5045 2c0a  .SOLVEPNP_IPPE,.
+0001aae0: 2020 2020 2020 2020 2020 2020 2269 7070              "ipp
+0001aaf0: 652d 7371 7561 7265 223a 2063 762e 534f  e-square": cv.SO
+0001ab00: 4c56 4550 4e50 5f49 5050 455f 5351 5541  LVEPNP_IPPE_SQUA
+0001ab10: 5245 2c0a 2020 2020 2020 2020 7d0a 0a20  RE,.        }.. 
+0001ab20: 2020 2020 2020 2023 2061 7320 7065 7220         # as per 
+0001ab30: 7468 6520 4e6f 7465 206f 6e20 736f 6c76  the Note on solv
+0001ab40: 6550 6e50 2070 6167 650a 2020 2020 2020  ePnP page.      
+0001ab50: 2020 2320 2077 6520 6e65 6564 2074 6f20    #  we need to 
+0001ab60: 656e 7375 7265 2074 6861 7420 7468 6520  ensure that the 
+0001ab70: 696d 6167 6520 706f 696e 7420 6461 7461  image point data
+0001ab80: 2069 7320 636f 6e74 6967 756f 7573 206e   is contiguous n
+0001ab90: 7831 7832 2061 7272 6179 0a20 2020 2020  x1x2 array.     
+0001aba0: 2020 206e 203d 2070 2e73 6861 7065 5b31     n = p.shape[1
+0001abb0: 5d0a 2020 2020 2020 2020 7020 3d20 6e70  ].        p = np
+0001abc0: 2e61 7363 6f6e 7469 6775 6f75 7361 7272  .ascontiguousarr
+0001abd0: 6179 2870 5b3a 322c 203a 5d2e 5429 2e72  ay(p[:2, :].T).r
+0001abe0: 6573 6861 7065 2828 6e2c 2031 2c20 3229  eshape((n, 1, 2)
+0001abf0: 290a 0a20 2020 2020 2020 2023 2064 6f20  )..        # do 
+0001ac00: 7468 6520 706f 7365 2065 7374 696d 6174  the pose estimat
+0001ac10: 696f 6e0a 2020 2020 2020 2020 736f 6c20  ion.        sol 
+0001ac20: 3d20 6376 2e73 6f6c 7665 506e 5028 502e  = cv.solvePnP(P.
+0001ac30: 542c 2070 2c20 7365 6c66 2e4b 2c20 7365  T, p, self.K, se
+0001ac40: 6c66 2e5f 6469 7374 6f72 7469 6f6e 2c20  lf._distortion, 
+0001ac50: 666c 6167 733d 6d65 7468 6f64 5f64 6963  flags=method_dic
+0001ac60: 745b 6d65 7468 6f64 5d29 0a0a 2020 2020  t[method])..    
+0001ac70: 2020 2020 6966 2073 6f6c 5b30 5d3a 0a20      if sol[0]:. 
+0001ac80: 2020 2020 2020 2020 2020 2023 2070 6f73             # pos
+0001ac90: 6520 6f66 2074 6172 6765 7420 7769 7468  e of target with
+0001aca0: 2072 6573 7065 6374 2074 6f20 6361 6d65   respect to came
+0001acb0: 7261 0a20 2020 2020 2020 2020 2020 2070  ra.            p
+0001acc0: 6f73 655f 435f 5420 3d20 5345 3328 736f  ose_C_T = SE3(so
+0001acd0: 6c5b 325d 2920 2a20 5345 332e 4575 6c65  l[2]) * SE3.Eule
+0001ace0: 7256 6563 2873 6f6c 5b31 5d29 0a20 2020  rVec(sol[1]).   
+0001acf0: 2020 2020 2020 2020 2023 2070 6f73 6520           # pose 
+0001ad00: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
+0001ad10: 776f 726c 6420 6672 616d 650a 2020 2020  world frame.    
+0001ad20: 2020 2020 2020 2020 6966 2066 7261 6d65          if frame
+0001ad30: 203d 3d20 2263 616d 6572 6122 3a0a 2020   == "camera":.  
+0001ad40: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0001ad50: 7475 726e 2070 6f73 655f 435f 540a 2020  turn pose_C_T.  
+0001ad60: 2020 2020 2020 2020 2020 656c 6966 2066            elif f
+0001ad70: 7261 6d65 203d 3d20 2277 6f72 6c64 223a  rame == "world":
+0001ad80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001ad90: 2072 6574 7572 6e20 7365 6c66 2e70 6f73   return self.pos
+0001ada0: 6520 2a20 706f 7365 5f43 5f54 0a20 2020  e * pose_C_T.   
+0001adb0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0001adc0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0001add0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+0001ade0: 6622 6261 6420 6672 616d 6520 7661 6c75  f"bad frame valu
+0001adf0: 6520 7b66 7261 6d65 7d22 290a 0a20 2020  e {frame}")..   
+0001ae00: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0001ae10: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
+0001ae20: 6e65 0a0a 0a23 202d 2d2d 2d2d 2d2d 2d2d  ne...# ---------
+0001ae30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001ae40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001ae50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001ae60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
+0001ae70: 230a 0a0a 636c 6173 7320 4669 7368 4579  #...class FishEy
+0001ae80: 6543 616d 6572 6128 4361 6d65 7261 4261  eCamera(CameraBa
+0001ae90: 7365 293a 0a20 2020 2072 2222 220a 2020  se):.    r""".  
+0001aea0: 2020 4372 6561 7465 2066 6973 6865 7965    Create fisheye
+0001aeb0: 2063 616d 6572 6120 7072 6f6a 6563 7469   camera projecti
+0001aec0: 6f6e 206d 6f64 656c 0a0a 2020 2020 2e2e  on model..    ..
+0001aed0: 2069 6e68 6572 6974 616e 6365 2d64 6961   inheritance-dia
+0001aee0: 6772 616d 3a3a 206d 6163 6869 6e65 7669  gram:: machinevi
+0001aef0: 7369 6f6e 746f 6f6c 626f 782e 4361 6d65  siontoolbox.Came
+0001af00: 7261 2e46 6973 6845 7965 4361 6d65 7261  ra.FishEyeCamera
+0001af10: 0a20 2020 2020 2020 203a 746f 702d 636c  .        :top-cl
+0001af20: 6173 7365 733a 206d 6163 6869 6e65 7669  asses: machinevi
+0001af30: 7369 6f6e 746f 6f6c 626f 782e 4361 6d65  siontoolbox.Came
+0001af40: 7261 2e43 616d 6572 610a 2020 2020 2020  ra.Camera.      
+0001af50: 2020 3a70 6172 7473 3a20 310a 0a20 2020    :parts: 1..   
+0001af60: 203a 7061 7261 6d20 6b3a 2073 6361 6c65   :param k: scale
+0001af70: 2066 6163 746f 720a 2020 2020 3a74 7970   factor.    :typ
+0001af80: 6520 6b3a 2066 6c6f 6174 2c20 6f70 7469  e k: float, opti
+0001af90: 6f6e 616c 0a20 2020 203a 7061 7261 6d20  onal.    :param 
+0001afa0: 7072 6f6a 6563 7469 6f6e 3a20 7072 6f6a  projection: proj
+0001afb0: 6563 7469 6f6e 206d 6f64 656c 3a20 6060  ection model: ``
+0001afc0: 2765 7175 6961 6e67 756c 6172 2760 6020  'equiangular'`` 
+0001afd0: 5b64 6566 6175 6c74 5d2c 2060 6027 7369  [default], ``'si
+0001afe0: 6e65 2760 602c 2060 6027 6571 7569 736f  ne'``, ``'equiso
+0001aff0: 6c69 6427 6060 206f 7220 6060 2773 7465  lid'`` or ``'ste
+0001b000: 7265 6f67 7261 7068 6963 2760 600a 2020  reographic'``.  
+0001b010: 2020 3a74 7970 6520 7072 6f6a 6563 7469    :type projecti
+0001b020: 6f6e 3a20 7374 722c 206f 7074 696f 6e61  on: str, optiona
+0001b030: 6c0a 2020 2020 3a70 6172 616d 206b 7761  l.    :param kwa
+0001b040: 7267 733a 2061 7267 756d 656e 7473 2070  rgs: arguments p
+0001b050: 6173 7365 6420 746f 203a 636c 6173 733a  assed to :class:
+0001b060: 6043 616d 6572 6142 6173 6560 2063 6f6e  `CameraBase` con
+0001b070: 7374 7275 6374 6f72 0a0a 2020 2020 4120  structor..    A 
+0001b080: 6669 7368 6579 6520 6361 6d65 7261 2063  fisheye camera c
+0001b090: 6f6e 7461 696e 7320 6120 7769 6465 2061  ontains a wide a
+0001b0a0: 6e67 6c65 206c 656e 732c 2061 6e64 2074  ngle lens, and t
+0001b0b0: 6865 2061 6e67 6c65 206f 6620 7468 650a  he angle of the.
+0001b0c0: 2020 2020 696e 636f 6d69 6e67 2072 6179      incoming ray
+0001b0d0: 2069 7320 6d61 7070 6564 2074 6f20 6120   is mapped to a 
+0001b0e0: 7261 6469 7573 2077 6974 6820 7265 7370  radius with resp
+0001b0f0: 6563 7420 746f 2074 6865 2070 7269 6e63  ect to the princ
+0001b100: 6970 616c 2070 6f69 6e74 2e0a 2020 2020  ipal point..    
+0001b110: 5468 6520 6d61 7070 696e 6720 6672 6f6d  The mapping from
+0001b120: 2065 6c65 7661 7469 6f6e 2061 6e67 6c65   elevation angle
+0001b130: 203a 6d61 7468 3a60 5c74 6865 7461 6020   :math:`\theta` 
+0001b140: 746f 2069 6d61 6765 2070 6c61 6e65 2072  to image plane r
+0001b150: 6164 6975 7320 6973 0a20 2020 2067 6976  adius is.    giv
+0001b160: 656e 2062 793a 0a0a 2020 2020 2020 2020  en by:..        
+0001b170: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 2020  =============   
+0001b180: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001b190: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001b1a0: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+0001b1b0: 5072 6f6a 6563 7469 6f6e 2020 2020 2020  Projection      
+0001b1c0: 3a6d 6174 683a 6072 285c 7468 6574 6129  :math:`r(\theta)
+0001b1d0: 600a 2020 2020 2020 2020 3d3d 3d3d 3d3d  `.        ======
+0001b1e0: 3d3d 3d3d 3d3d 3d20 2020 3d3d 3d3d 3d3d  =======   ======
+0001b1f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001b200: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001b210: 3d0a 2020 2020 2020 2020 6571 7569 616e  =.        equian
+0001b220: 6775 6c61 7220 2020 2020 3a6d 6174 683a  gular     :math:
+0001b230: 6072 203d 206b 205c 7468 6574 6160 0a20  `r = k \theta`. 
+0001b240: 2020 2020 2020 2073 696e 6520 2020 2020         sine     
+0001b250: 2020 2020 2020 203a 6d61 7468 3a60 7220         :math:`r 
+0001b260: 3d20 6b20 5c73 696e 205c 7468 6574 6160  = k \sin \theta`
+0001b270: 0a20 2020 2020 2020 2065 7175 6973 6f6c  .        equisol
+0001b280: 6964 2020 2020 2020 203a 6d61 7468 3a60  id       :math:`
+0001b290: 7220 3d20 6b20 5c73 696e 205c 6672 6163  r = k \sin \frac
+0001b2a0: 7b5c 7468 6574 617d 7b32 7d60 0a20 2020  {\theta}{2}`.   
+0001b2b0: 2020 2020 2073 7465 7265 6f67 7261 7068       stereograph
+0001b2c0: 6963 2020 203a 6d61 7468 3a60 7220 3d20  ic   :math:`r = 
+0001b2d0: 6b20 5c74 616e 205c 6672 6163 7b5c 7468  k \tan \frac{\th
+0001b2e0: 6574 617d 7b32 7d60 0a20 2020 2020 2020  eta}{2}`.       
+0001b2f0: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2020   =============  
+0001b300: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+0001b310: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001b320: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 3a6e  ========..    :n
+0001b330: 6f74 653a 0a20 2020 2020 2020 202d 2049  ote:.        - I
+0001b340: 6620 6060 4b60 6020 6973 206e 6f74 2073  f ``K`` is not s
+0001b350: 7065 6369 6669 6564 2069 7420 6973 2063  pecified it is c
+0001b360: 6f6d 7075 7465 6420 7375 6368 2074 6861  omputed such tha
+0001b370: 7420 7468 6520 6369 7263 756c 6172 0a20  t the circular. 
+0001b380: 2020 2020 2020 2020 2020 2069 6d61 6769             imagi
+0001b390: 6e67 2072 6567 696f 6e20 6d61 7869 6d61  ng region maxima
+0001b3a0: 6c6c 7920 6669 6c6c 7320 7468 6520 7371  lly fills the sq
+0001b3b0: 7561 7265 2069 6d61 6765 2070 6c61 6e65  uare image plane
+0001b3c0: 2e0a 2020 2020 2020 2020 2d20 5468 6973  ..        - This
+0001b3d0: 2063 616d 6572 6120 6d6f 6465 6c20 6173   camera model as
+0001b3e0: 7375 6d65 7320 6365 6e74 7261 6c20 7072  sumes central pr
+0001b3f0: 6f6a 6563 7469 6f6e 2c20 7468 6174 2069  ojection, that i
+0001b400: 732c 2074 6865 2066 6f63 616c 2070 6f69  s, the focal poi
+0001b410: 6e74 0a20 2020 2020 2020 2020 2020 2069  nt.            i
+0001b420: 7320 6174 207a 3d30 2061 6e64 2074 6865  s at z=0 and the
+0001b430: 2069 6d61 6765 2070 6c61 6e65 2069 7320   image plane is 
+0001b440: 6174 207a 3d66 2e20 2054 6865 2069 6d61  at z=f.  The ima
+0001b450: 6765 2069 7320 6e6f 7420 696e 7665 7274  ge is not invert
+0001b460: 6564 2e0a 0a20 2020 203a 7265 6665 7265  ed...    :refere
+0001b470: 6e63 6573 3a0a 2020 2020 2020 2020 2d20  nces:.        - 
+0001b480: 526f 626f 7469 6373 2c20 5669 7369 6f6e  Robotics, Vision
+0001b490: 2026 2043 6f6e 7472 6f6c 2066 6f72 2050   & Control for P
+0001b4a0: 7974 686f 6e2c 2053 6563 7469 6f6e 2031  ython, Section 1
+0001b4b0: 332e 332e 312c 2050 2e20 436f 726b 652c  3.3.1, P. Corke,
+0001b4c0: 2053 7072 696e 6765 7220 3230 3233 2e0a   Springer 2023..
+0001b4d0: 0a20 2020 203a 7365 6561 6c73 6f3a 203a  .    :seealso: :
+0001b4e0: 636c 6173 733a 6043 616d 6572 6142 6173  class:`CameraBas
+0001b4f0: 6560 203a 636c 6173 733a 6043 656e 7472  e` :class:`Centr
+0001b500: 616c 4361 6d65 7261 6020 3a63 6c61 7373  alCamera` :class
+0001b510: 3a60 4361 7461 6469 6f70 7472 6963 4361  :`CatadioptricCa
+0001b520: 6d65 7261 600a 2020 2020 2020 2020 3a63  mera`.        :c
+0001b530: 6c61 7373 3a60 5370 6865 7269 6361 6c43  lass:`SphericalC
+0001b540: 616d 6572 6160 0a20 2020 2022 2222 0a0a  amera`.    """..
+0001b550: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+0001b560: 2873 656c 662c 206b 3d4e 6f6e 652c 2070  (self, k=None, p
+0001b570: 726f 6a65 6374 696f 6e3d 2265 7175 6961  rojection="equia
+0001b580: 6e67 756c 6172 222c 202a 2a6b 7761 7267  ngular", **kwarg
+0001b590: 7329 3a0a 0a20 2020 2020 2020 2073 7570  s):..        sup
+0001b5a0: 6572 2829 2e5f 5f69 6e69 745f 5f28 6361  er().__init__(ca
+0001b5b0: 6d74 7970 653d 2266 6973 6865 7965 222c  mtype="fisheye",
+0001b5c0: 202a 2a6b 7761 7267 7329 0a0a 2020 2020   **kwargs)..    
+0001b5d0: 2020 2020 7365 6c66 2e70 726f 6a65 6374      self.project
+0001b5e0: 696f 6e20 3d20 7072 6f6a 6563 7469 6f6e  ion = projection
+0001b5f0: 0a0a 2020 2020 2020 2020 6966 206b 2069  ..        if k i
+0001b600: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0001b610: 2020 2020 7220 3d20 6e70 2e6d 696e 2828      r = np.min((
+0001b620: 7365 6c66 2e69 6d61 6765 7369 7a65 202d  self.imagesize -
+0001b630: 2073 656c 662e 7070 2920 2a20 7365 6c66   self.pp) * self
+0001b640: 2e72 686f 290a 0a20 2020 2020 2020 2069  .rho)..        i
+0001b650: 6620 7365 6c66 2e70 726f 6a65 6374 696f  f self.projectio
+0001b660: 6e20 3d3d 2022 6571 7569 616e 6775 6c61  n == "equiangula
+0001b670: 7222 3a0a 2020 2020 2020 2020 2020 2020  r":.            
+0001b680: 6966 206b 2069 7320 4e6f 6e65 3a0a 2020  if k is None:.  
+0001b690: 2020 2020 2020 2020 2020 2020 2020 6b20                k 
+0001b6a0: 3d20 7220 2f20 2870 6920 2f20 3229 0a20  = r / (pi / 2). 
+0001b6b0: 2020 2020 2020 2020 2020 2072 6675 6e63             rfunc
+0001b6c0: 203d 206c 616d 6264 6120 7468 6574 613a   = lambda theta:
+0001b6d0: 206b 202a 2074 6865 7461 0a20 2020 2020   k * theta.     
+0001b6e0: 2020 2065 6c69 6620 7365 6c66 2e70 726f     elif self.pro
+0001b6f0: 6a65 6374 696f 6e20 3d3d 2022 7369 6e65  jection == "sine
+0001b700: 223a 0a20 2020 2020 2020 2020 2020 2069  ":.            i
+0001b710: 6620 6b20 6973 204e 6f6e 653a 0a20 2020  f k is None:.   
+0001b720: 2020 2020 2020 2020 2020 2020 206b 203d               k =
+0001b730: 2072 0a20 2020 2020 2020 2020 2020 2072   r.            r
+0001b740: 6675 6e63 203d 206c 616d 6264 6120 7468  func = lambda th
+0001b750: 6574 613a 206b 202a 206e 702e 7369 6e28  eta: k * np.sin(
+0001b760: 7468 6574 6129 0a20 2020 2020 2020 2065  theta).        e
+0001b770: 6c69 6620 7365 6c66 2e70 726f 6a65 6374  lif self.project
+0001b780: 696f 6e20 3d3d 2022 6571 7569 736f 6c69  ion == "equisoli
+0001b790: 6422 3a0a 2020 2020 2020 2020 2020 2020  d":.            
+0001b7a0: 6966 206b 2069 7320 4e6f 6e65 3a0a 2020  if k is None:.  
+0001b7b0: 2020 2020 2020 2020 2020 2020 2020 6b20                k 
+0001b7c0: 3d20 7220 2f20 7369 6e28 7069 202f 2034  = r / sin(pi / 4
+0001b7d0: 290a 2020 2020 2020 2020 2020 2020 7266  ).            rf
+0001b7e0: 756e 6320 3d20 6c61 6d62 6461 2074 6865  unc = lambda the
+0001b7f0: 7461 3a20 6b20 2a20 6e70 2e73 696e 2874  ta: k * np.sin(t
+0001b800: 6865 7461 202f 2032 290a 2020 2020 2020  heta / 2).      
+0001b810: 2020 656c 6966 2073 656c 662e 7072 6f6a    elif self.proj
+0001b820: 6563 7469 6f6e 203d 3d20 2273 7465 7265  ection == "stere
+0001b830: 6f67 7261 7068 6963 223a 0a20 2020 2020  ographic":.     
+0001b840: 2020 2020 2020 2069 6620 6b20 6973 204e         if k is N
+0001b850: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0001b860: 2020 2020 206b 203d 2072 202f 2074 616e       k = r / tan
+0001b870: 2870 6920 2f20 3429 0a20 2020 2020 2020  (pi / 4).       
+0001b880: 2020 2020 2072 6675 6e63 203d 206c 616d       rfunc = lam
+0001b890: 6264 6120 7468 6574 613a 206b 202a 206e  bda theta: k * n
+0001b8a0: 702e 7461 6e28 7468 6574 6120 2f20 3229  p.tan(theta / 2)
+0001b8b0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0001b8c0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0001b8d0: 2056 616c 7565 4572 726f 7228 2275 6e6b   ValueError("unk
+0001b8e0: 6e6f 776e 2070 726f 6a65 6374 696f 6e20  nown projection 
+0001b8f0: 6d6f 6465 6c22 290a 0a20 2020 2020 2020  model")..       
+0001b900: 2073 656c 662e 6b20 3d20 6b0a 2020 2020   self.k = k.    
+0001b910: 2020 2020 7365 6c66 2e72 6675 6e63 203d      self.rfunc =
+0001b920: 2072 6675 6e63 0a0a 2020 2020 6465 6620   rfunc..    def 
+0001b930: 5f5f 7374 725f 5f28 7365 6c66 293a 0a20  __str__(self):. 
+0001b940: 2020 2020 2020 2073 203d 2073 7570 6572         s = super
+0001b950: 2829 2e5f 5f73 7472 5f5f 2829 0a20 2020  ().__str__().   
+0001b960: 2020 2020 2073 202b 3d20 7365 6c66 2e66       s += self.f
+0001b970: 6d74 2e66 6f72 6d61 7428 226d 6f64 656c  mt.format("model
+0001b980: 222c 2073 656c 662e 7072 6f6a 6563 7469  ", self.projecti
+0001b990: 6f6e 2c20 666d 743d 227b 7d22 290a 2020  on, fmt="{}").  
+0001b9a0: 2020 2020 2020 7320 2b3d 2073 656c 662e        s += self.
+0001b9b0: 666d 742e 666f 726d 6174 2822 6b22 2c20  fmt.format("k", 
+0001b9c0: 7365 6c66 2e6b 2c20 666d 743d 227b 3a2e  self.k, fmt="{:.
+0001b9d0: 3467 7d22 290a 2020 2020 2020 2020 7265  4g}").        re
+0001b9e0: 7475 726e 2073 0a0a 2020 2020 6465 6620  turn s..    def 
+0001b9f0: 7072 6f6a 6563 745f 706f 696e 7428 7365  project_point(se
+0001ba00: 6c66 2c20 502c 2070 6f73 653d 4e6f 6e65  lf, P, pose=None
+0001ba10: 2c20 6f62 6a70 6f73 653d 4e6f 6e65 293a  , objpose=None):
+0001ba20: 0a20 2020 2020 2020 2072 2222 220a 2020  .        r""".  
+0001ba30: 2020 2020 2020 5072 6f6a 6563 7420 3344        Project 3D
+0001ba40: 2070 6f69 6e74 7320 746f 2069 6d61 6765   points to image
+0001ba50: 2070 6c61 6e65 0a0a 2020 2020 2020 2020   plane..        
+0001ba60: 3a70 6172 616d 2050 3a20 3344 2077 6f72  :param P: 3D wor
+0001ba70: 6c64 2070 6f69 6e74 206f 7220 706f 696e  ld point or poin
+0001ba80: 7473 0a20 2020 2020 2020 203a 7479 7065  ts.        :type
+0001ba90: 2050 3a20 6172 7261 795f 6c69 6b65 2833   P: array_like(3
+0001baa0: 292c 2061 7272 6179 5f6c 696b 6528 332c  ), array_like(3,
+0001bab0: 6e29 0a20 2020 2020 2020 203a 7061 7261  n).        :para
+0001bac0: 6d20 706f 7365 3a20 6361 6d65 7261 2070  m pose: camera p
+0001bad0: 6f73 6520 7769 7468 2072 6573 7065 6374  ose with respect
+0001bae0: 2074 6f20 7468 6520 776f 726c 6420 6672   to the world fr
+0001baf0: 616d 652c 2064 6566 6175 6c74 7320 746f  ame, defaults to
+0001bb00: 0a20 2020 2020 2020 2020 2020 2063 616d  .            cam
+0001bb10: 6572 6127 7320 6060 706f 7365 6060 2061  era's ``pose`` a
+0001bb20: 7474 7269 6275 7465 0a20 2020 2020 2020  ttribute.       
+0001bb30: 203a 7479 7065 2070 6f73 653a 2053 453a   :type pose: SE:
+0001bb40: 636c 6173 733a 607e 7370 6174 6961 6c6d  class:`~spatialm
+0001bb50: 6174 682e 2e70 6f73 6533 642e 5345 3360  ath..pose3d.SE3`
+0001bb60: 332c 206f 7074 696f 6e61 6c0a 2020 2020  3, optional.    
+0001bb70: 2020 2020 3a70 6172 616d 206f 626a 706f      :param objpo
+0001bb80: 7365 3a20 2033 4420 706f 696e 7420 7265  se:  3D point re
+0001bb90: 6665 7265 6e63 6520 6672 616d 652c 2064  ference frame, d
+0001bba0: 6566 6175 6c74 7320 746f 2077 6f72 6c64  efaults to world
+0001bbb0: 2066 7261 6d65 0a20 2020 2020 2020 203a   frame.        :
+0001bbc0: 7479 7065 206f 626a 706f 7365 3a20 3a63  type objpose: :c
+0001bbd0: 6c61 7373 3a60 7e73 7061 7469 616c 6d61  lass:`~spatialma
+0001bbe0: 7468 2e2e 706f 7365 3364 2e53 4533 602c  th..pose3d.SE3`,
+0001bbf0: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
+0001bc00: 2020 3a70 6172 616d 2076 6973 6962 696c    :param visibil
+0001bc10: 6974 793a 2074 6573 7420 6966 2070 6f69  ity: test if poi
+0001bc20: 6e74 7320 6172 6520 7669 7369 626c 652c  nts are visible,
+0001bc30: 2064 6566 6175 6c74 2046 616c 7365 0a20   default False. 
+0001bc40: 2020 2020 2020 203a 7479 7065 2076 6973         :type vis
+0001bc50: 6962 696c 6974 793a 2062 6f6f 6c0a 2020  ibility: bool.  
+0001bc60: 2020 2020 2020 3a72 6169 7365 7320 5661        :raises Va
+0001bc70: 6c75 6545 7272 6f72 3a20 5b64 6573 6372  lueError: [descr
+0001bc80: 6970 7469 6f6e 5d0a 2020 2020 2020 2020  iption].        
+0001bc90: 3a72 6574 7572 6e3a 2069 6d61 6765 2070  :return: image p
+0001bca0: 6c61 6e65 2070 6f69 6e74 730a 2020 2020  lane points.    
+0001bcb0: 2020 2020 3a72 7479 7065 3a20 6e64 6172      :rtype: ndar
+0001bcc0: 7261 7928 322c 6e29 0a0a 2020 2020 2020  ray(2,n)..      
+0001bcd0: 2020 5072 6f6a 6563 7420 776f 726c 6420    Project world 
+0001bce0: 706f 696e 7473 2074 6f20 7468 6520 6669  points to the fi
+0001bcf0: 7368 6579 6520 6361 6d65 7261 2069 6d61  sheye camera ima
+0001bd00: 6765 2070 6c61 6e65 2e0a 0a20 2020 2020  ge plane...     
+0001bd10: 2020 2054 6865 2065 6c65 7661 7469 6f6e     The elevation
+0001bd20: 2061 6e67 6c65 2072 616e 6765 2069 7320   angle range is 
+0001bd30: 6672 6f6d 203a 6d61 7468 3a60 2d70 692f  from :math:`-pi/
+0001bd40: 3260 2028 6265 6c6f 7720 7468 6520 6d69  2` (below the mi
+0001bd50: 7272 6f72 2920 746f 0a20 2020 2020 2020  rror) to.       
+0001bd60: 206d 6178 616e 676c 6520 6162 6f76 6520   maxangle above 
+0001bd70: 7468 6520 686f 7269 7a6f 6e74 616c 2070  the horizontal p
+0001bd80: 6c61 6e65 2e20 5468 6520 6d61 7070 696e  lane. The mappin
+0001bd90: 6720 6672 6f6d 2065 6c65 7661 7469 6f6e  g from elevation
+0001bda0: 2061 6e67 6c65 0a20 2020 2020 2020 203a   angle.        :
+0001bdb0: 6d61 7468 3a60 5c74 6865 7461 6020 746f  math:`\theta` to
+0001bdc0: 2069 6d61 6765 2070 6c61 6e65 2072 6164   image plane rad
+0001bdd0: 6975 7320 6973 2067 6976 656e 2062 793a  ius is given by:
+0001bde0: 0a0a 2020 2020 2020 2020 2020 2020 3d3d  ..            ==
+0001bdf0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 2020 3d3d  ===========   ==
+0001be00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001be10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001be20: 3d3d 3d3d 3d0a 2020 2020 2020 2020 2020  =====.          
+0001be30: 2020 5072 6f6a 6563 7469 6f6e 2020 2020    Projection    
+0001be40: 2020 3a6d 6174 683a 6072 285c 7468 6574    :math:`r(\thet
+0001be50: 6129 600a 2020 2020 2020 2020 2020 2020  a)`.            
+0001be60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 2020  =============   
+0001be70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001be80: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001be90: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+0001bea0: 2020 2020 6571 7569 616e 6775 6c61 7220      equiangular 
+0001beb0: 2020 2020 3a6d 6174 683a 6072 203d 206b      :math:`r = k
+0001bec0: 205c 7468 6574 6160 0a20 2020 2020 2020   \theta`.       
+0001bed0: 2020 2020 2073 696e 6520 2020 2020 2020       sine       
+0001bee0: 2020 2020 203a 6d61 7468 3a60 7220 3d20       :math:`r = 
+0001bef0: 6b20 5c73 696e 205c 7468 6574 6160 0a20  k \sin \theta`. 
+0001bf00: 2020 2020 2020 2020 2020 2065 7175 6973             equis
+0001bf10: 6f6c 6964 2020 2020 2020 203a 6d61 7468  olid       :math
+0001bf20: 3a60 7220 3d20 6b20 5c73 696e 205c 6672  :`r = k \sin \fr
+0001bf30: 6163 7b5c 7468 6574 617d 7b32 7d60 0a20  ac{\theta}{2}`. 
+0001bf40: 2020 2020 2020 2020 2020 2073 7465 7265             stere
+0001bf50: 6f67 7261 7068 6963 2020 203a 6d61 7468  ographic   :math
+0001bf60: 3a60 7220 3d20 6b20 5c74 616e 205c 6672  :`r = k \tan \fr
+0001bf70: 6163 7b5c 7468 6574 617d 7b32 7d60 0a20  ac{\theta}{2}`. 
+0001bf80: 2020 2020 2020 2020 2020 203d 3d3d 3d3d             =====
+0001bf90: 3d3d 3d3d 3d3d 3d3d 2020 203d 3d3d 3d3d  ========   =====
+0001bfa0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001bfb0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001bfc0: 3d3d 0a0a 2020 2020 2020 2020 576f 726c  ==..        Worl
+0001bfd0: 6420 706f 696e 7473 2061 7265 2067 6976  d points are giv
+0001bfe0: 656e 2061 7320 6120 3144 2061 7272 6179  en as a 1D array
+0001bff0: 206f 7220 7468 6520 636f 6c75 6d6e 7320   or the columns 
+0001c000: 6f66 2061 2032 4420 6172 7261 7920 6f66  of a 2D array of
+0001c010: 0a20 2020 2020 2020 2045 7563 6c69 6465  .        Euclide
+0001c020: 616e 2063 6f6f 7264 696e 6174 6573 2e20  an coordinates. 
+0001c030: 5468 6520 636f 6d70 7574 6564 2069 6d61  The computed ima
+0001c040: 6765 2070 6c61 6e65 2063 6f6f 7264 696e  ge plane coordin
+0001c050: 6174 6573 2061 7265 0a20 2020 2020 2020  ates are.       
+0001c060: 2045 7563 6c69 6465 616e 2061 6e64 2067   Euclidean and g
+0001c070: 6976 656e 2061 7320 6120 3144 2061 7272  iven as a 1D arr
+0001c080: 6179 206f 7220 7468 6520 636f 7272 6573  ay or the corres
+0001c090: 706f 6e64 696e 6720 636f 6c75 6d6e 7320  ponding columns 
+0001c0a0: 6f66 2061 2032 440a 2020 2020 2020 2020  of a 2D.        
+0001c0b0: 6172 7261 792e 0a0a 2020 2020 2020 2020  array...        
+0001c0c0: 4966 2060 6070 6f73 6560 6020 6973 2073  If ``pose`` is s
+0001c0d0: 7065 6369 6669 6564 2069 7420 6973 2075  pecified it is u
+0001c0e0: 7365 6420 666f 7220 7468 6520 6361 6d65  sed for the came
+0001c0f0: 7261 2070 6f73 6520 696e 7374 6561 6420  ra pose instead 
+0001c100: 6f66 2074 6865 0a20 2020 2020 2020 2061  of the.        a
+0001c110: 7474 7269 6275 7465 2060 6070 6f73 6560  ttribute ``pose`
+0001c120: 602e 2020 5468 6520 6f62 6a65 6374 2773  `.  The object's
+0001c130: 2061 7474 7269 6275 7465 2069 7320 6e6f   attribute is no
+0001c140: 7420 7570 6461 7465 642e 0a0a 2020 2020  t updated...    
+0001c150: 2020 2020 5468 6520 706f 696e 7473 2060      The points `
+0001c160: 6050 6060 2061 7265 2062 7920 6465 6661  `P`` are by defa
+0001c170: 756c 7420 7769 7468 2072 6573 7065 6374  ult with respect
+0001c180: 2074 6f20 7468 6520 776f 726c 6420 6672   to the world fr
+0001c190: 616d 652c 2062 7574 0a20 2020 2020 2020  ame, but.       
+0001c1a0: 2074 6865 7920 6361 6e20 6265 2074 7261   they can be tra
+0001c1b0: 6e73 666f 726d 6564 2062 7920 7370 6563  nsformed by spec
+0001c1c0: 6966 7969 6e67 2060 606f 626a 706f 7365  ifying ``objpose
+0001c1d0: 6060 2e0a 0a20 2020 2020 2020 203a 7365  ``...        :se
+0001c1e0: 6561 6c73 6f3a 203a 6d65 7468 3a60 706c  ealso: :meth:`pl
+0001c1f0: 6f74 5f70 6f69 6e74 600a 2020 2020 2020  ot_point`.      
+0001c200: 2020 2222 220a 0a20 2020 2020 2020 2050    """..        P
+0001c210: 203d 2062 6173 652e 6765 746d 6174 7269   = base.getmatri
+0001c220: 7828 502c 2028 332c 204e 6f6e 6529 290a  x(P, (3, None)).
+0001c230: 0a20 2020 2020 2020 2069 6620 706f 7365  .        if pose
+0001c240: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0001c250: 2020 2020 2020 2020 2020 5420 3d20 7365            T = se
+0001c260: 6c66 2e70 6f73 652e 696e 7628 290a 2020  lf.pose.inv().  
+0001c270: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0001c280: 2020 2020 2020 2020 5420 3d20 5345 3328          T = SE3(
+0001c290: 290a 2020 2020 2020 2020 6966 206f 626a  ).        if obj
+0001c2a0: 706f 7365 2069 7320 6e6f 7420 4e6f 6e65  pose is not None
+0001c2b0: 3a0a 2020 2020 2020 2020 2020 2020 5420  :.            T 
+0001c2c0: 2a3d 206f 626a 706f 7365 0a0a 2020 2020  *= objpose..    
+0001c2d0: 2020 2020 5220 3d20 6e70 2e73 7172 7428      R = np.sqrt(
+0001c2e0: 6e70 2e73 756d 2850 2a2a 322c 2061 7869  np.sum(P**2, axi
+0001c2f0: 733d 3029 290a 2020 2020 2020 2020 7068  s=0)).        ph
+0001c300: 6920 3d20 6e70 2e61 7263 7461 6e32 2850  i = np.arctan2(P
+0001c310: 5b31 2c20 3a5d 2c20 505b 302c 203a 5d29  [1, :], P[0, :])
+0001c320: 0a20 2020 2020 2020 2074 6865 7461 203d  .        theta =
+0001c330: 206e 702e 6172 6363 6f73 2850 5b32 2c20   np.arccos(P[2, 
+0001c340: 3a5d 202f 2052 290a 0a20 2020 2020 2020  :] / R)..       
+0001c350: 2072 203d 2073 656c 662e 7266 756e 6328   r = self.rfunc(
+0001c360: 7468 6574 6129 0a20 2020 2020 2020 2078  theta).        x
+0001c370: 203d 2072 202a 206e 702e 636f 7328 7068   = r * np.cos(ph
+0001c380: 6929 0a20 2020 2020 2020 2079 203d 2072  i).        y = r
+0001c390: 202a 206e 702e 7369 6e28 7068 6929 0a0a   * np.sin(phi)..
+0001c3a0: 2020 2020 2020 2020 7576 203d 206e 702e          uv = np.
+0001c3b0: 6172 7261 7928 5b78 202f 2073 656c 662e  array([x / self.
+0001c3c0: 7268 6f75 202b 2073 656c 662e 7530 2c20  rhou + self.u0, 
+0001c3d0: 7920 2f20 7365 6c66 2e72 686f 7620 2b20  y / self.rhov + 
+0001c3e0: 7365 6c66 2e76 305d 290a 0a20 2020 2020  self.v0])..     
+0001c3f0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0001c400: 6164 645f 6e6f 6973 655f 6469 7374 6f72  add_noise_distor
+0001c410: 7469 6f6e 2875 7629 0a0a 0a23 202d 2d2d  tion(uv)...# ---
+0001c420: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001c430: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001c440: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001c450: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001c460: 2d2d 2d2d 2d20 230a 0a0a 636c 6173 7320  ----- #...class 
+0001c470: 4361 7461 6469 6f70 7472 6963 4361 6d65  CatadioptricCame
+0001c480: 7261 2843 616d 6572 6142 6173 6529 3a0a  ra(CameraBase):.
+0001c490: 2020 2020 7222 2222 0a20 2020 2043 7265      r""".    Cre
+0001c4a0: 6174 6520 6361 7461 6469 6f70 7472 6963  ate catadioptric
+0001c4b0: 2063 616d 6572 6120 7072 6f6a 6563 7469   camera projecti
+0001c4c0: 6f6e 206d 6f64 656c 0a0a 2020 2020 2e2e  on model..    ..
+0001c4d0: 2069 6e68 6572 6974 616e 6365 2d64 6961   inheritance-dia
+0001c4e0: 6772 616d 3a3a 206d 6163 6869 6e65 7669  gram:: machinevi
+0001c4f0: 7369 6f6e 746f 6f6c 626f 782e 4361 6d65  siontoolbox.Came
+0001c500: 7261 2e43 6174 6164 696f 7074 7269 6343  ra.CatadioptricC
+0001c510: 616d 6572 610a 2020 2020 2020 2020 3a74  amera.        :t
+0001c520: 6f70 2d63 6c61 7373 6573 3a20 6d61 6368  op-classes: mach
+0001c530: 696e 6576 6973 696f 6e74 6f6f 6c62 6f78  inevisiontoolbox
+0001c540: 2e43 616d 6572 612e 4361 6d65 7261 0a20  .Camera.Camera. 
+0001c550: 2020 2020 2020 203a 7061 7274 733a 2031         :parts: 1
+0001c560: 0a0a 2020 2020 3a70 6172 616d 206b 3a20  ..    :param k: 
+0001c570: 7363 616c 6520 6661 6374 6f72 0a20 2020  scale factor.   
+0001c580: 203a 7479 7065 206b 3a20 666c 6f61 742c   :type k: float,
+0001c590: 206f 7074 696f 6e61 6c0a 2020 2020 3a70   optional.    :p
+0001c5a0: 6172 616d 2070 726f 6a65 6374 696f 6e3a  aram projection:
+0001c5b0: 2070 726f 6a65 6374 696f 6e20 6d6f 6465   projection mode
+0001c5c0: 6c3a 2060 6027 6571 7569 616e 6775 6c61  l: ``'equiangula
+0001c5d0: 7227 6060 205b 6465 6661 756c 745d 2c20  r'`` [default], 
+0001c5e0: 6060 2773 696e 6527 6060 2c20 6060 2765  ``'sine'``, ``'e
+0001c5f0: 7175 6973 6f6c 6964 2760 6020 6f72 2060  quisolid'`` or `
+0001c600: 6027 7374 6572 656f 6772 6170 6869 6327  `'stereographic'
+0001c610: 6060 0a20 2020 203a 7479 7065 2070 726f  ``.    :type pro
+0001c620: 6a65 6374 696f 6e3a 2073 7472 2c20 6f70  jection: str, op
+0001c630: 7469 6f6e 616c 0a20 2020 203a 7061 7261  tional.    :para
+0001c640: 6d20 6b77 6172 6773 3a20 6172 6775 6d65  m kwargs: argume
+0001c650: 6e74 7320 7061 7373 6564 2074 6f20 3a63  nts passed to :c
+0001c660: 6c61 7373 3a60 4361 6d65 7261 4261 7365  lass:`CameraBase
+0001c670: 6020 636f 6e73 7472 7563 746f 720a 0a20  ` constructor.. 
+0001c680: 2020 2041 2063 6174 6164 696f 7074 7269     A catadioptri
+0001c690: 6320 6361 6d65 7261 2063 6f6d 7072 6973  c camera compris
+0001c6a0: 6573 2061 2070 6572 7370 6563 7469 7665  es a perspective
+0001c6b0: 2063 616d 6572 6120 706f 696e 7465 6420   camera pointed 
+0001c6c0: 6174 2061 0a20 2020 2063 6f6e 7665 7820  at a.    convex 
+0001c6d0: 6d69 7272 6f72 2c20 7479 7069 6361 6c6c  mirror, typicall
+0001c6e0: 7920 7061 7261 626f 6c6f 6964 616c 206f  y paraboloidal o
+0001c6f0: 7220 636f 6e69 6361 6c2e 0a0a 2020 2020  r conical...    
+0001c700: 5468 6520 656c 6576 6174 696f 6e20 616e  The elevation an
+0001c710: 676c 6520 7261 6e67 6520 6973 2066 726f  gle range is fro
+0001c720: 6d20 3a6d 6174 683a 602d 5c70 692f 3260  m :math:`-\pi/2`
+0001c730: 2028 6265 6c6f 7720 7468 6520 6d69 7272   (below the mirr
+0001c740: 6f72 2920 746f 0a20 2020 206d 6178 616e  or) to.    maxan
+0001c750: 676c 6520 6162 6f76 6520 7468 6520 686f  gle above the ho
+0001c760: 7269 7a6f 6e74 616c 2070 6c61 6e65 2e20  rizontal plane. 
+0001c770: 5468 6520 6d61 7070 696e 6720 6672 6f6d  The mapping from
+0001c780: 2065 6c65 7661 7469 6f6e 2061 6e67 6c65   elevation angle
+0001c790: 0a20 2020 203a 6d61 7468 3a60 5c74 6865  .    :math:`\the
+0001c7a0: 7461 6020 746f 2069 6d61 6765 2070 6c61  ta` to image pla
+0001c7b0: 6e65 2072 6164 6975 7320 6973 2067 6976  ne radius is giv
+0001c7c0: 656e 2062 793a 0a0a 2020 2020 2020 2020  en by:..        
+0001c7d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 2020  =============   
+0001c7e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001c7f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001c800: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+0001c810: 5072 6f6a 6563 7469 6f6e 2020 2020 2020  Projection      
+0001c820: 3a6d 6174 683a 6072 285c 7468 6574 6129  :math:`r(\theta)
+0001c830: 600a 2020 2020 2020 2020 3d3d 3d3d 3d3d  `.        ======
+0001c840: 3d3d 3d3d 3d3d 3d20 2020 3d3d 3d3d 3d3d  =======   ======
+0001c850: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001c860: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001c870: 3d0a 2020 2020 2020 2020 6571 7569 616e  =.        equian
+0001c880: 6775 6c61 7220 2020 2020 3a6d 6174 683a  gular     :math:
+0001c890: 6072 203d 206b 205c 7468 6574 6160 0a20  `r = k \theta`. 
+0001c8a0: 2020 2020 2020 2073 696e 6520 2020 2020         sine     
+0001c8b0: 2020 2020 2020 203a 6d61 7468 3a60 7220         :math:`r 
+0001c8c0: 3d20 6b20 5c73 696e 205c 7468 6574 6160  = k \sin \theta`
+0001c8d0: 0a20 2020 2020 2020 2065 7175 6973 6f6c  .        equisol
+0001c8e0: 6964 2020 2020 2020 203a 6d61 7468 3a60  id       :math:`
+0001c8f0: 7220 3d20 6b20 5c73 696e 205c 6672 6163  r = k \sin \frac
+0001c900: 7b5c 7468 6574 617d 7b32 7d60 0a20 2020  {\theta}{2}`.   
+0001c910: 2020 2020 2073 7465 7265 6f67 7261 7068       stereograph
+0001c920: 6963 2020 203a 6d61 7468 3a60 7220 3d20  ic   :math:`r = 
+0001c930: 6b20 5c74 616e 205c 6672 6163 7b5c 7468  k \tan \frac{\th
+0001c940: 6574 617d 7b32 7d60 0a20 2020 2020 2020  eta}{2}`.       
+0001c950: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 2020   =============  
+0001c960: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+0001c970: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0001c980: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 3a6e  ========..    :n
+0001c990: 6f74 653a 0a20 2020 2020 2020 202d 2049  ote:.        - I
+0001c9a0: 6620 6060 4b60 6020 6973 206e 6f74 2073  f ``K`` is not s
+0001c9b0: 7065 6369 6669 6564 2069 7420 6973 2063  pecified it is c
+0001c9c0: 6f6d 7075 7465 6420 7375 6368 2074 6861  omputed such tha
+0001c9d0: 7420 7468 6520 6369 7263 756c 6172 0a20  t the circular. 
+0001c9e0: 2020 2020 2020 2020 2020 2069 6d61 6769             imagi
+0001c9f0: 6e67 2072 6567 696f 6e20 6d61 7869 6d61  ng region maxima
+0001ca00: 6c6c 7920 6669 6c6c 7320 7468 6520 696d  lly fills the im
+0001ca10: 6167 6520 706c 616e 652e 0a20 2020 2020  age plane..     
+0001ca20: 2020 202d 2054 6869 7320 6361 6d65 7261     - This camera
+0001ca30: 206d 6f64 656c 2061 7373 756d 6573 2063   model assumes c
+0001ca40: 656e 7472 616c 2070 726f 6a65 6374 696f  entral projectio
+0001ca50: 6e2c 2074 6861 7420 6973 2c20 7468 6520  n, that is, the 
+0001ca60: 666f 6361 6c20 706f 696e 740a 2020 2020  focal point.    
+0001ca70: 2020 2020 2020 2020 6973 2061 7420 3a6d          is at :m
+0001ca80: 6174 683a 607a 3d30 6020 616e 6420 7468  ath:`z=0` and th
+0001ca90: 6520 696d 6167 6520 706c 616e 6520 6973  e image plane is
+0001caa0: 2061 7420 3a6d 6174 683a 607a 3d66 602e   at :math:`z=f`.
+0001cab0: 2020 5468 6520 696d 6167 6520 6973 206e    The image is n
+0001cac0: 6f74 2069 6e76 6572 7465 642e 0a0a 2020  ot inverted...  
+0001cad0: 2020 3a72 6566 6572 656e 6365 733a 0a20    :references:. 
+0001cae0: 2020 2020 2020 202d 2052 6f62 6f74 6963         - Robotic
+0001caf0: 732c 2056 6973 696f 6e20 2620 436f 6e74  s, Vision & Cont
+0001cb00: 726f 6c20 666f 7220 5079 7468 6f6e 2c20  rol for Python, 
+0001cb10: 5365 6374 696f 6e20 3133 2e33 2e32 2c20  Section 13.3.2, 
+0001cb20: 502e 2043 6f72 6b65 2c20 5370 7269 6e67  P. Corke, Spring
+0001cb30: 6572 2032 3032 332e 0a0a 2020 2020 3a73  er 2023...    :s
+0001cb40: 6565 616c 736f 3a20 3a63 6c61 7373 3a60  eealso: :class:`
+0001cb50: 4361 6d65 7261 4261 7365 6020 3a63 6c61  CameraBase` :cla
+0001cb60: 7373 3a60 4365 6e74 7261 6c43 616d 6572  ss:`CentralCamer
+0001cb70: 6160 203a 636c 6173 733a 6046 6973 6845  a` :class:`FishE
+0001cb80: 7965 4361 6d65 7261 600a 2020 2020 2020  yeCamera`.      
+0001cb90: 2020 3a63 6c61 7373 3a60 5370 6865 7269    :class:`Spheri
+0001cba0: 6361 6c43 616d 6572 6160 0a20 2020 2022  calCamera`.    "
+0001cbb0: 2222 0a0a 2020 2020 6465 6620 5f5f 696e  ""..    def __in
+0001cbc0: 6974 5f5f 2873 656c 662c 206b 3d4e 6f6e  it__(self, k=Non
+0001cbd0: 652c 2070 726f 6a65 6374 696f 6e3d 2265  e, projection="e
+0001cbe0: 7175 6961 6e67 756c 6172 222c 206d 6178  quiangular", max
+0001cbf0: 616e 676c 653d 4e6f 6e65 2c20 2a2a 6b77  angle=None, **kw
+0001cc00: 6172 6773 293a 0a0a 2020 2020 2020 2020  args):..        
+0001cc10: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+0001cc20: 2863 616d 7479 7065 3d22 6361 7461 6469  (camtype="catadi
+0001cc30: 6f70 7472 6963 222c 202a 2a6b 7761 7267  optric", **kwarg
+0001cc40: 7329 0a0a 2020 2020 2020 2020 7365 6c66  s)..        self
+0001cc50: 2e70 726f 6a65 6374 696f 6e20 3d20 7072  .projection = pr
+0001cc60: 6f6a 6563 7469 6f6e 0a0a 2020 2020 2020  ojection..      
+0001cc70: 2020 6966 206b 2069 7320 4e6f 6e65 3a0a    if k is None:.
+0001cc80: 2020 2020 2020 2020 2020 2020 7220 3d20              r = 
+0001cc90: 6e70 2e6d 696e 2828 7365 6c66 2e69 6d61  np.min((self.ima
+0001cca0: 6765 7369 7a65 202d 2073 656c 662e 7070  gesize - self.pp
+0001ccb0: 2920 2a20 7365 6c66 2e72 686f 290a 0a20  ) * self.rho).. 
+0001ccc0: 2020 2020 2020 2023 2063 6f6d 7075 7465         # compute
+0001ccd0: 206b 2069 6620 6e6f 7420 7370 6563 6966   k if not specif
+0001cce0: 6965 642c 2073 6f20 7468 6174 2068 656d  ied, so that hem
+0001ccf0: 6973 7068 6572 6520 6669 7473 2069 6e74  isphere fits int
+0001cd00: 6f0a 2020 2020 2020 2020 2320 696d 6167  o.        # imag
+0001cd10: 6520 706c 616e 652c 2072 6571 7569 7265  e plane, require
+0001cd20: 7320 6d61 7861 6e67 6c65 2062 6569 6e67  s maxangle being
+0001cd30: 2073 6574 0a0a 2020 2020 2020 2020 6966   set..        if
+0001cd40: 2073 656c 662e 7072 6f6a 6563 7469 6f6e   self.projection
+0001cd50: 203d 3d20 2265 7175 6961 6e67 756c 6172   == "equiangular
+0001cd60: 223a 0a20 2020 2020 2020 2020 2020 2069  ":.            i
+0001cd70: 6620 6b20 6973 204e 6f6e 653a 0a20 2020  f k is None:.   
+0001cd80: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001cd90: 6d61 7861 6e67 6c65 2069 7320 6e6f 7420  maxangle is not 
+0001cda0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0001cdb0: 2020 2020 2020 2020 2020 6b20 3d20 7220            k = r 
+0001cdc0: 2f20 2870 6920 2f20 3220 2b20 6d61 7861  / (pi / 2 + maxa
+0001cdd0: 6e67 6c65 290a 2020 2020 2020 2020 2020  ngle).          
+0001cde0: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+0001cdf0: 6178 616e 676c 6520 3d20 6d61 7861 6e67  axangle = maxang
+0001ce00: 6c65 0a20 2020 2020 2020 2020 2020 2020  le.             
+0001ce10: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001ce20: 2020 2020 2020 2020 2020 2020 2072 6169               rai
+0001ce30: 7365 2056 616c 7565 4572 726f 7228 226d  se ValueError("m
+0001ce40: 7573 7420 7370 6563 6966 7920 6569 7468  ust specify eith
+0001ce50: 6572 206b 206f 7220 6d61 7861 6e67 6c65  er k or maxangle
+0001ce60: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
+0001ce70: 6675 6e63 203d 206c 616d 6264 6120 7468  func = lambda th
+0001ce80: 6574 613a 206b 202a 2074 6865 7461 0a20  eta: k * theta. 
+0001ce90: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
+0001cea0: 2e70 726f 6a65 6374 696f 6e20 3d3d 2022  .projection == "
+0001ceb0: 7369 6e65 223a 0a20 2020 2020 2020 2020  sine":.         
+0001cec0: 2020 2069 6620 6b20 6973 204e 6f6e 653a     if k is None:
+0001ced0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001cee0: 206b 203d 2072 0a20 2020 2020 2020 2020   k = r.         
+0001cef0: 2020 2072 6675 6e63 203d 206c 616d 6264     rfunc = lambd
+0001cf00: 6120 7468 6574 613a 206b 202a 206e 702e  a theta: k * np.
+0001cf10: 7369 6e28 7468 6574 6129 0a20 2020 2020  sin(theta).     
+0001cf20: 2020 2065 6c69 6620 7365 6c66 2e70 726f     elif self.pro
+0001cf30: 6a65 6374 696f 6e20 3d3d 2022 6571 7569  jection == "equi
+0001cf40: 736f 6c69 6422 3a0a 2020 2020 2020 2020  solid":.        
+0001cf50: 2020 2020 6966 206b 2069 7320 4e6f 6e65      if k is None
+0001cf60: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001cf70: 2020 6b20 3d20 7220 2f20 7369 6e28 7069    k = r / sin(pi
+0001cf80: 202f 2034 290a 2020 2020 2020 2020 2020   / 4).          
+0001cf90: 2020 7266 756e 6320 3d20 6c61 6d62 6461    rfunc = lambda
+0001cfa0: 2074 6865 7461 3a20 6b20 2a20 6e70 2e73   theta: k * np.s
+0001cfb0: 696e 2874 6865 7461 202f 2032 290a 2020  in(theta / 2).  
+0001cfc0: 2020 2020 2020 656c 6966 2073 656c 662e        elif self.
+0001cfd0: 7072 6f6a 6563 7469 6f6e 203d 3d20 2273  projection == "s
+0001cfe0: 7465 7265 6f67 7261 7068 6963 223a 0a20  tereographic":. 
+0001cff0: 2020 2020 2020 2020 2020 2069 6620 6b20             if k 
+0001d000: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0001d010: 2020 2020 2020 2020 206b 203d 2072 202f           k = r /
+0001d020: 2074 616e 2870 6920 2f20 3429 0a20 2020   tan(pi / 4).   
+0001d030: 2020 2020 2020 2020 2072 6675 6e63 203d           rfunc =
+0001d040: 206c 616d 6264 6120 7468 6574 613a 206b   lambda theta: k
+0001d050: 202a 206e 702e 7461 6e28 7468 6574 6120   * np.tan(theta 
+0001d060: 2f20 3229 0a20 2020 2020 2020 2065 6c73  / 2).        els
+0001d070: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0001d080: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+0001d090: 2275 6e6b 6e6f 776e 2070 726f 6a65 6374  "unknown project
+0001d0a0: 696f 6e20 6d6f 6465 6c22 290a 0a20 2020  ion model")..   
+0001d0b0: 2020 2020 2073 656c 662e 6b20 3d20 6b0a       self.k = k.
+0001d0c0: 2020 2020 2020 2020 7365 6c66 2e72 6675          self.rfu
+0001d0d0: 6e63 203d 2072 6675 6e63 0a0a 2020 2020  nc = rfunc..    
+0001d0e0: 6465 6620 5f5f 7374 725f 5f28 7365 6c66  def __str__(self
+0001d0f0: 293a 0a20 2020 2020 2020 2073 203d 2073  ):.        s = s
+0001d100: 7570 6572 2829 2e5f 5f73 7472 5f5f 2829  uper().__str__()
+0001d110: 0a20 2020 2020 2020 2073 202b 3d20 7365  .        s += se
+0001d120: 6c66 2e66 6d74 2e66 6f72 6d61 7428 226d  lf.fmt.format("m
+0001d130: 6f64 656c 222c 2073 656c 662e 7072 6f6a  odel", self.proj
+0001d140: 6563 7469 6f6e 2c20 666d 743d 227b 7d22  ection, fmt="{}"
+0001d150: 290a 2020 2020 2020 2020 7320 2b3d 2073  ).        s += s
+0001d160: 656c 662e 666d 742e 666f 726d 6174 2822  elf.fmt.format("
+0001d170: 6b22 2c20 7365 6c66 2e6b 2c20 666d 743d  k", self.k, fmt=
+0001d180: 227b 3a2e 3467 7d22 290a 2020 2020 2020  "{:.4g}").      
+0001d190: 2020 7265 7475 726e 2073 0a0a 2020 2020    return s..    
+0001d1a0: 6465 6620 7072 6f6a 6563 745f 706f 696e  def project_poin
+0001d1b0: 7428 7365 6c66 2c20 502c 2070 6f73 653d  t(self, P, pose=
+0001d1c0: 4e6f 6e65 2c20 6f62 6a70 6f73 653d 4e6f  None, objpose=No
+0001d1d0: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
+0001d1e0: 0a20 2020 2020 2020 2050 726f 6a65 6374  .        Project
+0001d1f0: 2033 4420 706f 696e 7473 2074 6f20 696d   3D points to im
+0001d200: 6167 6520 706c 616e 650a 0a20 2020 2020  age plane..     
+0001d210: 2020 203a 7061 7261 6d20 503a 2033 4420     :param P: 3D 
+0001d220: 776f 726c 6420 706f 696e 7420 6f72 2070  world point or p
+0001d230: 6f69 6e74 730a 2020 2020 2020 2020 3a74  oints.        :t
+0001d240: 7970 6520 503a 2061 7272 6179 5f6c 696b  ype P: array_lik
+0001d250: 6528 3329 2c20 6172 7261 795f 6c69 6b65  e(3), array_like
+0001d260: 2833 2c6e 290a 2020 2020 2020 2020 3a70  (3,n).        :p
+0001d270: 6172 616d 2070 6f73 653a 2063 616d 6572  aram pose: camer
+0001d280: 6120 706f 7365 2077 6974 6820 7265 7370  a pose with resp
+0001d290: 6563 7420 746f 2074 6865 2077 6f72 6c64  ect to the world
+0001d2a0: 2066 7261 6d65 2c20 6465 6661 756c 7473   frame, defaults
+0001d2b0: 2074 6f0a 2020 2020 2020 2020 2020 2020   to.            
+0001d2c0: 6361 6d65 7261 2773 2060 6070 6f73 6560  camera's ``pose`
+0001d2d0: 6020 6174 7472 6962 7574 650a 2020 2020  ` attribute.    
+0001d2e0: 2020 2020 3a74 7970 6520 706f 7365 3a20      :type pose: 
+0001d2f0: 3a63 6c61 7373 3a60 7e73 7061 7469 616c  :class:`~spatial
+0001d300: 6d61 7468 2e2e 706f 7365 3364 2e53 4533  math..pose3d.SE3
+0001d310: 602c 206f 7074 696f 6e61 6c0a 2020 2020  `, optional.    
+0001d320: 2020 2020 3a70 6172 616d 206f 626a 706f      :param objpo
+0001d330: 7365 3a20 2033 4420 706f 696e 7420 7265  se:  3D point re
+0001d340: 6665 7265 6e63 6520 6672 616d 652c 2064  ference frame, d
+0001d350: 6566 6175 6c74 7320 746f 2077 6f72 6c64  efaults to world
+0001d360: 2066 7261 6d65 0a20 2020 2020 2020 203a   frame.        :
+0001d370: 7479 7065 206f 626a 706f 7365 3a20 3a63  type objpose: :c
+0001d380: 6c61 7373 3a60 7e73 7061 7469 616c 6d61  lass:`~spatialma
+0001d390: 7468 2e2e 706f 7365 3364 2e53 4533 602c  th..pose3d.SE3`,
+0001d3a0: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
+0001d3b0: 2020 3a70 6172 616d 2076 6973 6962 696c    :param visibil
+0001d3c0: 6974 793a 2074 6573 7420 6966 2070 6f69  ity: test if poi
+0001d3d0: 6e74 7320 6172 6520 7669 7369 626c 652c  nts are visible,
+0001d3e0: 2064 6566 6175 6c74 2046 616c 7365 0a20   default False. 
+0001d3f0: 2020 2020 2020 203a 7479 7065 2076 6973         :type vis
+0001d400: 6962 696c 6974 793a 2062 6f6f 6c0a 2020  ibility: bool.  
+0001d410: 2020 2020 2020 3a72 6169 7365 7320 5661        :raises Va
+0001d420: 6c75 6545 7272 6f72 3a20 5b64 6573 6372  lueError: [descr
+0001d430: 6970 7469 6f6e 5d0a 2020 2020 2020 2020  iption].        
+0001d440: 3a72 6574 7572 6e3a 2069 6d61 6765 2070  :return: image p
+0001d450: 6c61 6e65 2070 6f69 6e74 730a 2020 2020  lane points.    
+0001d460: 2020 2020 3a72 7479 7065 3a20 6e64 6172      :rtype: ndar
+0001d470: 7261 7928 322c 6e29 0a0a 2020 2020 2020  ray(2,n)..      
+0001d480: 2020 5072 6f6a 6563 7420 776f 726c 6420    Project world 
+0001d490: 706f 696e 7473 2074 6f20 7468 6520 6361  points to the ca
+0001d4a0: 7461 6469 6f70 7472 6963 2063 616d 6572  tadioptric camer
+0001d4b0: 6120 696d 6167 6520 706c 616e 652e 0a0a  a image plane...
+0001d4c0: 2020 2020 2020 2020 576f 726c 6420 706f          World po
+0001d4d0: 696e 7473 2061 7265 2067 6976 656e 2061  ints are given a
+0001d4e0: 7320 6120 3144 2061 7272 6179 206f 7220  s a 1D array or 
+0001d4f0: 7468 6520 636f 6c75 6d6e 7320 6f66 2061  the columns of a
+0001d500: 2032 4420 6172 7261 7920 6f66 0a20 2020   2D array of.   
+0001d510: 2020 2020 2045 7563 6c69 6465 616e 2063       Euclidean c
+0001d520: 6f6f 7264 696e 6174 6573 2e20 5468 6520  oordinates. The 
+0001d530: 636f 6d70 7574 6564 2069 6d61 6765 2070  computed image p
+0001d540: 6c61 6e65 2063 6f6f 7264 696e 6174 6573  lane coordinates
+0001d550: 2061 7265 0a20 2020 2020 2020 2045 7563   are.        Euc
+0001d560: 6c69 6465 616e 2061 6e64 2067 6976 656e  lidean and given
+0001d570: 2061 7320 6120 3144 2061 7272 6179 206f   as a 1D array o
+0001d580: 7220 7468 6520 636f 7272 6573 706f 6e64  r the correspond
+0001d590: 696e 6720 636f 6c75 6d6e 7320 6f66 2061  ing columns of a
+0001d5a0: 2032 440a 2020 2020 2020 2020 6172 7261   2D.        arra
+0001d5b0: 792e 0a0a 2020 2020 2020 2020 4966 2060  y...        If `
+0001d5c0: 6070 6f73 6560 6020 6973 2073 7065 6369  `pose`` is speci
+0001d5d0: 6669 6564 2069 7420 6973 2075 7365 6420  fied it is used 
+0001d5e0: 666f 7220 7468 6520 6361 6d65 7261 2070  for the camera p
+0001d5f0: 6f73 6520 696e 7374 6561 6420 6f66 2074  ose instead of t
+0001d600: 6865 0a20 2020 2020 2020 2061 7474 7269  he.        attri
+0001d610: 6275 7465 2060 6070 6f73 6560 602e 2020  bute ``pose``.  
+0001d620: 5468 6520 6f62 6a65 6374 2773 2061 7474  The object's att
+0001d630: 7269 6275 7465 2069 7320 6e6f 7420 7570  ribute is not up
+0001d640: 6461 7465 642e 0a0a 2020 2020 2020 2020  dated...        
+0001d650: 5468 6520 706f 696e 7473 2060 6050 6060  The points ``P``
+0001d660: 2061 7265 2062 7920 6465 6661 756c 7420   are by default 
+0001d670: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
+0001d680: 7468 6520 776f 726c 6420 6672 616d 652c  the world frame,
+0001d690: 2062 7574 0a20 2020 2020 2020 2074 6865   but.        the
+0001d6a0: 7920 6361 6e20 6265 2074 7261 6e73 666f  y can be transfo
+0001d6b0: 726d 6564 2062 7920 7370 6563 6966 7969  rmed by specifyi
+0001d6c0: 6e67 2060 606f 626a 706f 7365 6060 2e0a  ng ``objpose``..
+0001d6d0: 0a20 2020 2020 2020 203a 7365 6561 6c73  .        :seeals
+0001d6e0: 6f3a 203a 6d65 7468 3a60 706c 6f74 5f70  o: :meth:`plot_p
+0001d6f0: 6f69 6e74 600a 2020 2020 2020 2020 2222  oint`.        ""
+0001d700: 220a 2020 2020 2020 2020 5020 3d20 6261  ".        P = ba
+0001d710: 7365 2e67 6574 6d61 7472 6978 2850 2c20  se.getmatrix(P, 
+0001d720: 2833 2c20 4e6f 6e65 2929 0a0a 2020 2020  (3, None))..    
+0001d730: 2020 2020 6966 2070 6f73 6520 6973 206e      if pose is n
+0001d740: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+0001d750: 2020 2020 2054 203d 2073 656c 662e 706f       T = self.po
+0001d760: 7365 2e69 6e76 2829 0a20 2020 2020 2020  se.inv().       
+0001d770: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001d780: 2020 2054 203d 2053 4533 2829 0a20 2020     T = SE3().   
+0001d790: 2020 2020 2069 6620 6f62 6a70 6f73 6520       if objpose 
+0001d7a0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0001d7b0: 2020 2020 2020 2020 2054 202a 3d20 6f62           T *= ob
+0001d7c0: 6a70 6f73 650a 0a20 2020 2020 2020 2050  jpose..        P
+0001d7d0: 203d 2054 202a 2050 2020 2320 7472 616e   = T * P  # tran
+0001d7e0: 7366 6f72 6d20 706f 696e 7473 2074 6f20  sform points to 
+0001d7f0: 6361 6d65 7261 2066 7261 6d65 0a0a 2020  camera frame..  
+0001d800: 2020 2020 2020 2320 7072 6f6a 6563 7420        # project 
+0001d810: 746f 2074 6865 2069 6d61 6765 2070 6c61  to the image pla
+0001d820: 6e65 0a20 2020 2020 2020 2052 203d 206e  ne.        R = n
+0001d830: 702e 7371 7274 286e 702e 7375 6d28 502a  p.sqrt(np.sum(P*
+0001d840: 2a32 2c20 6178 6973 3d30 2929 0a20 2020  *2, axis=0)).   
+0001d850: 2020 2020 2070 6869 203d 206e 702e 6172       phi = np.ar
+0001d860: 6374 616e 3228 505b 312c 203a 5d2c 2050  ctan2(P[1, :], P
+0001d870: 5b30 2c20 3a5d 290a 2020 2020 2020 2020  [0, :]).        
+0001d880: 7468 6574 6120 3d20 6e70 2e61 7263 636f  theta = np.arcco
+0001d890: 7328 505b 322c 203a 5d20 2f20 5229 0a0a  s(P[2, :] / R)..
+0001d8a0: 2020 2020 2020 2020 7220 3d20 7365 6c66          r = self
+0001d8b0: 2e72 6675 6e63 2874 6865 7461 2920 2023  .rfunc(theta)  #
+0001d8c0: 2064 6570 656e 6473 206f 6e20 7072 6f6a   depends on proj
+0001d8d0: 6563 7469 6f6e 206d 6f64 656c 0a20 2020  ection model.   
+0001d8e0: 2020 2020 2078 203d 2072 202a 206e 702e       x = r * np.
+0001d8f0: 636f 7328 7068 6929 0a20 2020 2020 2020  cos(phi).       
+0001d900: 2079 203d 2072 202a 206e 702e 7369 6e28   y = r * np.sin(
+0001d910: 7068 6929 0a0a 2020 2020 2020 2020 7576  phi)..        uv
+0001d920: 203d 206e 702e 6172 7261 7928 5b78 202f   = np.array([x /
+0001d930: 2073 656c 662e 7268 6f75 202b 2073 656c   self.rhou + sel
+0001d940: 662e 7530 2c20 7920 2f20 7365 6c66 2e72  f.u0, y / self.r
+0001d950: 686f 7620 2b20 7365 6c66 2e76 305d 290a  hov + self.v0]).
+0001d960: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001d970: 7365 6c66 2e5f 6164 645f 6e6f 6973 655f  self._add_noise_
+0001d980: 6469 7374 6f72 7469 6f6e 2875 7629 0a0a  distortion(uv)..
+0001d990: 0a23 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .# -------------
+0001d9a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001d9b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001d9c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0001d9d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 230a 636c  ----------- #.cl
+0001d9e0: 6173 7320 5370 6865 7269 6361 6c43 616d  ass SphericalCam
+0001d9f0: 6572 6128 4361 6d65 7261 4261 7365 293a  era(CameraBase):
+0001da00: 0a20 2020 2022 2222 0a20 2020 2043 7265  .    """.    Cre
+0001da10: 6174 6520 7370 6865 7269 6361 6c20 6361  ate spherical ca
+0001da20: 6d65 7261 2070 726f 6a65 6374 696f 6e20  mera projection 
+0001da30: 6d6f 6465 6c0a 0a20 2020 202e 2e20 696e  model..    .. in
+0001da40: 6865 7269 7461 6e63 652d 6469 6167 7261  heritance-diagra
+0001da50: 6d3a 3a20 6d61 6368 696e 6576 6973 696f  m:: machinevisio
+0001da60: 6e74 6f6f 6c62 6f78 2e43 616d 6572 612e  ntoolbox.Camera.
+0001da70: 5370 6865 7269 6361 6c43 616d 6572 610a  SphericalCamera.
+0001da80: 2020 2020 2020 2020 3a74 6f70 2d63 6c61          :top-cla
+0001da90: 7373 6573 3a20 6d61 6368 696e 6576 6973  sses: machinevis
+0001daa0: 696f 6e74 6f6f 6c62 6f78 2e43 616d 6572  iontoolbox.Camer
+0001dab0: 612e 4361 6d65 7261 0a20 2020 2020 2020  a.Camera.       
+0001dac0: 203a 7061 7274 733a 2031 0a0a 2020 2020   :parts: 1..    
+0001dad0: 3a70 6172 616d 206b 7761 7267 733a 2061  :param kwargs: a
+0001dae0: 7267 756d 656e 7473 2070 6173 7365 6420  rguments passed 
+0001daf0: 746f 203a 636c 6173 733a 6043 616d 6572  to :class:`Camer
+0001db00: 6142 6173 6560 2063 6f6e 7374 7275 6374  aBase` construct
+0001db10: 6f72 0a0a 2020 2020 5468 6520 7370 6865  or..    The sphe
+0001db20: 7269 6361 6c20 6361 6d65 7261 2069 7320  rical camera is 
+0001db30: 616e 2069 6465 616c 697a 6174 696f 6e20  an idealization 
+0001db40: 7769 7468 2061 2063 6f6d 706c 6574 6520  with a complete 
+0001db50: 6669 656c 6420 6f66 2076 6965 770a 2020  field of view.  
+0001db60: 2020 7468 6174 2063 616e 2062 6520 7573    that can be us
+0001db70: 6564 2074 6f20 6765 6e65 7261 6c69 7a65  ed to generalize
+0001db80: 2061 6c6c 2063 616d 6572 6120 7072 6f6a   all camera proj
+0001db90: 6563 7469 6f6e 206d 6f64 656c 732e 0a0a  ection models...
+0001dba0: 2020 2020 3a72 6566 6572 656e 6365 733a      :references:
+0001dbb0: 0a20 2020 2020 2020 202d 2052 6f62 6f74  .        - Robot
+0001dbc0: 6963 732c 2056 6973 696f 6e20 2620 436f  ics, Vision & Co
+0001dbd0: 6e74 726f 6c20 666f 7220 5079 7468 6f6e  ntrol for Python
+0001dbe0: 2c20 5365 6374 696f 6e20 3133 2e33 2e33  , Section 13.3.3
+0001dbf0: 2c20 502e 2043 6f72 6b65 2c20 5370 7269  , P. Corke, Spri
+0001dc00: 6e67 6572 2032 3032 332e 0a0a 2020 2020  nger 2023...    
+0001dc10: 3a73 6565 616c 736f 3a20 3a63 6c61 7373  :seealso: :class
+0001dc20: 3a60 4361 6d65 7261 4261 7365 6020 3a63  :`CameraBase` :c
+0001dc30: 6c61 7373 3a60 4365 6e74 7261 6c43 616d  lass:`CentralCam
+0001dc40: 6572 6160 203a 636c 6173 733a 6043 6174  era` :class:`Cat
+0001dc50: 6164 696f 7074 7269 6343 616d 6572 6160  adioptricCamera`
+0001dc60: 0a20 2020 2020 2020 203a 636c 6173 733a  .        :class:
+0001dc70: 6046 6973 6845 7965 4361 6d65 7261 600a  `FishEyeCamera`.
+0001dc80: 2020 2020 2222 220a 0a20 2020 2064 6566      """..    def
+0001dc90: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+0001dca0: 2a2a 6b77 6172 6773 293a 0a0a 2020 2020  **kwargs):..    
+0001dcb0: 2020 2020 2320 696e 766f 6b65 2074 6865      # invoke the
+0001dcc0: 2073 7570 6572 636c 6173 7320 636f 6e73   superclass cons
+0001dcd0: 7472 7563 746f 720a 2020 2020 2020 2020  tructor.        
+0001dce0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+0001dcf0: 280a 2020 2020 2020 2020 2020 2020 6361  (.            ca
+0001dd00: 6d74 7970 653d 2273 7068 6572 6963 616c  mtype="spherical
+0001dd10: 222c 0a20 2020 2020 2020 2020 2020 206c  ",.            l
+0001dd20: 696d 6974 733d 5b2d 7069 2c20 7069 2c20  imits=[-pi, pi, 
+0001dd30: 302c 2070 695d 2c0a 2020 2020 2020 2020  0, pi],.        
+0001dd40: 2020 2020 6c61 6265 6c73 3d5b 224c 6f6e      labels=["Lon
+0001dd50: 6769 7475 6465 20cf 8620 2872 6164 2922  gitude .. (rad)"
+0001dd60: 2c20 2243 6f6c 6174 6974 7564 6520 ceb8  , "Colatitude ..
+0001dd70: 2028 7261 6429 225d 2c0a 2020 2020 2020   (rad)"],.      
+0001dd80: 2020 2020 2020 2a2a 6b77 6172 6773 2c0a        **kwargs,.
+0001dd90: 2020 2020 2020 2020 290a 0a20 2020 2023          )..    #
+0001dda0: 2072 6574 7572 6e20 6669 656c 642d 6f66   return field-of
+0001ddb0: 2d76 6965 7720 616e 676c 6520 666f 7220  -view angle for 
+0001ddc0: 7820 616e 6420 7920 6469 7265 6374 696f  x and y directio
+0001ddd0: 6e20 2872 6164 290a 2020 2020 6465 6620  n (rad).    def 
+0001dde0: 666f 7628 7365 6c66 293a 0a20 2020 2020  fov(self):.     
+0001ddf0: 2020 2022 2222 0a20 2020 2020 2020 2043     """.        C
+0001de00: 616d 6572 6120 6669 656c 642d 6f66 2d76  amera field-of-v
+0001de10: 6965 7720 616e 676c 6573 0a0a 2020 2020  iew angles..    
+0001de20: 2020 2020 3a72 6574 7572 6e3a 2066 6965      :return: fie
+0001de30: 6c64 206f 6620 7669 6577 2061 6e67 6c65  ld of view angle
+0001de40: 7320 696e 2072 6164 6961 6e73 0a20 2020  s in radians.   
+0001de50: 2020 2020 203a 7274 7970 653a 206e 6461       :rtype: nda
+0001de60: 7272 6179 2832 290a 0a20 2020 2020 2020  rray(2)..       
+0001de70: 2043 6f6d 7075 7465 7320 7468 6520 6669   Computes the fi
+0001de80: 656c 6420 6f66 2076 6965 7720 616e 676c  eld of view angl
+0001de90: 6573 2028 3278 3129 2069 6e20 7261 6469  es (2x1) in radi
+0001dea0: 616e 7320 666f 7220 7468 6520 6361 6d65  ans for the came
+0001deb0: 7261 0a20 2020 2020 2020 2068 6f72 697a  ra.        horiz
+0001dec0: 6f6e 7461 6c20 616e 6420 7665 7274 6963  ontal and vertic
+0001ded0: 616c 2064 6972 6563 7469 6f6e 732e 0a20  al directions.. 
+0001dee0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0001def0: 2020 2072 6574 7572 6e20 5b32 202a 2070     return [2 * p
+0001df00: 692c 2032 202a 2070 695d 0a0a 2020 2020  i, 2 * pi]..    
+0001df10: 6465 6620 7072 6f6a 6563 745f 706f 696e  def project_poin
+0001df20: 7428 7365 6c66 2c20 502c 2070 6f73 653d  t(self, P, pose=
+0001df30: 4e6f 6e65 2c20 6f62 6a70 6f73 653d 4e6f  None, objpose=No
+0001df40: 6e65 293a 0a20 2020 2020 2020 2072 2222  ne):.        r""
+0001df50: 220a 2020 2020 2020 2020 5072 6f6a 6563  ".        Projec
+0001df60: 7420 3344 2070 6f69 6e74 7320 746f 2069  t 3D points to i
+0001df70: 6d61 6765 2070 6c61 6e65 0a0a 2020 2020  mage plane..    
+0001df80: 2020 2020 3a70 6172 616d 2050 3a20 3344      :param P: 3D
+0001df90: 2077 6f72 6c64 2070 6f69 6e74 206f 7220   world point or 
+0001dfa0: 706f 696e 7473 0a20 2020 2020 2020 203a  points.        :
+0001dfb0: 7479 7065 2050 3a20 6172 7261 795f 6c69  type P: array_li
+0001dfc0: 6b65 2833 292c 2061 7272 6179 5f6c 696b  ke(3), array_lik
+0001dfd0: 6528 332c 6e29 0a20 2020 2020 2020 203a  e(3,n).        :
+0001dfe0: 7061 7261 6d20 706f 7365 3a20 6361 6d65  param pose: came
+0001dff0: 7261 2070 6f73 6520 7769 7468 2072 6573  ra pose with res
+0001e000: 7065 6374 2074 6f20 7468 6520 776f 726c  pect to the worl
+0001e010: 6420 6672 616d 652c 2064 6566 6175 6c74  d frame, default
+0001e020: 7320 746f 0a20 2020 2020 2020 2020 2020  s to.           
+0001e030: 2063 616d 6572 6127 7320 6060 706f 7365   camera's ``pose
+0001e040: 6060 2061 7474 7269 6275 7465 0a20 2020  `` attribute.   
+0001e050: 2020 2020 203a 7479 7065 2070 6f73 653a       :type pose:
+0001e060: 203a 636c 6173 733a 607e 7370 6174 6961   :class:`~spatia
+0001e070: 6c6d 6174 682e 2e70 6f73 6533 642e 5345  lmath..pose3d.SE
+0001e080: 3360 2c20 6f70 7469 6f6e 616c 0a20 2020  3`, optional.   
+0001e090: 2020 2020 203a 7061 7261 6d20 6f62 6a70       :param objp
+0001e0a0: 6f73 653a 2020 3344 2070 6f69 6e74 2072  ose:  3D point r
+0001e0b0: 6566 6572 656e 6365 2066 7261 6d65 2c20  eference frame, 
+0001e0c0: 6465 6661 756c 7473 2074 6f20 776f 726c  defaults to worl
+0001e0d0: 6420 6672 616d 650a 2020 2020 2020 2020  d frame.        
+0001e0e0: 3a74 7970 6520 6f62 6a70 6f73 653a 203a  :type objpose: :
+0001e0f0: 636c 6173 733a 607e 7370 6174 6961 6c6d  class:`~spatialm
+0001e100: 6174 682e 2e70 6f73 6533 642e 5345 3360  ath..pose3d.SE3`
+0001e110: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
+0001e120: 2020 203a 7265 7475 726e 3a20 696d 6167     :return: imag
+0001e130: 6520 706c 616e 6520 706f 696e 7473 0a20  e plane points. 
+0001e140: 2020 2020 2020 203a 7274 7970 653a 206e         :rtype: n
+0001e150: 6461 7272 6179 2832 2c6e 290a 0a20 2020  darray(2,n)..   
+0001e160: 2020 2020 2050 726f 6a65 6374 2077 6f72       Project wor
+0001e170: 6c64 2070 6f69 6e74 7320 746f 2074 6865  ld points to the
+0001e180: 2073 7068 6572 6963 616c 2063 616d 6572   spherical camer
+0001e190: 6120 696d 6167 6520 706c 616e 652e 0a0a  a image plane...
+0001e1a0: 2020 2020 2020 2020 576f 726c 6420 706f          World po
+0001e1b0: 696e 7473 2061 7265 2067 6976 656e 2061  ints are given a
+0001e1c0: 7320 6120 3144 2061 7272 6179 206f 7220  s a 1D array or 
+0001e1d0: 7468 6520 636f 6c75 6d6e 7320 6f66 2061  the columns of a
+0001e1e0: 2032 4420 6172 7261 7920 6f66 0a20 2020   2D array of.   
+0001e1f0: 2020 2020 2045 7563 6c69 6465 616e 2063       Euclidean c
+0001e200: 6f6f 7264 696e 6174 6573 2e20 5468 6520  oordinates. The 
+0001e210: 636f 6d70 7574 6564 2069 6d61 6765 2070  computed image p
+0001e220: 6c61 6e65 2063 6f6f 7264 696e 6174 6573  lane coordinates
+0001e230: 2061 7265 0a20 2020 2020 2020 2069 6e20   are.        in 
+0001e240: 706f 6c61 7220 666f 726d 203a 6d61 7468  polar form :math
+0001e250: 3a60 285c 7068 692c 205c 7468 6574 6129  :`(\phi, \theta)
+0001e260: 6020 286c 6f6e 6769 7475 6465 2c20 636f  ` (longitude, co
+0001e270: 6c61 7469 7475 6465 292c 0a20 2020 2020  latitude),.     
+0001e280: 2020 2061 6e64 2067 6976 656e 2061 7320     and given as 
+0001e290: 6120 3144 2061 7272 6179 206f 7220 7468  a 1D array or th
+0001e2a0: 6520 636f 7272 6573 706f 6e64 696e 6720  e corresponding 
+0001e2b0: 636f 6c75 6d6e 7320 6f66 2061 2032 440a  columns of a 2D.
+0001e2c0: 2020 2020 2020 2020 6172 7261 792e 0a0a          array...
+0001e2d0: 2020 2020 2020 2020 4966 2060 6070 6f73          If ``pos
+0001e2e0: 6560 6020 6973 2073 7065 6369 6669 6564  e`` is specified
+0001e2f0: 2069 7420 6973 2075 7365 6420 666f 7220   it is used for 
+0001e300: 7468 6520 6361 6d65 7261 2070 6f73 6520  the camera pose 
+0001e310: 696e 7374 6561 6420 6f66 2074 6865 0a20  instead of the. 
+0001e320: 2020 2020 2020 2061 7474 7269 6275 7465         attribute
+0001e330: 2060 6070 6f73 6560 602e 2020 5468 6520   ``pose``.  The 
+0001e340: 6f62 6a65 6374 2773 2061 7474 7269 6275  object's attribu
+0001e350: 7465 2069 7320 6e6f 7420 7570 6461 7465  te is not update
+0001e360: 642e 0a0a 2020 2020 2020 2020 5468 6520  d...        The 
+0001e370: 706f 696e 7473 2060 6050 6060 2061 7265  points ``P`` are
+0001e380: 2062 7920 6465 6661 756c 7420 7769 7468   by default with
+0001e390: 2072 6573 7065 6374 2074 6f20 7468 6520   respect to the 
+0001e3a0: 776f 726c 6420 6672 616d 652c 2062 7574  world frame, but
+0001e3b0: 0a20 2020 2020 2020 2074 6865 7920 6361  .        they ca
+0001e3c0: 6e20 6265 2074 7261 6e73 666f 726d 6564  n be transformed
+0001e3d0: 2062 7920 7370 6563 6966 7969 6e67 2060   by specifying `
+0001e3e0: 606f 626a 706f 7365 6060 2e0a 0a20 2020  `objpose``...   
+0001e3f0: 2020 2020 203a 7365 6561 6c73 6f3a 203a       :seealso: :
+0001e400: 6d65 7468 3a60 706c 6f74 5f70 6f69 6e74  meth:`plot_point
+0001e410: 600a 2020 2020 2020 2020 2222 220a 2020  `.        """.  
+0001e420: 2020 2020 2020 5020 3d20 6261 7365 2e67        P = base.g
+0001e430: 6574 6d61 7472 6978 2850 2c20 2833 2c20  etmatrix(P, (3, 
+0001e440: 4e6f 6e65 2929 0a0a 2020 2020 2020 2020  None))..        
+0001e450: 6966 2070 6f73 6520 6973 204e 6f6e 653a  if pose is None:
+0001e460: 0a20 2020 2020 2020 2020 2020 2070 6f73  .            pos
+0001e470: 6520 3d20 7365 6c66 2e70 6f73 650a 0a20  e = self.pose.. 
+0001e480: 2020 2020 2020 2070 6f73 6520 3d20 706f         pose = po
+0001e490: 7365 2e69 6e76 2829 0a0a 2020 2020 2020  se.inv()..      
+0001e4a0: 2020 6966 206f 626a 706f 7365 2069 7320    if objpose is 
+0001e4b0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+0001e4c0: 2020 2020 2020 706f 7365 202a 3d20 6f62        pose *= ob
+0001e4d0: 6a70 6f73 650a 0a20 2020 2020 2020 2050  jpose..        P
+0001e4e0: 203d 2070 6f73 6520 2a20 5020 2023 2074   = pose * P  # t
+0001e4f0: 7261 6e73 666f 726d 2070 6f69 6e74 7320  ransform points 
+0001e500: 746f 2063 616d 6572 6120 6672 616d 650a  to camera frame.
+0001e510: 0a20 2020 2020 2020 2052 203d 206e 702e  .        R = np.
+0001e520: 6c69 6e61 6c67 2e6e 6f72 6d28 502c 2061  linalg.norm(P, a
+0001e530: 7869 733d 3029 0a20 2020 2020 2020 2078  xis=0).        x
+0001e540: 203d 2050 5b30 2c20 3a5d 202f 2052 0a20   = P[0, :] / R. 
+0001e550: 2020 2020 2020 2079 203d 2050 5b31 2c20         y = P[1, 
+0001e560: 3a5d 202f 2052 0a20 2020 2020 2020 207a  :] / R.        z
+0001e570: 203d 2050 5b32 2c20 3a5d 202f 2052 0a0a   = P[2, :] / R..
+0001e580: 2020 2020 2020 2020 7068 6920 3d20 6e70          phi = np
+0001e590: 2e61 7263 7461 6e32 2879 2c20 7829 0a20  .arctan2(y, x). 
+0001e5a0: 2020 2020 2020 2074 6865 7461 203d 206e         theta = n
+0001e5b0: 702e 6172 6363 6f73 287a 290a 2020 2020  p.arccos(z).    
+0001e5c0: 2020 2020 7265 7475 726e 206e 702e 6172      return np.ar
+0001e5d0: 7261 7928 5b70 6869 2c20 7468 6574 615d  ray([phi, theta]
+0001e5e0: 290a 0a20 2020 2064 6566 2076 6973 6a61  )..    def visja
+0001e5f0: 635f 7028 7365 6c66 2c20 702c 2064 6570  c_p(self, p, dep
+0001e600: 7468 3d4e 6f6e 6529 3a0a 2020 2020 2020  th=None):.      
+0001e610: 2020 7222 2222 0a20 2020 2020 2020 2056    r""".        V
+0001e620: 6973 7561 6c20 4a61 636f 6269 616e 2066  isual Jacobian f
+0001e630: 6f72 2070 6f69 6e74 2066 6561 7475 7265  or point feature
+0001e640: 730a 0a20 2020 2020 2020 203a 7061 7261  s..        :para
+0001e650: 6d20 703a 2069 6d61 6765 2070 6c61 6e65  m p: image plane
+0001e660: 2070 6f69 6e74 730a 2020 2020 2020 2020   points.        
+0001e670: 3a74 7970 6520 703a 2061 7272 6179 5f6c  :type p: array_l
+0001e680: 696b 6528 3229 206f 7220 6e64 6172 7261  ike(2) or ndarra
+0001e690: 7928 322c 4e29 0a20 2020 2020 2020 203a  y(2,N).        :
+0001e6a0: 7061 7261 6d20 6465 7074 683a 2070 6f69  param depth: poi
+0001e6b0: 6e74 2064 6570 7468 2c20 6465 6661 756c  nt depth, defaul
+0001e6c0: 7473 2074 6f20 4e6f 6e65 0a20 2020 2020  ts to None.     
+0001e6d0: 2020 203a 7479 7065 2064 6570 7468 3a20     :type depth: 
+0001e6e0: 666c 6f61 7420 6f72 2061 7272 6179 5f6c  float or array_l
+0001e6f0: 696b 6528 4e29 2c20 6f70 7469 6f6e 616c  ike(N), optional
+0001e700: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
+0001e710: 3a20 7669 7375 616c 204a 6163 6f62 6961  : visual Jacobia
+0001e720: 6e0a 2020 2020 2020 2020 3a72 7479 7065  n.        :rtype
+0001e730: 3a20 6e64 6172 7261 7928 322c 3629 206f  : ndarray(2,6) o
+0001e740: 7220 6e64 6172 7261 7928 324e 2c36 290a  r ndarray(2N,6).
+0001e750: 0a20 2020 2020 2020 2043 6f6d 7075 7465  .        Compute
+0001e760: 2074 6865 2069 6d61 6765 204a 6163 6f62   the image Jacob
+0001e770: 6961 6e20 3a6d 6174 683a 605c 6d61 747b  ian :math:`\mat{
+0001e780: 4a7d 6020 7768 6963 6820 6d61 7073 0a0a  J}` which maps..
+0001e790: 2020 2020 2020 2020 2e2e 206d 6174 683a          .. math:
+0001e7a0: 3a0a 0a20 2020 2020 2020 2020 2020 205c  :..            \
+0001e7b0: 6476 6563 7b70 7d20 3d20 5c6d 6174 7b4a  dvec{p} = \mat{J
+0001e7c0: 7d28 5c76 6563 7b70 7d2c 207a 2920 5c76  }(\vec{p}, z) \v
+0001e7d0: 6563 7b5c 6e75 7d0a 0a20 2020 2020 2020  ec{\nu}..       
+0001e7e0: 2063 616d 6572 6120 7370 6174 6961 6c20   camera spatial 
+0001e7f0: 7665 6c6f 6369 7479 203a 6d61 7468 3a60  velocity :math:`
+0001e800: 5c76 6563 7b5c 6e75 7d60 2074 6f20 7468  \vec{\nu}` to th
+0001e810: 6520 696d 6167 6520 706c 616e 6520 7665  e image plane ve
+0001e820: 6c6f 6369 7479 0a20 2020 2020 2020 203a  locity.        :
+0001e830: 6d61 7468 3a60 5c64 7665 637b 707d 6020  math:`\dvec{p}` 
+0001e840: 6f66 2074 6865 2070 6f69 6e74 2077 6865  of the point whe
+0001e850: 7265 203a 6d61 7468 3a60 5c76 6563 7b70  re :math:`\vec{p
+0001e860: 7d3d 285c 7068 692c 205c 7468 6574 6129  }=(\phi, \theta)
+0001e870: 600a 0a20 2020 2020 2020 2049 6620 6060  `..        If ``
+0001e880: 7060 6020 6465 7363 7269 6265 7320 6d75  p`` describes mu
+0001e890: 6c74 6970 6c65 2070 6f69 6e74 7320 7468  ltiple points th
+0001e8a0: 656e 2072 6574 7572 6e20 6120 7374 6163  en return a stac
+0001e8b0: 6b20 6f66 2074 6865 7365 0a20 2020 2020  k of these.     
+0001e8c0: 2020 203a 6d61 7468 3a60 325c 7469 6d65     :math:`2\time
+0001e8d0: 7320 3660 206d 6174 7269 6365 732c 206f  s 6` matrices, o
+0001e8e0: 6e65 2070 6572 2070 6f69 6e74 2e0a 0a20  ne per point... 
+0001e8f0: 2020 2020 2020 2044 6570 7468 2069 7320         Depth is 
+0001e900: 7468 6520 7a2d 636f 6d70 6f6e 656e 7420  the z-component 
+0001e910: 6f66 2074 6865 2070 6f69 6e74 2773 2063  of the point's c
+0001e920: 6f6f 7264 696e 6174 6520 696e 2074 6865  oordinate in the
+0001e930: 2063 616d 6572 6120 6672 616d 652e 0a20   camera frame.. 
+0001e940: 2020 2020 2020 2049 6620 6060 6465 7074         If ``dept
+0001e950: 6860 6020 6973 2061 2073 6361 6c61 7220  h`` is a scalar 
+0001e960: 7468 656e 2069 7420 6973 2074 6865 2064  then it is the d
+0001e970: 6570 7468 2066 6f72 2061 6c6c 2070 6f69  epth for all poi
+0001e980: 6e74 732e 0a20 2020 2020 2020 2022 2222  nts..        """
+0001e990: 0a0a 2020 2020 2020 2020 4a20 3d20 5b5d  ..        J = []
+0001e9a0: 0a20 2020 2020 2020 2069 6620 736d 6261  .        if smba
+0001e9b0: 7365 2e69 7373 6361 6c61 7228 6465 7074  se.isscalar(dept
+0001e9c0: 6829 3a0a 2020 2020 2020 2020 2020 2020  h):.            
+0001e9d0: 6465 7074 6820 3d20 5b64 6570 7468 5d20  depth = [depth] 
+0001e9e0: 2a20 702e 7368 6170 655b 315d 0a0a 2020  * p.shape[1]..  
+0001e9f0: 2020 2020 2020 666f 7220 2870 6869 2c20        for (phi, 
+0001ea00: 7468 6574 6129 2c20 5220 696e 207a 6970  theta), R in zip
+0001ea10: 2870 2e54 2c20 6465 7074 6829 3a0a 2020  (p.T, depth):.  
+0001ea20: 2020 2020 2020 2020 2020 7370 203d 206e            sp = n
+0001ea30: 702e 7369 6e28 7068 6929 0a20 2020 2020  p.sin(phi).     
+0001ea40: 2020 2020 2020 2063 7020 3d20 6e70 2e63         cp = np.c
+0001ea50: 6f73 2870 6869 290a 2020 2020 2020 2020  os(phi).        
+0001ea60: 2020 2020 7374 203d 206e 702e 7369 6e28      st = np.sin(
+0001ea70: 7468 6574 6129 0a20 2020 2020 2020 2020  theta).         
+0001ea80: 2020 2063 7420 3d20 6e70 2e63 6f73 2874     ct = np.cos(t
+0001ea90: 6865 7461 290a 0a20 2020 2020 2020 2020  heta)..         
+0001eaa0: 2020 204a 6b20 3d20 6e70 2e61 7272 6179     Jk = np.array
+0001eab0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001eac0: 2020 5b0a 2020 2020 2020 2020 2020 2020    [.            
+0001ead0: 2020 2020 2020 2020 5b73 7020 2f20 5220          [sp / R 
+0001eae0: 2f20 7374 2c20 2d63 7020 2f20 5220 2f20  / st, -cp / R / 
+0001eaf0: 7374 2c20 302c 2063 7020 2a20 6374 202f  st, 0, cp * ct /
+0001eb00: 2073 742c 2073 7020 2a20 6374 202f 2073   st, sp * ct / s
+0001eb10: 742c 202d 315d 2c0a 2020 2020 2020 2020  t, -1],.        
+0001eb20: 2020 2020 2020 2020 2020 2020 5b2d 6370              [-cp
+0001eb30: 202a 2063 7420 2f20 522c 202d 7370 202a   * ct / R, -sp *
+0001eb40: 2063 7420 2f20 522c 2073 7420 2f20 522c   ct / R, st / R,
+0001eb50: 2073 702c 202d 6370 2c20 305d 2c0a 2020   sp, -cp, 0],.  
+0001eb60: 2020 2020 2020 2020 2020 2020 2020 5d0a                ].
+0001eb70: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0001eb80: 2020 2020 2020 2020 2020 4a2e 6170 7065            J.appe
+0001eb90: 6e64 284a 6b29 0a20 2020 2020 2020 2072  nd(Jk).        r
+0001eba0: 6574 7572 6e20 6e70 2e76 7374 6163 6b28  eturn np.vstack(
+0001ebb0: 4a29 0a0a 2020 2020 6465 6620 706c 6f74  J)..    def plot
+0001ebc0: 2873 656c 662c 2066 7261 6d65 3d46 616c  (self, frame=Fal
+0001ebd0: 7365 2c20 2a2a 6b77 6172 6773 293a 0a20  se, **kwargs):. 
+0001ebe0: 2020 2020 2020 2073 6d62 6173 652e 706c         smbase.pl
+0001ebf0: 6f74 5f73 7068 6572 6528 0a20 2020 2020  ot_sphere(.     
+0001ec00: 2020 2020 2020 2072 6164 6975 733d 312c         radius=1,
+0001ec10: 0a20 2020 2020 2020 2020 2020 2066 696c  .            fil
+0001ec20: 6c65 643d 5472 7565 2c0a 2020 2020 2020  led=True,.      
+0001ec30: 2020 2020 2020 636f 6c6f 723d 226c 6967        color="lig
+0001ec40: 6874 7965 6c6c 6f77 222c 0a20 2020 2020  htyellow",.     
+0001ec50: 2020 2020 2020 2061 6c70 6861 3d30 2e33         alpha=0.3
+0001ec60: 2c0a 2020 2020 2020 2020 2020 2020 7265  ,.            re
+0001ec70: 736f 6c75 7469 6f6e 3d32 302c 0a20 2020  solution=20,.   
+0001ec80: 2020 2020 2020 2020 2063 656e 7472 653d           centre=
+0001ec90: 7365 6c66 2e70 6f73 652e 742c 0a20 2020  self.pose.t,.   
+0001eca0: 2020 2020 2029 0a20 2020 2020 2020 2073       ).        s
+0001ecb0: 656c 662e 706f 7365 2e70 6c6f 7428 7374  elf.pose.plot(st
+0001ecc0: 796c 653d 2261 7272 6f77 222c 2061 7869  yle="arrow", axi
+0001ecd0: 736c 6162 656c 3d54 7275 652c 206c 656e  slabel=True, len
+0001ece0: 6774 683d 312e 3429 0a0a 0a23 2063 6c61  gth=1.4)...# cla
+0001ecf0: 7373 2043 656e 7472 616c 4361 6d65 7261  ss CentralCamera
+0001ed00: 5f70 6f6c 6172 2843 616d 6572 6129 3a0a  _polar(Camera):.
+0001ed10: 2320 2020 2020 2222 220a 2320 2020 2020  #     """.#     
+0001ed20: 4365 6e74 7261 6c20 7072 6f6a 6563 7469  Central projecti
+0001ed30: 6f6e 2063 616d 6572 6120 636c 6173 730a  on camera class.
+0001ed40: 2320 2020 2020 2222 220a 0a23 2020 2020  #     """..#    
+0001ed50: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+0001ed60: 6c66 2c0a 2320 2020 2020 2020 2020 2020  lf,.#           
+0001ed70: 2020 2020 2020 2066 3d31 2c0a 2320 2020         f=1,.#   
+0001ed80: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0001ed90: 6973 746f 7274 696f 6e3d 4e6f 6e65 2c0a  istortion=None,.
+0001eda0: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+0001edb0: 2020 202a 2a6b 7761 7267 7329 3a0a 2320     **kwargs):.# 
+0001edc0: 2020 2020 2020 2020 2222 220a 2320 2020          """.#   
+0001edd0: 2020 2020 2020 4372 6561 7465 2063 656e        Create cen
+0001ede0: 7472 616c 2063 616d 6572 6120 7072 6f6a  tral camera proj
+0001edf0: 6563 7469 6f6e 206d 6f64 656c 2069 6e20  ection model in 
+0001ee00: 706f 6c61 7220 636f 6f72 6469 6e61 7465  polar coordinate
+0001ee10: 730a 0a23 2020 2020 2020 2020 203a 7061  s..#         :pa
+0001ee20: 7261 6d20 663a 2066 6f63 616c 206c 656e  ram f: focal len
+0001ee30: 6774 682c 2064 6566 6175 6c74 7320 746f  gth, defaults to
+0001ee40: 2038 2a31 652d 330a 2320 2020 2020 2020   8*1e-3.#       
+0001ee50: 2020 3a74 7970 6520 663a 2066 6c6f 6174    :type f: float
+0001ee60: 2c20 6f70 7469 6f6e 616c 0a23 2020 2020  , optional.#    
+0001ee70: 2020 2020 203a 7061 7261 6d20 6469 7374       :param dist
+0001ee80: 6f72 7469 6f6e 3a20 6361 6d65 7261 2064  ortion: camera d
+0001ee90: 6973 746f 7274 696f 6e20 7061 7261 6d65  istortion parame
+0001eea0: 7465 7273 2c20 6465 6661 756c 7473 2074  ters, defaults t
+0001eeb0: 6f20 4e6f 6e65 0a23 2020 2020 2020 2020  o None.#        
+0001eec0: 203a 7479 7065 2064 6973 746f 7274 696f   :type distortio
+0001eed0: 6e3a 2061 7272 6179 5f6c 696b 6528 3529  n: array_like(5)
+0001eee0: 2c20 6f70 7469 6f6e 616c 0a0a 2320 2020  , optional..#   
+0001eef0: 2020 2020 2020 3a73 6565 616c 736f 3a20        :seealso: 
+0001ef00: 3a6d 6574 683a 6064 6973 746f 7274 600a  :meth:`distort`.
+0001ef10: 2320 2020 2020 2020 2020 2222 220a 0a23  #         """..#
+0001ef20: 2020 2020 2020 2020 2073 7570 6572 2829           super()
+0001ef30: 2e5f 5f69 6e69 745f 5f28 7479 7065 3d27  .__init__(type='
+0001ef40: 7065 7273 7065 6374 6976 6527 2c20 2a2a  perspective', **
+0001ef50: 6b77 6172 6773 290a 2320 2020 2020 2020  kwargs).#       
+0001ef60: 2020 2320 544f 444f 2073 6f6d 6520 6f66    # TODO some of
+0001ef70: 2074 6869 7320 6c6f 6769 6320 746f 2066   this logic to f
+0001ef80: 2061 6e64 2070 7020 7365 7474 6572 730a   and pp setters.
+0001ef90: 2320 2020 2020 2020 2020 7365 6c66 2e66  #         self.f
+0001efa0: 203d 2066 0a0a 2320 2020 2020 2020 2020   = f..#         
+0001efb0: 7365 6c66 2e5f 6469 7374 6f72 7469 6f6e  self._distortion
+0001efc0: 203d 2064 6973 746f 7274 696f 6e0a 0a23   = distortion..#
+0001efd0: 2020 2020 2040 636c 6173 736d 6574 686f       @classmetho
+0001efe0: 640a 2320 2020 2020 6465 6620 4465 6661  d.#     def Defa
+0001eff0: 756c 7428 636c 732c 202a 2a6b 7761 7267  ult(cls, **kwarg
+0001f000: 7329 3a0a 2320 2020 2020 2020 2020 6465  s):.#         de
+0001f010: 6661 756c 7420 3d20 7b0a 2320 2020 2020  fault = {.#     
+0001f020: 2020 2020 2020 2020 2766 273a 2030 2e30          'f': 0.0
+0001f030: 3038 2c0a 2320 2020 2020 2020 2020 2020  08,.#           
+0001f040: 2020 2772 686f 273a 2031 3065 2d36 2c0a    'rho': 10e-6,.
+0001f050: 2320 2020 2020 2020 2020 2020 2020 2769  #             'i
+0001f060: 6d61 6765 7369 7a65 273a 2031 3030 302c  magesize': 1000,
+0001f070: 0a23 2020 2020 2020 2020 2020 2020 2027  .#             '
+0001f080: 7070 273a 2028 3530 302c 3530 3029 2c0a  pp': (500,500),.
+0001f090: 2320 2020 2020 2020 2020 2020 2020 276e  #             'n
+0001f0a0: 616d 6527 3a20 2764 6566 6175 6c74 2070  ame': 'default p
+0001f0b0: 6572 7370 6563 7469 7665 2063 616d 6572  erspective camer
+0001f0c0: 6127 0a23 2020 2020 2020 2020 207d 0a0a  a'.#         }..
+0001f0d0: 2320 2020 2020 2020 2020 7265 7475 726e  #         return
+0001f0e0: 2043 656e 7472 616c 4361 6d65 7261 5f70   CentralCamera_p
+0001f0f0: 6f6c 6172 282a 2a7b 2a2a 6465 6661 756c  olar(**{**defaul
+0001f100: 742c 202a 2a6b 7761 7267 737d 290a 0a23  t, **kwargs})..#
+0001f110: 2020 2020 2064 6566 205f 5f73 7472 5f5f       def __str__
+0001f120: 2873 656c 6629 3a0a 2320 2020 2020 2020  (self):.#       
+0001f130: 2020 7320 3d20 7375 7065 7228 292e 5f5f    s = super().__
+0001f140: 7374 725f 5f28 290a 2320 2020 2020 2020  str__().#       
+0001f150: 2020 7320 2b3d 2073 656c 662e 666d 742e    s += self.fmt.
+0001f160: 666f 726d 6174 2827 7072 696e 6369 7061  format('principa
+0001f170: 6c20 7074 272c 2073 656c 662e 7070 290a  l pt', self.pp).
+0001f180: 2320 2020 2020 2020 2020 7320 2b3d 2073  #         s += s
+0001f190: 656c 662e 666d 742e 666f 726d 6174 2827  elf.fmt.format('
+0001f1a0: 666f 6361 6c20 6c65 6e67 7468 272c 2073  focal length', s
+0001f1b0: 656c 662e 6629 0a0a 2320 2020 2020 2020  elf.f)..#       
+0001f1c0: 2020 7265 7475 726e 2073 0a0a 0a23 2020    return s...#  
+0001f1d0: 2020 2064 6566 2070 726f 6a65 6374 5f70     def project_p
+0001f1e0: 6f69 6e74 2873 656c 662c 2050 2c20 706f  oint(self, P, po
+0001f1f0: 7365 3d4e 6f6e 652c 206f 626a 706f 7365  se=None, objpose
+0001f200: 3d4e 6f6e 652c 202a 2a6b 7761 7267 7329  =None, **kwargs)
+0001f210: 3a0a 2320 2020 2020 2020 2020 7222 2222  :.#         r"""
+0001f220: 0a23 2020 2020 2020 2020 2050 726f 6a65  .#         Proje
+0001f230: 6374 2033 4420 706f 696e 7473 2074 6f20  ct 3D points to 
+0001f240: 696d 6167 6520 706c 616e 650a 0a23 2020  image plane..#  
+0001f250: 2020 2020 2020 203a 7061 7261 6d20 503a         :param P:
+0001f260: 2033 4420 706f 696e 7473 2074 6f20 7072   3D points to pr
+0001f270: 6f6a 6563 7420 696e 746f 2063 616d 6572  oject into camer
+0001f280: 6120 696d 6167 6520 706c 616e 650a 2320  a image plane.# 
+0001f290: 2020 2020 2020 2020 3a74 7970 6520 503a          :type P:
+0001f2a0: 2061 7272 6179 5f6c 696b 6528 3329 2c20   array_like(3), 
+0001f2b0: 6172 7261 795f 6c69 6b65 2833 2c6e 290a  array_like(3,n).
+0001f2c0: 2320 2020 2020 2020 2020 3a70 6172 616d  #         :param
+0001f2d0: 2070 6f73 653a 2063 616d 6572 6120 706f   pose: camera po
+0001f2e0: 7365 2077 6974 6820 7265 7370 6563 7420  se with respect 
+0001f2f0: 746f 2074 6865 2077 6f72 6c64 2066 7261  to the world fra
+0001f300: 6d65 2c20 6465 6661 756c 7473 2074 6f0a  me, defaults to.
+0001f310: 2320 2020 2020 2020 2020 2020 2020 6361  #             ca
+0001f320: 6d65 7261 2773 2060 6070 6f73 6560 6020  mera's ``pose`` 
+0001f330: 6174 7472 6962 7574 650a 2320 2020 2020  attribute.#     
+0001f340: 2020 2020 3a74 7970 6520 706f 7365 3a20      :type pose: 
+0001f350: 5345 332c 206f 7074 696f 6e61 6c0a 2320  SE3, optional.# 
+0001f360: 2020 2020 2020 2020 3a70 6172 616d 206f          :param o
+0001f370: 626a 706f 7365 3a20 2033 4420 706f 696e  bjpose:  3D poin
+0001f380: 7420 7265 6665 7265 6e63 6520 6672 616d  t reference fram
+0001f390: 652c 2064 6566 6175 6c74 7320 746f 2077  e, defaults to w
+0001f3a0: 6f72 6c64 2066 7261 6d65 0a23 2020 2020  orld frame.#    
+0001f3b0: 2020 2020 203a 7479 7065 206f 626a 706f       :type objpo
+0001f3c0: 7365 3a20 5345 332c 206f 7074 696f 6e61  se: SE3, optiona
+0001f3d0: 6c0a 2320 2020 2020 2020 2020 3a70 6172  l.#         :par
+0001f3e0: 616d 2076 6973 6962 696c 6974 793a 2074  am visibility: t
+0001f3f0: 6573 7420 6966 2070 6f69 6e74 7320 6172  est if points ar
+0001f400: 6520 7669 7369 626c 652c 2064 6566 6175  e visible, defau
+0001f410: 6c74 2046 616c 7365 0a23 2020 2020 2020  lt False.#      
+0001f420: 2020 203a 7479 7065 2076 6973 6962 696c     :type visibil
+0001f430: 6974 793a 2062 6f6f 6c0a 2320 2020 2020  ity: bool.#     
+0001f440: 2020 2020 3a70 6172 616d 2072 6574 696e      :param retin
+0001f450: 616c 3a20 7472 616e 7366 6f72 6d20 746f  al: transform to
+0001f460: 2072 6574 696e 616c 2063 6f6f 7264 696e   retinal coordin
+0001f470: 6174 6573 2c20 6465 6661 756c 7420 4661  ates, default Fa
+0001f480: 6c73 650a 2320 2020 2020 2020 2020 3a74  lse.#         :t
+0001f490: 7970 6520 7265 7469 6e61 6c3a 2062 6f6f  ype retinal: boo
+0001f4a0: 6c2c 206f 7074 696f 6e61 6c0a 2320 2020  l, optional.#   
+0001f4b0: 2020 2020 2020 3a72 6574 7572 6e3a 2069        :return: i
+0001f4c0: 6d61 6765 2070 6c61 6e65 2070 6f69 6e74  mage plane point
+0001f4d0: 730a 2320 2020 2020 2020 2020 3a72 7479  s.#         :rty
+0001f4e0: 7065 3a20 6e64 6172 7261 7928 322c 6e29  pe: ndarray(2,n)
+0001f4f0: 0a0a 2320 2020 2020 2020 2020 5072 6f6a  ..#         Proj
+0001f500: 6563 7420 6120 3344 2070 6f69 6e74 2074  ect a 3D point t
+0001f510: 6f20 7468 6520 696d 6167 6520 706c 616e  o the image plan
+0001f520: 650a 0a23 2020 2020 2020 2020 202e 2e20  e..#         .. 
+0001f530: 6d61 7468 3a3a 0a0a 2320 2020 2020 2020  math::..#       
+0001f540: 2020 2020 2020 5c68 7665 637b 707d 203d        \hvec{p} =
+0001f550: 205c 6d61 747b 437d 205c 6876 6563 7b50   \mat{C} \hvec{P
+0001f560: 7d0a 0a23 2020 2020 2020 2020 2077 6865  }..#         whe
+0001f570: 7265 203a 6d61 7468 3a60 5c6d 6174 7b43  re :math:`\mat{C
+0001f580: 7d60 2069 7320 7468 6520 6361 6d65 7261  }` is the camera
+0001f590: 2063 616c 6962 7261 7469 6f6e 206d 6174   calibration mat
+0001f5a0: 7269 7820 616e 6420 3a6d 6174 683a 605c  rix and :math:`\
+0001f5b0: 6876 6563 7b70 7d60 2061 6e64 203a 6d61  hvec{p}` and :ma
+0001f5c0: 7468 3a60 5c68 7665 637b 507d 600a 2320  th:`\hvec{P}`.# 
+0001f5d0: 2020 2020 2020 2020 6172 6520 7468 6520          are the 
+0001f5e0: 696d 6167 6520 706c 616e 6520 616e 6420  image plane and 
+0001f5f0: 776f 726c 6420 6672 616d 6520 636f 6f72  world frame coor
+0001f600: 6469 6e61 7465 7320 7265 7370 6563 7469  dinates respecti
+0001f610: 7665 6c79 2e0a 0a23 2020 2020 2020 2020  vely...#        
+0001f620: 2045 7861 6d70 6c65 3a0a 0a23 2020 2020   Example:..#    
+0001f630: 2020 2020 202e 2e20 7275 6e62 6c6f 636b       .. runblock
+0001f640: 3a3a 2070 7963 6f6e 0a0a 2320 2020 2020  :: pycon..#     
+0001f650: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
+0001f660: 206d 6163 6869 6e65 7669 7369 6f6e 746f   machinevisionto
+0001f670: 6f6c 626f 7820 696d 706f 7274 2043 656e  olbox import Cen
+0001f680: 7472 616c 4361 6d65 7261 0a23 2020 2020  tralCamera.#    
+0001f690: 2020 2020 2020 2020 203e 3e3e 2063 616d           >>> cam
+0001f6a0: 6572 6120 3d20 4365 6e74 7261 6c43 616d  era = CentralCam
+0001f6b0: 6572 6128 290a 2320 2020 2020 2020 2020  era().#         
+0001f6c0: 2020 2020 3e3e 3e20 6361 6d65 7261 2e70      >>> camera.p
+0001f6d0: 726f 6a65 6374 5f70 6f69 6e74 2828 302e  roject_point((0.
+0001f6e0: 332c 2030 2e34 2c20 3229 290a 0a23 2020  3, 0.4, 2))..#  
+0001f6f0: 2020 2020 2020 2049 6620 6060 706f 7365         If ``pose
+0001f700: 6060 2069 7320 7370 6563 6966 6965 6420  `` is specified 
+0001f710: 6974 2069 7320 7573 6564 2066 6f72 2074  it is used for t
+0001f720: 6865 2063 616d 6572 6120 6672 616d 6520  he camera frame 
+0001f730: 706f 7365 2c20 6f74 6865 7277 6973 650a  pose, otherwise.
+0001f740: 2320 2020 2020 2020 2020 7468 6520 6174  #         the at
+0001f750: 7472 6962 7574 6520 6060 706f 7365 6060  tribute ``pose``
+0001f760: 2e20 2054 6865 206f 626a 6563 7427 7320  .  The object's 
+0001f770: 6060 706f 7365 6060 2061 7474 7269 6275  ``pose`` attribu
+0001f780: 7465 2069 7320 6e6f 7420 7570 6461 7465  te is not update
+0001f790: 640a 2320 2020 2020 2020 2020 6966 2060  d.#         if `
+0001f7a0: 6070 6f73 6560 6020 6973 2073 7065 6369  `pose`` is speci
+0001f7b0: 6669 6564 2e0a 0a23 2020 2020 2020 2020  fied...#        
+0001f7c0: 2041 2073 696e 676c 6520 706f 696e 7420   A single point 
+0001f7d0: 6361 6e20 6265 2073 7065 6369 6669 6564  can be specified
+0001f7e0: 2061 7320 6120 332d 7665 6374 6f72 2c20   as a 3-vector, 
+0001f7f0: 6d75 6c74 6970 6c65 2070 6f69 6e74 7320  multiple points 
+0001f800: 6173 2061 6e0a 2320 2020 2020 2020 2020  as an.#         
+0001f810: 6172 7261 7920 7769 7468 2074 6872 6565  array with three
+0001f820: 2072 6f77 7320 616e 6420 6f6e 6520 636f   rows and one co
+0001f830: 6c75 6d6e 2028 782c 2079 2c20 7a29 2070  lumn (x, y, z) p
+0001f840: 6572 2070 6f69 6e74 2e0a 0a23 2020 2020  er point...#    
+0001f850: 2020 2020 2054 6865 2070 6f69 6e74 7320       The points 
+0001f860: 6060 5060 6020 6172 6520 6279 2064 6566  ``P`` are by def
+0001f870: 6175 6c74 2077 6974 6820 7265 7370 6563  ault with respec
+0001f880: 7420 746f 2074 6865 2077 6f72 6c64 2066  t to the world f
+0001f890: 7261 6d65 2c20 6275 740a 2320 2020 2020  rame, but.#     
+0001f8a0: 2020 2020 7468 6579 2063 616e 2062 6520      they can be 
+0001f8b0: 7472 616e 7366 6f72 6d65 6420 6279 2073  transformed by s
+0001f8c0: 7065 6369 6679 696e 6720 6060 6f62 6a70  pecifying ``objp
+0001f8d0: 6f73 6560 602e 0a0a 2320 2020 2020 2020  ose``...#       
+0001f8e0: 2020 4966 2077 6f72 6c64 2070 6f69 6e74    If world point
+0001f8f0: 7320 6172 6520 6265 6869 6e64 2074 6865  s are behind the
+0001f900: 2063 616d 6572 612c 2074 6865 2069 6d61   camera, the ima
+0001f910: 6765 2070 6c61 6e65 2070 6f69 6e74 7320  ge plane points 
+0001f920: 6172 6520 7365 7420 746f 0a23 2020 2020  are set to.#    
+0001f930: 2020 2020 204e 614e 2e0a 0a23 2020 2020       NaN...#    
+0001f940: 2020 2020 2069 6620 6060 7669 7369 6269       if ``visibi
+0001f950: 6c69 7479 6060 2069 7320 5472 7565 2074  lity`` is True t
+0001f960: 6865 6e20 6561 6368 2070 726f 6a65 6374  hen each project
+0001f970: 6564 2070 6f69 6e74 2069 7320 6368 6563  ed point is chec
+0001f980: 6b65 6420 746f 2065 6e73 7572 650a 2320  ked to ensure.# 
+0001f990: 2020 2020 2020 2020 6974 206c 6965 7320          it lies 
+0001f9a0: 696e 2074 6865 2062 6f75 6e64 7320 6f66  in the bounds of
+0001f9b0: 2074 6865 2069 6d61 6765 2070 6c61 6e65   the image plane
+0001f9c0: 2e20 2049 6e20 7468 6973 2063 6173 6520  .  In this case 
+0001f9d0: 7468 6572 6520 6172 6520 7477 6f0a 2320  there are two.# 
+0001f9e0: 2020 2020 2020 2020 7265 7475 726e 2076          return v
+0001f9f0: 616c 7565 733a 2074 6865 2069 6d61 6765  alues: the image
+0001fa00: 2070 6c61 6e65 2063 6f6f 7264 696e 6174   plane coordinat
+0001fa10: 6573 2061 6e64 2061 6e20 6172 7261 7920  es and an array 
+0001fa20: 6f66 2062 6f6f 6c65 616e 730a 2320 2020  of booleans.#   
+0001fa30: 2020 2020 2020 696e 6469 6361 7469 6e67        indicating
+0001fa40: 2069 6620 7468 6520 636f 7272 6573 706f   if the correspo
+0001fa50: 6e64 696e 6720 706f 696e 7420 6973 2076  nding point is v
+0001fa60: 6973 6962 6c65 2e0a 2320 2020 2020 2020  isible..#       
+0001fa70: 2020 2222 220a 2320 2020 2020 2020 2020    """.#         
+0001fa80: 6966 2070 6f73 6520 6973 204e 6f6e 653a  if pose is None:
+0001fa90: 0a23 2020 2020 2020 2020 2020 2020 2070  .#             p
+0001faa0: 6f73 6520 3d20 7365 6c66 2e70 6f73 650a  ose = self.pose.
+0001fab0: 0a23 2020 2020 2020 2020 2043 203d 2073  .#         C = s
+0001fac0: 656c 662e 4328 706f 7365 2c20 7265 7469  elf.C(pose, reti
+0001fad0: 6e61 6c3d 7265 7469 6e61 6c29 0a0a 2320  nal=retinal)..# 
+0001fae0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+0001faf0: 7461 6e63 6528 502c 206e 702e 6e64 6172  tance(P, np.ndar
+0001fb00: 7261 7929 3a0a 2320 2020 2020 2020 2020  ray):.#         
+0001fb10: 2020 2020 6966 2050 2e6e 6469 6d20 3d3d      if P.ndim ==
+0001fb20: 2031 3a0a 2320 2020 2020 2020 2020 2020   1:.#           
+0001fb30: 2020 2020 2020 5020 3d20 502e 7265 7368        P = P.resh
+0001fb40: 6170 6528 282d 312c 2031 2929 2020 2320  ape((-1, 1))  # 
+0001fb50: 6d61 6b65 2069 7420 6120 636f 6c75 6d6e  make it a column
+0001fb60: 0a23 2020 2020 2020 2020 2065 6c73 653a  .#         else:
+0001fb70: 0a23 2020 2020 2020 2020 2020 2020 2050  .#             P
+0001fb80: 203d 2062 6173 652e 6765 7476 6563 746f   = base.getvecto
+0001fb90: 7228 502c 206f 7574 3d27 636f 6c27 290a  r(P, out='col').
+0001fba0: 0a23 2020 2020 2020 2020 2023 206d 616b  .#         # mak
+0001fbb0: 6520 6974 2068 6f6d 6f67 656e 656f 7573  e it homogeneous
+0001fbc0: 2069 6620 6e6f 7420 616c 7265 6164 790a   if not already.
+0001fbd0: 2320 2020 2020 2020 2020 6966 2050 2e73  #         if P.s
+0001fbe0: 6861 7065 5b30 5d20 3d3d 2033 3a0a 2320  hape[0] == 3:.# 
+0001fbf0: 2020 2020 2020 2020 2020 2020 5020 3d20              P = 
+0001fc00: 6261 7365 2e65 3268 2850 290a 0a23 2020  base.e2h(P)..#  
+0001fc10: 2020 2020 2020 2023 2070 726f 6a65 6374         # project
+0001fc20: 2033 4420 706f 696e 7473 0a0a 2320 2020   3D points..#   
+0001fc30: 2020 2020 2020 6966 206f 626a 706f 7365        if objpose
+0001fc40: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2320   is not None:.# 
+0001fc50: 2020 2020 2020 2020 2020 2020 5020 3d20              P = 
+0001fc60: 6f62 6a70 6f73 652e 4120 4020 500a 0a23  objpose.A @ P..#
+0001fc70: 2020 2020 2020 2020 2078 203d 2043 2040           x = C @
+0001fc80: 2050 0a0a 2320 2020 2020 2020 2020 6966   P..#         if
+0001fc90: 2062 6568 696e 643a 0a23 2020 2020 2020   behind:.#      
+0001fca0: 2020 2020 2020 2078 5b32 2c20 785b 322c         x[2, x[2,
+0001fcb0: 203a 5d20 3c20 305d 203d 206e 702e 6e61   :] < 0] = np.na
+0001fcc0: 6e20 2023 2070 6f69 6e74 7320 6265 6869  n  # points behi
+0001fcd0: 6e64 2074 6865 2063 616d 6572 6120 6172  nd the camera ar
+0001fce0: 6520 7365 7420 746f 204e 614e 0a0a 2320  e set to NaN..# 
+0001fcf0: 2020 2020 2020 2020 7820 3d20 6261 7365          x = base
+0001fd00: 2e68 3265 2878 290a 0a23 2020 2020 2020  .h2e(x)..#      
+0001fd10: 2020 2023 2061 6464 2047 6175 7373 6961     # add Gaussia
+0001fd20: 6e20 6e6f 6973 6520 616e 6420 6469 7374  n noise and dist
+0001fd30: 6f72 7469 6f6e 0a23 2020 2020 2020 2020  ortion.#        
+0001fd40: 2078 203d 2073 656c 662e 6164 645f 6e6f   x = self.add_no
+0001fd50: 6973 655f 6469 7374 6f72 7469 6f6e 2878  ise_distortion(x
+0001fd60: 290a 0a23 2020 2020 2020 2020 2023 2020  )..#         #  
+0001fd70: 646f 2076 6973 6962 696c 6974 7920 6368  do visibility ch
+0001fd80: 6563 6b20 6966 2072 6571 7569 7265 640a  eck if required.
+0001fd90: 2320 2020 2020 2020 2020 6966 2076 6973  #         if vis
+0001fda0: 6962 696c 6974 793a 0a23 2020 2020 2020  ibility:.#      
+0001fdb0: 2020 2020 2020 2076 6973 6962 6c65 203d         visible =
+0001fdc0: 207e 6e70 2e69 736e 616e 2878 5b30 2c3a   ~np.isnan(x[0,:
+0001fdd0: 5d29 205c 0a23 2020 2020 2020 2020 2020  ]) \.#          
+0001fde0: 2020 2020 2020 2026 2028 785b 302c 203a         & (x[0, :
+0001fdf0: 5d20 3e3d 2030 2920 5c0a 2320 2020 2020  ] >= 0) \.#     
+0001fe00: 2020 2020 2020 2020 2020 2020 2620 2878              & (x
+0001fe10: 5b31 2c20 3a5d 203e 3d20 3029 205c 0a23  [1, :] >= 0) \.#
+0001fe20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fe30: 2026 2028 785b 302c 203a 5d20 3c20 7365   & (x[0, :] < se
+0001fe40: 6c66 2e6e 7529 205c 0a23 2020 2020 2020  lf.nu) \.#      
+0001fe50: 2020 2020 2020 2020 2020 2026 2028 785b             & (x[
+0001fe60: 312c 203a 5d20 3c20 7365 6c66 2e6e 7629  1, :] < self.nv)
+0001fe70: 0a0a 2320 2020 2020 2020 2020 2020 2020  ..#             
+0001fe80: 7265 7475 726e 2078 2c20 7669 7369 626c  return x, visibl
+0001fe90: 650a 2320 2020 2020 2020 2020 656c 7365  e.#         else
+0001fea0: 3a0a 2320 2020 2020 2020 2020 2020 2020  :.#             
+0001feb0: 7265 7475 726e 2078 0a0a 2320 2020 2020  return x..#     
+0001fec0: 6465 6620 706c 6f74 5f70 6f69 6e74 2873  def plot_point(s
+0001fed0: 656c 662c 2050 700a 2320 2020 2020 2020  elf, Pp.#       
+0001fee0: 2020 6178 203d 205f 6e65 7770 6c6f 7428    ax = _newplot(
+0001fef0: 7365 6c66 2c20 6669 672c 2061 7829 0a0a  self, fig, ax)..
+0001ff00: 2320 2020 2020 2020 2020 6966 2073 656c  #         if sel
+0001ff10: 662e 5f69 6d61 6765 2069 7320 6e6f 7420  f._image is not 
+0001ff20: 4e6f 6e65 3a0a 2320 2020 2020 2020 2020  None:.#         
+0001ff30: 2020 2020 2320 6966 2063 616d 6572 6120      # if camera 
+0001ff40: 6861 7320 616e 2069 6d61 6765 2c20 6469  has an image, di
+0001ff50: 7370 6c61 7920 7361 6964 2069 6d61 6765  splay said image
+0001ff60: 0a23 2020 2020 2020 2020 2020 2020 2069  .#             i
+0001ff70: 6469 7370 2873 656c 662e 5f69 6d61 6765  disp(self._image
+0001ff80: 2c0a 2320 2020 2020 2020 2020 2020 2020  ,.#             
+0001ff90: 2020 2020 2020 2020 2020 6669 673d 6669            fig=fi
+0001ffa0: 672c 0a23 2020 2020 2020 2020 2020 2020  g,.#            
+0001ffb0: 2020 2020 2020 2020 2020 2061 783d 6178             ax=ax
+0001ffc0: 2c0a 2320 2020 2020 2020 2020 2020 2020  ,.#             
+0001ffd0: 2020 2020 2020 2020 2020 7469 746c 653d            title=
+0001ffe0: 7365 6c66 2e5f 6e61 6d65 2c0a 2320 2020  self._name,.#   
+0001fff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020000: 2020 2020 6472 6177 6f6e 6c79 3d54 7275      drawonly=Tru
+00020010: 6529 0a23 2020 2020 2020 2020 2065 6c73  e).#         els
+00020020: 653a 0a23 2020 2020 2020 2020 2020 2020  e:.#            
+00020030: 2069 6620 7365 6c66 2e6c 696d 6974 7320   if self.limits 
+00020040: 6973 204e 6f6e 653a 0a23 2020 2020 2020  is None:.#      
+00020050: 2020 2020 2020 2020 2020 2061 782e 7365             ax.se
+00020060: 745f 786c 696d 2830 2c20 7365 6c66 2e6e  t_xlim(0, self.n
+00020070: 7529 0a23 2020 2020 2020 2020 2020 2020  u).#            
+00020080: 2020 2020 2061 782e 7365 745f 796c 696d       ax.set_ylim
+00020090: 2830 2c20 7365 6c66 2e6e 7629 0a23 2020  (0, self.nv).#  
+000200a0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+000200b0: 0a23 2020 2020 2020 2020 2020 2020 2020  .#              
+000200c0: 2020 2061 782e 7365 745f 786c 696d 2873     ax.set_xlim(s
+000200d0: 656c 662e 6c69 6d69 7473 5b30 5d2c 2073  elf.limits[0], s
+000200e0: 656c 662e 6c69 6d69 7473 5b31 5d29 0a23  elf.limits[1]).#
+000200f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020100: 2061 782e 7365 745f 796c 696d 2873 656c   ax.set_ylim(sel
+00020110: 662e 6c69 6d69 7473 5b32 5d2c 2073 656c  f.limits[2], sel
+00020120: 662e 6c69 6d69 7473 5b33 5d29 0a23 2020  f.limits[3]).#  
+00020130: 2020 2020 2020 2020 2020 2061 782e 6175             ax.au
+00020140: 746f 7363 616c 6528 4661 6c73 6529 0a23  toscale(False).#
+00020150: 2020 2020 2020 2020 2020 2020 2061 782e               ax.
+00020160: 7365 745f 6173 7065 6374 2827 6571 7561  set_aspect('equa
+00020170: 6c27 290a 2320 2020 2020 2020 2020 2020  l').#           
+00020180: 2020 6178 2e69 6e76 6572 745f 7961 7869    ax.invert_yaxi
+00020190: 7328 290a 2320 2020 2020 2020 2020 2020  s().#           
+000201a0: 2020 6178 2e67 7269 6428 5472 7565 290a    ax.grid(True).
+000201b0: 2320 2020 2020 2020 2020 2020 2020 6966  #             if
+000201c0: 2073 656c 662e 6c61 6265 6c73 2069 7320   self.labels is 
+000201d0: 4e6f 6e65 3a0a 2320 2020 2020 2020 2020  None:.#         
+000201e0: 2020 2020 2020 2020 6178 2e73 6574 5f78          ax.set_x
+000201f0: 6c61 6265 6c28 2775 2028 7069 7865 6c73  label('u (pixels
+00020200: 2927 290a 2320 2020 2020 2020 2020 2020  )').#           
+00020210: 2020 2020 2020 6178 2e73 6574 5f79 6c61        ax.set_yla
+00020220: 6265 6c28 2776 2028 7069 7865 6c73 2927  bel('v (pixels)'
+00020230: 290a 2320 2020 2020 2020 2020 2020 2020  ).#             
+00020240: 656c 7365 3a0a 2320 2020 2020 2020 2020  else:.#         
+00020250: 2020 2020 2020 2020 6178 2e73 6574 5f78          ax.set_x
+00020260: 6c61 6265 6c28 7365 6c66 2e6c 6162 656c  label(self.label
+00020270: 735b 305d 290a 2320 2020 2020 2020 2020  s[0]).#         
+00020280: 2020 2020 2020 2020 6178 2e73 6574 5f79          ax.set_y
+00020290: 6c61 6265 6c28 7365 6c66 2e6c 6162 656c  label(self.label
+000202a0: 735b 315d 290a 2320 2020 2020 2020 2020  s[1]).#         
+000202b0: 2020 2020 6178 2e73 6574 5f74 6974 6c65      ax.set_title
+000202c0: 2873 656c 662e 6e61 6d65 290a 2320 2020  (self.name).#   
+000202d0: 2020 2020 2020 2020 2020 6178 2e73 6574            ax.set
+000202e0: 5f66 6163 6563 6f6c 6f72 2827 6c69 6768  _facecolor('ligh
+000202f0: 7479 656c 6c6f 7727 290a 2320 2020 2020  tyellow').#     
+00020300: 2020 2020 2020 2020 6178 2e66 6967 7572          ax.figur
+00020310: 652e 6361 6e76 6173 2e73 6574 5f77 696e  e.canvas.set_win
+00020320: 646f 775f 7469 746c 6528 274d 6163 6869  dow_title('Machi
+00020330: 6e65 2056 6973 696f 6e20 546f 6f6c 626f  ne Vision Toolbo
+00020340: 7820 666f 7220 5079 7468 6f6e 2729 0a0a  x for Python')..
+00020350: 2320 2020 2020 2020 2020 2320 544f 444f  #         # TODO
+00020360: 2066 6967 7572 6520 6f75 7420 6178 6573   figure out axes
+00020370: 2074 6963 6b73 2c20 6574 630a 2320 2020   ticks, etc.#   
+00020380: 2020 2020 2020 7265 7475 726e 2061 7820        return ax 
+00020390: 2023 206c 696b 656c 7920 7468 6973 2072   # likely this r
+000203a0: 6574 7572 6e20 6973 206e 6f74 206e 6563  eturn is not nec
+000203b0: 6573 7361 7279 0a0a 6966 205f 5f6e 616d  essary..if __nam
+000203c0: 655f 5f20 3d3d 2022 5f5f 6d61 696e 5f5f  e__ == "__main__
+000203d0: 223a 0a20 2020 2066 726f 6d20 7370 6174  ":.    from spat
+000203e0: 6961 6c6d 6174 6820 696d 706f 7274 2055  ialmath import U
+000203f0: 6e69 7451 7561 7465 726e 696f 6e0a 0a20  nitQuaternion.. 
+00020400: 2020 2023 2069 6d31 203d 2049 6d61 6765     # im1 = Image
+00020410: 2e52 6561 6428 2265 6966 6665 6c32 2d31  .Read("eiffel2-1
+00020420: 2e70 6e67 222c 2067 7265 793d 5472 7565  .png", grey=True
+00020430: 290a 2020 2020 2320 6361 6d65 7261 203d  ).    # camera =
+00020440: 2043 656e 7472 616c 4361 6d65 7261 2829   CentralCamera()
+00020450: 3b0a 2020 2020 2320 6361 6d65 7261 2e64  ;.    # camera.d
+00020460: 6973 7028 696d 3129 3b0a 0a20 2020 2023  isp(im1);..    #
+00020470: 2063 616d 203d 2043 656e 7472 616c 4361   cam = CentralCa
+00020480: 6d65 7261 2866 3d30 2e30 3829 0a20 2020  mera(f=0.08).   
+00020490: 2023 2070 7269 6e74 2863 616d 290a 2020   # print(cam).  
+000204a0: 2020 2320 5020 3d20 5b30 2e31 2c20 302e    # P = [0.1, 0.
+000204b0: 322c 2033 5d0a 2020 2020 2320 7072 696e  2, 3].    # prin
+000204c0: 7428 6361 6d2e 7072 6f6a 6563 745f 706f  t(cam.project_po
+000204d0: 696e 7428 5029 290a 0a20 2020 2063 616d  int(P))..    cam
+000204e0: 203d 2043 656e 7472 616c 4361 6d65 7261   = CentralCamera
+000204f0: 2866 3d30 2e30 382c 2069 6d61 6765 7369  (f=0.08, imagesi
+00020500: 7a65 3d31 3030 302c 2072 686f 3d31 3065  ze=1000, rho=10e
+00020510: 2d36 290a 2020 2020 7072 696e 7428 6361  -6).    print(ca
+00020520: 6d29 0a0a 2020 2020 6361 6d2e 7072 6f6a  m)..    cam.proj
+00020530: 6563 745f 706f 696e 7428 5b31 2c20 322c  ect_point([1, 2,
+00020540: 2033 5d29 0a0a 2020 2020 2320 5020 3d20   3])..    # P = 
+00020550: 6e70 2e61 7272 6179 285b 5b30 2c20 3130  np.array([[0, 10
+00020560: 5d2c 205b 302c 2031 305d 2c20 5b31 302c  ], [0, 10], [10,
+00020570: 2031 305d 5d29 0a20 2020 2023 2070 2c20   10]]).    # p, 
+00020580: 7669 7369 626c 6520 3d20 6361 6d2e 7072  visible = cam.pr
+00020590: 6f6a 6563 745f 706f 696e 7428 502c 2076  oject_point(P, v
+000205a0: 6973 6962 696c 6974 793d 5472 7565 290a  isibility=True).
+000205b0: 2020 2020 2320 7669 7369 626c 650a 0a20      # visible.. 
+000205c0: 2020 2023 2050 203d 205b 302e 312c 2030     # P = [0.1, 0
+000205d0: 2e32 2c20 335d 0a20 2020 2023 2070 7269  .2, 3].    # pri
+000205e0: 6e74 2863 616d 2e70 726f 6a65 6374 5f70  nt(cam.project_p
+000205f0: 6f69 6e74 2850 2929 0a0a 2020 2020 2320  oint(P))..    # 
+00020600: 5431 203d 2053 4533 282d 302e 312c 2030  T1 = SE3(-0.1, 0
+00020610: 2c20 3029 202a 2053 4533 2e52 7928 302e  , 0) * SE3.Ry(0.
+00020620: 3429 3b0a 2020 2020 2320 6361 6d65 7261  4);.    # camera
+00020630: 3120 3d20 4365 6e74 7261 6c43 616d 6572  1 = CentralCamer
+00020640: 6128 6e61 6d65 3d22 6361 6d65 7261 2031  a(name="camera 1
+00020650: 222c 2066 3d30 2e30 3032 2c20 696d 6167  ", f=0.002, imag
+00020660: 6573 697a 653d 3130 3030 2c20 7268 6f3d  esize=1000, rho=
+00020670: 3130 652d 362c 2070 6f73 653d 5431 290a  10e-6, pose=T1).
+00020680: 2020 2020 2320 2320 7072 696e 7428 6361      # # print(ca
+00020690: 6d65 7261 3129 0a0a 2020 2020 2320 6361  mera1)..    # ca
+000206a0: 6d65 7261 312e 6465 636f 6d70 6f73 6548  mera1.decomposeH
+000206b0: 286e 702e 6579 6528 332c 3329 290a 0a20  (np.eye(3,3)).. 
+000206c0: 2020 2023 204c 203d 204c 696e 6533 2e54     # L = Line3.T
+000206d0: 776f 506f 696e 7473 285b 302c 2030 2c20  woPoints([0, 0, 
+000206e0: 315d 2c20 5b31 2c20 312c 2031 5d29 0a20  1], [1, 1, 1]). 
+000206f0: 2020 2023 2063 616d 6572 6120 3d20 4365     # camera = Ce
+00020700: 6e74 7261 6c43 616d 6572 612e 4465 6661  ntralCamera.Defa
+00020710: 756c 7428 293b 0a20 2020 2023 206c 203d  ult();.    # l =
+00020720: 2063 616d 6572 612e 7072 6f6a 6563 745f   camera.project_
+00020730: 6c69 6e65 284c 290a 2020 2020 2320 6361  line(L).    # ca
+00020740: 6d65 7261 2e70 6c6f 745f 6c69 6e65 3328  mera.plot_line3(
+00020750: 4c29 0a0a 2020 2020 2320 7820 3d20 6e70  L)..    # x = np
+00020760: 2e72 5f5b 6361 6d2e 706f 7365 2e74 2c20  .r_[cam.pose.t, 
+00020770: 556e 6974 5175 6174 6572 6e69 6f6e 2863  UnitQuaternion(c
+00020780: 616d 2e70 6f73 6529 2e76 6563 335d 0a20  am.pose).vec3]. 
+00020790: 2020 2023 2070 7269 6e74 2878 290a 2020     # print(x).  
+000207a0: 2020 2320 702c 204a 412c 204a 4220 3d20    # p, JA, JB = 
+000207b0: 6361 6d2e 6465 7269 7661 7469 7665 7328  cam.derivatives(
+000207c0: 782c 2050 290a 2020 2020 2320 7072 696e  x, P).    # prin
+000207d0: 7428 7029 0a20 2020 2023 2070 7269 6e74  t(p).    # print
+000207e0: 2863 616d 2e70 726f 6a65 6374 5f70 6f69  (cam.project_poi
+000207f0: 6e74 2850 2929 0a20 2020 2023 2070 7269  nt(P)).    # pri
+00020800: 6e74 284a 4129 0a20 2020 2023 2070 7269  nt(JA).    # pri
+00020810: 6e74 284a 4229 0a0a 2020 2020 2320 736d  nt(JB)..    # sm
+00020820: 6261 7365 2e70 6c6f 7476 6f6c 3328 3229  base.plotvol3(2)
+00020830: 0a0a 2020 2020 2320 6361 6d2e 706c 6f74  ..    # cam.plot
+00020840: 5f63 616d 6572 6128 7363 616c 653d 302e  _camera(scale=0.
+00020850: 352c 2073 6861 7065 3d27 6361 6d65 7261  5, shape='camera
+00020860: 272c 2054 3d53 4533 2e52 7928 6e70 2e70  ', T=SE3.Ry(np.p
+00020870: 692f 3229 290a 0a20 2020 2023 2070 6c74  i/2))..    # plt
+00020880: 2e73 686f 7728 626c 6f63 6b3d 5472 7565  .show(block=True
+00020890: 290a 2020 2020 2320 7072 696e 7428 6361  ).    # print(ca
+000208a0: 6d29 0a20 2020 2023 2023 2063 616d 2e70  m).    # # cam.p
+000208b0: 6f73 6520 3d20 5345 3328 5b30 2e31 2c20  ose = SE3([0.1, 
+000208c0: 302e 322c 2030 2e33 5d29 0a20 2020 2023  0.2, 0.3]).    #
+000208d0: 2070 7269 6e74 2863 616d 2e70 6f73 6529   print(cam.pose)
+000208e0: 0a20 2020 2023 2023 2066 6967 2c20 6178  .    # # fig, ax
+000208f0: 203d 2063 2e70 6c6f 745f 6361 6d65 7261   = c.plot_camera
+00020900: 2866 7275 7374 756d 3d54 7275 6529 0a20  (frustum=True). 
+00020910: 2020 2023 2023 2070 6c74 2e73 686f 7728     # # plt.show(
+00020920: 290a 2020 2020 2320 6e70 2e73 6574 5f70  ).    # np.set_p
+00020930: 7269 6e74 6f70 7469 6f6e 7328 6c69 6e65  rintoptions(line
+00020940: 7769 6474 683d 3132 302c 2066 6f72 6d61  width=120, forma
+00020950: 7474 6572 3d7b 2766 6c6f 6174 273a 206c  tter={'float': l
+00020960: 616d 6264 6120 783a 2066 227b 783a 382e  ambda x: f"{x:8.
+00020970: 3467 7d22 2069 6620 6162 7328 7829 203e  4g}" if abs(x) >
+00020980: 2031 652d 3130 2065 6c73 6520 6622 7b30   1e-10 else f"{0
+00020990: 3a38 2e34 677d 227d 290a 0a20 2020 2023  :8.4g}"})..    #
+000209a0: 2070 7269 6e74 2863 616d 2e70 726f 6a65   print(cam.proje
+000209b0: 6374 285b 312c 322c 335d 2929 0a0a 2020  ct([1,2,3]))..  
+000209c0: 2020 2320 7072 696e 7428 6361 6d2e 7669    # print(cam.vi
+000209d0: 736a 6163 5f70 2828 3330 302c 3330 3029  sjac_p((300,300)
+000209e0: 2c20 3129 290a 2020 2020 2320 6361 6d2e  , 1)).    # cam.
+000209f0: 666c 6f77 6669 656c 6428 5b30 2c30 2c30  flowfield([0,0,0
+00020a00: 2c20 302c 302c 315d 290a 2020 2020 2320  , 0,0,1]).    # 
+00020a10: 2320 6675 6e64 616d 656e 7461 6c20 6d61  # fundamental ma
+00020a20: 7472 6978 0a20 2020 2023 2023 2063 7265  trix.    # # cre
+00020a30: 6174 6520 2b38 2077 6f72 6c64 2070 6f69  ate +8 world poi
+00020a40: 6e74 7320 2832 3020 696e 2074 6869 7320  nts (20 in this 
+00020a50: 6361 7365 290a 2020 2020 2320 6e78 2c20  case).    # nx, 
+00020a60: 6e79 203d 2028 342c 2035 290a 2020 2020  ny = (4, 5).    
+00020a70: 2320 6465 7074 6820 3d20 330a 2020 2020  # depth = 3.    
+00020a80: 2320 7820 3d20 6e70 2e6c 696e 7370 6163  # x = np.linspac
+00020a90: 6528 2d31 2c20 312c 206e 7829 0a20 2020  e(-1, 1, nx).   
+00020aa0: 2023 2079 203d 206e 702e 6c69 6e73 7061   # y = np.linspa
+00020ab0: 6365 282d 312c 2031 2c20 6e79 290a 2020  ce(-1, 1, ny).  
+00020ac0: 2020 2320 582c 2059 203d 206e 702e 6d65    # X, Y = np.me
+00020ad0: 7368 6772 6964 2878 2c20 7929 0a20 2020  shgrid(x, y).   
+00020ae0: 2023 205a 203d 2064 6570 7468 202a 206e   # Z = depth * n
+00020af0: 702e 6f6e 6573 2858 2e73 6861 7065 290a  p.ones(X.shape).
+00020b00: 2020 2020 2320 5020 3d20 6e70 2e64 7374      # P = np.dst
+00020b10: 6163 6b28 2858 2c20 592c 205a 2929 0a20  ack((X, Y, Z)). 
+00020b20: 2020 2023 2050 4320 3d20 6e70 2e72 6176     # PC = np.rav
+00020b30: 656c 2850 2c20 6f72 6465 723d 2743 2729  el(P, order='C')
+00020b40: 0a20 2020 2023 2050 5720 3d20 6e70 2e72  .    # PW = np.r
+00020b50: 6573 6861 7065 2850 432c 2028 332c 206e  eshape(PC, (3, n
+00020b60: 7820 2a20 6e79 292c 206f 7264 6572 3d27  x * ny), order='
+00020b70: 4627 290a 0a20 2020 2023 2023 2063 7265  F')..    # # cre
+00020b80: 6174 6520 7072 6f6a 6563 7469 6f6e 7320  ate projections 
+00020b90: 6672 6f6d 2070 6f73 6520 313a 0a20 2020  from pose 1:.   
+00020ba0: 2023 2070 7269 6e74 2863 2e54 290a 2020   # print(c.T).  
+00020bb0: 2020 2320 7031 203d 2063 2e70 726f 6a65    # p1 = c.proje
+00020bc0: 6374 2850 5729 2020 2320 7031 2077 7274  ct(PW)  # p1 wrt
+00020bd0: 2063 2773 2054 0a20 2020 2023 2070 7269   c's T.    # pri
+00020be0: 6e74 2870 3129 0a20 2020 2023 2063 2e70  nt(p1).    # c.p
+00020bf0: 6c6f 7428 5057 290a 0a20 2020 2023 2023  lot(PW)..    # #
+00020c00: 2064 6566 696e 6520 706f 7365 2032 3a0a   define pose 2:.
+00020c10: 2020 2020 2320 5432 203d 2053 4533 285b      # T2 = SE3([
+00020c20: 302e 342c 2030 2e32 2c20 302e 335d 2920  0.4, 0.2, 0.3]) 
+00020c30: 2023 206a 7573 7420 7075 7265 2078 2d74   # just pure x-t
+00020c40: 7261 6e73 6c61 7469 6f6e 0a20 2020 2023  ranslation.    #
+00020c50: 2070 3220 3d20 632e 7072 6f6a 6563 7428   p2 = c.project(
+00020c60: 5057 2c20 5432 290a 2020 2020 2320 7072  PW, T2).    # pr
+00020c70: 696e 7428 7032 290a 2020 2020 2320 632e  int(p2).    # c.
+00020c80: 706c 6f74 2870 3229 0a0a 2020 2020 2320  plot(p2)..    # 
+00020c90: 2320 636f 6e76 6572 7420 7031 2c20 7032  # convert p1, p2
+00020ca0: 2069 6e74 6f20 6c69 7374 7320 6f66 2070   into lists of p
+00020cb0: 6f69 6e74 733f 0a20 2020 2023 2070 3120  oints?.    # p1 
+00020cc0: 3d20 6e70 2e66 6c6f 6174 3332 286e 702e  = np.float32(np.
+00020cd0: 7472 616e 7370 6f73 6528 7031 2929 0a20  transpose(p1)). 
+00020ce0: 2020 2023 2070 3220 3d20 6e70 2e66 6c6f     # p2 = np.flo
+00020cf0: 6174 3332 286e 702e 7472 616e 7370 6f73  at32(np.transpos
+00020d00: 6528 7032 2929 0a20 2020 2023 2046 203d  e(p2)).    # F =
+00020d10: 2063 2e46 6672 6f6d 506f 696e 7473 2870   c.FfromPoints(p
+00020d20: 312c 0a20 2020 2023 2020 2020 2020 2020  1,.    #        
+00020d30: 2020 2020 2020 2020 2020 2070 322c 0a20             p2,. 
+00020d40: 2020 2023 2020 2020 2020 2020 2020 2020     #            
+00020d50: 2020 2020 2020 206d 6574 686f 643d 2738         method='8
+00020d60: 7027 2c0a 2020 2020 2320 2020 2020 2020  p',.    #       
+00020d70: 2020 2020 2020 2020 2020 2020 7261 6e73              rans
+00020d80: 6163 5468 7265 7368 3d33 2c0a 2020 2020  acThresh=3,.    
+00020d90: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00020da0: 2020 2020 636f 6e66 6964 656e 6365 3d30      confidence=0
+00020db0: 2e39 392c 0a20 2020 2023 2020 2020 2020  .99,.    #      
+00020dc0: 2020 2020 2020 2020 2020 2020 206d 6178               max
+00020dd0: 6974 6572 733d 3130 290a 0a20 2020 2023  iters=10)..    #
+00020de0: 2023 2074 6f20 6368 6563 6b20 463a 0a20   # to check F:. 
+00020df0: 2020 2023 2070 3168 203d 2065 3268 2870     # p1h = e2h(p
+00020e00: 312e 5429 0a20 2020 2023 2070 3268 203d  1.T).    # p2h =
+00020e10: 2065 3268 2870 322e 5429 0a20 2020 2023   e2h(p2.T).    #
+00020e20: 2070 6670 203d 205b 7032 685b 3a2c 2069   pfp = [p2h[:, i
+00020e30: 5d2e 5420 4020 4620 4020 7031 685b 3a2c  ].T @ F @ p1h[:,
+00020e40: 2069 5d20 666f 7220 6920 696e 2072 616e   i] for i in ran
+00020e50: 6765 2870 3168 2e73 6861 7065 5b31 5d29  ge(p1h.shape[1])
+00020e60: 5d0a 2020 2020 2320 2320 5b70 7269 6e74  ].    # # [print
+00020e70: 2870 6670 6929 2066 6f72 2070 6670 6920  (pfpi) for pfpi 
+00020e80: 696e 2070 6670 5d0a 2020 2020 2320 666f  in pfp].    # fo
+00020e90: 7220 7066 7069 2069 6e20 7066 703a 0a20  r pfpi in pfp:. 
+00020ea0: 2020 2023 2020 2020 2070 7269 6e74 2870     #     print(p
+00020eb0: 6670 6929 0a20 2020 2023 2023 2073 686f  fpi).    # # sho
+00020ec0: 756c 6420 6265 2061 6c6c 2063 6c6f 7365  uld be all close
+00020ed0: 2074 6f20 7a65 726f 2c20 7768 6963 6820   to zero, which 
+00020ee0: 7468 6579 2061 7265 210a 0a20 2020 2023  they are!..    #
+00020ef0: 2023 2065 7373 656e 7469 616c 206d 6174   # essential mat
+00020f00: 7269 7820 6672 6f6d 2070 6f69 6e74 733a  rix from points:
+00020f10: 0a20 2020 2023 2045 203d 2063 2e45 6672  .    # E = c.Efr
+00020f20: 6f6d 506f 696e 7473 2870 312c 2070 322c  omPoints(p1, p2,
+00020f30: 2063 2e43 290a 0a20 2020 2023 2023 2054   c.C)..    # # T
+00020f40: 4f44 4f20 7665 7269 6679 2045 0a0a 2020  ODO verify E..  
+00020f50: 2020 2320 696d 706f 7274 2063 6f64 650a    # import code.
+00020f60: 2020 2020 2320 636f 6465 2e69 6e74 6572      # code.inter
+00020f70: 6163 7428 6c6f 6361 6c3d 6469 6374 2867  act(local=dict(g
+00020f80: 6c6f 6261 6c73 2829 2c20 2a2a 6c6f 6361  lobals(), **loca
+00020f90: 6c73 2829 2929 0a                        ls())).
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageBlobs.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageBlobs.py`

 * *Files 6% similar despite different names*

```diff
@@ -17,45 +17,76 @@
 import tempfile
 import subprocess
 import webbrowser
 import sys
 
 # NOTE, might be better to use a matplotlib color cycler
 import random as rng
+
 rng.seed(13543)  # would this be called every time at Blobs init?
 import matplotlib.pyplot as plt
 
 # decorators
 def scalar_result(func):
     def innerfunc(*args):
         out = func(*args)
         if len(out) == 1:
             return out[0]
         else:
             return np.array(out)
+
     inner = innerfunc
     inner.__doc__ = func.__doc__  # pass through the doc string
     return inner
 
+
 def array_result(func):
     def innerfunc(*args):
         out = func(*args)
         if len(out) == 1:
             return out[0]
         else:
             return out
+
     inner = innerfunc
     inner.__doc__ = func.__doc__  # pass through the doc string
     return inner
 
-_moment_tuple = namedtuple('moments', 
-    ['m00', 'm10', 'm01', 'm20', 'm11', 'm02', 
-    'm30', 'm21', 'm12', 'm03', 'mu20', 'mu11', 'mu02', 
-    'mu30', 'mu21', 'mu12', 'mu03', 'nu20', 'nu11', 'nu02', 
-    'nu30', 'nu21', 'nu12', 'nu03'])
+
+_moment_tuple = namedtuple(
+    "moments",
+    [
+        "m00",
+        "m10",
+        "m01",
+        "m20",
+        "m11",
+        "m02",
+        "m30",
+        "m21",
+        "m12",
+        "m03",
+        "mu20",
+        "mu11",
+        "mu02",
+        "mu30",
+        "mu21",
+        "mu12",
+        "mu03",
+        "nu20",
+        "nu11",
+        "nu02",
+        "nu30",
+        "nu21",
+        "nu12",
+        "nu03",
+    ],
+)
+
+
 class Blob:
     id = None
     bbox = None
     moments = None
     touch = None
     perimeter = None
     a = None
@@ -68,22 +99,22 @@
     level = None
 
     def __init__(self):
         return
 
     def __str__(self):
         l = [f"{key}: {value}" for key, value in self.__dict__.items()]
-        return '\n'.join(l)
+        return "\n".join(l)
 
     def __repr__(self):
         return str(self)
 
 
 class Blobs(UserList):  # lgtm[py/missing-equals]
-    
+
     _image = []  # keep image saved for each Blobs object
 
     def __init__(self, image=None, **kwargs):
         """
         Find blobs and compute their attributes
 
         :param image: image to use, defaults to None
@@ -121,15 +152,15 @@
 
         or a list if applied to multiple blobs::
 
             >>> blobs.area
 
         :note: A color image is internally converted to greyscale.
 
-        :references: 
+        :references:
             - Robotics, Vision & Control for Python, Section 12.1.2.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`filter` :meth:`sort`
             `opencv.moments <https://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#ga556a180f43cab22649c23ada36a8a139>`_,
             `opencv.boundingRect <https://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#ga103fcbda2f540f3ef1c042d6a9b35ac7>`_,
             `opencv.findContours <https://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#gadf1ad6a0b82947fa1fe3c3d497f260e0>`_
         """
@@ -139,50 +170,49 @@
             # initialise empty Blobs
             # Blobs()
             return
 
         self._image = image  # keep reference to original image
 
         image = image.mono()
-        
-        # get all the contours
-        contours, hierarchy = cv.findContours(image.to_int(),
-                                              mode=cv.RETR_TREE,
-                                              method=cv.CHAIN_APPROX_NONE)
 
+        # get all the contours
+        contours, hierarchy = cv.findContours(
+            image.to_int(), mode=cv.RETR_TREE, method=cv.CHAIN_APPROX_NONE
+        )
 
         self._hierarchy_raw = hierarchy
         self._contours_raw = contours
 
         # change hierarchy from a (1,M,4) to (M,4)
         # the elements of each row are:
-        #   0: index of next contour at same level, 
-        #   1: index of previous contour at same level, 
-        #   2: index of first child, 
+        #   0: index of next contour at same level,
+        #   1: index of previous contour at same level,
+        #   2: index of first child,
         #   3: index of parent
-        hierarchy = hierarchy[0,:,:]  # drop the first singleton dimension
+        hierarchy = hierarchy[0, :, :]  # drop the first singleton dimension
         parents = hierarchy[:, 3]
 
         # change contours to list of 2xN arraay
-        contours = [c[:,0,:] for c in contours]
+        contours = [c[:, 0, :] for c in contours]
 
         ## first pass: moments, children, bbox
 
         for i, (contour, hier) in enumerate(zip(contours, hierarchy)):
 
             blob = Blob()
             blob.id = i
 
             ## bounding box: umin, vmin, width, height
             u1, v1, w, h = cv.boundingRect(contour)
             u2 = u1 + w
             v2 = v1 + h
             blob.bbox = np.r_[u1, u2, v1, v2]
 
-            blob.touch = u1 == 0  or v1 == 0 or u2 == image.umax or v2 == image.vmax
+            blob.touch = u1 == 0 or v1 == 0 or u2 == image.umax or v2 == image.vmax
 
             ## children
 
             # gets list of children for each contour based on hierarchy
             # follows similar for loop logic from _hierarchicalmoments, so
             # TODO use _getchildren to cut redundant code in _hierarchicalmoments
 
@@ -216,20 +246,20 @@
 
             ## moment hierarchy
 
             # for moments in a hierarchy, for any pq moment of a blob ignoring its
             # children you simply subtract the pq moment of each of its children.
             # That gives you the “proper” pq moment for the blob, which you then
             # use to compute area, centroid etc. for each contour
-       
+
             # TODO: this should recurse all the way down
             M = blob.moments
             for child in blob.children:
                 # subtract moments of the child
-                M = {key: M[key] -  self.data[child].moments[key] for key in M}
+                M = {key: M[key] - self.data[child].moments[key] for key in M}
 
             # convert dict to named tuple, easier to access using dot notation
             M = _moment_tuple._make([M[field] for field in _moment_tuple._fields])
             blob.moments = M
 
             ## centroid
             blob.uc = M.m10 / M.m00
@@ -254,22 +284,24 @@
             # * Area and perimeter measurement of blobs in discrete binary pictures.
             #   Z.Kulpa. Comput. Graph. Image Process., 6:434-451, 1977.
             # * Methods to Estimate Areas and Perimeters of Blob-like Objects: a
             #   Comparison. Proc. IAPR Workshop on Machine Vision Applications.,
             #   December 13-15, 1994, Kawasaki, Japan
             #   L. Yang, F. Albregtsen, T. Loennestad, P. Groettum
             kulpa = np.pi / 8.0 * (1.0 + np.sqrt(2.0))
-            blob.circularity = (4.0 * np.pi * M.m00) / (blob.perimeter_length * kulpa) ** 2
+            blob.circularity = (4.0 * np.pi * M.m00) / (
+                blob.perimeter_length * kulpa
+            ) ** 2
 
         ## third pass, region tree coloring to determine vertex depth
         while any([b.level is None for b in self.data]):  # while some uncolored
             for blob in self.data:
                 if blob.level is None:
                     if blob.parent == -1:
-                        blob.level = 0 # root level
+                        blob.level = 0  # root level
                     elif self.data[blob.parent].level is not None:
                         # one higher than parent's depth
                         blob.level = self.data[blob.parent].level + 1
 
         self.filter(**kwargs)
 
         return
@@ -313,15 +345,15 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('sharks.png')
             >>> blobs
             >>> blobs.filter(area=10_000)
             >>> blobs.filter(area=10_000, circularity=0.3)
 
-        :references: 
+        :references:
             - Robotics, Vision & Control for Python, Section 12.1.2.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`sort`
         """
         mask = []
 
         if area is not None:
@@ -389,33 +421,33 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('sharks.png')
             >>> blobs = img.blobs()
             >>> blobs.sort()
 
-        :references: 
+        :references:
             - Robotics, Vision & Control for Python, Section 12.1.2.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`filter`
         """
         if by == "area":
             k = np.argsort(self.area)
         elif by == "circularity":
             k = np.argsort(self.circularity)
         elif by == "perimeter":
             k = np.argsort(self.perimeter_length)
         elif by == "aspect":
             k = np.argsort(self.aspect)
         elif by == "touch":
             k = np.argsort(self.touch)
-        
+
         if reverse:
             k = k[::-1]
-        
+
         return self[k]
 
     def __getitem__(self, i):
         new = Blobs()
         new._image = self._image
 
         if isinstance(i, (int, slice)):
@@ -427,47 +459,51 @@
         elif isinstance(i, (list, tuple)):
             new.data = [self.data[k] for k in i]
 
         elif isinstance(i, np.ndarray):
             # numpy thing
             if np.issubdtype(i.dtype, np.integer):
                 new.data = [self.data[k] for k in i]
-            elif np.issubdtype(i.dtype, np.bool_) and len(i) == len(self):
+            elif np.issubdtype(i.dtype, bool) and len(i) == len(self):
                 new.data = [self.data[k] for k in range(len(i)) if i[k]]
         return new
 
     def __repr__(self):
         # s = "" for i, blob in enumerate(self): s += f"{i}:
         # area={blob.area:.1f} @ ({blob.uc:.1f}, {blob.vc:.1f}),
         # touch={blob.touch}, orient={blob.orientation * 180 / np.pi:.1f}°,
         # aspect={blob.aspect:.2f}, circularity={blob.circularity:.2f},
         # parent={blob._parent}\n"
 
         # return s
 
         table = ANSITable(
-                    Column("id"),
-                    Column("parent"),
-                    Column("centroid"),
-                    Column("area", fmt="{:.3g}"),
-                    Column("touch"),
-                    Column("perim", fmt="{:.1f}"),
-                    Column("circul", fmt="{:.3f}"),
-                    Column("orient", fmt="{:.1f}°"),
-                    Column("aspect", fmt="{:.3g}"),
-                    border="thin"
+            Column("id"),
+            Column("parent"),
+            Column("centroid"),
+            Column("area", fmt="{:.3g}"),
+            Column("touch"),
+            Column("perim", fmt="{:.1f}"),
+            Column("circul", fmt="{:.3f}"),
+            Column("orient", fmt="{:.1f}°"),
+            Column("aspect", fmt="{:.3g}"),
+            border="thin",
         )
         for b in self.data:
-            table.row(b.id, b.parent, f"{b.uc:.1f}, {b.vc:.1f}",
-                      b.moments.m00,
-                      b.touch,
-                      b.perimeter_length,
-                      b.circularity,
-                      np.rad2deg(b.orientation),
-                      b.b / b.a)
+            table.row(
+                b.id,
+                b.parent,
+                f"{b.uc:.1f}, {b.vc:.1f}",
+                b.moments.m00,
+                b.touch,
+                b.perimeter_length,
+                b.circularity,
+                np.rad2deg(b.orientation),
+                b.b / b.a,
+            )
 
         return str(table)
 
     @property
     @scalar_result
     def area(self):
         """
@@ -581,15 +617,15 @@
     def bbox(self):
         """
         Bounding box
 
         :return: bounding
         :rtype: ndarray(4)
 
-        The bounding box is a 1D array [umin, umax, vmin, vmax]. 
+        The bounding box is a 1D array [umin, umax, vmin, vmax].
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> im = Image.Read('shark2.png')
@@ -700,15 +736,14 @@
             >>> blobs[0].vmax
             >>> blobs.vmax
 
         :seealso: :meth:`vmin` :meth:`bbox`
         """
         return [b.bbox[1] + b.bbox[3] for b in self.data]
 
-
     @property
     @scalar_result
     def bboxarea(self):
         """
         Area of the bounding box
 
         :return: area of the bounding box in pixels
@@ -769,15 +804,15 @@
     def a(self):
         """
         Radius of equivalent ellipse
 
         :return: largest ellipse radius
         :rtype: float
 
-        Returns the major axis length which is invariant to blob position 
+        Returns the major axis length which is invariant to blob position
         and orientation.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -795,15 +830,15 @@
     def b(self):
         """
         Radius of equivalent ellipse
 
         :return: smallest ellipse radius
         :rtype: float
 
-        Returns the minor axis length which is invariant to blob position 
+        Returns the minor axis length which is invariant to blob position
         and orientation.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -903,15 +938,15 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> im = Image.Read('multiblobs.png')
             >>> blobs = im.blobs()
             >>> blobs[2].level
             >>> blobs.level
-        
+
         :seealso: :meth:`color` :meth:`parent` :meth:`children` :meth:`dotfile`
         """
         return [b.level for b in self.data]
 
     @property
     @scalar_result
     def color(self):
@@ -930,15 +965,15 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> im = Image.Read('multiblobs.png')
             >>> blobs = im.blobs()
             >>> blobs[2].color
             >>> blobs.color
-        
+
         :seealso: :meth:`level` :meth:`parent` :meth:`children`
         """
         return [b.level & 1 for b in self.data]
 
     @property
     @scalar_result
     def parent(self):
@@ -956,15 +991,15 @@
             >>> im = Image.Read('multiblobs.png')
             >>> blobs = im.blobs()
             >>> print(blobs)
             >>> blobs[5].parent
             >>> blobs[6].parent
 
         A parent of -1 is the image background.
-        
+
         :seealso: :meth:`children` :meth:`level` :meth:`dotfile`
         """
         return [b.parent for b in self.data]
 
     @property
     @array_result
     def children(self):
@@ -994,17 +1029,17 @@
         Moments of blobs
 
         :return: moments of blobs
         :rtype: named tuple or list of named tuples
 
         Compute multiple moments of each blob and return them as a named tuple
         with attributes
-        
+
         ==========================  ===============================================================================
-        Moment type                 attribute name                                                                        
+        Moment type                 attribute name
         ==========================  ===============================================================================
         moments                     ``m00`` ``m10`` ``m01`` ``m20`` ``m11`` ``m02`` ``m30`` ``m21`` ``m12`` ``m03``
         central moments             ``mu20`` ``mu11`` ``mu02`` ``mu30`` ``mu21`` ``mu12`` ``mu03`` |
         normalized central moments  ``nu20`` ``nu11`` ``nu02`` ``nu30`` ``nu21`` ``nu12`` ``nu03`` |
         ==========================  ===============================================================================
 
         :seealso: :meth:`centroid` :meth:`humoments`
@@ -1018,41 +1053,38 @@
 
         :return: Hu image moments
         :rtype: ndarray(7) or ndarray(N,7)
 
         Computes the seven Hu image moment invariants of the image.  These
         are a robust shape descriptor that is invariant to position, orientation
         and scale.
-        
+
         :seealso: :meth:`moments`
         """
+
         def hu(b):
             m = b.moments
             phi = np.empty((7,))
             phi[0] = m.nu20 + m.nu02
-            phi[1] = (m.nu20 - m.nu02)**2 + 4*m.nu11**2
-            phi[2] = (m.nu30 - 3*m.nu12)**2 + (3*m.nu21 - m.nu03)**2
-            phi[3] = (m.nu30 + m.nu12)**2 + (m.nu21 + m.nu03)**2
-            phi[4] = (m.nu30 - 3*m.nu12) \
-                        * (m.nu30+m.nu12) \
-                        * ((m.nu30 +m.nu12)**2 - 3*(m.nu21+m.nu03)**2) \
-                    + \
-                    (3*m.nu21 - m.nu03) \
-                        * (m.nu21+m.nu03) \
-                        * (3*(m.nu30+m.nu12)**2 - (m.nu21+m.nu03)**2)
-            phi[5] = (m.nu20 - m.nu02)*((m.nu30 +m.nu12)**2 \
-                    - (m.nu21+m.nu03)**2) \
-                    + 4*m.nu11 *(m.nu30+m.nu12)*(m.nu21+m.nu03)
-            phi[6] = (3*m.nu21 - m.nu03) \
-                        * (m.nu30+m.nu12) \
-                        * ((m.nu30 +m.nu12)**2 - 3*(m.nu21+m.nu03)**2) \
-                    + \
-                        (3*m.nu12 - m.nu30) \
-                        * (m.nu21+m.nu03) \
-                        * (3*(m.nu30+m.nu12)**2 - (m.nu21+m.nu03)**2)
+            phi[1] = (m.nu20 - m.nu02) ** 2 + 4 * m.nu11**2
+            phi[2] = (m.nu30 - 3 * m.nu12) ** 2 + (3 * m.nu21 - m.nu03) ** 2
+            phi[3] = (m.nu30 + m.nu12) ** 2 + (m.nu21 + m.nu03) ** 2
+            phi[4] = (m.nu30 - 3 * m.nu12) * (m.nu30 + m.nu12) * (
+                (m.nu30 + m.nu12) ** 2 - 3 * (m.nu21 + m.nu03) ** 2
+            ) + (3 * m.nu21 - m.nu03) * (m.nu21 + m.nu03) * (
+                3 * (m.nu30 + m.nu12) ** 2 - (m.nu21 + m.nu03) ** 2
+            )
+            phi[5] = (m.nu20 - m.nu02) * (
+                (m.nu30 + m.nu12) ** 2 - (m.nu21 + m.nu03) ** 2
+            ) + 4 * m.nu11 * (m.nu30 + m.nu12) * (m.nu21 + m.nu03)
+            phi[6] = (3 * m.nu21 - m.nu03) * (m.nu30 + m.nu12) * (
+                (m.nu30 + m.nu12) ** 2 - 3 * (m.nu21 + m.nu03) ** 2
+            ) + (3 * m.nu12 - m.nu30) * (m.nu21 + m.nu03) * (
+                3 * (m.nu30 + m.nu12) ** 2 - (m.nu21 + m.nu03) ** 2
+            )
             return phi
 
         return [hu(b) for b in self.data]
 
     @property
     @scalar_result
     def perimeter_length(self):
@@ -1079,15 +1111,14 @@
         :note: The length of the internal perimeter is found from summing
             the external perimeter of each child blob.
 
         :seealso: :meth:`perimeter` :meth:`children`
         """
         return [b.perimeter_length for b in self.data]
 
-
     @property
     @scalar_result
     def circularity(self):
         r"""
         Blob circularity
 
         :return: circularity
@@ -1108,20 +1139,20 @@
             >>> blobs.circularity
 
         :note:  Kulpa's correction factor is applied to account for edge
             discretization:
 
             - Area and perimeter measurement of blobs in discrete binary pictures.
               Z.Kulpa. Comput. Graph. Image Process., 6:434-451, 1977.
-    
+
             - Methods to Estimate Areas and Perimeters of Blob-like Objects: a
               Comparison. Proc. IAPR Workshop on Machine Vision Applications.,
               December 13-15, 1994, Kawasaki, Japan
               L. Yang, F. Albregtsen, T. Loennestad, P. Groettum
-        
+
         :seealso: :meth:`area` :meth:`perimeter_length`
         """
         return [b.circularity for b in self.data]
 
     @property
     @array_result
     def perimeter(self):
@@ -1174,25 +1205,25 @@
             >>> im = Image.Read('shark2.png')
             >>> blobs = im.blobs()
             >>> blobs[0].perimeter.shape
             >>> blobs[0].perimeter_approx(5).shape
             >>> with np.printoptions(threshold=10):
             >>>     blobs[0].perimeter_approx(5)
 
-        which in this case has reduced the number of perimeter points from 
+        which in this case has reduced the number of perimeter points from
         471 to 15.
 
         :note: The perimeter is not closed, that is, the first and last point
             are not the same.
 
         :seealso: :meth:`perimeter` :meth:`polar` `cv2.approxPolyDP <https://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#ga0012a5fdaea70b8a9970165d98722b4c>`_
         """
         perimeters = []
         for b in self.data:
-            perimeter = cv.approxPolyDP(b.perimeter.T,  epsilon=epsilon, closed=False)
+            perimeter = cv.approxPolyDP(b.perimeter.T, epsilon=epsilon, closed=False)
             # result is Nx1x2
             perimeters.append(np.squeeze(perimeter).T)
 
         return perimeters
 
     @array_result
     def polar(self, N=400):
@@ -1204,61 +1235,61 @@
         :return: Contour, one point per column
         :rtype: ndarray(2,N)
 
         Returns a polar representation of the boundary with
         respect to the centroid.  Each boundary point is represented by a column
         :math:`(r, \theta)`.  The polar profile can be used for scale and
         orientation invariant matching of shapes.
-        
+
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> im = Image.Read('shark2.png')
             >>> blobs = im.blobs()
             >>> p = blobs[0].polar()
             >>> p.shape
-        
+
         :note: The points are evenly spaced around the perimeter but are
             not evenly spaced in subtended angle.
 
         :seealso: :meth:`polarmatch` :meth:`perimeter`
         """
+
         def polarfunc(b):
 
             contour = np.array(b.perimeter) - np.c_[b.p].T
 
-            r = np.sqrt(np.sum(contour ** 2, axis=0))
+            r = np.sqrt(np.sum(contour**2, axis=0))
             theta = -np.arctan2(contour[1, :], contour[0, :])
 
             s = np.linspace(0, 1, len(r))
             si = np.linspace(0, 1, N)
 
             f_r = sp.interpolate.interp1d(s, r)
             f_theta = sp.interpolate.interp1d(s, theta)
 
             return np.array((f_r(si), f_theta(si)))
 
         return [polarfunc(b) for b in self]
 
-
     def polarmatch(self, target):
         r"""
         Compare polar profiles
 
         :param target: the blob index to match against
         :type target: int
         :return: similarity and orientation offset
         :rtype: ndarray(N), ndarray(N)
 
         Performs cross correlation between the polar profiles of blobs.  All
         blobs are matched against blob index ``target``.  Blob index ``target``
         is included in the results.
-        
+
         There are two return values:
 
         1. Similarity is a 1D array, one entry per blob, where a value of one
            indicates maximum similarity irrespective of orientation and scale.
         2. Orientation offset is a 1D array, one entry per blob, is the relative
            orientation of blobs with respect to the ``target`` blob.  The
            ``target`` blob has an orientation offset of 0.5. These values lie in
@@ -1288,25 +1319,24 @@
             # get the radius profile
             r = self[i].polar()[0, :]
             # normalize to zero mean and unit variance
             r -= r.mean()
             r /= np.std(r)
             R.append(r)
         R = np.array(R)  # on row per blob boundary
-        n =  R.shape[1]
+        n = R.shape[1]
 
         # get the target profile
         target = R[target, :]
 
         # cross correlate, with wrapping
-        out = sp.ndimage.correlate1d(R, target, axis=1, mode='wrap') / n
+        out = sp.ndimage.correlate1d(R, target, axis=1, mode="wrap") / n
         idx = np.argmax(out, axis=1)
         return [out[k, idx[k]] for k in range(len(self))], idx / n
 
-
     def plot_box(self, **kwargs):
         """
         Plot a bounding box for the blob using Matplotlib
 
         :param kwargs: arguments passed to ``plot_box``
 
         Plot a bounding box for every blob described by this object.
@@ -1323,15 +1353,14 @@
 
         :seealso: :meth:`plot_labelbox` :meth:`plot_centroid` :meth:`plot_perimeter` :func:`~machinevisiontoolbox.base.graphics.plot_box`
         """
 
         for blob in self:
             plot_box(lrbt=blob.bbox, **kwargs)
 
-
     def plot_labelbox(self, **kwargs):
         """
         Plot a labelled bounding box for the blob using Matplotlib
 
         :param kwargs: arguments passed to ``plot_labelbox``
 
         Plot a labelled bounding box for every blob described by this object.
@@ -1356,18 +1385,18 @@
 
         :seealso: :meth:`plot_box` :meth:`plot_perimeter` :func:`~machinevisiontoolbox.base.graphics.plot_point`
         """
         if label:
             text = "{:d}"
         else:
             text = ""
-        
-        if 'marker' not in kwargs:
-            kwargs['marker'] = ['bx', 'bo']
-            kwargs['fillstyle'] = 'none'
+
+        if "marker" not in kwargs:
+            kwargs["marker"] = ["bx", "bo"]
+            kwargs["fillstyle"] = "none"
         for i, blob in enumerate(self):
             plot_point(pos=blob.centroid, text=text.format(i), **kwargs)
 
     def plot_perimeter(self, **kwargs):
         """
         Plot perimeter of blob using Matplotlib
 
@@ -1377,17 +1406,18 @@
 
         :seealso: :meth:`plot_box` :meth:`plot_centroid`
         """
         for blob in self:
             x, y = blob.perimeter
             plt.plot(x, y, **kwargs)
 
-    def label_image(self,
-                  image=None,
-                  ):
+    def label_image(
+        self,
+        image=None,
+    ):
         """
         Create label image from blobs
 
         :param image: image to draw into, defaults to new image
         :type image: :class:`Image`, optional
         :return: greyscale label image
         :rtype: :class:`Image`
@@ -1404,24 +1434,25 @@
 
         # TODO check contours, icont, colors, etc are valid
         # done because we squeezed hierarchy from a (1,M,4) to an (M,4) earlier
 
         labels = np.zeros(image.shape[:2], dtype=np.uint8)
         for i in range(len(self)):
             # TODO figure out how to draw alpha/transparencies?
-            cv.drawContours(image=labels,
-                            contours=self._contours_raw,
-                            contourIdx=i,
-                            color=i+1,
-                            thickness=-1,  # fill the contour
-                            hierarchy=self._hierarchy_raw)
+            cv.drawContours(
+                image=labels,
+                contours=self._contours_raw,
+                contourIdx=i,
+                color=i + 1,
+                thickness=-1,  # fill the contour
+                hierarchy=self._hierarchy_raw,
+            )
 
         return image.__class__(labels)
 
-
     def dotfile(self, filename=None, direction=None, show=False):
         """
         Create a GraphViz dot file
 
         :param filename: filename to save graph to, defaults to None
         :type filename: str, optional
         :param direction: graph drawing direction, defaults to top to bottom
@@ -1431,15 +1462,15 @@
 
         Creates the specified file which contains the `GraphViz
         <https://graphviz.org>`_ code to represent the blob hierarchy as a
         directed graph.  By default output is to the console.
 
         :note: If ``filename`` is a file object then the file will *not*
             be closed after the GraphViz model is written.
-        
+
         :seealso: :meth:`child` :meth:`parent` :meth:`level`
         """
 
         if show:
             # create the temporary dotfile
             filename = tempfile.TemporaryFile(mode="w")
         if filename is None:
@@ -1455,30 +1486,30 @@
             print(f"rankdir = {direction}", file=f)
 
         # add the nodes including name and position
         for id, blob in enumerate(self):
             print('  "{:d}"'.format(id), file=f)
             print('  "{:d}" -> "{:d}"'.format(blob.parent, id), file=f)
 
-        print('}', file=f)
+        print("}", file=f)
 
         if show:
             # rewind the dot file, create PDF file in the filesystem, run dot
             f.seek(0)
             pdffile = tempfile.NamedTemporaryFile(suffix=".pdf", delete=False)
             subprocess.run("dot -Tpdf", shell=True, stdin=filename, stdout=pdffile)
 
             # open the PDF file in browser (hopefully portable), then cleanup
             webbrowser.open(f"file://{pdffile.name}")
         else:
             if filename is None or isinstance(filename, str):
                 f.close()  # noqa
 
-class ImageBlobsMixin:
 
+class ImageBlobsMixin:
     def blobs(self, **kwargs):
         """
         Find and describe blobs in image
 
         :return: blobs in the image
         :rtype: :class:`Blobs`
 
@@ -1493,48 +1524,51 @@
             >>> from machinevisiontoolbox import Image
             >>> im = Image.Read('shark2.png')
             >>> blobs = im.blobs()
             >>> type(blobs)
             >>> len(blobs)
             >>> print(blobs)
 
-        :references: 
+        :references:
             - Robotics, Vision & Control for Python, Section 12.1.2.1, P. Corke, Springer 2023.
         """
 
         # TODO do the feature extraction here
         # each blob is a named tuple??
         # This could be applied to MSERs
         return Blobs(self, **kwargs)
 
 
 if __name__ == "__main__":
 
     from machinevisiontoolbox import Image
     import matplotlib.pyplot as plt
 
-    im = Image.Read('multiblobs.png')
+    im = Image.Read("multiblobs.png")
 
-    f  = im.blobs()
+    f = im.blobs()
     # z = f.label_image()
-    
+
     labels = f.label_image()
-    labels.disp(colormap='viridis', ncolors=10, colorbar=dict(shrink=0.8, aspect=20*0.8), block=True)
+    labels.disp(
+        colormap="viridis",
+        ncolors=10,
+        colorbar=dict(shrink=0.8, aspect=20 * 0.8),
+        block=True,
+    )
     pass
 
     # im = Image.Read('sharks.png')
 
-
     # im.disp()
     # blobs=im.blobs()
     # print(blobs)
 
     # blobs.plot_box(color="red")
 
-
     # # blobs = Blobs()
     # # print(len(blobs))
 
     # blobs = im.blobs()
     # print(len(blobs))
     # print(blobs[0].area)
     # print(blobs.area)
@@ -1559,15 +1593,14 @@
     # print(blobs.filter(circularity=0.8))
 
     # print(blobs.color)
 
     # print(blobs[2].humoments)
     # print(blobs.humoments)
 
-
     # print(blobs[3].moments)
 
     # blobs.dotfile(show=True)
 
     # from ansitable.table import _unicode
     # _unicode = False
 
@@ -1577,17 +1610,14 @@
     # print(blobs[5].contour(epsilon=20))
     # im.disp()
     # blobs.plot_labelbox(filled=False, labelcolor='red', edgecolor='red')
     # blobs.plot_centroid()
     # print(blobs[0].children)
     # plt.show(block=True)
 
-    
-
-
     # # read image
     # from machinevisiontoolbox import Image
     # im = Image(cv.imread('images/multiblobs.png', cv.IMREAD_GRAYSCALE))
 
     # # call Blobs class
     # b = Blob(image=im)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageColor.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageColor.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,19 +5,21 @@
 import cv2 as cv
 
 from machinevisiontoolbox.base import color, name2color
 from machinevisiontoolbox.base import imageio
 
 from scipy import interpolate
 
+
 class ImageColorMixin:
     """
     Image processing color operations on the Image class
     """
-    def mono(self, opt='r601'):
+
+    def mono(self, opt="r601"):
         """
         Convert color image to monochrome
 
         :param opt: greyscale conversion mode, one of: 'r601' [default], 'r709',
           'value' or 'cv'
         :type opt: str, optional
         :return: monochrome image
@@ -27,15 +29,15 @@
         image.  Various conversion options are available:
 
         ===========  =====================================================
         ``opt``      definition
         ===========  =====================================================
         ``'r601'``   ITU Rec. 601, Y' = 0.229 R' + 0.587 G' + 0.114 B'
         ``'r709'``   ITU Rec. 709, Y' =  0.2126 R' + 0.7152 G' + 0.0722 B'
-        ``'value'``  V (value) component of HSV space 
+        ``'value'``  V (value) component of HSV space
         ``'cv'``     OpenCV colorspace() RGB to gray conversion
         ===========  =====================================================
 
         Example:
 
         .. runblock:: pycon
 
@@ -51,42 +53,39 @@
 
         :seealso: :meth:`colorspace` :meth:`colorize`
         """
 
         if not self.iscolor:
             return self
 
-        if opt == 'r601':
-            mono = 0.229 * self.red() + 0.587 * self.green() + \
-                0.114 * self.blue()
-
-        elif opt == 'r709':
-            mono = 0.2126 * self.red() + 0.7152 * self.green() + \
-                0.0722 * self.blue()
+        if opt == "r601":
+            mono = 0.229 * self.red() + 0.587 * self.green() + 0.114 * self.blue()
+
+        elif opt == "r709":
+            mono = 0.2126 * self.red() + 0.7152 * self.green() + 0.0722 * self.blue()
 
-        elif opt == 'value':
+        elif opt == "value":
             # 'value' refers to the V in HSV space, not the CIE L*
             # the mean of the max and min of RGB values at each pixel
             mn = self.image.min(axis=2)
             mx = self.image.max(axis=2)
 
             mono = mn / 2 + mx / 2
 
-        elif opt == 'cv':
+        elif opt == "cv":
             if self.isrgb:
-              return self.colorspace('gray', src="rgb")
+                return self.colorspace("gray", src="rgb")
             else:
-              return self.colorspace('gray', src="bgr")
+                return self.colorspace("gray", src="bgr")
         else:
-            raise TypeError('unknown type for opt')
+            raise TypeError("unknown type for opt")
 
         return self.__class__(self.cast(mono.image))
 
-
-    def chromaticity(self, which='RG'):
+    def chromaticity(self, which="RG"):
         r"""
         Create chromaticity image
 
         :param which: string comprising single letter color plane names, defaults to 'RG'
         :type which: str, optional
         :return: chromaticity image
         :rtype: :class:`Image` instance
@@ -111,30 +110,31 @@
 
         :references:
             - Robotics, Vision & Control for Python, Section 10.2.5, P. Corke, Springer 2023.
 
         :seealso: :func:`~machinevisiontoolbox.base.color.tristim2cc`
         """
         if not self.iscolor:
-            raise ValueError('cannot compute chromaticity for greyscale image')
+            raise ValueError("cannot compute chromaticity for greyscale image")
         if self.nplanes != 3:
-            raise ValueError('expecting 3 plane image')
+            raise ValueError("expecting 3 plane image")
 
         sum = np.sum(self.image, axis=2)
         r = self.plane(which[0]).image / sum
         g = self.plane(which[1]).image / sum
 
-        return self.__class__(np.dstack((r, g)), colororder=which.lower(), dtype="float32")
-
+        return self.__class__(
+            np.dstack((r, g)), colororder=which.lower(), dtype="float32"
+        )
 
-    def colorize(self, color=[1, 1, 1], colororder='RGB', alpha=False):
+    def colorize(self, color=[1, 1, 1], colororder="RGB", alpha=False):
         """
         Colorize a greyscale image
 
-        :param color: base color 
+        :param color: base color
         :type color: string, array_like(3)
         :param colororder: order of color channels of resulting image
         :type colororder: str, dict
         :return: color image
         :rtype: :class:`Image` instance
 
         The greyscale image is colorized by setting each output pixel to the product
@@ -157,114 +157,117 @@
 
         # TODO, colorize all in list
         if isinstance(color, str):
             color = name2color(color)
         else:
             color = argcheck.getvector(color).astype(self.dtype)
         if self.iscolor:
-            raise ValueError(self.image, 'Image must be greyscale')
+            raise ValueError(self.image, "Image must be greyscale")
 
         # alpha can be False, True, or scalar
         if alpha is False:
-            out = np.dstack((color[0] * self.image,
-                             color[1] * self.image,
-                             color[2] * self.image))
+            out = np.dstack(
+                (color[0] * self.image, color[1] * self.image, color[2] * self.image)
+            )
         else:
             if alpha is True:
-              alpha = 1
+                alpha = 1
 
-            out = np.dstack((color[0] * self.image,
-                           color[1] * self.image,
-                           color[2] * self.image,
-                           alpha * np.ones(self.shape)))
+            out = np.dstack(
+                (
+                    color[0] * self.image,
+                    color[1] * self.image,
+                    color[2] * self.image,
+                    alpha * np.ones(self.shape),
+                )
+            )
 
         if self.isint and np.issubdtype(color.dtype, np.floating):
             out = self.cast(out)
 
         return self.__class__(out, colororder=colororder)
 
-
     def kmeans_color(self, k=None, centroids=None, seed=None):
         """
-        k-means color clustering
+          k-means color clustering
 
-        **Training**
+          **Training**
 
-        :param k: number of clusters, defaults to None
-        :type k: int, optional
-        :param seed: random number seed, defaults to None
-        :type seed: int, optional
-        :return: label image, centroids and residual
-        :rtype: :class:`Image`, ndarray(P,k), float
-
-        The pixels are grouped into ``k`` clusters based on their Euclidean
-        distance from ``k`` cluster centroids.  Clustering is iterative and
-        the intial cluster centroids are random.
+          :param k: number of clusters, defaults to None
+          :type k: int, optional
+          :param seed: random number seed, defaults to None
+          :type seed: int, optional
+          :return: label image, centroids and residual
+          :rtype: :class:`Image`, ndarray(P,k), float
 
-        The method returns a label image, indicating the assigned cluster for
-        each input pixel, the cluster centroids and a residual.
+          The pixels are grouped into ``k`` clusters based on their Euclidean
+          distance from ``k`` cluster centroids.  Clustering is iterative and
+          the intial cluster centroids are random.
 
-        Example:
+          The method returns a label image, indicating the assigned cluster for
+          each input pixel, the cluster centroids and a residual.
 
-        .. runblock:: pycon
+          Example:
 
-            >>> from machinevisiontoolbox import Image
-            >>> targets = Image.Read("tomato_124.png", dtype="float", gamma="sRGB")
-            >>> ab = targets.colorspace("L*a*b*").plane("a*:b*")
-            >>> targets_labels, targets_centroids, resid = ab.kmeans_color(k=3, seed=0)
-            >>> targets_centroids
-
-        **Classification**
-
-        :param centroids: cluster centroids from training phase
-        :type centroids: ndarray(P,k)
-        :return: label image
-        :rtype: :class:`Image`
+          .. runblock:: pycon
 
-        Pixels in the input image are assigned the label of the closest centroid.
+              >>> from machinevisiontoolbox import Image
+              >>> targets = Image.Read("tomato_124.png", dtype="float", gamma="sRGB")
+              >>> ab = targets.colorspace("L*a*b*").plane("a*:b*")
+              >>> targets_labels, targets_centroids, resid = ab.kmeans_color(k=3, seed=0)
+              >>> targets_centroids
 
-        :note: The colorspace of the images could a chromaticity space to classify
-          objects while ignoring brightness variation.
+          **Classification**
 
-        :references:
-            - Robotics, Vision & Control for Python, Section 12.1.1.2, P. Corke, Springer 2023.
+          :param centroids: cluster centroids from training phase
+          :type centroids: ndarray(P,k)
+          :return: label image
+          :rtype: :class:`Image`
+
+          Pixels in the input image are assigned the label of the closest centroid.
+
+          :note: The colorspace of the images could a chromaticity space to classify
+            objects while ignoring brightness variation.
 
-      :seealso: `opencv.kmeans <https://docs.opencv.org/3.4/d5/d38/group__core__cluster.html#ga9a34dc06c6ec9460e90860f15bcd2f88>`_
-      """
+          :references:
+              - Robotics, Vision & Control for Python, Section 12.1.1.2, P. Corke, Springer 2023.
+
+        :seealso: `opencv.kmeans <https://docs.opencv.org/3.4/d5/d38/group__core__cluster.html#ga9a34dc06c6ec9460e90860f15bcd2f88>`_
+        """
         # TODO
         # colorspace can be RGB, rg, Lab, ab
 
         if seed is not None:
             cv.setRNGSeed(seed)
-        
+
         data = self.to_float().reshape((-1, self.nplanes))
         criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 10, 1.0)
 
         if k is not None:
             # perform clustering
             ret, label, centres = cv.kmeans(
-                    data=data,
-                    K= k,
-                    bestLabels=None,
-                    criteria=criteria,
-                    attempts=10,
-                    flags=cv.KMEANS_RANDOM_CENTERS
-                )
+                data=data,
+                K=k,
+                bestLabels=None,
+                criteria=criteria,
+                attempts=10,
+                flags=cv.KMEANS_RANDOM_CENTERS,
+            )
             return self.__class__(label.reshape(self.shape[:2])), centres.T, ret
-        
+
         elif centroids is not None:
             # assign pixels to given cluster centres
             # M x K
             k = centroids.shape[1]
             data = np.repeat(data[..., np.newaxis], k, axis=2)  # N x M x K
 
             # compute L2 norm over the error
             distance = np.linalg.norm(data - centroids, axis=1)  # N x K
 
-            # now find which cluster centre gave the smallest error 
+            # now find which cluster centre gave the smallest error
             label = np.argmin(distance, axis=1)
 
             return self.__class__(label.reshape(self.shape[:2]))
 
     def colorspace(self, dst, src=None):
         """
         Transform a color image between color representations
@@ -331,17 +334,16 @@
             colororder = dst
             colororder = colororder.replace("*", "*:", 2)
         else:
             colororder = None
 
         return self.__class__(out, dtype=self.dtype, colororder=colororder)
 
-
     @classmethod
-    def Overlay(cls, im1, im2, colors='rc'):
+    def Overlay(cls, im1, im2, colors="rc"):
         """
         Overlay two greyscale images in different colors
 
         :param im1: first image
         :type im1: :class:`Image`
         :param im2: second image
         :type im2: :class:`Image`
@@ -361,29 +363,29 @@
             >>> from machinevisiontoolbox import Image
             >>> img1 = Image.Read('eiffel-1.png', mono=True)
             >>> img2 = Image.Read('eiffel-2.png', mono=True)
             >>> Image.Overlay(img1, img2)
             >>> Image.Overlay(img1, img2, 'rg')
             >>> Image.Overlay(img1, img2, ((1, 0, 0), (0, 1, 0)))
 
-        :note: Images can be different size, the output image size is the 
+        :note: Images can be different size, the output image size is the
           maximum of the dimensions of the input images.  Small dimensions are
           zero padded.  The top-left corner of both images are aligned.
 
         :seealso: :meth:`anaglyph` :meth:`blend` :meth:`stshow`
         """
         if im1.iscolor or im2.iscolor:
-            raise ValueError('images must be greyscale')
+            raise ValueError("images must be greyscale")
         h = max(im1.height, im2.height)
         w = max(im1.width, im2.width)
-        overlay = cls.Constant(w, h, [0, 0, 0], colororder='RGB')
-        im1 = im1.colorize(colors[0]) 
+        overlay = cls.Constant(w, h, [0, 0, 0], colororder="RGB")
+        im1 = im1.colorize(colors[0])
         im2 = im2.colorize(colors[1])
-        overlay.paste(im1, (0,0), 'add', copy=False)
-        overlay.paste(im2, (0,0), 'add', copy=False)
+        overlay.paste(im1, (0, 0), "add", copy=False)
+        overlay.paste(im2, (0, 0), "add", copy=False)
         return overlay
 
     def gamma_encode(self, gamma):
         r"""
         Gamma encoding
 
         :param gamma: gamma value
@@ -467,21 +469,25 @@
             - Robotics, Vision & Control for Python, Section 10.2.7, 10.3.6, P. Corke, Springer 2023.
 
         :seealso: :meth:`gamma_encode` :meth:`colorspace`
         """
         out = color.gamma_decode(self.image, gamma)
         return self.__class__(out, colororder=self.colororder)
 
+
 # --------------------------------------------------------------------------- #
 if __name__ == "__main__":
 
     import pathlib
     import os.path
 
     from machinevisiontoolbox import Image
 
-    im1 = Image.Read('eiffel-1.png', mono=True)
-    im2 = Image.Read('eiffel-2.png', mono=True)
-    Image.Overlay(im1, im2, 'rc').disp(block=True)
-
-    
-    exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_color.py").read())  # pylint: disable=exec-used
+    im1 = Image.Read("eiffel-1.png", mono=True)
+    im2 = Image.Read("eiffel-2.png", mono=True)
+    Image.Overlay(im1, im2, "rc").disp(block=True)
+
+    exec(
+        open(
+            pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_color.py"
+        ).read()
+    )  # pylint: disable=exec-used
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageConstants.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageConstants.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,28 +12,29 @@
 import numpy as np
 import cv2 as cv
 from numpy.lib.arraysetops import isin
 from machinevisiontoolbox.base import int_image, float_image, name2color
 from machinevisiontoolbox.ImageSpatial import Kernel
 from spatialmath.base import isscalar, islistof
 import warnings
+
 # import spatialmath.base.argcheck as argcheck
 
 
 from machinevisiontoolbox.base.imageio import idisp, iread, iwrite, convert
 import urllib
 import xml.etree.ElementTree as ET
 
 
 class ImageConstantsMixin:
 
     # ======================= patterns ================================== #
 
     @classmethod
-    def Zeros(cls, w, h=None, colororder=None, dtype='uint8'):
+    def Zeros(cls, w, h=None, colororder=None, dtype="uint8"):
         """
         Create image with zero value pixels
 
         :param w: width, or (width, height)
         :type w: int, (int, int)
         :param h: height, defaults to None
         :type h: int, optional
@@ -51,33 +52,33 @@
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> Image.Zeros(20)
             >>> Image.Zeros(10,20)
             >>> Image.Zeros(20, dtype='float', colororder="RGB") # create color image, all black
-        
+
         :seealso: :meth:`Constant`
         """
         if h is None:
             if isinstance(w, (tuple, list)):
                 h = w[1]
                 w = w[0]
             else:
                 h = w
         shape = [h, w]
-        
+
         if colororder is not None:
             p = len(cls.colordict(colororder))
             shape.append(p)
 
         return cls(np.zeros(shape, dtype=dtype), colororder=colororder)
 
     @classmethod
-    def Constant(cls, w, h=None, value=0, colororder=None, dtype='uint8'):
+    def Constant(cls, w, h=None, value=0, colororder=None, dtype="uint8"):
         """
         Create image with all pixels having same value
 
         :param w: width, or (width, height)
         :type w: int, (int, int)
         :param h: height, defaults to None
         :type h: int, optional
@@ -120,34 +121,34 @@
             if isinstance(w, (tuple, list)):
                 h = w[1]
                 w = w[0]
             else:
                 h = w
         shape = (h, w)
         if isinstance(value, float):
-            dtype = 'float'
+            dtype = "float"
 
         if isinstance(value, str):
             # value given as a string, assume colorname
             value = name2color(value, dtype=dtype)
 
         if isinstance(value, Iterable):
             # iterable
             if len(value) == 3 and colororder is None:
-                colororder = 'RGB'
+                colororder = "RGB"
 
             planes = []
             for bg in value:
                 planes.append(np.full(shape, bg, dtype=dtype))
             return cls(np.stack(planes, axis=2), colororder=colororder)
 
         else:
             # scalar
             return cls(np.full(shape, value, dtype=dtype))
-            
+
     @classmethod
     def String(cls, s):
         """
         Create a small image from text string
 
         :param s: text string
         :type s: str
@@ -163,28 +164,28 @@
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.String('01234|56789|87654')
             >>> img.print()
 
-        :note: Pixel values are determined by the unicode value of the 
+        :note: Pixel values are determined by the unicode value of the
             character relative to unicode for '0', so other ASCII characters
             (apart from pipe) can be used to obtain pixel values greater than 9.
             'Z' is 90 and 'z' is 122.
 
         :seealso: :meth:`Constant`
         """
         pixels = []
-        for row in s.split('|'):
-            pixels.append([ord(c) - ord('0') for c in row])
-        return cls(pixels, dtype='uint8')
+        for row in s.split("|"):
+            pixels.append([ord(c) - ord("0") for c in row])
+        return cls(pixels, dtype="uint8")
 
     @classmethod
-    def Random(cls, w, h=None, value=0, colororder=None, dtype='uint8'):
+    def Random(cls, w, h=None, value=0, colororder=None, dtype="uint8"):
         """
         Create image with random pixel values
 
         :param w: width, or (width, height)
         :type w: int, (int, int)
         :param h: height, defaults to None
         :type h: int, optional
@@ -218,25 +219,24 @@
                 h = w[1]
                 w = w[0]
             else:
                 h = w
         shape = [w, h]
         if colororder is not None:
             shape.append(len(cls.colordict(colororder)))
-        
+
         if np.issubdtype(dtype, np.integer):
             im = np.random.randint(0, np.iinfo(dtype).max, size=shape, dtype=dtype)
         elif np.issubdtype(dtype, np.floating):
             im = np.random.rand(*shape)
 
         return cls(im, colororder=colororder)
 
-
     @classmethod
-    def Squares(cls, number, size=256, fg=1, bg=0, dtype='uint8'):
+    def Squares(cls, number, size=256, fg=1, bg=0, dtype="uint8"):
         """
         Create image containing grid of squares
 
         :param number: number of squares horizontally and vertically
         :type number: int
         :param size: image width and height, defaults to 256
         :type size: int, optional
@@ -264,20 +264,20 @@
         side = 2 * d + 1  # keep it odd
         sq = np.full((side, side), fg, dtype=dtype)
         s2 = side // 2
         for r in range(number):
             y0 = (r * 3 + 2) * d
             for c in range(number):
                 x0 = (c * 3 + 2) * d
-                im[y0-s2:y0+s2+1, x0-s2:x0+s2+1] = sq
+                im[y0 - s2 : y0 + s2 + 1, x0 - s2 : x0 + s2 + 1] = sq
 
         return cls(im)
 
     @classmethod
-    def Circles(cls, number, size=256, fg=1, bg=0, dtype='uint8'):
+    def Circles(cls, number, size=256, fg=1, bg=0, dtype="uint8"):
         """
         Create image containing grid of circles
 
         :param number: number of circles horizontally and vertically
         :type number: int
         :param size: image width and height, defaults to 256
         :type size: int, optional
@@ -306,20 +306,20 @@
         s2 = side // 2
         circle = Kernel.Circle(s2).astype(dtype) * (fg - bg) + bg
 
         for r in range(number):
             y0 = (r * 3 + 2) * d
             for c in range(number):
                 x0 = (c * 3 + 2) * d
-                im[y0-s2:y0+s2+1, x0-s2:x0+s2+1] = circle
+                im[y0 - s2 : y0 + s2 + 1, x0 - s2 : x0 + s2 + 1] = circle
 
         return cls(im)
 
     @classmethod
-    def Ramp(cls, size=256, cycles=2, dir='x', dtype='float32'):
+    def Ramp(cls, size=256, cycles=2, dir="x", dtype="float32"):
         """
         Create image of linear ramps
 
         :param dir: ramp direction: 'x' [default] or 'y'
         :type dir: str, optional
         :param size: image width and height, defaults to 256
         :type size: int, optional
@@ -348,21 +348,21 @@
             max = np.iinfo(dtype).max
         else:
             max = 1.0
         x = np.arange(0, size)
         s = np.expand_dims(np.mod(x, c) / (c - 1) * max, axis=0).astype(dtype)
         image = np.repeat(s, size, axis=0)
 
-        if dir == 'y':
+        if dir == "y":
             image = image.T
 
         return cls(image, dtype=dtype)
 
     @classmethod
-    def Sin(cls, size=256, cycles=2, dir='x', dtype='float32'):
+    def Sin(cls, size=256, cycles=2, dir="x", dtype="float32"):
         """
         Create image of sinusoidal intensity pattern
 
         :param dir: sinusoid direction: 'x' [default] or 'y'
         :type dir: str, optional
         :param size: image width and height, defaults to 256
         :type size: int, optional
@@ -388,28 +388,35 @@
         """
         c = size / cycles
         x = np.arange(0, size)
         if np.issubdtype(dtype, np.integer):
             max = np.iinfo(dtype).max
         else:
             max = 1.0
-        s = np.expand_dims((np.sin(x / c * 2 * np.pi) + 1) * max / 2, axis=0).astype(dtype)
+        s = np.expand_dims((np.sin(x / c * 2 * np.pi) + 1) * max / 2, axis=0).astype(
+            dtype
+        )
         image = np.repeat(s, size, axis=0)
-        if dir == 'y':
+        if dir == "y":
             image = image.T
 
         return cls(image, dtype=dtype)
 
 
 # --------------------------------------------------------------------------- #
 if __name__ == "__main__":
 
     import pathlib
     import os.path
-    
+
     from machinevisiontoolbox import Image
+
     # z = Image.Ramp(2, value=range(6), colororder='ABCDEF')
     # print(z)
     Image.Sin(256, 2).image
-    Image.Sin(256, 2, dtype='uint8').image
-    
-    exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_core.py").read())  # pylint: disable=exec-used
+    Image.Sin(256, 2, dtype="uint8").image
+
+    exec(
+        open(
+            pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_core.py"
+        ).read()
+    )  # pylint: disable=exec-used
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageCore.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageCore.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,18 +7,25 @@
 
 from pathlib import Path
 import os.path
 import os
 import numpy as np
 import cv2 as cv
 from numpy.lib.arraysetops import isin
-from machinevisiontoolbox.base import int_image, float_image, draw_line, draw_circle, draw_box
+from machinevisiontoolbox.base import (
+    int_image,
+    float_image,
+    draw_line,
+    draw_circle,
+    draw_box,
+)
 from machinevisiontoolbox.ImageSpatial import Kernel
 from spatialmath.base import isscalar, islistof
 import warnings
+
 # import spatialmath.base.argcheck as argcheck
 
 from machinevisiontoolbox.base.imageio import idisp, iread, iwrite, convert
 import urllib
 
 from machinevisiontoolbox.ImageIO import ImageIOMixin
 from machinevisiontoolbox.ImageConstants import ImageConstantsMixin
@@ -34,40 +41,43 @@
 from machinevisiontoolbox.ImagePointFeatures import ImagePointFeaturesMixin
 from machinevisiontoolbox.ImageMultiview import ImageMultiviewMixin
 
 """
 This class encapsulates a Numpy array containing the pixel values.  The object
 supports arithmetic using overloaded operators, as well a large number of methods.
 """
-class Image(
-            ImageIOMixin,
-            ImageConstantsMixin,
-            ImageProcessingMixin,
-            ImageMorphMixin,
-            ImageSpatialMixin,
-            ImageColorMixin,
-            ImageReshapeMixin,
-            ImageBlobsMixin,
-            ImageWholeFeaturesMixin,
-            ImageRegionFeaturesMixin,
-            ImageLineFeaturesMixin,
-            ImagePointFeaturesMixin,
-            ImageMultiviewMixin
-            ):
 
-    def __init__(self,
-                 image=None,
-                 colororder=None,
-                 copy=False,
-                 shape=None,
-                 dtype=None,
-                 name=None,
-                 id=None,
-                 domain=None,
-                 **kwargs):
+
+class Image(
+    ImageIOMixin,
+    ImageConstantsMixin,
+    ImageProcessingMixin,
+    ImageMorphMixin,
+    ImageSpatialMixin,
+    ImageColorMixin,
+    ImageReshapeMixin,
+    ImageBlobsMixin,
+    ImageWholeFeaturesMixin,
+    ImageRegionFeaturesMixin,
+    ImageLineFeaturesMixin,
+    ImagePointFeaturesMixin,
+    ImageMultiviewMixin,
+):
+    def __init__(
+        self,
+        image=None,
+        colororder=None,
+        copy=False,
+        shape=None,
+        dtype=None,
+        name=None,
+        id=None,
+        domain=None,
+        **kwargs,
+    ):
         """
         Create an Image instance
 
         :param image: image data
         :type image: array_like(H,W), :class:`Image`
         :param colororder: order of color channels
         :type colororder: str, dict
@@ -81,15 +91,15 @@
         :type name: str, optional
         :param id: numeric id of image, typically a sequence number, defaults to None
         :type id: int, optional
         :param domain: domain of image, defaults to None
         :type domain: array_like(W), array_like(H), optional
         :raises TypeError: unknown type passed to constructor
 
-        Create a new image instance which contains pixel values as well as 
+        Create a new image instance which contains pixel values as well as
         information about image size, datatype, color planes and domain.
 
         The ``image`` can be specified in several ways:
 
         - as an :class:`Image` instance and its pixel array will be *referenced*
           by the new :class:`Image`.
         - an a NumPy 2D or 3D array for a greyscale or color image respectively.
@@ -100,26 +110,26 @@
 
         The ``dtype`` of an image comes from the internal NumPy pixel array.
         If ``image`` is an :class:`Image` instance or NumPy ndarray then its dtype is
         determined by the NumPy ndarray.
 
         If ``image`` is given as a list of lists and ``dtype`` is not given,
         then the :class:`Image` type is:
-        
+
         - float32 if the list contains any floating point values, otherwise
         - the smallest signed or unsigned int that can represent its
           value span.
 
         An ``image`` can have bool values.  When used in a numerical expression
         its values will bs cast to numeric values of 0 or 1 representing
-        False and True respectively. 
-        
+        False and True respectively.
+
         **Color planes**
 
-        Images can have multiple planes, typically three (representing the 
+        Images can have multiple planes, typically three (representing the
         primary colors red, green and blue) but any number is possible. In
         the underlying Numpy array these planes are identified by an integer
         plane index (the last dimension of the 3D array).  The :class:`Image`
         contains a dictionary that maps the name of a color plane to its
         index value.  The color plane order can be specified as a dict or
         a string.
 
@@ -169,39 +179,41 @@
         elif isinstance(image, list):
             # list of lists
 
             # attempt to convert it to an ndarray
             try:
                 image = np.array(image)
             except VisibleDeprecationWarning:
-                raise ValueError('bad argument passed to Image constructor')
+                raise ValueError("bad argument passed to Image constructor")
 
             if dtype is None:
                 # no type given, automatically choose it
                 if np.issubdtype(image.dtype, np.floating):
                     # list contained a float
                     dtype = np.float32
-                
+
                 elif np.issubdtype(image.dtype, np.integer):
                     # list contained only ints, convert to int/uint8 of smallest
                     # size to contain all values
                     if image.min() < 0:
                         # value is signed
-                        for type in ['int8', 'int16', 'int32']:
-                            if (image.max() <= np.iinfo(type).max) and (image.min() >= np.iinfo(type).min):
+                        for type in ["int8", "int16", "int32"]:
+                            if (image.max() <= np.iinfo(type).max) and (
+                                image.min() >= np.iinfo(type).min
+                            ):
                                 dtype = np.dtype(type)
                                 break
                     else:
                         # value is unsigned
-                        for type in ['uint8', 'uint16', 'uint32']:
+                        for type in ["uint8", "uint16", "uint32"]:
                             if image.max() <= np.iinfo(type).max:
                                 dtype = np.dtype(type)
                                 break
         else:
-            raise ValueError('bad argument passed to Image constructor')
+            raise ValueError("bad argument passed to Image constructor")
 
         # change type of array if dtype was specified
         if dtype is not None:
             image = image.astype(dtype)
 
         self.name = name
 
@@ -215,17 +227,17 @@
 
         if copy:
             self._A = image.copy()
         else:
             self._A = image
 
         if self.nplanes > 1 and colororder is None:
-            colororder = 'RGB'
-            warnings.warn('defaulting color to RGB')
-            
+            colororder = "RGB"
+            warnings.warn("defaulting color to RGB")
+
         if colororder is not None:
             self.colororder = colororder
 
         self.name = name
 
     __array_ufunc__ = None  # allow Image matrices operators with NumPy values
 
@@ -250,26 +262,26 @@
             s += ", " + self.colororder_str
         if self.id is not None:
             s += f", id={self.id}"
         if self.name is not None:
             name = self.name
             # if it's a long name, take from rightmost / and add ellipsis
             if len(name) > 20:
-                k = [i for i, c in enumerate(name) if c == '/']
+                k = [i for i, c in enumerate(name) if c == "/"]
                 if len(k) >= 2:
-                    name = name[k[-2]:]
+                    name = name[k[-2] :]
                 else:
                     name = name[-20:]
                 name = "..." + name
             s += f" [{name}]"
         if self.domain is not None:
             s += f", u::{self.domain[0][0]:.3g}:{self.domain[0][-1]:.3g}, v::{self.domain[1][0]:.3g}:{self.domain[1][-1]:.3g}"
         return s
 
-    def print(self, fmt=None, seperator=' ', precision=2):
+    def print(self, fmt=None, seperator=" ", precision=2):
         """
         Print image pixels in compact format
 
         :param fmt: format string, defaults to None
         :type fmt: str, optional
         :param separator: value separator, defaults to single space
         :type separator: str, optional
@@ -283,50 +295,44 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Squares(1, 10)
             >>> img.print()
             >>> img = Image.Squares(1, 10, dtype='float')
             >>> img.print()
-        
+
         :note:
             - For a boolean image True and False are displayed as 1 and 0
               respectively.
             - For a multiplane images the planes are printed sequentially.
 
         :seealso: :meth:`showpixels`
         """
         if fmt is None:
             if self.isint:
-                width = max(
-                    len(str(self.max())),
-                    len(str(self.min()))
-                )
+                width = max(len(str(self.max())), len(str(self.min())))
                 fmt = f"{seperator}{{:{width}d}}"
             elif self.isbool:
                 width = 1
                 fmt = f"{seperator}{{:{width}d}}"
             elif self.isfloat:
                 ff = f"{{:.{precision}f}}"
-                width = max(
-                    len(ff.format(self.max())),
-                    len(ff.format(self.min()))
-                    )
-                fmt = f"{seperator}{{:{width}.{precision}f}}"                
-        
+                width = max(len(ff.format(self.max())), len(ff.format(self.min())))
+                fmt = f"{seperator}{{:{width}.{precision}f}}"
+
         if self.iscolor:
-            plane_names = self.colororder_str.split(':')
+            plane_names = self.colororder_str.split(":")
             for plane in range(self.nplanes):
                 print(f"plane {plane_names[plane]}:")
                 self.plane(plane).print()
         else:
             for v in self.vspan():
                 row = ""
                 for u in self.uspan():
-                    row += fmt.format(self.image[v,u])
+                    row += fmt.format(self.image[v, u])
                 print(row)
 
     def __repr__(self):
         """
         Single line summary of image parameters
 
         :return: single line summary of image
@@ -385,25 +391,25 @@
 
         For the first two cases the color plane indices are implicit in the
         order in the string.
 
         :note: Changing the color order does not change the order of the planes
             in the image array, it simply changes their label.
 
-        :seealso: :meth:`colororder_str` :meth:`colordict` :meth:`plane` :meth:`red` :meth:`green` :meth:`blue` 
+        :seealso: :meth:`colororder_str` :meth:`colordict` :meth:`plane` :meth:`red` :meth:`green` :meth:`blue`
         """
         return self._colororder
 
     @colororder.setter
     def colororder(self, colororder):
 
         cdict = Image.colordict(colororder)
 
         if len(cdict) != self.nplanes:
-            raise ValueError('colororder length does not match number of planes')
+            raise ValueError("colororder length does not match number of planes")
         self._colororder = cdict
 
     @staticmethod
     def colordict(colororder):
         """
         Parse a color order specification
 
@@ -427,24 +433,24 @@
             >>> Image.colordict('RGB')
             >>> Image.colordict('red:green:blue')
             >>> Image.colordict({'L*': 0, 'U*': 1, 'V*': 2})
         """
         if isinstance(colororder, dict):
             cdict = colororder
         elif isinstance(colororder, str):
-            if ':' in colororder:
-                colororder = colororder.split(':')
+            if ":" in colororder:
+                colororder = colororder.split(":")
             else:
                 colororder = list(colororder)
-                
+
             cdict = {}
             for i, color in enumerate(colororder):
                 cdict[color] = i
         else:
-            raise ValueError('color order must be a dict or string')
+            raise ValueError("color order must be a dict or string")
         return cdict
 
     @property
     def colororder_str(self):
         """
         Image color order as a string
 
@@ -454,20 +460,20 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img.colororder_str
-        
+
         :seealso: :meth:`colororder`
         """
         if self.colororder is not None:
             s = sorted(self.colororder.items(), key=lambda x: x[1])
-            return ':'.join([x[0] for x in s])
+            return ":".join([x[0] for x in s])
         else:
             return ""
 
     @property
     def name(self):
         """
         Set/get image name
@@ -484,15 +490,15 @@
             >>> img = Image.Read('flowers1.png')
             >>> img.name[-70:]
             >>> img.name = 'my image'
             >>> img.name
 
         :note: Images loaded from a file have their name initially set to
             the full file pathname.
-        
+
         :seealso: :meth:`Read`
         """
         return self._name
 
     @name.setter
     def name(self, name):
         self._name = name
@@ -557,15 +563,15 @@
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png') > 200
             >>> img.isint
             >>> img.isbool
 
         :seealso: :meth:`isint` :meth:`isfloat`
         """
-        return np.issubdtype(self.dtype, np.bool_)
+        return np.issubdtype(self.dtype, bool)
 
     @property
     def dtype(self):
         """
         Datatype of image
 
         :return: NumPy datatype of image
@@ -598,15 +604,15 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img.width
-        
+
         :seealso: :meth:`height` :meth:`size` :meth:`umax`
         """
         return self.A.shape[1]
 
     @property
     def height(self):
         """
@@ -638,14 +644,15 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img.umax
+            >>> img.width
 
         :seealso: :meth:`width`
         """
         return self.A.shape[1] - 1
 
     @property
     def vmax(self):
@@ -658,20 +665,20 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img.vmax
+            >>> img.height
 
         :seealso: :meth:`height`
         """
         return self.A.shape[0] - 1
 
-
     def uspan(self, step=1):
         """
         Linear span of image horizontally
 
         :param step: step size, defaults to 1
         :type step: int, optional
         :return: 1D array of values [0 ... width-1]
@@ -688,15 +695,15 @@
             >>>     img.uspan()
 
         :note: If the image has a ``domain`` specified the horizontal
             component of this is returned instead.
 
         .. warning:: Computed using :meth:`numpy.arange` and for ``step>1`` the
             maximum coordinate may not be returned.
-            
+
         :seealso: :meth:`umax` :meth:`vspan`
         """
         if self.domain is None:
             return np.arange(0, self.width, step)
         else:
             return self.domain[0]
 
@@ -920,20 +927,19 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img.ndim
             >>> img = Image.Read('street.png')
             >>> img.ndim
-        
+
         :seealso: :meth:`nplanes` :meth:`shape`
         """
         return self.A.ndim
 
-
     def contains(self, p):
         """
         Test if coordinate lies within image
 
         :param p: pixel coordinate
         :type p: array_like(2), ndarray(2,N)
         :return: whether pixel coordinate lies within image bounds
@@ -952,17 +958,16 @@
         """
         if isinstance(p, np.ndarray) and p.ndim == 2 and p.shape[0] == 2:
             u = p[0, :]
             v = p[1, :]
         else:
             u = p[0]
             v = p[1]
-        
-        return np.logical_and.reduce((u >= 0, v >= 0, u < self.width, v < self.height))
 
+        return np.logical_and.reduce((u >= 0, v >= 0, u < self.width, v < self.height))
 
     # ---- color related ---- #
     @property
     def iscolor(self):
         """
         Image has color pixels?
 
@@ -1002,15 +1007,15 @@
             >>> img = Image.Read('flowers1.png')
             >>> img.isbgr
 
         :note: Is False if image is not color.
 
         :seealso: :meth:`colororder`
         """
-        return self.colororder_str == 'B:G:R'
+        return self.colororder_str == "B:G:R"
 
     @property
     def isrgb(self):
         """
         Image has RGB color order?
 
         :return: Image has RGB color order
@@ -1024,15 +1029,15 @@
             >>> img = Image.Read('flowers1.png')
             >>> img.isrgb
 
         :note: Is False if image is not color.
 
         :seealso: :meth:`colororder`
         """
-        return self.colororder_str == 'R:G:B'
+        return self.colororder_str == "R:G:B"
 
     def to(self, dtype):
         """
         Convert image datatype
 
         :param dtype: Numpy data type
         :type dtype: str
@@ -1090,27 +1095,28 @@
             >>> img = Image.Random(3, dtype='float')
             >>> img.image
             >>> img.astype('uint8').image
 
         :seealso: :meth:`to`
         """
         return self.__class__(self.A.astype(dtype), dtype=dtype)
+
     # ---- NumPy array access ---- #
 
     @property
     def image(self):
         """
         Image as NumPy array
 
         :return: image as a NumPy array
         :rtype: ndarray(H,W) or ndarray(H,W,3)
 
         Return a reference to the encapsulated NumPy array that holds the pixel
         values.
-        
+
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img
@@ -1172,15 +1178,15 @@
         :rtype: ndarray(H,W,3)
 
         The image is guaranteed to be in RGB order irrespective of current color order.
 
         :seealso: :meth:`image` :meth:`bgr` :meth:`colororder`
         """
         if not self.iscolor:
-            raise ValueError('greyscale image has no rgb property')
+            raise ValueError("greyscale image has no rgb property")
         if self.isrgb:
             return self.A
         elif self.isbgr:
             return self.A[:, :, ::-1]
 
     @property
     def bgr(self):
@@ -1192,32 +1198,32 @@
         :rtype: ndarray(H,W,3)
 
         The image is guaranteed to be in BGR (OpenCV standard) order irrespective of current color order.
 
         :seealso: :meth:`image` :meth:`rgb` :meth:`colororder`
         """
         if not self.iscolor:
-            raise ValueError('greyscale image has no bgr property')
+            raise ValueError("greyscale image has no bgr property")
         if self.isbgr:
             return self.A
         elif self.isrgb:
             return self.A[:, :, ::-1]
 
     # ------------------------- datatype operations ----------------------- #
 
-    def to_int(self, intclass='uint8'):
+    def to_int(self, intclass="uint8"):
         """
         Image as integer NumPy array
 
         :param intclass: name of NumPy supported integer class, default is 'uint8'
         :type intclass: str, optional
         :return: NumPy array with integer values
         :rtype: ndarray(H,W) or ndarray(H,W,P)
 
-        Return a NumPy array with pixels converted to the integer class 
+        Return a NumPy array with pixels converted to the integer class
         ``intclass``.  For the case where the input image is:
 
         * a floating point class, the pixel values are scaled from an
           input range of [0,1] to a range spanning zero to the maximum positive
           value of the output integer class.
         * an integer class, then the pixels are scaled and cast to ``intclass``.
           The scale factor is the ratio of the maximum value of the input and
@@ -1240,31 +1246,31 @@
             >>> img = Image([[False, True], [True, False]])
             >>> img
             >>> img.to_int('uint8')
             >>> img.to_int('uint16')
 
         :note: Works for greyscale or color (arbitrary number of planes) image
 
-        :seealso: :func:`to_float` :meth:`cast` :meth:`like` 
+        :seealso: :func:`to_float` :meth:`cast` :meth:`like`
         """
         return int_image(self.image, intclass)
 
-    def to_float(self, floatclass='float32'):
+    def to_float(self, floatclass="float32"):
         """
         Image as float NumPy array
 
         :param floatclass: 'single', 'double', 'float32' [default], 'float64'
         :type floatclass: str
         :return: Image with floating point pixel types
         :rtype: :class:`Image`
 
         Return a NumPy array with pixels converted to the floating point class ``floatclass``
         and the values span the range 0 to 1. For the case where the input image
         is:
-        
+
         * an integer class, the pixel values are scaled from an input range
           spanning zero to the maximum positive value of the integer
           class to [0.0, 1.0]
         * a floating class, the pixels are cast to change type but not their
           value.
         * boolean class, False is mapped to 0.0 and True is mapped to 1.0.
 
@@ -1276,33 +1282,32 @@
             >>> img = Image([[50, 100], [150, 200]])
             >>> img
             >>> img.to_float()
             >>> img = Image([[0.0, 0.3], [0.5, 1.0]])
             >>> img
             >>> img.to_float('float64')
             >>> img = Image([[False, True], [True, False]])
-            >>> img.to_float()    
+            >>> img.to_float()
 
         :note: Works for greyscale or color (arbitrary number of planes) image
 
         :seealso: :meth:`to_int` :meth:`cast` :meth:`like`
         """
         return float_image(self.image, floatclass)
 
-
     def cast(self, value):
         """
         Cast value to same type as image
 
         :param value: value to cast
         :type value: scalar, ndarray
         :return: value cast to same type as image
         :rtype: numpy type, ndarray
 
-        The value, scalar or integer, is **cast** to the same type as the image.  
+        The value, scalar or integer, is **cast** to the same type as the image.
         The result has the same numeric value, but the type is changed.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -1353,39 +1358,46 @@
             >>> img.like(0.5)
 
         :seealso: :meth:`cast` :meth:`to_int` :meth:`to_float`
 
         """
         if self.isint:
             # matching to an integer image
-            if isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.integer) or isinstance(value, (int, np.integer)):
+            if (
+                isinstance(value, np.ndarray)
+                and np.issubdtype(value.dtype, np.integer)
+                or isinstance(value, (int, np.integer))
+            ):
                 # already an integer, cast it to right sort
                 return self.cast(value)
             else:
                 # it's a float, rescale it then cast
                 return self.cast(value * self.maxval)
         else:
             # matching to a float image
-            if isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating) or isinstance(value, (float, np.floating)):
+            if (
+                isinstance(value, np.ndarray)
+                and np.issubdtype(value.dtype, np.floating)
+                or isinstance(value, (float, np.floating))
+            ):
                 # already a float of some sort, cast it to the right sort
                 return self.cast(value)
             else:
                 # it's an int.  We use hints to determine the size, otherwise
                 # get it from the type
                 if maxint is None:
                     maxint = np.iinfo(value.dtype).max
                 elif isinstance(maxint, int):
                     pass
                 elif isinstance(maxint, str) or isinstance(maxint, np.dtype):
                     maxint = np.iinfo(maxint).max
                 else:
-                    raise ValueError('bad max value specified')
+                    raise ValueError("bad max value specified")
                 return self.cast(value / maxint)
 
-
     @property
     def minval(self):
         """
         Minimum value of image datatype
 
         :return: Minimum value
         :rtype: int or float
@@ -1397,15 +1409,15 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Zeros(20, dtype='float32')
             >>> img.minval
             >>> img = Image.Zeros(20, dtype='uint8')
             >>> img.minval
-        
+
         :seealso: :meth:`maxval`
         """
         if self.isint:
             return np.iinfo(self.dtype).min
         else:
             return np.finfo(self.dtype).min
 
@@ -1424,15 +1436,15 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Zeros(20, dtype='float32')
             >>> img.maxval
             >>> img = Image.Zeros(20, dtype='uint8')
             >>> img.maxval
-        
+
         :seealso: :meth:`minval`
         """
         if self.isint:
             return np.iinfo(self.dtype).max
         else:
             return np.finfo(self.dtype).max
 
@@ -1452,22 +1464,22 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Zeros(20, dtype='float32')
             >>> img.true
             >>> img = Image.Zeros(20, dtype='uint8')
             >>> img.true
-        
+
         :seealso: :meth:`false` :meth:`maxval`
         """
         if self.isint:
             return self.maxval
         else:
             return 1.0
-    
+
     @property
     def false(self):
         """
         False value for logical image
 
         :return: Value used as true
         :rtype: int or float
@@ -1480,18 +1492,19 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Zeros(20, dtype='float32')
             >>> img.false
             >>> img = Image.Zeros(20, dtype='uint8')
             >>> img.false
-        
+
         :seealso: :meth:`true`
         """
         return 0
+
     # ------------------------- color plane access -------------------------- #
 
     @property
     def nplanes(self):
         """
         Number of color planes
 
@@ -1548,58 +1561,58 @@
             >>> green_blue = img.plane('G:B') # green and blue planes
             >>> green_blue
             >>> green_blue.iscolor
             >>> green_blue.nplanes
             >>> red_blue = img.plane([0, 2]) # blue and red planes
             >>> red_blue
 
-        :note: 
+        :note:
             - This can also be performed using the overloaded ``__getitem__``
               operator.
             - To select more than one plane, use either a sequence of integers or a string
               of colon separated plane names.
 
         :seealso: :meth:`red` :meth:`green` :meth:`blue` :meth:``__getitem__``
         """
         if not self.iscolor:
-            raise ValueError('cannot extract color plane from greyscale image')
+            raise ValueError("cannot extract color plane from greyscale image")
 
         if isinstance(planes, int):
             if planes < 0 or planes >= self.nplanes:
-                raise ValueError('plane index out of range')
+                raise ValueError("plane index out of range")
             iplanes = planes
             colororder = None
             planes = [planes]
         elif isinstance(planes, str):
             iplanes = []
             colororder = {}
-            if ':' in planes:
+            if ":" in planes:
                 planes = planes.split(":")
-                planes = [p for p in planes if p != '']
+                planes = [p for p in planes if p != ""]
             for plane in planes:
                 try:
                     i = self.colororder[plane]
                     iplanes.append(i)
                     colororder[plane] = len(colororder)  # copy to new dict
                 except KeyError:
-                    raise ValueError('bad plane name specified')
+                    raise ValueError("bad plane name specified")
         elif isinstance(planes, (tuple, list)):
             colororder = {}
             for plane in planes:
                 if not isinstance(plane, int) or plane < 0 or plane >= self.nplanes:
-                    raise ValueError('plane index invalid or out of range')
+                    raise ValueError("plane index invalid or out of range")
                 colorname = [k for k, v in self.colororder.items() if v == plane][0]
                 colororder[colorname] = plane
             iplanes = planes
         else:
-            raise ValueError('bad plane specified')
+            raise ValueError("bad plane specified")
 
         if isinstance(iplanes, list) and len(iplanes) == 1:
-                iplanes = iplanes[0]
-                colororder = None
+            iplanes = iplanes[0]
+            colororder = None
         return self.__class__(self.A[:, :, iplanes], colororder=colororder)
 
     def __getitem__(self, key):
         """
         Extract slice of image
 
         :param key: slice to extract
@@ -1629,30 +1642,30 @@
             >>> roi
             >>> roi = img[100:200, 300:400, 1:]
             >>> roi
 
         :seealso: :meth:`red` :meth:`green` :meth:`blue` :meth:`plane` :meth:`roi`
         """
         if isinstance(key, int):
-            return self.__class__(self.image[...,key])
+            return self.__class__(self.image[..., key])
         elif isinstance(key, str):
             return self.plane(key)
         elif isinstance(key, (list, tuple)):
             if self.iscolor and len(key) == 2:
                 key = (key[0], key[1], slice(None))
             out = self.image[key]
             colororder = None
             if out.ndim == 3:
                 colororder = self.colororder_str.split(":")
                 colororder = colororder[key[2]]
                 colororder = ":".join(colororder)
             return self.__class__(out, colororder=colororder)
 
         else:
-            raise ValueError('invalid slice')
+            raise ValueError("invalid slice")
 
     def red(self):
         """
         Extract the red plane of a color image
 
         :raises ValueError: if image is not color
         :return out: greyscale image representing the red image plane
@@ -1661,20 +1674,27 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("flowers4.png")
             >>> red = img.red() # red plane
+            >>> red.disp()
             >>> red
             >>> red.iscolor
 
-        :seealso: :meth:`plane` :meth:`green` :meth:`blue` 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            Image.Read("flowers4.png").red().disp()
+
+
+        :seealso: :meth:`plane` :meth:`green` :meth:`blue`
         """
-        return self.plane('R')
+        return self.plane("R")
 
     def green(self):
         """
         Extract the green plane of a color image
 
         :raises ValueError: if image is not color
         :return out: greyscale image representing the green image plane
@@ -1683,20 +1703,26 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("flowers4.png")
             >>> green = img.green() # green plane
+            >>> green.disp()
             >>> green
             >>> green.iscolor
 
-        :seealso: :meth:`plane` :meth:`red` :meth:`blue` 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            Image.Read("flowers4.png").green().disp()
+
+        :seealso: :meth:`plane` :meth:`red` :meth:`blue`
         """
-        return self.plane('G')
+        return self.plane("G")
 
     def blue(self):
         """
         Extract the blue plane of a color image
 
         :raises ValueError: if image is not color
         :return out: greyscale image representing the blue image plane
@@ -1705,29 +1731,32 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("flowers4.png")
             >>> blue = img.blue() # blue plane
+            >>> blue.disp()
             >>> blue
             >>> blue.iscolor
 
-        :seealso: :meth:`plane` :meth:`red` :meth:`green` 
-        """
-        return self.plane('B')
+        .. plot::
 
+            from machinevisiontoolbox import Image
+            Image.Read("flowers4.png").blue().disp()
 
+        :seealso: :meth:`plane` :meth:`red` :meth:`green`
+        """
+        return self.plane("B")
 
     # I think these are not used anymore
 
     # def astype(self, type):
     #     return self.__class__(self.A, dtype=type)
 
-
     # ------------------------- operators ------------------------------ #
 
     # arithmetic
     def __mul__(self, other):
         """
         Overloaded ``*`` operator
 
@@ -1779,16 +1808,16 @@
             >>> z = img**3
             >>> z.image
 
         ..warning:: Values will be wrapped not clipped to the range of the
             pixel datatype.
         """
         if not isscalar(other):
-            raise ValueError('exponent must be a scalar')
-        return self._binop(self, other, lambda x, y: x ** y)
+            raise ValueError("exponent must be a scalar")
+        return self._binop(self, other, lambda x, y: x**y)
 
     def __add__(self, other):
         """
         Overloaded ``+`` operator
 
         :return: elementwise addition of images
         :rtype: :class:`Image`
@@ -1917,15 +1946,15 @@
     def __minus__(self):
         """
         Overloaded unary ``-`` operator
 
         :return: elementwise negation of image
         :rtype: :class:`Image`
 
-        
+
         Compute the elementwise negation of an Image.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -2032,15 +2061,15 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image([[1, 2], [3, 4]])
             >>> z = img  << 1
             >>> z.image
         """
         if not isinstance(other, int):
-            raise ValueError('left shift must be by integer amount')
+            raise ValueError("left shift must be by integer amount")
         return self._binop(self, other, lambda x, y: x << y)
 
     def __rshift__(self, other):
         """
         Overloaded ``>>`` operator
 
         :return: elementwise binary-right-shift of images
@@ -2054,15 +2083,15 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image([[1, 2], [3, 4]])
             >>> z = img >> 2
             >>> z.image
         """
         if not isinstance(other, int):
-            raise ValueError('left shift must be by integer amount')
+            raise ValueError("left shift must be by integer amount")
         return self._binop(self, other, lambda x, y: x >> y)
 
     # relational
     def __eq__(self, other):
         """
         Overloaded ``==`` operator
 
@@ -2125,15 +2154,15 @@
         Overloaded ``>`` operator
 
         :return: elementwise comparison of pixels
         :rtype: bool :class:`Image`
 
         Compute the inequality between an Image and another image or a scalar.
         Supports:
-        
+
             * image ``>`` image
             * scalar ``>`` image
             * image ``>`` scalar
 
         Example:
 
         .. runblock:: pycon
@@ -2260,30 +2289,32 @@
 
         return self._unop(self, lambda x: ~x)
 
     @staticmethod
     def _binop(left, right, op, logical=False):
         if isinstance(right, left.__class__):
             # both images
-            if left.nplanes == right.nplanes :
+            if left.nplanes == right.nplanes:
                 return left.__class__(op(left.A, right.A), colororder=left.colororder)
             elif left.nplanes > 1 and right.nplanes == 1:
                 # left image is multiplane, right is singleton
                 out = []
                 for i in range(left.nplanes):
-                    out.append(op(left.A[:,:,i], right.A))
+                    out.append(op(left.A[:, :, i], right.A))
                 return left.__class__(np.stack(out, axis=2), colororder=left.colororder)
             elif left.nplanes == 1 and right.nplanes > 1:
                 # right image is multiplane, left is singleton
                 out = []
                 for i in range(right.nplanes):
-                    out.append(op(left.A, right.A[:,:,i]))
-                return right.__class__(np.stack(out, axis=2), colororder=right.colororder)
+                    out.append(op(left.A, right.A[:, :, i]))
+                return right.__class__(
+                    np.stack(out, axis=2), colororder=right.colororder
+                )
             else:
-                raise ValueError('planes mismatch')
+                raise ValueError("planes mismatch")
         else:
             # right is a scalar or numpy array
             return left.__class__(op(left.A, right), colororder=left.colororder)
 
     @staticmethod
     def _logicalop(left, right, op):
         true = left.cast(left.true)
@@ -2297,15 +2328,14 @@
 
         return left.__class__(out, colororder=left.colororder)
 
     @staticmethod
     def _unop(left, op):
         return left.__class__(op(left.A), colororder=left.colororder)
 
-
     # ---------------------------- functions ---------------------------- #
 
     def abs(self):
         """
         Absolute value of image
 
         :return: elementwise absolute value of image
@@ -2316,15 +2346,15 @@
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image([[-1, 2], [3, -4]], dtype='int8')
             >>> z = img.abs()
-            >>> z.image            
+            >>> z.image
         """
         return self._unop(self, np.abs)
 
     def sqrt(self):
         """
         Square root of image
 
@@ -2349,17 +2379,17 @@
         Sum of all pixels
 
         :param args: additional positional arguments to :func:`numpy.sum`
         :param kwargs: additional keyword arguments to :func:`numpy.sum`
         :return: sum
 
         Computes the sum of pixels in the image:
-        
+
         .. math::
-        
+
             \sum_{uvc} I_{uvc}
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -2372,16 +2402,16 @@
 
         :note:
             - The return value type is the same as the image type.
             - By default the result is a scalar computed over all pixels,
               if the ``axis`` option is given the results is a 1D or 2D NumPy
               array.
 
-        :seealso: :func:`numpy.sum` :meth:`~~machinevisiontoolbox.ImageWholeFeatures.ImageWholeFeaturesMixin.mpq` 
-            :meth:`~machinevisiontoolbox.ImageWholeFeatures.ImageWholeFeaturesMixin.npq` 
+        :seealso: :func:`numpy.sum` :meth:`~~machinevisiontoolbox.ImageWholeFeatures.ImageWholeFeaturesMixin.mpq`
+            :meth:`~machinevisiontoolbox.ImageWholeFeatures.ImageWholeFeaturesMixin.npq`
             :meth:`~machinevisiontoolbox.ImageWholeFeatures.ImageWholeFeaturesMixin.upq`
         """
         return np.sum(self.A, *args, **kwargs)
 
     def min(self, *args, **kwargs):
         """
         Minimum value of all pixels
@@ -2558,18 +2588,21 @@
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img.stats()
         """
+
         def printstats(plane):
-            print(f"range={plane.min()} - {plane.max()}, "
+            print(
+                f"range={plane.min()} - {plane.max()}, "
                 f"mean={plane.mean():.3f}, "
-                f"sdev={plane.std():.3f}")
+                f"sdev={plane.std():.3f}"
+            )
 
         if self.iscolor:
             for k, v in sorted(self.colororder.items(), key=lambda x: x[1]):
                 print(f"{k:s}: ", end="")
                 printstats(self.A[..., v])
         else:
             printstats(self.A)
@@ -2624,15 +2657,15 @@
             >>> img.disp()
             >>> img = Image.Zeros(100, colororder="RGB")
             >>> img.draw_circle((20,30), 15, color=[0, 200, 0], thickness=-1) # filled green circle
             >>> img.disp()
 
         :note: If the image has N planes the color should have N elements.
 
-        :seealso: :func:`~machinevisiontoolbox.base.graphics.draw_circle` 
+        :seealso: :func:`~machinevisiontoolbox.base.graphics.draw_circle`
         """
 
         draw_circle(self.image, centre, radius, **kwargs)
 
     def draw_box(self, **kwargs):
         """
         Draw box into image
@@ -2653,14 +2686,15 @@
 
         :note: If the image has N planes the color should have N elements.
 
         :seealso: :func:`~machinevisiontoolbox.base.graphics.draw_box`
         """
         draw_box(self.image, **kwargs)
 
+
 # --------------------------------------------------------------------------- #
 if __name__ == "__main__":
 
     import pathlib
     import os.path
     from machinevisiontoolbox import Image
 
@@ -2670,22 +2704,21 @@
     flowers = Image.Read("flowers8.png")
 
     flowers.stats()
 
     print(flowers[100:200, 100:200])
     print(flowers[100:200, 100:200, 1:])
 
-
     # Image.Constant(5, value='r').print()
     # img = Image.Squares(1, 20) > 0
     # img.print()
 
     # flowers = Image.Read("flowers8.png")
     # print(flowers)
     # z = flowers.plane("G:B:R")
     # print(z)
 
     # im = Image.Read("street.png")
     # print(im.image[10,20])
     # print(im[10,20])
-    
-    # exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_core.py").read())  # pylint: disable=exec-used
+
+    # exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_core.py").read())  # pylint: disable=exec-used
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageIO.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageIO.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,15 +5,22 @@
 import numpy as np
 import scipy as sp
 from scipy import interpolate
 import cv2 as cv
 from pathlib import Path
 import os.path
 from spatialmath.base import argcheck, getvector
-from machinevisiontoolbox.base import iread, iwrite, colorname, int_image, float_image, idisp
+from machinevisiontoolbox.base import (
+    iread,
+    iwrite,
+    colorname,
+    int_image,
+    float_image,
+    idisp,
+)
 
 import os
 import cv2 as cv
 import zipfile
 import numpy as np
 import fnmatch
 from numpy.core.numeric import _rollaxis_dispatcher
@@ -56,37 +63,39 @@
             >>> Image.Read('flowers1.png', grey=True)
             >>> Image.Read('flowers1.png', dtype='float16')
             >>> Image.Read('flowers1.png', reduce=4)
             >>> Image.Read('flowers1.png', gamma='sRGB') # linear tristimulus values
 
         :note:  If the path is not absolute it is first searched for relative
             to the current directory, and if not found, it is searched for in
-            the ``images`` folder of the ``mvtb_data`` package.
+            the ``images`` folder of the ```mvtb_data`` package <https://github.com/petercorke/machinevision-toolbox-python/tree/master/mvtb-data>`_.
 
         :seealso: :func:`~machinevisiontoolbox.base.imageio.iread` :func:`~machinevisiontoolbox.base.imageio.convert`  `cv2.imread <https://docs.opencv.org/master/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56>`_
         """
         if not isinstance(filename, (str, Path)):
-            raise ValueError('expecting a string or path')
+            raise ValueError("expecting a string or path")
 
         # read the image
         data = iread(filename, rgb=rgb, **kwargs)
 
         # result is a tuple(image, filename) or a list of tuples
 
         colororder = None
         if isinstance(data, tuple):
             # singleton image, make it a list
             image, name = data
             if not alpha and image.ndim == 3 and image.shape[2] == 4:
                 image = image[:, :, :3]
             if image.ndim > 2:
-                colororder = 'RGB' if rgb else 'BGR'
-            return cls(image, name=name, colororder=colororder)  # OpenCV file read order)
+                colororder = "RGB" if rgb else "BGR"
+            return cls(
+                image, name=name, colororder=colororder
+            )  # OpenCV file read order)
         elif isinstance(data, list):
-            raise ValueError('wildcard read not support, use FileCollection')
+            raise ValueError("wildcard read not support, use FileCollection")
 
     def disp(self, title=None, **kwargs):
         """
         Display image
 
         :param title: named of window, defaults to image ``name``
         :type title: bool
@@ -98,32 +107,40 @@
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img.disp()
 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            Image.Read('flowers1.png').disp()
+
         :seealso: :func:`~machinevisiontoolbox.base.imageio.idisp`
         """
         if title is False:
             title = None
         elif title is None and self.name is not None:
             _, title = os.path.split(self.name)
 
         if self.domain is not None:
             # left right top bottom
-            kwargs['extent'] = [self.domain[0][0], self.domain[0][-1], 
-                      self.domain[1][-1], self.domain[1][0]]
+            kwargs["extent"] = [
+                self.domain[0][0],
+                self.domain[0][-1],
+                self.domain[1][-1],
+                self.domain[1][0],
+            ]
+
+        return idisp(
+            self.A, title=title, colororder="RGB" if self.isrgb else "BGR", **kwargs
+        )
 
-        return idisp(self.A,
-                title=title,
-                colororder="RGB" if self.isrgb else "BGR",
-                **kwargs)
-
-    def write(self, filename, dtype='uint8', **kwargs):
+    def write(self, filename, dtype="uint8", **kwargs):
         """
         Write image to file
 
         :param filename: filename to write to
         :type filename: str
         :param dtype: data type to convert to, before writing
         :type dtype: str
@@ -173,36 +190,36 @@
             >>> meta = img.metadata()  # get all metadata as a dict
             >>> len(meta)
             >>> meta
             >>> meta['FocalLength']
             >>> img.metadata('FocalLength')  # get specific metadata item
 
         :note:  Metadata items will be converted, where possible, to int or float values.
-        
+
         """
         try:
             import PIL
             from PIL.ExifTags import TAGS
         except ImportError:
-            print('Pillow is required to read image file metadata\npip install pillow')
+            print("Pillow is required to read image file metadata\npip install pillow")
 
         image = PIL.Image.open(self.name)
         exif = {}
 
-        # iterate over the EXIF tags 
+        # iterate over the EXIF tags
         meta = image._getexif()
         if meta is None:
             return  # no metadata
 
         for tag, value in meta.items():
 
             if tag in TAGS:
                 # map tag number to tag name
                 exif[TAGS[tag]] = value
-        
+
         if key is None:
             return exif
         else:
             val = exif[key]
             if isinstance(val, str):
                 # attempt to turn string into int or float
                 try:
@@ -211,21 +228,26 @@
                     pass
                 try:
                     return float(val)
                 except ValueError:
                     pass
                 return val
             if isinstance(val, int):
-                return  val
+                return val
+            elif isinstance(val, tuple) and len(val) == 2:
+                # old versions of PIL return (numerator, denominator)
+                return val[0] / val[1]
             else:
                 # float values are actually type PIL.TiffImagePlugin.IFDRational
                 val = float(val)
-                return  val
+                return val
 
-    def showpixels(self, textcolors=['yellow', 'blue'], fmt=None, ax=None, windowsize=0, **kwargs):
+    def showpixels(
+        self, textcolors=["yellow", "blue"], fmt=None, ax=None, windowsize=0, **kwargs
+    ):
         """
         Display image with pixel values
 
         :param textcolors: text color, defaults to ['yellow', 'blue']
         :type textcolors: list, optional
         :param fmt: format string for displaying pixel values, defaults to None
         :type fmt: str, optional
@@ -236,32 +258,46 @@
         :return: a moving window
         :rtype: ``Window`` instance
 
         Display a monochrome image with the pixel values overlaid.  This is
         suitable for small images, of order 10x10, used for pedagogical
         purposes.  For example it can be used to animate the operation of
         sliding window operations like convolution or morphology.
-        
+
         The first color in ``textcolors`` is used for pixels below 50% intensity
-        and the second color for those above 50%.  
+        and the second color for those above 50%.
 
         If ``windowsize`` is given then a translucent colored window is
         superimposed and a ``Window`` instance returned.  This allows the window
         position, color and opacity to be changed.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Random(10)
             >>> window = img.showpixels(windowsize=1) # with 3x3 window
             >>> window.move(2,3) # position window at (2,3)
             >>> window.move(4,5, color='blue', alpha=0.7)
-        
+
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            img = Image.Random(10)
+            img.showpixels(windowsize=1)
+
+
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            img = Image.Random(10)
+            window = img.showpixels(windowsize=1)
+            window.move(2,3)
+
         :seealso: :meth:`print`
         """
 
         if ax is None:
             ax = plt.gca()
 
         if self.isint:
@@ -275,31 +311,38 @@
         for v in range(self.height):
             for u in range(self.width):
                 if isinstance(textcolors, (list, tuple)):
                     if image[v, u] < halfway:
                         color = textcolors[0]
                     else:
                         color = textcolors[1]
-                elif textcolors == 'grey':
+                elif textcolors == "grey":
                     if image[v, u] < halfway:
-                        color = image[v, u] + 0.4 * np.r_[1,1,1]
+                        color = image[v, u] + 0.4 * np.r_[1, 1, 1]
                     else:
-                        color = image[v,u] - 0.4 * np.r_[1,1,1]
-
-                ax.text(u, v, fmt.format(image[v, u]), horizontalalignment='center', 
-                    verticalalignment='center', color=color, **kwargs)
+                        color = image[v, u] - 0.4 * np.r_[1, 1, 1]
 
-        ax.imshow(image, cmap='gray')
-        ax.set_xlabel('u (pixels)')
-        ax.set_ylabel('v (pixels)')
+                ax.text(
+                    u,
+                    v,
+                    fmt.format(image[v, u]),
+                    horizontalalignment="center",
+                    verticalalignment="center",
+                    color=color,
+                    **kwargs,
+                )
+
+        ax.imshow(image, cmap="gray")
+        ax.set_xlabel("u (pixels)")
+        ax.set_ylabel("v (pixels)")
 
         plt.draw()
 
         class Window:
-            def __init__(self, h=1, color='red', alpha=0.6, ax=None):
+            def __init__(self, h=1, color="red", alpha=0.6, ax=None):
                 self.h = h
                 self.color = color
                 self.alpha = alpha
 
                 w = 2 * h + 1
                 patch = plt.Rectangle((0, 0), w, w, color=color, alpha=alpha)
                 if ax is None:
@@ -311,30 +354,28 @@
             def move(self, u, v, color=None, alpha=0.5):
                 if color is not None:
                     self.color = color
                     self.patch.set_color(color)
                 if alpha is not None:
                     self.alpha = alpha
                     self.patch.set_alpha(alpha)
-                    
+
                 self.patch.set_x(u - self.h - 0.5)
                 self.patch.set_y(v - self.h - 0.5)
 
         if windowsize > 0:
             return Window(windowsize)
 
     # def ascvtype(self):
     #     if np.issubdtype(self.image.dtype, np.floating):
     #         return self.image.astype(np.float32)
     #     else:
     #         return self.image.astype(np.uint8)
-    
-
 
-    def anaglyph(self, right, colors='rc', disp=0):
+    def anaglyph(self, right, colors="rc", disp=0):
         """
         Convert stereo images to an anaglyph image
 
         :param right: right image
         :type right: Image instance
         :param colors: lens colors (left, right), defaults to 'rc'
         :type colors: str, optional
@@ -374,21 +415,28 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> left = Image.Read("rocks2-l.png", reduce=2)
             >>> right = Image.Read("rocks2-r.png", reduce=2)
             >>> left.anaglyph(right).disp()
 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            left = Image.Read("rocks2-l.png", reduce=2)
+            right = Image.Read("rocks2-r.png", reduce=2)
+            left.anaglyph(right).disp()
+
         :reference:
             - Robotics, Vision & Control for Python, Section 14.4, P. Corke, Springer 2023.
 
         :seealso: :meth:`stdisp` :meth:`Overlay`
         """
         if self.size != right.size:
-            raise ValueError('images must be same size')
+            raise ValueError("images must be same size")
         width, height = self.size
 
         # ensure the images are greyscale
         left = self.mono()
         right = right.mono()
 
         if disp > 0:
@@ -397,68 +445,79 @@
 
         elif disp < 0:
             disp = -disp
             left = left.trim(left=disp)
             right = right.trim(right=disp)
 
         colordict = {
-            'r': (1, 0, 0),
-            'g': (0, 1, 0),
-            'b': (0, 0, 1),
-            'c': (0, 1, 1),
-            'm': (1, 0, 1),
-            'o': (1, 1, 0),
+            "r": (1, 0, 0),
+            "g": (0, 1, 0),
+            "b": (0, 0, 1),
+            "c": (0, 1, 1),
+            "m": (1, 0, 1),
+            "o": (1, 1, 0),
         }
-        return left.colorize(colordict[colors[0]]) \
-             + right.colorize(colordict[colors[1]])
+        return left.colorize(colordict[colors[0]]) + right.colorize(
+            colordict[colors[1]]
+        )
 
     def stdisp(self, right):
         """
         Interactive display of stereo image pair
 
         :param right: right image
         :type right: :class:`Image`
 
         The left and right images are displayed, stacked horizontally.  Clicking
         in the left-hand image sets a crosshair cursor in the right-hand
-        image.  Clicking the corresponding point in the right-hand image 
+        image.  Clicking the corresponding point in the right-hand image
         will display the disparity at the top of the right-hand image.
 
         Example::
 
             >>> from machinevisiontoolbox import Image
             >>> left = Image.Read("rocks2-l.png", reduce=2)
             >>> right = Image.Read("rocks2-r.png", reduce=2)
             >>> left.stdisp(right)
 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            left = Image.Read("rocks2-l.png", reduce=2)
+            right = Image.Read("rocks2-r.png", reduce=2)
+            left.stdisp(right)
+
         :note: The images are assumed to be epipolar aligned.
 
         :reference:
             - Robotics, Vision & Control for Python, Section 14.4, P. Corke, Springer 2023.
 
         :seealso: :meth:`anaglyph`
         """
+
         class Cursor:
             """
             A cross hair cursor.
             """
+
             def __init__(self, ax, ax2):
                 self.ax = ax
                 self.ax2 = ax2
-                self.horizontal_line = ax.axhline(color='k', lw=0.8)
-                self.horizontal_line2 = ax2.axhline(color='k', lw=0.8)
-                self.vertical_line = ax.axvline(color='k', lw=0.8)
-                self.vertical_line2 = ax2.axvline(color='k', lw=0.8)
-                self.vertical_line3 = ax2.axvline(color='k', lw=0.8, ls='--')
+                self.horizontal_line = ax.axhline(color="k", lw=0.8)
+                self.horizontal_line2 = ax2.axhline(color="k", lw=0.8)
+                self.vertical_line = ax.axvline(color="k", lw=0.8)
+                self.vertical_line2 = ax2.axvline(color="k", lw=0.8)
+                self.vertical_line3 = ax2.axvline(color="k", lw=0.8, ls="--")
                 self.leftclicked = False
                 self.x_left = None
 
                 # text location in axes coordinates
-                self.text = self.ax2.text(0.05, 0.95, '', transform=ax2.transAxes,
-                    backgroundcolor='w')
+                self.text = self.ax2.text(
+                    0.05, 0.95, "", transform=ax2.transAxes, backgroundcolor="w"
+                )
 
             def set_cross_hair_visible(self, visible):
                 need_redraw = self.horizontal_line.get_visible() != visible
                 self.horizontal_line.set_visible(visible)
                 self.horizontal_line2.set_visible(visible)
 
                 self.vertical_line.set_visible(visible)
@@ -469,15 +528,15 @@
                 return need_redraw
 
             def on_mouse_move(self, event):
                 if event.inaxes == self.ax2 and self.leftclicked:
                     x, y = event.xdata, event.ydata
                     # update the line positions
                     self.vertical_line3.set_xdata(x)
-                    self.text.set_text('d={:.2f}'.format(self.x_left - x))
+                    self.text.set_text("d={:.2f}".format(self.x_left - x))
                     self.ax2.figure.canvas.draw()
                 # if  event.inaxes:
                 #     need_redraw = self.set_cross_hair_visible(False)
                 #     if need_redraw:
                 #         self.ax.figure.canvas.draw()
                 # else:
                 #     self.set_cross_hair_visible(True)
@@ -508,36 +567,39 @@
 
         fig, (ax1, ax2) = plt.subplots(ncols=2, sharey=True)
 
         self.disp(ax=ax1, grid=True)
         right.disp(ax=ax2, grid=True)
 
         cursor = Cursor(ax1, ax2)
-        fig.canvas.mpl_connect('motion_notify_event', cursor.on_mouse_move)
-        fig.canvas.mpl_connect('button_press_event', cursor.on_click)
+        fig.canvas.mpl_connect("motion_notify_event", cursor.on_mouse_move)
+        fig.canvas.mpl_connect("button_press_event", cursor.on_click)
         plt.show(block=True)
 
 
 # --------------------------------------------------------------------------- #
 if __name__ == "__main__":
 
     import pathlib
     import os.path
 
-    from machinevisiontoolbox import VideoCamera
-    import time
-    camera = VideoCamera(1)
-    time.sleep(10)
-    for i in range(10):
-        image = camera.grab()
-        time.sleep(0.1)
+    # from machinevisiontoolbox import VideoCamera
+    # import time
 
+    # camera = VideoCamera(1)
+    # time.sleep(10)
+    # for i in range(10):
+    #     image = camera.grab()
+    #     time.sleep(0.1)
 
-    camera.release()
-    image.disp()
+    # camera.release()
+    # image.disp()
 
-    from machinevisiontoolbox import *
-    church = Image.Read('shark2.png')
+    # from machinevisiontoolbox import *
+
+    from machinevisiontoolbox import Image
+
+    church = Image.Read("shark2.png")
     print(church.metadata())
     church.disp(block=True)
-    
-    # exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_processing.py").read())  # pylint: disable=exec-used
+
+    # exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_processing.py").read())  # pylint: disable=exec-used
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageLineFeatures.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageLineFeatures.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,68 +3,70 @@
 import matplotlib.pyplot as plt
 from matplotlib.patches import Polygon
 from matplotlib.ticker import ScalarFormatter
 
 import cv2 as cv
 from spatialmath import base
 
+
 class ImageLineFeaturesMixin:
     """
     Line features are common in in many human-built environments.
 
     """
 
     def Hough(self, **kwargs):
         """
         Find Hough line features
 
         :return: Hough lines
         :rtype: :class:`~machinevisiontoolbox.ImageLineFeatures.HoughFeature`
 
-        Compute the Hough transform of the image and return an object that 
+        Compute the Hough transform of the image and return an object that
         represents the lines found within the image.
 
         :seealso: :class:`~machinevisiontoolbox.ImageLineFeatures.HoughFeature`
         """
         return HoughFeature(self, **kwargs)
 
+
 # --------------------- supporting classes -------------------------------- #
 
-class HoughFeature:
 
+class HoughFeature:
     def __init__(self, image, ntheta=180, drho=1):
         r"""
         Hough line features
 
         :param image: greyscale image
         :type image: :class:`Image`
         :param ntheta: number of steps in the :meth:`\theta` direction, defaults to 180
         :type ntheta: int, optional
         :param drho: increment size in the :meth:`\rho` direction, defaults to 1
         :type drho: int, optional
 
         Create a Hough line feature object.  It can be used to detect:
-        
+
         - lines using the classical Hough algorithm :meth:`lines`
         - line segments using the probabilistic Hough algorith  :meth:`lines_p`
 
         The Hough accumulator is a 2D array that counts votes for lines
-        
+
         .. math:: u \cos \theta + v \sin \theta = \rho
 
         with quantized parameters :math:`\theta` and :math:`\rho`.  The parameter
         :math:`\theta` is quantized into ``ntheta`` steps spanning the interval
-        :math:`[-\pi, \pi)`, while :math:`\rho` is quantized into steps of 
+        :math:`[-\pi, \pi)`, while :math:`\rho` is quantized into steps of
         ``drho`` spanning the vertical dimension of the image.
 
-        :note: Lines are not detected until :meth:`lines` or  :meth:`lines_p` 
+        :note: Lines are not detected until :meth:`lines` or  :meth:`lines_p`
             is called.  This instance simply holds parameters.
 
         :reference:
-            - Robotics, Vision & Control for Python, Section 12.2, P. Corke, 
+            - Robotics, Vision & Control for Python, Section 12.2, P. Corke,
               Springer 2023.
 
         :seealso: :meth:`lines` :meth:`lines_p`
         """
 
         self.image = image.to_int()
         self.dtheta = np.pi / ntheta
@@ -76,147 +78,145 @@
         Get Hough lines
 
         :param minvotes: only return lines with at least this many votes
         :type minvotes: int
         :return: Hough lines, one per row as :math:`(\theta, \rho)`
         :rtype: ndarray(n,2)
 
-        Return a set of lines that have at least ``minvotes`` of support.  Each 
+        Return a set of lines that have at least ``minvotes`` of support.  Each
         line is described by :math:`(\theta, \rho)` such that
 
         .. math:: u \cos \theta + v \sin \theta = \rho
 
         :seealso: :meth:`plot_lines` :meth:`lines_p` `opencv.HoughLines <https://docs.opencv.org/3.4/dd/d1a/group__imgproc__feature.html#ga46b4e588934f6c8dfd509cc6e0e4545a>`_
         """
         lines = cv.HoughLines(
-                image=self.image,
-                rho=self.drho,
-                theta=self.dtheta,
-                threshold=minvotes
-                )
+            image=self.image, rho=self.drho, theta=self.dtheta, threshold=minvotes
+        )
         if lines is None:
             return np.zeros((0, 2))
         else:
-            return np.array((lines[:,0,1], lines[:,0,0])).T
+            return np.array((lines[:, 0, 1], lines[:, 0, 0])).T
 
     def lines_p(self, minvotes, minlinelength=30, maxlinegap=10, seed=None):
         r"""
-        Get probabilistic Hough lines 
+        Get probabilistic Hough lines
 
         :param minvotes: only return lines with at least this many votes
         :type minvotes: int
         :param minlinelength: minimum line length. Line segments shorter than that are rejected.
         :type minlinelength: int
         :param maxlinegap: maximum allowed gap between points on the same line to link them.
         :type maxlinegap: int
         :return: Hough lines, one per row as :math:`(u_1, v_1, u_2, v_2)`
         :rtype: ndarray(n,4)
 
-        Return a set of line segments that have at least ``minvotes`` of support.  Each 
+        Return a set of line segments that have at least ``minvotes`` of support.  Each
         line segment is described by its end points :math:`(u_1, v_1)` and
         :math:`(u_2, v_2)`.
 
         :seealso: :meth:`plot_lines` :meth:`lines` `opencv.HoughLinesP <https://docs.opencv.org/3.4/dd/d1a/group__imgproc__feature.html#ga8618180a5948286384e3b7ca02f6feeb>`_
         """
         if seed is not None:
             cv.setRNGSeed(seed)
-            
+
         lines = cv.HoughLinesP(
-                image=self.image,
-                rho=self.drho,
-                theta=self.dtheta,
-                threshold=minvotes,
-                minLineLength=minlinelength,
-                maxLineGap=maxlinegap
-                )
+            image=self.image,
+            rho=self.drho,
+            theta=self.dtheta,
+            threshold=minvotes,
+            minLineLength=minlinelength,
+            maxLineGap=maxlinegap,
+        )
         if lines is None:
             return np.zeros((0, 4))
         else:
-            return lines[:,0,:]
+            return lines[:, 0, :]
 
     def plot_lines(self, lines, *args, **kwargs):
         r"""
         Plot Hough lines
 
         :param lines: Hough or probabilistic Hough lines
         :type lines: ndarray(n,2), ndarray(n,4)
         :param args: positional arguments passed to Matplotlib :obj:`~matplotlib.pyplot.plot`
         :param kwargs: arguments passed to Matplotlib :obj:`~matplotlib.pyplot.plot`
 
         Detected lines are given as rows of ``lines``:
 
-        - for Hough lines, each row is :math:`(\theta, \rho)`, and  lines are 
+        - for Hough lines, each row is :math:`(\theta, \rho)`, and  lines are
           clipped by the bounds of the current plot.
         - for probabilistic Hough lines, each row is :math:`(u_1, v_1, u_2, v_2)`,
           and lines segments are drawn on the current plot.
 
         :seealso: :meth:`lines` :meth:`lines_p`
         """
         if lines.shape[1] == 2:
             # Hough lines
             theta, rho = lines.T
             homlines = np.row_stack((np.cos(theta), np.sin(theta), -rho))
             base.plot_homline(homlines, *args, **kwargs)
         else:
             for line in lines:
-                plt.plot(line[[0,2]], line[[1,3]], *args, **kwargs)
+                plt.plot(line[[0, 2]], line[[1, 3]], *args, **kwargs)
 
     def accumulator(self, skip=1):
         r"""
         Compute the Hough accumulator
 
         :param skip: increment for line strength threshold, defaults to 1
         :type skip: int, optional
 
         It creates two new attributes for the instance:
 
         - ``A`` which is the Hough "accumulator" array, rows represent :math:`\rho`
           and columns represent :math:`\theta`.
         - ``votes`` is a list of the number of lines found versus threshold, it
           can be used to select an optimal threshold.
-        - ``extent`` is :math:`[\theta_{\mbox{min}}, \theta_{\mbox{max}}, 
+        - ``extent`` is :math:`[\theta_{\mbox{min}}, \theta_{\mbox{max}},
           \rho_{\mbox{min}}, \rho_{\mbox{max}}]`.
 
         .. warning:: The OpenCV ``HoughLines`` function does not expose the
             accumulator array. This method "reverse engineers" the accumulator
-            array through a costly process of computing the Hough transform 
+            array through a costly process of computing the Hough transform
             for all possible thresholds (increasing in steps of ``skip``). This
             is helpful for pedagogy but very inefficient in practice.
 
         :seealso: :meth:`plot_accumulator`
         """
 
         self.nz = np.sum(self.image > 0)
         t = 0
         theta = np.empty((0,))
         rho = np.empty((0,))
         votes = []
         while True:
             lines = cv.HoughLines(
-                image=self.image,
-                rho=self.drho,
-                theta=self.dtheta,
-                threshold=t
-                )
+                image=self.image, rho=self.drho, theta=self.dtheta, threshold=t
+            )
 
             if lines is None:
                 # no lines found at this threshold, bail out
                 self.t = t - 1
                 break
 
             # append the found lines and votes
-            theta = np.concatenate((theta, lines[:,0,1].flatten()))
-            rho = np.concatenate((rho, lines[:,0,0].flatten()))
+            theta = np.concatenate((theta, lines[:, 0, 1].flatten()))
+            rho = np.concatenate((rho, lines[:, 0, 0].flatten()))
             votes.append(lines.shape[0])
 
             t += skip  # increment the line strength threshold
 
         # now create the accumulator array
-        theta_bins = np.arange(theta.min() - self.dtheta / 2, theta.max() + self.dtheta / 2, self.dtheta)
-        rho_bins = np.arange(rho.min() - self.drho / 2, rho.max() + self.drho / 2, self.drho)
+        theta_bins = np.arange(
+            theta.min() - self.dtheta / 2, theta.max() + self.dtheta / 2, self.dtheta
+        )
+        rho_bins = np.arange(
+            rho.min() - self.drho / 2, rho.max() + self.drho / 2, self.drho
+        )
 
         self.extent = [theta_bins[0], theta_bins[-1], rho_bins[0], rho_bins[-1]]
         self.A = np.histogram2d(theta, rho, bins=(theta_bins, rho_bins))[0].T
         self.votes = votes
 
     def plot_accumulator(self, **kwargs):
         r"""
@@ -229,23 +229,31 @@
         that :math:`(\theta, \rho)` coordinate.
 
         :seealso: :meth:`accumulator`
         """
         if self.A is None:
             self.accumulator()
 
-        plt.imshow(self.A, aspect='auto', interpolation='nearest', origin='lower', extent=(self.extent), **kwargs)
+        plt.imshow(
+            self.A,
+            aspect="auto",
+            interpolation="nearest",
+            origin="lower",
+            extent=(self.extent),
+            **kwargs,
+        )
 
-        plt.xlabel(r'$\theta$ (radians)')
+        plt.xlabel(r"$\theta$ (radians)")
         plt.xlim(0, np.pi)
-        plt.ylabel(r'$\rho$ (pixels)')
+        plt.ylabel(r"$\rho$ (pixels)")
         plt.grid(True)
 
+
 if __name__ == "__main__":
 
     from machinevisiontoolbox import Image
     from math import pi
 
     square = Image.Squares(number=1, size=256, fg=128).rotate(0.3)
-    edges = square.canny();
+    edges = square.canny()
     h = edges.hough()
     print(h)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageMorph.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageMorph.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,19 +21,21 @@
         :rtype: Image instance (N,H) as uint8
 
         - ``IM.getse(se)`` converts matrix ``se`` into a uint8 numpy array for
           opencv, which only accepts kernels of type CV_8U
         """
         se = np.array(se).astype(np.uint8)
         if se.min() < 0:
-            raise ValueError('cannot convert array with negative values to a structuring element')
+            raise ValueError(
+                "cannot convert array with negative values to a structuring element"
+            )
 
         return se
 
-    def erode(self, se, n=1, border='replicate', bordervalue=0, **kwargs):
+    def erode(self, se, n=1, border="replicate", bordervalue=0, **kwargs):
         """
         Morphological erosion
 
         :param se: structuring element
         :type se: ndarray(N,M)
         :param n: number of times to apply the erosion, defaults to 1
         :type n: int, optional
@@ -54,49 +56,52 @@
 
             >>> from machinevisiontoolbox import Image
             >>> import numpy as np
             >>> img = Image.Squares(1,7)
             >>> img.print()
             >>> img.erode(np.ones((3,3))).print()
 
-        :note: 
+        :note:
             - It is cheaper to apply a smaller structuring element multiple times
               than one large one, the effective structuing element is the
               Minkowski sum of the structuring element with itself N times.
             - The structuring element typically has odd side lengths.
-            - For a greyscale image this is the maximum value over the 
+            - For a greyscale image this is the maximum value over the
               structuring element.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.6, P. Corke, Springer 2023.
 
-        :seealso: :meth:`dilate` 
+        :seealso: :meth:`dilate`
             `opencv.erode <https://docs.opencv.org/3.4/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb>`_
         """
 
         # check if valid input:
         se = self._getse(se)
         # TODO check if se is valid (odd number and less than im.shape)
         # consider cv.getStructuringElement?
         # eg, se = cv.getStructuringElement(cv.MORPH_RECT, (3,3))
 
         if not isinstance(n, int):
             n = int(n)
         if n <= 0:
-            raise ValueError(n, 'n must be greater than 0')
+            raise ValueError(n, "n must be greater than 0")
 
-        out = cv.erode(self.to_int(), se,
-                            iterations=n,
-                            borderType=self._bordertype_cv(border, exclude=('wrap')),
-                            borderValue=bordervalue,
-                            **kwargs)
+        out = cv.erode(
+            self.to_int(),
+            se,
+            iterations=n,
+            borderType=self._bordertype_cv(border, exclude=("wrap")),
+            borderValue=bordervalue,
+            **kwargs,
+        )
 
         return self.__class__(out)
 
-    def dilate(self, se, n=1, border='replicate', bordervalue=0, **kwargs):
+    def dilate(self, se, n=1, border="replicate", bordervalue=0, **kwargs):
         """
         Morphological dilation
 
         :param se: structuring element
         :type se: ndarray(N,M)
         :param n: number of times to apply the dilation, defaults to 1
         :type n: int, optional
@@ -118,46 +123,49 @@
             >>> from machinevisiontoolbox import Image
             >>> import numpy as np
             >>> pixels = np.zeros((7,7)); pixels[3,3] = 1
             >>> img = Image(pixels)
             >>> img.print()
             >>> img.dilate(np.ones((3,3))).print()
 
-        :note: 
+        :note:
             - It is cheaper to apply a smaller structuring element multiple times
               than one large one, the effective structuing element is the
               Minkowski sum of the structuring element with itself N times.
             - The structuring element typically has odd side lengths.
-            - For a greyscale image this is the minimum value over the 
+            - For a greyscale image this is the minimum value over the
               structuring element.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.6, P. Corke, Springer 2023.
 
         :seealso: :meth:`erode` `opencv.dilate <https://docs.opencv.org/3.4/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c>`_
         """
 
         # check if valid input:
         se = self._getse(se)
 
         if not isinstance(n, int):
             n = int(n)
         if n <= 0:
-            raise ValueError(n, 'n must be greater than 0')
+            raise ValueError(n, "n must be greater than 0")
 
         # for im in [img.image in self]: # then can use cv.dilate(im)
-        out = cv.dilate(self.to_int(), se,
-                    iterations=n,
-                    borderType=self._bordertype_cv(border, exclude=('wrap')),
-                    borderValue=bordervalue,
-                    **kwargs)
+        out = cv.dilate(
+            self.to_int(),
+            se,
+            iterations=n,
+            borderType=self._bordertype_cv(border, exclude=("wrap")),
+            borderValue=bordervalue,
+            **kwargs,
+        )
 
         return self.__class__(out)
 
-    def morph(self, se, op, n=1, border='replicate', bordervalue=0, **kwargs):
+    def morph(self, se, op, n=1, border="replicate", bordervalue=0, **kwargs):
         """
         Morphological neighbourhood processing
 
         :param se: structuring element
         :type se: ndarray(N,M)
         :param op: morphological operation, one of: 'min', 'max', 'diff'
         :type op: str
@@ -200,60 +208,66 @@
         # se = cv.getStructuringElement(cv.MORPH_RECT, (3,3))
         se = self._getse(se)
 
         # TODO check if se is valid (odd number and less than im.shape),
         # can also be a scalar
 
         if not isinstance(op, str):
-            raise TypeError(op, 'oper must be a string')
+            raise TypeError(op, "oper must be a string")
 
         if not isinstance(n, int):
             n = int(n)
         if n <= 0:
-            raise ValueError(n, 'n must be greater than 0')
+            raise ValueError(n, "n must be greater than 0")
 
         if self.isbool:
             image = self.to_int()
         else:
             image = self.A
 
-        if op == 'min':
-            out = cv.morphologyEx(image,
-                                    cv.MORPH_ERODE,
-                                    se,
-                                    iterations=n,
-                                    borderType=self._bordertype_cv(border),
-                                    borderValue=bordervalue,
-                                    **kwargs)
-        elif op == 'max':
-            out = cv.morphologyEx(self.A,
-                                    cv.MORPH_DILATE,
-                                    se,
-                                    iterations=n,
-                                    borderType=self._bordertype_cv(border),
-                                    borderValue=bordervalue,
-                                    **kwargs)
-        elif op == 'diff':
+        if op == "min":
+            out = cv.morphologyEx(
+                image,
+                cv.MORPH_ERODE,
+                se,
+                iterations=n,
+                borderType=self._bordertype_cv(border),
+                borderValue=bordervalue,
+                **kwargs,
+            )
+        elif op == "max":
+            out = cv.morphologyEx(
+                self.A,
+                cv.MORPH_DILATE,
+                se,
+                iterations=n,
+                borderType=self._bordertype_cv(border),
+                borderValue=bordervalue,
+                **kwargs,
+            )
+        elif op == "diff":
             se = self.getse(se)
-            out = cv.morphologyEx(self.A,
-                                    cv.MORPH_GRADIENT,
-                                    se,
-                                    iterations=n,
-                                    borderType=self._bordertype_cv(border),
-                                    borderValue=bordervalue,
-                                    **kwargs)
+            out = cv.morphologyEx(
+                self.A,
+                cv.MORPH_GRADIENT,
+                se,
+                iterations=n,
+                borderType=self._bordertype_cv(border),
+                borderValue=bordervalue,
+                **kwargs,
+            )
         else:
-            raise ValueError('morph does not support oper')
+            raise ValueError("morph does not support oper")
 
         if self.isbool:
             out = out.astype(bool)
-            
+
         return self.__class__(out)
 
-    def open(self, se, n=1, border='replicate', bordervalue=0, **kwargs):
+    def open(self, se, n=1, border="replicate", bordervalue=0, **kwargs):
         """
         Morphological opening
 
         :param se: structuring element
         :type se: ndarray(N,M)
         :param n: number of times to apply the erosion then dilation, defauts to 1
         :type n: int, optional
@@ -292,25 +306,26 @@
         :seealso: :meth:`close :meth:`morph` `opencv.morphologyEx <https://docs.opencv.org/3.4/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f>`_
         """
 
         # probably cleanest approach:
         # out = [self.erode(se, **kwargs).dilate(se, **kwargs) for im in self]
         # return self.__class__(out)
 
-        out = cv.morphologyEx(self.to_int(),
-                                cv.MORPH_OPEN,
-                                se,
-                                iterations=n,
-                                borderType=self._bordertype_cv(border),
-                                borderValue=bordervalue,
-                                **kwargs)
+        out = cv.morphologyEx(
+            self.to_int(),
+            cv.MORPH_OPEN,
+            se,
+            iterations=n,
+            borderType=self._bordertype_cv(border),
+            borderValue=bordervalue,
+            **kwargs,
+        )
         return self.__class__(out)
 
-
-    def close(self, se, n=1, border='replicate', bordervalue=0, **kwargs):
+    def close(self, se, n=1, border="replicate", bordervalue=0, **kwargs):
         """
         Morphological closing
 
         :param se: structuring element
         :type se: ndarray(N,M)
         :param n: number of times to apply the dilation then erosion, defauts to 1
         :type n: int, optional
@@ -344,38 +359,40 @@
             - The structuring element typically has odd side lengths.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.6, P. Corke, Springer 2023.
 
         :seealso: :meth:`open` :meth:`morph` `opencv.morphologyEx <https://docs.opencv.org/3.4/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f>`_
         """
-        out = cv.morphologyEx(self.to_int(),
-                                cv.MORPH_CLOSE,
-                                se,
-                                iterations=n,
-                                borderType=self._bordertype_cv(border),
-                                borderValue=bordervalue,
-                                **kwargs)
+        out = cv.morphologyEx(
+            self.to_int(),
+            cv.MORPH_CLOSE,
+            se,
+            iterations=n,
+            borderType=self._bordertype_cv(border),
+            borderValue=bordervalue,
+            **kwargs,
+        )
         return self.__class__(out)
 
-    def hitormiss(self, s1, s2=None, border='replicate', bordervalue=0, **kwargs):
+    def hitormiss(self, s1, s2=None, border="replicate", bordervalue=0, **kwargs):
         r"""
         Hit or miss transform
 
         :param s1: structuring element 1
         :type s1: ndarray(N,M)
         :param s2: structuring element 2
         :type s2: ndarray(N,M)
         :param kwargs: arguments passed to ``opencv.morphologyEx``
         :return: transformed image
         :rtype: :class:`Image`
 
         Return the hit-or-miss transform of the binary image which is defined by
         two structuring elements structuring elements
-        
+
         .. math:: Y = (X \ominus S_1) \cap (X \ominus S_2)
 
         which is the logical-and of the binary image and its complement, eroded
         by two different structuring elements. This preserves pixels where ones
         in the window are consistent with :math:`S_1` and zeros in the window
         are consistent with :math:`S_2`.
 
@@ -412,15 +429,14 @@
 
         if s2 is not None:
             s1 = s1 - s2
 
         out = cv.morphologyEx(self.A, cv.MORPH_HITMISS, s1)
         return self.__class__(out)
 
-
     def thin(self, **kwargs):
         """
         Morphological skeletonization
 
         :param kwargs: options passed to :meth:`hitormiss`
         :return: Image
         :rtype: :class:`Image` instance
@@ -435,33 +451,29 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.String('000000|011110|011110|000000')
             >>> img.print()
             >>> img.thin().print()
             >>> img = Image.Read("shark2.png")
             >>> skeleton = img.thin()
-    
+
         :references:
             - Robotics, Vision & Control for Python, Section 11.6.3, P. Corke, Springer 2023.
-        
+
         :seealso: :meth:`thin_animate` :meth:`hitormiss` :meth:`endpoint` :meth:`triplepoint`
         """
 
         # create a binary image (True/False)
         # im = im > 0
 
         # create structuring elements
-        sa = np.array([[-1, -1, -1],
-                       [0, 1, 0],
-                       [1, 1, 1]])
-        sb = np.array([[0, -1, -1],
-                       [1, 1, -1],
-                       [0, 1, 0]])
+        sa = np.array([[-1, -1, -1], [0, 1, 0], [1, 1, 1]])
+        sb = np.array([[0, -1, -1], [1, 1, -1], [0, 1, 0]])
 
-        im = self.to('uint8')
+        im = self.to("uint8")
         o = im
         while True:
             for i in range(4):
                 r = im.hitormiss(sa)
                 # might also use the bitwise operator ^
                 im -= r
                 r = im.hitormiss(sb)
@@ -484,15 +496,15 @@
         :return: Image
         :rtype: :class:`Image` instance
 
         Return the thinned version (skeleton) of the binary image as another
         binary image. Any non-zero region is replaced by a network of
         single-pixel wide lines.
 
-        The algorithm is iterative, and the result of of each iteration is 
+        The algorithm is iterative, and the result of of each iteration is
         displayed using Matplotlib.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -505,22 +517,18 @@
         :seealso: :meth:`thin` :meth:`hitormiss` :meth:`endpoint` :meth:`triplepoint`
         """
 
         # create a binary image (True/False)
         # im = im > 0
 
         # create structuring elements
-        sa = np.array([[-1, -1, -1],
-                        [0, 1, 0],
-                        [1, 1, 1]])
-        sb = np.array([[0, -1, -1],
-                        [1, 1, -1],
-                        [0, 1, 0]])
+        sa = np.array([[-1, -1, -1], [0, 1, 0], [1, 1, 1]])
+        sb = np.array([[0, -1, -1], [1, 1, -1], [0, 1, 0]])
 
-        im = self.to('uint8')
+        im = self.to("uint8")
         o = im
         h = im.disp()
         while True:
             for i in range(4):
                 r = im.hitormiss(sa)
                 # might also use the bitwise operator ^
                 im -= r
@@ -544,15 +552,15 @@
         :param kwargs: options passed to :meth:`hitormiss`
         :return: Image
         :rtype: :class:`Image` instance
 
         Return a binary image where pixels are True if the corresponding pixel
         in the binary image is the end point of a single-pixel wide line such as
         found in an image skeleton.
-        
+
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.String('000000|011110|000000')
             >>> img.print()
@@ -563,15 +571,15 @@
         :references:
             - Robotics, Vision & Control for Python, Section 11.6.3, P. Corke, Springer 2023.
 
         :seealso: :meth:`hitormiss` :meth:`thin` :meth:`triplepoint`
         """
 
         se = np.zeros((3, 3, 8))
-        se[:, :, 0] = np.array([[-1,  1, -1], [-1, 1, -1], [-1, -1, -1]])
+        se[:, :, 0] = np.array([[-1, 1, -1], [-1, 1, -1], [-1, -1, -1]])
         se[:, :, 1] = np.array([[-1, -1, 1], [-1, 1, -1], [-1, -1, -1]])
         se[:, :, 2] = np.array([[-1, -1, -1], [-1, 1, 1], [-1, -1, -1]])
         se[:, :, 3] = np.array([[-1, -1, -1], [-1, 1, -1], [-1, -1, 1]])
         se[:, :, 4] = np.array([[-1, -1, -1], [-1, 1, -1], [-1, 1, -1]])
         se[:, :, 5] = np.array([[-1, -1, -1], [-1, 1, -1], [1, -1, -1]])
         se[:, :, 6] = np.array([[-1, -1, -1], [1, 1, -1], [-1, -1, -1]])
         se[:, :, 7] = np.array([[1, -1, -1], [-1, 1, -1], [-1, -1, -1]])
@@ -607,15 +615,15 @@
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.6.3, P. Corke, Springer 2023.
 
         :seealso: :meth:`hitormiss` :meth:`thin` :meth:`endpoint`
         """
 
-        se = np.zeros((3, 3, 16), dtype='int8')
+        se = np.zeros((3, 3, 16), dtype="int8")
         se[:, :, 0] = np.array([[-1, 1, -1], [1, 1, 1], [-1, -1, -1]])
         se[:, :, 1] = np.array([[1, -1, 1], [-1, 1, -1], [-1, -1, 1]])
         se[:, :, 2] = np.array([[-1, 1, -1], [-1, 1, 1], [-1, 1, -1]])
         se[:, :, 3] = np.array([[-1, -1, 1], [-1, 1, -1], [1, -1, 1]])
         se[:, :, 4] = np.array([[-1, -1, -1], [1, 1, 1], [-1, 1, -1]])
         se[:, :, 5] = np.array([[1, -1, -1], [-1, 1, -1], [1, -1, 1]])
         se[:, :, 6] = np.array([[-1, 1, -1], [1, 1, -1], [-1, 1, -1]])
@@ -632,15 +640,14 @@
         out = np.zeros(self.shape, self.dtype)
         for i in range(se.shape[2]):
             out = np.bitwise_or(out, self.hitormiss(se[:, :, i]).A)
 
         return self.__class__(out)
 
 
-
 # --------------------------------------------------------------------------#
-if __name__ == '__main__':
+if __name__ == "__main__":
 
     img = Image.Read("shark2.png")
     img.thin_animate()
     # test run ImageProcessingColor.py
-    print('ImageProcessingMorph.py')
+    print("ImageProcessingMorph.py")
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageMultiview.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageMultiview.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 #!/usr/bin/env python
 import numpy as np
 from spatialmath.base import argcheck, getvector, e2h, h2e, transl2
 import cv2 as cv
 
+
 class ImageMultiviewMixin:
     # ======================= stereo ================================== #
 
     def stereo_simple(self, right, hw, drange):
         """
         Simple stereo matching
 
@@ -56,16 +57,20 @@
             stack = []
             w = 2 * hw + 1
             w1 = w - 1
 
             for upad in range(w):
                 for vpad in range(w):
                     stack.append(
-                        np.pad(image, ((vpad, w1 - vpad), (upad, w1- upad)),
-                        mode='constant', constant_values=np.nan)
+                        np.pad(
+                            image,
+                            ((vpad, w1 - vpad), (upad, w1 - upad)),
+                            mode="constant",
+                            constant_values=np.nan,
+                        )
                     )
             return np.dstack(stack)
 
         if isinstance(drange, int):
             drange = (0, drange)
 
         # left = self.mono().image.astype(np.float32)
@@ -81,65 +86,71 @@
         left = left - left.mean(axis=2)[..., np.newaxis]
         right = right - right.mean(axis=2)[..., np.newaxis]
 
         # idisp(np.sum(left ** 2, axis=2))
         # idisp(np.sum(right ** 2, axis=2))
 
         # shift right image to the right
-        right = right[:, :-drange[0], :]
-        right = np.pad(right, ((0, 0), (drange[0], 0), (0, 0)),
-            mode='constant', constant_values=np.nan)
+        right = right[:, : -drange[0], :]
+        right = np.pad(
+            right,
+            ((0, 0), (drange[0], 0), (0, 0)),
+            mode="constant",
+            constant_values=np.nan,
+        )
 
         similarities = []
 
         # suppress divide by zero error messages
         # possible ZNCC values include:
         #  - NaN 0 / 0  invalid value encountered in true_divide
         # - inf  x / 0  divide by zero encountered in true_divide
-        with np.errstate(divide='ignore', invalid='ignore'):
+        with np.errstate(divide="ignore", invalid="ignore"):
 
             for d in np.arange(drange[1] - drange[0]):  # lgtm[py/unused-loop-variable]
 
                 # compute the ZNCC
-                sumLL = np.sum(left ** 2, axis=2)
-                sumRR = np.sum(right ** 2, axis=2)
+                sumLL = np.sum(left**2, axis=2)
+                sumRR = np.sum(right**2, axis=2)
                 sumLR = np.sum(left * right, axis=2)
 
                 denom = np.sqrt(sumLL * sumRR)
                 # if (denom == 0).sum() > 0:
                 #     print('divide by zero in ZNCC')
 
                 similarity = sumLR / denom
 
-                similarity = np.where(denom==0, np.nan, similarity)
+                similarity = np.where(denom == 0, np.nan, similarity)
                 similarities.append(similarity)
 
                 # shift right image 1 pixel to the right
                 right = right[:, :-1, :]
-                right = np.pad(right, ((0, 0), (1, 0), (0, 0)),
-                    mode='constant', constant_values=np.nan)
+                right = np.pad(
+                    right,
+                    ((0, 0), (1, 0), (0, 0)),
+                    mode="constant",
+                    constant_values=np.nan,
+                )
 
         # stack the similarity images at each disparity into the 3D DSI
         dsi = np.dstack(similarities)
-        
+
         # disparity is the index of the maxima in the disparity direction
         disparity = np.argmax(dsi, axis=2).astype(np.float32) + drange[0]
 
         # maxima is the maximum similarity in the disparity direction
         maxima = np.max(dsi, axis=2)
 
-        # whereever maxima is nan set disparity to nan, similarity will be 
+        # whereever maxima is nan set disparity to nan, similarity will be
         # done for border regions
         disparity = np.where(np.isnan(maxima), np.nan, disparity)
 
-        disparity[:, :drange[0]] = np.nan
+        disparity[:, : drange[0]] = np.nan
 
-        return self.__class__(disparity, dtype=np.float32), \
-               self.__class__(maxima), \
-               dsi
+        return self.__class__(disparity, dtype=np.float32), self.__class__(maxima), dsi
 
     @classmethod
     def DSI_refine(cls, DSI, drange=None):
         """
         Refine disparity from disparity space image
 
         :param DSI: disparity space image
@@ -160,34 +171,34 @@
             >>> disparity = Image.DSI_refine(DSI)
 
         :references:
             - Robotics, Vision & Control for Python, Section 14.4.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`stereo_simple`
         """
-        DSI_flat = DSI.reshape((-1,DSI.shape[2]))
+        DSI_flat = DSI.reshape((-1, DSI.shape[2]))
 
         YP = []
         Y = []
         YN = []
-        
+
         if drange is None:
             disparity = np.argmax(DSI, axis=2)
             drange = [disparity.min(), disparity.max()]
         for i, d in enumerate(np.argmax(DSI, axis=2).ravel()):
             if drange[0] < d < drange[1]:
-                YP.append(DSI_flat[i, d-1])
+                YP.append(DSI_flat[i, d - 1])
                 Y.append(DSI_flat[i, d])
-                YN.append(DSI_flat[i, d+1])
+                YN.append(DSI_flat[i, d + 1])
             else:
                 YP.append(np.nan)
                 Y.append(np.nan)
                 YN.append(np.nan)
-        
-        YP= np.array(YP).reshape(DSI.shape[:2])
+
+        YP = np.array(YP).reshape(DSI.shape[:2])
         Y = np.array(Y).reshape(DSI.shape[:2])
         YN = np.array(YN).reshape(DSI.shape[:2])
 
         A = YP + YN - 2 * Y
         B = YN - YP
 
         d_subpix = disparity - B / (2 * A)
@@ -214,15 +225,15 @@
         the disparity image, same size as input images, whose elements give the
         subpixel-interpolated disparity (in pixels) of the corresponding point
         in the left image.
 
         Speckle are small regions of anomalous disparity.  A speckle is defined
         as less than A pixels with disparity variation less than V, and the
         filter parameters are (A, V).  The disparity values within a detected
-        speckle are set to that of its enclosing region. 
+        speckle are set to that of its enclosing region.
 
         Example::
 
             >>> rocks_l = Image.Read("rocks2-l.png", reduce=2)
             >>> rocks_r = Image.Read("rocks2-r.png", reduce=2)
             >>> disparity = rocks_l.stereo_BM(rocks_r, hw=3, drange=[40, 90], speckle=(200, 2))
 
@@ -230,46 +241,42 @@
 
         :references:
             - Robotics, Vision & Control for Python, Section 14.4.2.7, P. Corke, Springer 2023.
 
         :seealso: :meth:`stereo_SGBM` :meth:`stereo_simple` `opencv.StereoBM <https://docs.opencv.org/3.4/d9/dba/classcv_1_1StereoBM.html>`_
         """
         # https://docs.opencv.org/master/d9/dba/classcv_1_1StereoBM.html
-        
+
         if isinstance(drange, int):
             drange = (0, drange)
-        
+
         if hw < 2:
-            raise ValueError('block size too small')
+            raise ValueError("block size too small")
 
         # number of disparities must be multiple of 16
         ndisparities = drange[1] - drange[0]
         ndisparities = int(np.ceil(ndisparities // 16) * 16)
 
         # create the stereo matcher
-        stereo = cv.StereoBM_create(
-            numDisparities=ndisparities,
-            blockSize=2*hw+1)
+        stereo = cv.StereoBM_create(numDisparities=ndisparities, blockSize=2 * hw + 1)
         stereo.setMinDisparity(drange[0])
 
         left = self.mono().image.astype(np.uint8)
         right = right.mono().image.astype(np.uint8)
 
         # set speckle filter
         # it seems to make very little difference
         # it's not clear if range is in the int16 units or not
         if speckle is None:
             speckle = (0, 0)
 
         stereo.setSpeckleWindowSize(speckle[0])
         stereo.setSpeckleRange(int(16 * speckle[1]))
 
-        disparity = stereo.compute(
-            left=left,
-            right=right)
+        disparity = stereo.compute(left=left, right=right)
 
         return self.__class__(disparity / 16.0)
 
     def stereo_SGBM(self, right, hw, drange, speckle=None):
         """
         Stereo semi-global block matching
 
@@ -289,74 +296,68 @@
         It returns the disparity image, same size as input images, whose
         elements give the subpixel-interpolated disparity (in pixels) of the
         corresponding point in the left image.
 
         Speckle are small regions of anomalous disparity.  A speckle is defined
         as less than A pixels with disparity variation less than V, and the
         filter parameters are (A, V).  The disparity values within a detected
-        speckle are set to that of its enclosing region. 
+        speckle are set to that of its enclosing region.
 
         Example::
 
             >>> rocks_l = Image.Read("rocks2-l.png", reduce=2)
             >>> rocks_r = Image.Read("rocks2-r.png", reduce=2)
             >>> disparity = rocks_l.stereo_SGBM(rocks_r, hw=3, drange=[40, 90], speckle=(200, 2))
 
         :note: The images are assumed to be epipolar aligned.
 
         :references:
             - Stereo processing by semiglobal matching and mutual information,
               Heiko Hirschmuller,
-              IEEE Transactions on Pattern Analysis and Machine Intelligence, 
+              IEEE Transactions on Pattern Analysis and Machine Intelligence,
               30(2):328–341, 2008.
             - Robotics, Vision & Control for Python, Section 14.4.2.7, P. Corke, Springer 2023.
 
         :seealso: :meth:`stereo_SGBM` :meth:`stereo_simple` `opencv.StereoSGBM <https://docs.opencv.org/3.4/d2/d85/classcv_1_1StereoSGBM.html>`_
         """
         # https://docs.opencv.org/master/d2/d85/classcv_1_1StereoSGBM.html#details
-        
+
         if isinstance(drange, int):
             drange = (0, drange)
-        
+
         if hw < 2:
-            raise ValueError('block size too small')
+            raise ValueError("block size too small")
 
         # number of disparities must be multiple of 16
         ndisparities = drange[1] - drange[0]
         ndisparities = int(np.ceil(ndisparities // 16) * 16)
 
         # create the stereo matcher
         stereo = cv.StereoSGBM_create(
-            minDisparity=drange[0],
-            numDisparities=ndisparities,
-            blockSize=2*hw+1)
-
+            minDisparity=drange[0], numDisparities=ndisparities, blockSize=2 * hw + 1
+        )
 
         left = self.mono().image.astype(np.uint8)
         right = right.mono().image.astype(np.uint8)
 
         # set speckle filter
         # it seems to make very little difference
         # it's not clear if range is in the int16 units or not
         if speckle is not None:
             stereo.setSpeckleWindowSize(speckle[0])
             stereo.setSpeckleRange(speckle[1])
 
-        disparity = stereo.compute(
-            left=left,
-            right=right)
+        disparity = stereo.compute(left=left, right=right)
 
         return self.__class__(disparity / 16.0)
 
     # def line(self, start, end, color):
     # should be draw_line
     #     return self.__class__(cv.line(self.image, start, end, color))
 
-
-
     def rectify_homographies(self, m, F):
         """
         Create rectification homographies
 
         :param m: corresponding points
         :type m: :class:`~machinevisiontoolbox.ImagePointFeatures.FeatureMatch`
         :param F: fundamental matrix
@@ -382,9 +383,11 @@
             >>> walls_r_rect = walls_r.warp_perspective(H_r)
 
         :references:
             - Robotics, Vision & Control for Python, Section 14.4.3, P. Corke, Springer 2023.
 
         :seealso: :meth:`warp_perspective` :class:`Match` `opencv.stereoRectifyUncalibrated <https://docs.opencv.org/3.4/d9/d0c/group__calib3d.html#gaadc5b14471ddc004939471339294f052>`_
         """
-        retval, H1, H2 = cv.stereoRectifyUncalibrated(m.inliers.p1, m.inliers.p2, F, self.size)
-        return H1, H2
+        retval, H1, H2 = cv.stereoRectifyUncalibrated(
+            m.inliers.p1, m.inliers.p2, F, self.size
+        )
+        return H1, H2
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImagePointFeatures.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImagePointFeatures.py`

 * *Files 8% similar despite different names*

```diff
@@ -11,15 +11,21 @@
 import numpy as np
 import math
 
 import cv2 as cv
 import matplotlib.pyplot as plt
 from ansitable import ANSITable, Column
 import spatialmath.base as smb
-from machinevisiontoolbox.base import findpeaks2d, draw_circle, draw_line, draw_point, color_bgr
+from machinevisiontoolbox.base import (
+    findpeaks2d,
+    draw_circle,
+    draw_line,
+    draw_point,
+    color_bgr,
+)
 
 # from machinevisiontoolbox.classes import Image
 
 # from machinevisiontoolbox.Image import *
 # from machinevisiontoolbox.Image import Image
 
 
@@ -30,46 +36,59 @@
 def scalar_result(func):
     def innerfunc(*args):
         out = func(*args)
         if len(out) == 1:
             return out[0]
         else:
             return np.array(out)
+
     inner = innerfunc
     inner.__doc__ = func.__doc__  # pass through the doc string
     return inner
 
+
 def array_result(func):
     def innerfunc(*args):
         out = func(*args)
         if len(out) == 1:
             return out[0]
         else:
             return np.array(out)
+
     inner = innerfunc
     inner.__doc__ = func.__doc__  # pass through the doc string
     return inner
 
+
 def array_result2(func):
     def innerfunc(*args):
         out = func(*args)
         if len(out) == 1:
             return out[0].flatten()
         else:
             return np.squeeze(np.array(out)).T
+
     inner = innerfunc
     inner.__doc__ = func.__doc__  # pass through the doc string
     return inner
 
+
 class BaseFeature2D:
     """
     A 2D point feature class
     """
 
-    def __init__(self, kp=None, des=None, scale=False, orient=False, image=None,):
+    def __init__(
+        self,
+        kp=None,
+        des=None,
+        scale=False,
+        orient=False,
+        image=None,
+    ):
         """
         Create set of 2D point features
 
         :param kp: list of :obj:`opencv.KeyPoint` objects, one per feature, defaults to None
         :type kp: list of N elements, optional
         :param des: Feature descriptor, each is an M-vector, defaults to None
         :type des: ndarray(N,M), optional
@@ -160,15 +179,15 @@
 
         # index or slice the keypoint list
         if isinstance(i, int):
             new._kp = [self._kp[i]]
         elif isinstance(i, slice):
             new._kp = self._kp[i]
         elif isinstance(i, np.ndarray):
-            if np.issubdtype(i.dtype, np.bool):
+            if np.issubdtype(i.dtype, bool):
                 new._kp = [self._kp[k] for k, true in enumerate(i) if true]
             elif np.issubdtype(i.dtype, np.integer):
                 new._kp = [self._kp[k] for k in i]
         elif isinstance(i, (list, tuple)):
             new._kp = [self._kp[k] for k in i]
 
         # index or slice the descriptor array
@@ -194,20 +213,23 @@
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("eiffel-1.png")
             >>> orb = img.BRISK()
             >>> orb
-            >>> orb[0]  # feature 0      
+            >>> orb[0]  # feature 0
         """
         if len(self) > 1:
             return f"{self.__class__.__name__} features, {len(self)} points"
         else:
-            s = f"{self.__class__.__name__}: ({self.u:.1f}, {self.v:.1f}), strength={self.strength:.2f}"
+            s = (
+                f"{self.__class__.__name__}: ({self.u:.1f}, {self.v:.1f}),"
+                f" strength={self.strength:.2f}"
+            )
             if self._has_scale:
                 s += f", scale={self.scale:.1f}"
             if self._has_orient:
                 s += f", orient={self.orientation:.1f}°"
             s += f", id={self.id}"
             return s
 
@@ -227,70 +249,63 @@
         List matches
 
         Print the features in a simple format, one line per feature.
 
         :seealso: :meth:`table`
         """
         for i, f in enumerate(self):
-            s = f"{self._feature_type} feature {i}: ({f.u:.1f}, {f.v:.1f}), strength={f.strength:.2f}"
+            s = (
+                f"{self._feature_type} feature {i}: ({f.u:.1f}, {f.v:.1f}),"
+                f" strength={f.strength:.2f}"
+            )
             if f._has_scale:
                 s += f", scale={f.scale:.1f}"
             if f._has_orient:
                 s += f", orient={f.orientation:.1f}°"
             s += f", id={f.id}"
             print(s)
-            
+
     def table(self):
         """
         Print features in tabular form
 
         Each row is in the table includes: the index in the feature vector,
         centroid coordinate, feature strength, feature scale and image id.
 
         :seealso: :meth:`str`
         """
-        columns = [
-                Column("#"),
-                Column("centroid"),
-                Column("strength", fmt="{:.3g}")
-        ]
+        columns = [Column("#"), Column("centroid"), Column("strength", fmt="{:.3g}")]
         if self._has_scale:
-            columns.append(
-                    Column("scale", fmt="{:.3g}")
-            )
+            columns.append(Column("scale", fmt="{:.3g}"))
         if self._has_orient:
-            columns.append(
-                    Column("orient", fmt="{:.3g}°")
-            )
+            columns.append(Column("orient", fmt="{:.3g}°"))
         columns.append(Column("id", fmt="{:d}"))
         table = ANSITable(*columns, border="thin")
         for i, f in enumerate(self):
             values = [f.strength]
             if self._has_scale:
                 values.append(f.scale)
             if self._has_orient:
                 values.append(f.orientation)
 
-            table.row(i, f"{f.u:.1f}, {f.v:.1f}",
-                    *values,
-                    f.id)
+            table.row(i, f"{f.u:.1f}, {f.v:.1f}", *values, f.id)
         table.print()
 
     def gridify(self, nbins, nfeat):
         """
         Sort features into grid
 
         :param nfeat: maximum number of features per grid cell
         :type nfeat: int
         :param nbins: number of grid cells horizontally and vertically
         :type nbins: int
         :return: set of gridded features
         :rtype: :class:`BaseFeature2D` instance
 
-        Select features such that no more than ``nfeat`` features fall into each 
+        Select features such that no more than ``nfeat`` features fall into each
         grid cell.  The image is divided into an ``nbins`` x ``nbins`` grid.
 
         .. warning:: Takes the first ``nfeat`` features in each grid cell, not the
             ``nfeat`` strongest.  Sort the features by strength to achieve this.
 
         :seealso: :meth:`sort`
         """
@@ -302,15 +317,15 @@
             nh = nbins
 
         image = self._image
         binwidth = image.width // nw
         binheight = image.height // nh
 
         keep = []
-        bins = np.zeros((nh, nw), dtype='int')
+        bins = np.zeros((nh, nw), dtype="int")
 
         for f in self.features:
             ix = f.p[0] // binwidth
             iy = f.p[1] // binheight
 
             if bins[iy, ix] < nfeat:
                 keep.append(f)
@@ -348,15 +363,19 @@
 
         :seealso: :meth:`__radd__`
         """
         if isinstance(other, list) and len(other) == 0 or other is None:
             return self
 
         if self._feature_type != other._feature_type:
-            raise TypeError('cant add different feature types:', self._feature_type, other._feature_type)
+            raise TypeError(
+                "cant add different feature types:",
+                self._feature_type,
+                other._feature_type,
+            )
         new = self.__class__()
         new._feature_type = self._feature_type
 
         new._kp = self._kp + other._kp
         new._descriptor = np.vstack((self._descriptor, other._descriptor))
 
         return new
@@ -390,15 +409,15 @@
             >>> orb
 
         :seealso: :meth:`__add__`
         """
         if isinstance(other, list) and len(other) == 0:
             return self
         else:
-            raise ValueError('bad')
+            raise ValueError("bad")
 
     @property
     @scalar_result
     def u(self):
         """
         Horizontal coordinate of feature point
 
@@ -589,23 +608,21 @@
             >>> img = Image.Read("eiffel-1.png")
             >>> orb = img.ORB()
             >>> orb[0].p
             >>> orb[:5].p
         """
         return np.vstack([kp.pt for kp in self._kp]).T
 
-
-
-    #         DEFAULT 	
+    #         DEFAULT
     # Output image matrix will be created (Mat::create), i.e. existing memory of output image may be reused. Two source image, matches and single keypoints will be drawn. For each keypoint only the center point will be drawn (without the circle around keypoint with keypoint size and orientation).
-    # DRAW_OVER_OUTIMG 	
+    # DRAW_OVER_OUTIMG
     # Output image matrix will not be created (Mat::create). Matches will be drawn on existing content of output image.
-    # NOT_DRAW_SINGLE_POINTS 	
+    # NOT_DRAW_SINGLE_POINTS
     # Single keypoints will not be drawn.
-    # DRAW_RICH_KEYPOINTS 	
+    # DRAW_RICH_KEYPOINTS
     # For each keypoint the circle around keypoint with keypoint size and orientation will be drawn.
 
     # TODO def draw descriptors? (eg vl_feat, though mvt-mat doesn't have this)
     # TODO descriptor distance
     # TODO descriptor similarity
     # TODO display/print/char function?
 
@@ -637,45 +654,53 @@
             >>> orb2 = Image.Read("eiffel-2.png").ORB()
             >>> dist = orb1.distance(orb2)
             >>> dist.shape
 
         :note:
             - The matrix is symmetric.
             - For the metric "L1" and "L2" the best match is the smallest distance
-            - For the metric "ncc" the best match is the largest distance.  A value over 
+            - For the metric "ncc" the best match is the largest distance.  A value over
               0.8 is often considered to be a good match.
-        
+
         :seealso: :meth:`match`
         """
-        metric_dict = {'L1': 1, 'L2': 2}
+        metric_dict = {"L1": 1, "L2": 2}
 
         n1 = len(self)
         n2 = len(other)
         D = np.empty((n1, n2))
         if n1 == 1:
             des1 = self._descriptor[np.newaxis, :]
         else:
             des1 = self._descriptor
         if n2 == 1:
             des2 = other._descriptor[np.newaxis, :]
         else:
-            des2 =  other._descriptor
+            des2 = other._descriptor
 
         for i in range(n1):
             for j in range(n2):
-                if metric == 'ncc':
+                if metric == "ncc":
                     d = np.dot(des1[i, :], des2[j, :])
                 else:
-                    d = np.linalg.norm(des1[i, :] - des2[j, :],
-                        ord=metric_dict[metric])
+                    d = np.linalg.norm(des1[i, :] - des2[j, :], ord=metric_dict[metric])
                 D[i, j] = d
                 D[j, i] = d
         return D
 
-    def match(self, other, ratio=0.75, crosscheck=False, metric='L2', sort=True, top=None, thresh=None):
+    def match(
+        self,
+        other,
+        ratio=0.75,
+        crosscheck=False,
+        metric="L2",
+        sort=True,
+        top=None,
+        thresh=None,
+    ):
         """
         Match point features
 
         :param other: set of feature points
         :type other: BaseFeature2D
         :param ratio: parameter for Lowe's ratio test, defaults to 0.75
         :type ratio: float, optional
@@ -715,21 +740,21 @@
         # d1 and d2 must have greater than 1 columns
 
         # do matching
         # sorting
         # return
 
         metricdict = {
-            'L1': cv.NORM_L1,
-            'L2': cv.NORM_L2,
-            'hamming': cv.NORM_HAMMING,
-            'hamming2': cv.NORM_HAMMING2,
+            "L1": cv.NORM_L1,
+            "L2": cv.NORM_L2,
+            "hamming": cv.NORM_HAMMING,
+            "hamming2": cv.NORM_HAMMING2,
         }
         if metric not in metricdict:
-            raise ValueError('bad metric name')
+            raise ValueError("bad metric name")
 
         # create BFMatcher (brute force matcher) object
         # bf = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)
         bf = cv.BFMatcher_create(metricdict[metric], crossCheck=crosscheck)
 
         # Match descriptors.
         # matches0 = bf.match(d1, d2)
@@ -740,15 +765,15 @@
             k = 2
 
         matches0 = bf.knnMatch(self.descriptor, other.descriptor, k=k)
 
         # the elements of matches are:
         #  queryIdx: first feature set (self)
         #  trainingIdx: second feature set (other)
-        
+
         if not crosscheck:
             # apply ratio test
             good = []
             for m, n in matches0:
                 if m.distance < ratio * n.distance:
                     good.append(m)
         else:
@@ -767,15 +792,17 @@
 
         # Draw first 10 matches.
         # img3 = cv2.drawMatches(img1,kp1,img2,kp2,matches[:10], flags=2)
 
         # opencv documentation for the descriptor matches
         # https://docs.opencv.org/4.4.0/d4/de0/classcv_1_1DMatch.html
 
-        return FeatureMatch([(m.queryIdx, m.trainIdx, m.distance) for m in good], self, other)
+        return FeatureMatch(
+            [(m.queryIdx, m.trainIdx, m.distance) for m in good], self, other
+        )
 
     def subset(self, N=100):
         """
         Select subset of features
 
         :param N: the number of features to select, defaults to 100
         :type N: int, optional
@@ -791,22 +818,22 @@
 
             >>> from machinevisiontoolbox import Image
             >>> orb = Image.Read("eiffel-1.png").ORB()
             >>> len(orb)
             >>> orb2 = orb.subset(50)
             >>> len(orb2)
         """
-        step = max(1, len(self)  // N)
+        step = max(1, len(self) // N)
         k = list(range(0, len(self), step))
         k = k[:N]
         new = self[k]
         new._feature_type = self._feature_type
         return new
-        
-    def sort(self, by='strength', descending=True, inplace=False):
+
+    def sort(self, by="strength", descending=True, inplace=False):
         """
         Sort features
 
         :param by: sort by ``'strength'`` [default] or ``'scale'``
         :type by: str, optional
         :param descending: sort in descending order, defaults to True
         :type descending: bool, optional
@@ -824,24 +851,24 @@
         """
         # if by == 'strength':
         #     s = sorted(self, key=lambda f: f.strength, reverse=descending)
         # elif by == 'scale':
         #     s = sorted(self, key=lambda f: f.scale, reverse=descending)
         # else:
         #     raise ValueError('bad sort method', by)
-        if by == 'strength':
+        if by == "strength":
             key = self.strength
-        elif by == 'scale':
+        elif by == "scale":
             key = self.scale
         else:
-            raise ValueError('bad sort method', by)
+            raise ValueError("bad sort method", by)
         key = np.array(key)
         if descending:
             key = -key
-        
+
         index = np.argsort(key)
 
         if inplace:
             self._kp = [self._kp[i] for i in index]
             self._descriptor = self._descriptor[index, :]
         else:
             new = self.__class__()
@@ -857,15 +884,15 @@
         :param images: the image from which the feature was extracted
         :type images: :class:`Image` or list of :class:`Image`
         :param N: size of square window, defaults to 50
         :type N: int, optional
         :return: support region
         :rtype: :class:`Image` instance
 
-        The support region about the feature's centroid is extracted, 
+        The support region about the feature's centroid is extracted,
         rotated and scaled.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -878,35 +905,35 @@
             ``id`` attribute is used to index into ``images`` which must be a
             list of Image objects.
         """
 
         from machinevisiontoolbox import Image
 
         if len(self) > 1:
-            raise ValueError('can only compute support region for single feature')
-        
+            raise ValueError("can only compute support region for single feature")
+
         if isinstance(images, Image):
             image = images.A
         else:
             # list or iterable
             image = images[self.id].A
 
         # M = smb.transl2(N/2, N/2) @ smb.trot2(self.orientation) @ smb.transl2(-self.u, -self.v)
         # M = M[:2, :] / self.scale * N / 2
         # translate to origin and rotate
         M = smb.trot2(self.orientation) @ smb.transl2(-self.u, -self.v)
 
         # scale it to fill the window
         M *= N / 2 / self.scale
-        M[2,2] = 1
+        M[2, 2] = 1
 
         # translate to centre of window
-        M = smb.transl2(N/2, N/2) @ M
+        M = smb.transl2(N / 2, N / 2) @ M
 
-        out = cv.warpAffine(src=image, M=M[:2,:], dsize=(N, N), flags=cv.INTER_LINEAR)
+        out = cv.warpAffine(src=image, M=M[:2, :], dsize=(N, N), flags=cv.INTER_LINEAR)
         return Image(out)
 
     def filter(self, **kwargs):
         """
         Filter features
 
         :param kwargs: the filter parameters
@@ -940,46 +967,48 @@
         :note: If ``value`` is a range the ``numpy.Inf`` or ``-numpy.Inf``
             can be used as values.
         """
 
         features = self
 
         for filter, limits in kwargs.items():
-            if filter == 'scale':
+            if filter == "scale":
                 v = features.scale
                 k = (limits[0] <= v) & (v <= limits[1])
-            elif filter == 'minscale':
+            elif filter == "minscale":
                 v = features.scale
                 k = v >= limits
-            elif filter == 'maxscale':
+            elif filter == "maxscale":
                 v = features.scale
                 k = v <= limits
-            elif filter == 'strength':
+            elif filter == "strength":
                 v = features.strength
                 k = (limits[0] <= v) & (v <= limits[1])
-            elif filter == 'minstrength':
+            elif filter == "minstrength":
                 v = features.strength
                 k = limits >= v
-            elif filter == 'percentstrength':
+            elif filter == "percentstrength":
                 v = features.strength
                 vmax = v.max()
                 k = v >= vmax * limits / 100
             else:
-                raise ValueError('unknown filter key', filter)
+                raise ValueError("unknown filter key", filter)
 
             features = features[k]
-        
+
         return features
 
-    def drawKeypoints(self,
-                      image,
-                      drawing=None,
-                      isift=None,
-                      flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,
-                      **kwargs):
+    def drawKeypoints(
+        self,
+        image,
+        drawing=None,
+        isift=None,
+        flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,
+        **kwargs,
+    ):
         """
         Render keypoints into image
 
         :param image: original image
         :type image: :class:`Image`
         :param drawing: _description_, defaults to None
         :type drawing: _type_, optional
@@ -1008,62 +1037,64 @@
         # check valid imagesource
         # TODO if max(self._u) or max(self._v) are greater than image width,
         # height, respectively, then raise ValueError
 
         # TODO check flags, setup dictionary or string for plot options
 
         if drawing is None:
-            drawing = np.zeros((image.shape[0], image.shape[1], 3),
-                               dtype=np.uint8)
+            drawing = np.zeros((image.shape[0], image.shape[1], 3), dtype=np.uint8)
 
         kp = self._kp
 
         if isift is None:
             isift = np.arange(0, len(self._kp))  # might need a +1 here
         else:
             isift = np.array(isift, ndmin=1, copy=True)
 
         # TODO should check that isift is consistent with kp (min value is 0,
         # max value is <= len(kp))
-        cv.drawKeypoints(image.image, # image, source image
-                         #kp[isift],
-                         kp,
-                         drawing,  # outimage
-                         flags=flags,
-                         **kwargs)
+        cv.drawKeypoints(
+            image.image,  # image, source image
+            # kp[isift],
+            kp,
+            drawing,  # outimage
+            flags=flags,
+            **kwargs,
+        )
 
         return image.__class__(drawing)
 
-    def drawMatches(self,
-                    im1,
-                    sift1,
-                    im2,
-                    sift2,
-                    matches,
-                    **kwargs):
+    def drawMatches(self, im1, sift1, im2, sift2, matches, **kwargs):
         # TODO should I just have input two SIFT objects,
         # or in this case just another SIFT object?
 
         # draw_params = dict(matchColor=(0, 255, 0),
         #                   singlePointColor=(255, 0, 0),
         #                   matchesMask=matches,
         #                   flags=0)
 
-        out = cv.drawMatchesKnn(im1.image,
-                                sift1._kp,
-                                im2.image,
-                                sift2._kp,
-                                matches,
-                                None,
-                                **kwargs)
+        out = cv.drawMatchesKnn(
+            im1.image, sift1._kp, im2.image, sift2._kp, matches, None, **kwargs
+        )
 
         return im1.__class__(out)
-    
-    def plot(self, *args, ax=None, filled=False, color='blue', alpha=1,
-        hand=False, handcolor='blue', handthickness=1, handalpha=1, **kwargs):
+
+    def plot(
+        self,
+        *args,
+        ax=None,
+        filled=False,
+        color="blue",
+        alpha=1,
+        hand=False,
+        handcolor="blue",
+        handthickness=1,
+        handalpha=1,
+        **kwargs,
+    ):
         """
         Plot features using Matplotlib
 
         :param ax: axes to plot onto, defaults to None
         :type ax: axes, optional
         :param filled: shapes are filled, defaults to False
         :type filled: bool, optional
@@ -1085,29 +1116,58 @@
 
         """
         ax = smb.axes_logic(ax, 2)
 
         if filled:
             for kp in self:
                 centre = kp.p.flatten()
-                c = plt.Circle(centre, radius=kp.scale, clip_on=True, color=color, alpha=alpha, **kwargs)
+                c = plt.Circle(
+                    centre,
+                    radius=kp.scale,
+                    clip_on=True,
+                    color=color,
+                    alpha=alpha,
+                    **kwargs,
+                )
                 ax.add_patch(c)
                 if hand:
-                    circum = centre + kp.scale * np.r_[math.cos(kp.orientation), math.sin(kp.orientation)]
-                    l = plt.Line2D((centre[0], circum[0]), (centre[1], circum[1]), color=handcolor, linewidth=handthickness, alpha=handalpha)
+                    circum = (
+                        centre
+                        + kp.scale
+                        * np.r_[math.cos(kp.orientation), math.sin(kp.orientation)]
+                    )
+                    l = plt.Line2D(
+                        (centre[0], circum[0]),
+                        (centre[1], circum[1]),
+                        color=handcolor,
+                        linewidth=handthickness,
+                        alpha=handalpha,
+                    )
                     ax.add_line(l)
         else:
             if len(args) == 0 and len(kwargs) == 0:
-                kwargs = dict(marker='+y', markerfacecolor='none')
+                kwargs = dict(marker="+y", markerfacecolor="none")
             smb.plot_point(self.p, *args, **kwargs)
 
     #     plt.draw()
 
-    def draw(self, image, *args, ax=None, filled=False, color='blue', alpha=1,
-        hand=False, handcolor='blue', handthickness=1, handalpha=1, **kwargs):
+    def draw(
+        self,
+        image,
+        *args,
+        ax=None,
+        filled=False,
+        color="blue",
+        alpha=1,
+        hand=False,
+        handcolor="blue",
+        handthickness=1,
+        handalpha=1,
+        **kwargs,
+    ):
         """
         Draw features into image
 
         :param ax: axes to plot onto, defaults to None
         :type ax: axes, optional
         :param filled: shapes are filled, defaults to False
         :type filled: bool, optional
@@ -1128,46 +1188,68 @@
         to the circumference, like a clock hand.
 
         """
         img = image.image
         if filled:
             for kp in self:
                 centre = kp.p.flatten()
-                
-                draw_circle(img, centre, radius=kp.scale, clip_on=True, color=color, alpha=alpha, **kwargs)
+
+                draw_circle(
+                    img,
+                    centre,
+                    radius=kp.scale,
+                    clip_on=True,
+                    color=color,
+                    alpha=alpha,
+                    **kwargs,
+                )
                 # draw_circle(img, centre, radius=kp.scale, clip_on=True, color=color, alpha=alpha, **kwargs)
 
                 if hand:
-                    circum = centre + kp.scale * np.r_[math.cos(kp.orientation), math.sin(kp.orientation)]
-                    draw_line(img, (centre[0], circum[0]), (centre[1], circum[1]), color=handcolor, thickness=handthickness, alpha=handalpha)
+                    circum = (
+                        centre
+                        + kp.scale
+                        * np.r_[math.cos(kp.orientation), math.sin(kp.orientation)]
+                    )
+                    draw_line(
+                        img,
+                        (centre[0], circum[0]),
+                        (centre[1], circum[1]),
+                        color=handcolor,
+                        thickness=handthickness,
+                        alpha=handalpha,
+                    )
         else:
             if len(args) == 0 and len(kwargs) == 0:
-                kwargs = dict(marker='+y')
+                kwargs = dict(marker="+y")
             draw_point(img, self.p, *args, fontsize=0.6, **kwargs)
-    
-    def draw2(self, image, color='y', type='point'):
+
+    def draw2(self, image, color="y", type="point"):
         img = image.image
         if isinstance(color, str):
             color = color_bgr(color)
-        
-        options = {'rich': cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,
-                'point': cv.DRAW_MATCHES_FLAGS_DEFAULT,
-                'not': cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS}
-
-        cv.drawKeypoints(img, # image, source image
-                    self._kp,
-                    img,  # outimage
-                    color=color,
-                    flags=options[type] + cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG
-                    )
+
+        options = {
+            "rich": cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,
+            "point": cv.DRAW_MATCHES_FLAGS_DEFAULT,
+            "not": cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS,
+        }
+
+        cv.drawKeypoints(
+            img,  # image, source image
+            self._kp,
+            img,  # outimage
+            color=color,
+            flags=options[type] + cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG,
+        )
 
         return image.__class__(img)
 
-class FeatureMatch:
 
+class FeatureMatch:
     def __init__(self, m, fv1, fv2, inliers=None):
         """
         Create feature match object
 
         :param m: a list of match tuples (id1, id2, distance)
         :type m: list of tuples (int, int, float)
         :param fv1: first set of features
@@ -1184,15 +1266,15 @@
         is the distance between the feature's descriptors.
 
         A :class:`FeatureMatch` object:
 
             - has a length, the number of matches it contains
             - can be sliced to extract a subset of matches
             - inlier/outlier status of matches
-        
+
         :note: This constructor would not be called directly, it is used by the
             ``match`` method of the :class:`BaseFeature2D` subclass.
 
         :seealso: :obj:`BaseFeature2D.match` `cv2.KeyPoint <https://docs.opencv.org/4.5.2/d2/d29/classcv_1_1KeyPoint.html#a507d41b54805e9ee5042b922e68e4372>`_
         """
         self._matches = m
         self._kp1 = fv1
@@ -1232,24 +1314,24 @@
             if self._inliers is not None:
                 inliers = self._inliers[i]
         elif isinstance(i, slice):
             matches = self._matches[i]
             if self._inliers is not None:
                 inliers = self._inliers[i]
         elif isinstance(i, np.ndarray):
-            if np.issubdtype(i.dtype, np.bool):
+            if np.issubdtype(i.dtype, bool):
                 matches = [m for m, g in zip(self._matches, i) if g]
                 if self._inliers is not None:
                     inliers = [m for m, g in zip(self._inliers, i) if g]
             elif np.issubdtype(i.dtype, np.integer):
                 matches = [self._matches[k] for k in i]
                 if self._inliers is not None:
                     inliers = [self._inliers[k] for k in i]
         else:
-            raise ValueError('bad index')
+            raise ValueError("bad index")
         return FeatureMatch(matches, self._kp1, self._kp2, inliers)
 
     def __len__(self):
         """
         Number of matches
 
         :return: number of matches
@@ -1305,15 +1387,15 @@
         into the first and second feature sets that were matched. Each feature
         has a position, strength, scale and id.
 
         This method returns the match that contains the feature in the first
         feature set with specific ``id``. If no such match exists it returns
         None.
 
-        :note:  
+        :note:
             - For efficient lookup, on the first call a dict is built that maps
               feature id to index in the feature set.
             - Useful when features in the sets come from multiple images and
               ``id`` is used to indicate the source image.
 
         :seealso: :class:`BaseFeature2D` :obj:`BaseFeature2D.id` :meth:`by_id2`
         """
@@ -1343,15 +1425,15 @@
         into the first and second feature sets that were matched. Each feature
         has a position, strength, scale and id.
 
         This method returns the match that contains the feature in the second
         feature set with specific ``id``. If no such match exists it returns
         None.
 
-        :note:  
+        :note:
             - For efficient lookup, on the first call a dict is built that maps
               feature id to index in the feature set.
             - Useful when features in the sets come from multiple images and
               ``id`` is used to indicate the source image.
 
         :seealso: :class:`BaseFeature2D` :obj:`BaseFeature2D.id` :meth:`by_id1`
         """
@@ -1371,15 +1453,15 @@
         """
         String representation of matches
 
         :return: string representation
         :rtype: str
 
         If the object contains a single correspondence, show the feature
-        indices and distance metric.  For multiple correspondences, show 
+        indices and distance metric.  For multiple correspondences, show
         summary data.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -1387,15 +1469,18 @@
             >>> orb2 = Image.Read("eiffel-2.png").ORB()
             >>> matches = orb1.match(orb2)
             >>> str(matches)
             >>> str(matches[0])
         """
 
         if len(self) == 1:
-            return f"{self.status} {self.distance:6.2f}: ({self.p1[0, 0]:.1f}, {self.p1[1, 0]:.1f}) <--> ({self.p2[0, 0]:.1f}, {self.p2[1, 0]:.1f})"
+            return (
+                f"{self.status} {self.distance:6.2f}: ({self.p1[0, 0]:.1f},"
+                f" {self.p1[1, 0]:.1f}) <--> ({self.p2[0, 0]:.1f}, {self.p2[1, 0]:.1f})"
+            )
         else:
             s = f"{len(self)} matches"
             if self._inliers is not None:
                 ninlier = sum(self._inliers)
                 s += f", with {ninlier} ({ninlier/len(self)*100:.1f}%) inliers"
             return s
 
@@ -1403,15 +1488,15 @@
         """
         String representation of matches
 
         :return: string representation
         :rtype: str
 
         If the object contains a single correspondence, show the feature
-        indices and distance metric.  For multiple correspondences, show 
+        indices and distance metric.  For multiple correspondences, show
         summary data.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -1429,65 +1514,73 @@
         """
         Inlier status of matches
 
         :return: inlier status of matches
         :rtype: bool
         """
         if self._inliers is not None:
-            return '+' if self._inliers else '-'
+            return "+" if self._inliers else "-"
         else:
-            return ''
+            return ""
 
     def list(self):
         """
         List matches
 
         Print the matches in a simple format, one line per match.
 
         :seealso: :meth:`table`
         """
         for i, m in enumerate(self._matches):
             # TODO shouldnt have to flatten
             p1 = self._kp1[m[0]].p.flatten()
             p2 = self._kp2[m[1]].p.flatten()
             if self._inliers is not None:
-                status = '+' if self._inliers[i] else '-'
+                status = "+" if self._inliers[i] else "-"
             else:
-                status = ''
-            s = f"{i:3d}:  {status} {m[2]:6.2f} ({p1[0]:.1f}, {p1[1]:.1f}) <--> ({p2[0]:.1f}, {p2[1]:.1f})"
+                status = ""
+            s = (
+                f"{i:3d}:  {status} {m[2]:6.2f} ({p1[0]:.1f}, {p1[1]:.1f}) <-->"
+                f" ({p2[0]:.1f}, {p2[1]:.1f})"
+            )
             print(s)
-            
+
     def table(self):
         """
         Print matches in tabular form
 
         Each row in the table includes: the index of the match, inlier/outlier
         status, match strength, feature coordinates.
 
         :seealso: :meth:`__str__`
         """
         columns = [
-                Column("#"),
-                Column("inlier"),
-                Column("strength", fmt="{:.3g}"),
-                Column("p1", colalign="<", fmt="{:s}"),
-                Column("p2", colalign="<", fmt="{:s}")
+            Column("#"),
+            Column("inlier"),
+            Column("strength", fmt="{:.3g}"),
+            Column("p1", colalign="<", fmt="{:s}"),
+            Column("p2", colalign="<", fmt="{:s}"),
         ]
         table = ANSITable(*columns, border="thin")
 
         for i, m in enumerate(self._matches):
             # TODO shouldnt have to flatten
             p1 = self._kp1[m[0]].p.flatten()
             p2 = self._kp2[m[1]].p.flatten()
             if self._inliers is not None:
-                status = '+' if self._inliers[i] else '-'
+                status = "+" if self._inliers[i] else "-"
             else:
-                status = ''
-            table.row(i, status, m[2], f"({p1[0]:.1f}, {p1[1]:.1f})",
-                f"({p2[0]:.1f}, {p2[1]:.1f})")
+                status = ""
+            table.row(
+                i,
+                status,
+                m[2],
+                f"({p1[0]:.1f}, {p1[1]:.1f})",
+                f"({p2[0]:.1f}, {p2[1]:.1f})",
+            )
         table.print()
 
     @property
     def inliers(self):
         """
         Extract inlier matches
 
@@ -1571,21 +1664,26 @@
         #     plt.plot((p1[0], p2[0] + u[1]), (p1[1], p2[1]), *pos, **kwargs)
         p1 = self.p1
         p2 = self.p2
         plt.plot((p1[0, :], p2[0, :] + u[1]), (p1[1, :], p2[1, :]), *pos, **kwargs)
         if plt.isinteractive():
             plt.show(block=block)
 
-    def plot_correspondence(self, *arg, offset=(0,0), **kwargs):
+    def plot_correspondence(self, *arg, offset=(0, 0), **kwargs):
         p1 = self.p1
         p2 = self.p2
-        plt.plot((p1[0, :], p2[0, :] + offset[0]), (p1[1, :], p2[1, :] + offset[1]), *arg, **kwargs)
+        plt.plot(
+            (p1[0, :], p2[0, :] + offset[0]),
+            (p1[1, :], p2[1, :] + offset[1]),
+            *arg,
+            **kwargs,
+        )
         plt.draw()
 
-    def estimate(self, func, method='ransac', **args):
+    def estimate(self, func, method="ransac", **args):
 
         solution = func(self.p1, self.p2, method=method, **args)
         self._inliers = solution[-1]
 
         return solution[:-1]
 
     @property
@@ -1738,172 +1836,203 @@
             >>> orb2 = Image.Read("eiffel-2.png").ORB()
             >>> matches = orb1.match(orb2)
             >>> matches.id2
             >>> matches[0].id2
         """
         return [m[1] for m in self._matches]
 
+
 # -------------------- subclasses of BaseFeature2D -------------------------- #
 class SIFTFeature(BaseFeature2D):
     """
     Create set of SIFT point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.SIFTFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
 
+
 class ORBFeature(BaseFeature2D):
     """
     Create set of ORB point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.ORBFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class BRISKFeature(BaseFeature2D):
     """
     Create set of BRISK point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.BRISKFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class AKAZEFeature(BaseFeature2D):
     """
     Create set of AKAZE point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.AKAZEFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class HarrisFeature(BaseFeature2D):
     """
     Create set of Harris corner features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.HarrisFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 # pure feature descriptors
 
+
 class FREAKFeature(BaseFeature2D):
     """
     Create set of FREAK point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.FREAKFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class BOOSTFeature(BaseFeature2D):
     """
     Create set of BOOST point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.BOOSTFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class BRIEFFeature(BaseFeature2D):
     """
     Create set of BRIEF point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.BRIEFFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class DAISYFeature(BaseFeature2D):
     """
     Create set of DAISY point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.DAISYFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class LATCHFeature(BaseFeature2D):
     """
     Create set of LATCH point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.LATCHFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
+
 class LUCIDFeature(BaseFeature2D):
     """
     Create set of LUCID point features
 
     .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.LUCIDFeature
         :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
         :parts: 1
     """
+
     pass
 
-class ImagePointFeaturesMixin:
 
-    def _image2feature(self, cls, sortby=None, nfeat=None, id='image', scale=False, orient=False, **kwargs):
-           # https://datascience.stackexchange.com/questions/43213/freak-feature-extraction-opencv
+class ImagePointFeaturesMixin:
+    def _image2feature(
+        self,
+        cls,
+        sortby=None,
+        nfeat=None,
+        id="image",
+        scale=False,
+        orient=False,
+        **kwargs,
+    ):
+        # https://datascience.stackexchange.com/questions/43213/freak-feature-extraction-opencv
         algorithms = {
-            'SIFT': cv.SIFT_create,
-            'ORB': cv.ORB_create,
-            'Harris': _Harris_create,
-            'BRISK': cv.BRISK_create,
-            'AKAZE': cv.AKAZE_create,
+            "SIFT": cv.SIFT_create,
+            "ORB": cv.ORB_create,
+            "Harris": _Harris_create,
+            "BRISK": cv.BRISK_create,
+            "AKAZE": cv.AKAZE_create,
             # 'FREAK': (cv.FREAK_create, FREAKFeature),
             # 'DAISY': (cv.DAISY_create, DAISYFeature),
         }
 
         # check if image is valid
         # TODO, MSER can handle color
         image = self.mono()
 
         # get a reference to the appropriate detector
-        algorithm = cls.__name__.replace('Feature', '')
+        algorithm = cls.__name__.replace("Feature", "")
         try:
             detector = algorithms[algorithm](**kwargs)
         except KeyError:
-            raise ValueError('bad algorithm specified')
+            raise ValueError("bad algorithm specified")
 
         kp, des = detector.detectAndCompute(image.A, mask=None)
 
         # kp is a list of N KeyPoint objects
         # des is NxM ndarray of keypoint descriptors
 
-        if id == 'image':
+        if id == "image":
             if image.id is not None:
                 # copy image id into the keypoints
                 for k in kp:
                     k.class_id = image.id
-        elif id == 'index':
+        elif id == "index":
             for i, k in enumerate(kp):
-                    k.class_id = i
+                k.class_id = i
         elif isinstance(id, int):
             for k in kp:
-                    k.class_id = id
+                k.class_id = id
         else:
-            raise ValueError('bad id')
+            raise ValueError("bad id")
 
         # do sorting in here
-        
+
         if nfeat is not None:
             kp = kp[:nfeat]
             des = des[:nfeat, :]
 
         # construct a new Feature2DBase subclass
         features = cls(kp, des, scale=scale, orient=orient)
 
@@ -1938,25 +2067,23 @@
             >>> len(sift)  # number of features
             >>> print(sift[:5])
 
         :references:
             - Distinctive image features from scale-invariant keypoints.
               David G. Lowe
               Int. J. Comput. Vision, 60(2):91–110, November 2004.
-            - Robotics, Vision & Control for Python, Section 14.1, 
+            - Robotics, Vision & Control for Python, Section 14.1,
               P. Corke, Springer 2023.
 
         :seealso: :class:`SIFTFeature` `cv2.SIFT_create <https://docs.opencv.org/4.5.2/d7/d60/classcv_1_1SIFT.html>`_
         """
 
-        return self._image2feature(SIFTFeature, scale=True, orient=True, **kwargs) 
+        return self._image2feature(SIFTFeature, scale=True, orient=True, **kwargs)
 
-    def ORB(self,
-            scoreType='harris',
-            **kwargs):
+    def ORB(self, scoreType="harris", **kwargs):
         """
         Find ORB features in image
 
         :param kwargs: arguments passed to OpenCV
         :return: set of 2D point features
         :rtype: :class:`ORBFeature`
 
@@ -1976,18 +2103,18 @@
             >>> orb = img.ORB()
             >>> len(orb)  # number of features
             >>> print(orb[:5])
 
         :seealso: :class:ORBFeature`, `cv2.ORB_create <https://docs.opencv.org/4.5.2/db/d95/classcv_1_1ORB.html>`_
         """
 
-        scoreoptions = {'harris': cv.ORB_HARRIS_SCORE,
-                        'fast': cv.ORB_FAST_SCORE}
-        return self._image2feature(ORBFeature, scoreType=scoreoptions[scoreType], **kwargs) 
-
+        scoreoptions = {"harris": cv.ORB_HARRIS_SCORE, "fast": cv.ORB_FAST_SCORE}
+        return self._image2feature(
+            ORBFeature, scoreType=scoreoptions[scoreType], **kwargs
+        )
 
     def BRISK(self, **kwargs):
         """
         Find BRISK features in image
 
         .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.BRISKFeature
             :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
@@ -2009,20 +2136,20 @@
             >>> brisk = img.BRISK()
             >>> len(brisk)  # number of features
             >>> print(brisk[:5])
 
         :references:
             - Brisk: Binary robust invariant scalable keypoints.
               Stefan Leutenegger, Margarita Chli, and Roland Yves Siegwart.
-              In Computer Vision (ICCV), 2011 IEEE International Conference on, 
+              In Computer Vision (ICCV), 2011 IEEE International Conference on,
               pages 2548–2555. IEEE, 2011.
 
         :seealso: :class:`BRISKFeature` `cv2.BRISK_create <https://docs.opencv.org/4.5.2/d7/d60/classcv_1_1BRISK.html>`_
         """
-        return self._image2feature(BRISKFeature, **kwargs) 
+        return self._image2feature(BRISKFeature, **kwargs)
 
     def AKAZE(self, **kwargs):
         """
         Find AKAZE features in image
 
         .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.AKAZEFeature
             :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
@@ -2046,20 +2173,19 @@
             >>> print(akaze[:5])
 
         :references:
             - Fast explicit diffusion for accelerated features in nonlinear scale spaces.
               Pablo F Alcantarilla, Jesús Nuevo, and Adrien Bartoli.
               Trans. Pattern Anal. Machine Intell, 34(7):1281–1298, 2011.
 
-        :seealso: 
+        :seealso:
             :class:`~machinevisiontoolbox.ImagePointFeatures.AKAZEFeature`
             `cv2.AKAZE <https://docs.opencv.org/4.5.2/d7/d60/classcv_1_1AKAZE.html>`_
         """
-        return self._image2feature(AKAZEFeature, **kwargs) 
-
+        return self._image2feature(AKAZEFeature, **kwargs)
 
     def Harris(self, **kwargs):
         r"""
         Find Harris features in image
 
         .. inheritance-diagram:: machinevisiontoolbox.ImagePointFeatures.HarrisFeature
             :top-classes: machinevisiontoolbox.ImagePointFeatures.BaseFeature2D
@@ -2092,28 +2218,28 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("eiffel-1.png")
             >>> harris = img.Harris()
             >>> len(harris)  # number of features
             >>> print(harris[:5])
 
-        .. note:: The Harris corner detector and descriptor is not part of 
+        .. note:: The Harris corner detector and descriptor is not part of
             OpenCV and has been custom written for pedagogical purposes.
 
         :references:
-            - A combined corner and edge detector. 
+            - A combined corner and edge detector.
               CG Harris, MJ Stephens
               Proceedings of the Fourth Alvey Vision Conference, 1988
               Manchester, pp 147–151
-            - Robotics, Vision & Control for Python, Section 12.3.1, 
+            - Robotics, Vision & Control for Python, Section 12.3.1,
                 P. Corke, Springer 2023.
 
         :seealso: :class:`HarrisFeature`
         """
-        return self._image2feature(HarrisFeature, **kwargs) 
+        return self._image2feature(HarrisFeature, **kwargs)
 
     def ComboFeature(self, detector, descriptor, det_opts, des_opts):
         """
         Combination feature detector and descriptor
 
         :param detector: detector name
         :type detector: str
@@ -2133,39 +2259,39 @@
 
         :seealso: :class:`BOOSTFeature` :class:`BRIEFFeature` :class:`DAISYFeature` :class:`FREAKFeature` :class:`LATCHFeature` :class:`LUCIDFeature`
         """
 
         # WORK IN PROGRESS
 
         detectors = {
-            'AGAST': cv.AgastFeatureDetector_create,
-            'FAST':  cv.FastFeatureDetector_create,
-            'GoodFeaturesToTrack': cv.GFTTDetector_create,
+            "AGAST": cv.AgastFeatureDetector_create,
+            "FAST": cv.FastFeatureDetector_create,
+            "GoodFeaturesToTrack": cv.GFTTDetector_create,
         }
 
         descriptors = {
-            'BOOST': (cv.xfeatures2d.BoostDesc_create, BOOSTFeature),
-            'BRIEF': (cv.xfeatures2d.BriefDescriptorExtractor_create, BRIEFFeature),
-            'DAISY': (cv.xfeatures2d.BriefDescriptorExtractor_create, DAISYFeature),
-            'FREAK': (cv.xfeatures2d.BriefDescriptorExtractor_create, FREAKFeature),
-            'LATCH': (cv.xfeatures2d.BriefDescriptorExtractor_create, LATCHFeature),
-            'LUCID': (cv.xfeatures2d.BriefDescriptorExtractor_create, LUCIDFeature),
+            "BOOST": (cv.xfeatures2d.BoostDesc_create, BOOSTFeature),
+            "BRIEF": (cv.xfeatures2d.BriefDescriptorExtractor_create, BRIEFFeature),
+            "DAISY": (cv.xfeatures2d.BriefDescriptorExtractor_create, DAISYFeature),
+            "FREAK": (cv.xfeatures2d.BriefDescriptorExtractor_create, FREAKFeature),
+            "LATCH": (cv.xfeatures2d.BriefDescriptorExtractor_create, LATCHFeature),
+            "LUCID": (cv.xfeatures2d.BriefDescriptorExtractor_create, LUCIDFeature),
         }
         # eg. Feature2D('FAST', 'FREAK')
         if detector in detectors:
             # call it
             kp = detectors[detector](self.image.A, **det_opts)
         elif iscallable(detector):
             # call it
             kp = detector(self.image.A, **det_opts)
         else:
-            raise ValueError('unknown detector')
+            raise ValueError("unknown detector")
 
-class _Harris_create:
 
+class _Harris_create:
     def __init__(self, nfeat=250, k=0.04, scale=7, hw=2, patch=5):
 
         self.nfeat = nfeat
         self.k = k
         self.hw = hw
         self.peakscale = scale
         self.patch = patch
@@ -2176,36 +2302,40 @@
         dst = cv.cornerHarris(image, 2, 2 * self.hw + 1, self.k)
         peaks = findpeaks2d(dst, npeaks=None, scale=self.peakscale, positive=True)
         kp = []
         des = []
         w = 2 * self.patch + 1
         w2 = w**2
         for peak in peaks:
-            x  = int(round(peak[0]))
-            y  = int(round(peak[1]))
+            x = int(round(peak[0]))
+            y = int(round(peak[1]))
             try:
-                W = image[y-self.patch:y+self.patch+1, x-self.patch:x+self.patch+1]
+                W = image[
+                    y - self.patch : y + self.patch + 1,
+                    x - self.patch : x + self.patch + 1,
+                ]
                 v = W.flatten()
                 if W.size > 0:
                     if len(v) != w2:
                         # handle case where last subscript is outside image bound
                         continue
-                    
+
                     des.append(smb.unitvec(v))
                     kp.append(cv.KeyPoint(x, y, 0, 0, peak[2]))
             except IndexError:
                 # handle the case where the descriptor window falls off the edge
                 pass
 
         for i, d in enumerate(des):
             if d.shape != des[1].shape:
                 print(i, d.shape)
 
         return kp, np.array(des)
 
+
 # ------------------------------------------------------------------------- #
 if __name__ == "__main__":
 
     # step 1: familiarisation with open cv's sift
 
     # im = cv.imread('images/test/longquechen-moon.png')
     # im = cv.imread('images/monalisa.png')
@@ -2243,47 +2373,42 @@
     # code.interact(local=dict(globals(), **locals()))
 
     from machinevisiontoolbox import Image, ImageCollection
 
     # kp1 = Image.Read('eiffel-1.png').SIFT()
     # kp2 = Image.Read('eiffel-2.png').SIFT()
 
-
-
     # kp1 = Image.Read('eiffel2-1.png').Harris()
 
     # # d = kp1[0].distance(kp1[1])
     # # print(d)
     # d = kp1[0].distance(kp1[30])
     # print(d)
 
     # matches = kp1.match(kp2)
     # matches.subset(10).table()
     # matches.subset(100).plot(linewidth=0.7, darken=False, color="yellow")
 
-
     # c = matches.correspondences()
 
     # # im = Image('eiffel2-1.png')
     # # ax = im.disp()
 
     # # # sort into descending order
     # # ks = kp1.sort()
     # # print(len(kp1), len(ks))
     # # print(kp1[0]._descriptor)
     # # print(ks[0]._descriptor)
-    
+
     # # kp1.plot(hand=True, handalpha=0.2)
     # from machinevisiontoolbox import Image
 
-
     # matches[:10].plot('b', alpha=0.6)
 
     # plt.show(block=True)
-    
 
     # im1 = Image.Read("eiffel2-1.png", grey=True)
     # im2 = Image.Read("eiffel2-2.png", grey=True)
     # hf = im1.Harris()
     # hf = im1.Harris(nfeat=200)
 
     # im1.disp(darken=True); hf.plot("gs")
@@ -2309,36 +2434,33 @@
     sf1 = im1.SIFT(nfeat=200)
 
     # im1.disp()
     # sf1.plot()
     # plt.show(block=True)
 
     im2 = im1.colorize()
-    sf1.draw2(im2, color='r', type='rich')
+    sf1.draw2(im2, color="r", type="rich")
     im2.disp()
     plt.show(block=True)
 
     # im3 = im1.colorize()
     # z = sf1.drawKeypoints(im3)
     # im3.disp(block=True)
 
-
-
     plt.show(block=True)
 
     # hf1 = im1.Harris(nfeat=250, scale=10)
     # print(hf1[5])
     # hf1[:5].table()
     # hf1[:5].list()
 
-
     # sf1 = []
     # sf1 += im1.SIFT(nfeat=250)
     # sf1 += im1.SIFT(nfeat=250)
-    
+
     # print(sf1[5])
     # sf1[:5].table()
     # sf1[:5].list()
     # sf2 = im2.SIFT();
 
     # print(len(sf1))
     # print(len(sf2))
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageProcessing.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageProcessing.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,16 +7,24 @@
 from numpy.lib.arraysetops import isin
 import scipy as sp
 from scipy import interpolate
 import cv2 as cv
 from pathlib import Path
 import os.path
 from spatialmath.base import argcheck, getvector, e2h, h2e, transl2
-from machinevisiontoolbox.base import iread, iwrite, colorname, \
-    int_image, float_image, idisp, name2color
+from machinevisiontoolbox.base import (
+    iread,
+    iwrite,
+    colorname,
+    int_image,
+    float_image,
+    idisp,
+    name2color,
+)
+
 
 class ImageProcessingMixin:
 
     # ======================= image processing ============================= #
 
     def LUT(self, lut, colororder=None):
         """
@@ -30,15 +38,15 @@
         :rtype: :class:`Image`
 
         For a greyscale image the LUT can be:
 
             - (256,)
             - (256,N) in which case the resulting image has ``N`` planes created
               my applying the I'th column of the LUT to the input image
-  
+
         For a color image the LUT can be:
 
             - (256,) and applied to every plane, or
             - (256,N) where the LUT columns are applied to the ``N`` planes of
               the input image.
 
         Example:
@@ -148,15 +156,15 @@
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.4, P. Corke, Springer 2023.
 
         :seealso: :meth:`apply`
         """
         if self.size != other.size:
-            raise ValueError('two images must have same size')
+            raise ValueError("two images must have same size")
         if vectorize:
             func = np.vectorize(func)
         return self.__class__(func(self.A, other.A), colororder=self.colororder)
 
     def clip(self, min, max):
         """
         Clip pixel values
@@ -179,15 +187,14 @@
             >>> img = Image([[1, 2], [3, 4]])
             >>> img.clip(2, 3).A
 
         :seealso: :func:`numpy.clip`
         """
         return self.__class__(np.clip(self.A, min, max), colororder=self.colororder)
 
-
     def roll(self, ru=0, rv=0):
         """
         Roll image by row or column
 
         :param ru: roll in the column direction, defaults to 0
         :type ru: int, optional
         :param rv: roll in the row direction, defaults to 0
@@ -252,16 +259,16 @@
         :param clip: clip pixel values to interval [0, max], defaults to True
         :type clip: bool, optional
         :return: Image with pixel values stretched to M across r
         :rtype: :class:`Image`
 
         Returns a normalised image in which all pixel values are linearly mapped
         to the interval of 0.0 to ``max``. That is, the minimum pixel value is
-        mapped to 0 and the maximum pixel value is mapped to ``max``.  
-        
+        mapped to 0 and the maximum pixel value is mapped to ``max``.
+
         If ``range`` is specified then ``range[0]`` is mapped to 0.0 and
         ``range[1]`` is mapped to ``max``.  If ``clip`` is False then pixels
         less than ``range[0]`` will be mapped to a negative value and pixels
         greater than ``range[1]`` will be mapped to a value greater than
         ``max``.
 
         Example:
@@ -270,16 +277,16 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
             >>> img.stretch().A
 
         :references:
 
-            - Robotics, Vision & Control, Section 12.1, P. Corke,
-              Springer 2011.
+            - Robotics, Vision & Control for Python, Section 12.1, P. Corke,
+              Springer 2023.
         """
 
         # TODO make all infinity values = None?
 
         im = self.A
         if range is None:
             mn = np.min(im)
@@ -298,18 +305,18 @@
     def thresh(self, *args, **kwargs):
         """
         Image threshold
 
         .. deprecated::
             Use :meth:`threshold` instead
         """
-        warn('Deprecated, please use threshold', DeprecationWarning, stacklevel=2)
+        warn("Deprecated, please use threshold", DeprecationWarning, stacklevel=2)
         return self.threshold(*args, **kwargs)
 
-    def threshold(self, t=None, opt='binary'):
+    def threshold(self, t=None, opt="binary"):
         r"""
         Image threshold
 
         :param t: threshold value
         :type t: scalar, str
         :param option: threshold option, defaults to 'binary'
         :type option: str, optional
@@ -357,76 +364,75 @@
             >>> img = Image([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
             >>> img.threshold(5).image
 
         :note:
             - The threshold is applied to all color planes
             - If threshold is 'otsu' or 'triangle' the image must be greyscale,
               and the computed threshold is also returned.
-              
+
         :references:
             - A Threshold Selection Method from Gray-Level Histograms, N. Otsu.
               IEEE Trans. Systems, Man and Cybernetics Vol SMC-9(1), Jan 1979,
               pp 62-66.
             - Automatic measurement of sister chromatid exchange frequency"
               Zack (Zack GW, Rogers WE, Latt SA (1977),
               J. Histochem. Cytochem. 25 (7): 741–53.
             - Robotics, Vision & Control for Python, Section 12.1.1, P. Corke, Springer 2023.
 
-        :seealso: 
-            :meth:`threshold_interactive` 
-            :meth:`threshold_adaptive_` 
-            :meth:`otsu` 
+        :seealso:
+            :meth:`threshold_interactive`
+            :meth:`threshold_adaptive_`
+            :meth:`otsu`
             `opencv.threshold <https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57>`_
         """
 
         # dictionary of threshold options from OpenCV
         options_dict = {
-            'binary': cv.THRESH_BINARY,
-            'binary_inv': cv.THRESH_BINARY_INV,
-            'truncate': cv.THRESH_TRUNC,
-            'tozero': cv.THRESH_TOZERO,
-            'tozero_inv': cv.THRESH_TOZERO_INV,
-        }
-        threshold_dict = {
-            'otsu': cv.THRESH_OTSU,
-            'triangle': cv.THRESH_TRIANGLE
+            "binary": cv.THRESH_BINARY,
+            "binary_inv": cv.THRESH_BINARY_INV,
+            "truncate": cv.THRESH_TRUNC,
+            "tozero": cv.THRESH_TOZERO,
+            "tozero_inv": cv.THRESH_TOZERO_INV,
         }
+        threshold_dict = {"otsu": cv.THRESH_OTSU, "triangle": cv.THRESH_TRIANGLE}
 
         flag = options_dict[opt]
         if isinstance(t, str):
             # auto threshold requested
             flag |= threshold_dict[t]
 
             threshvalue, imt = cv.threshold(
-                src=self.to_int(),
-                thresh=0.0,
-                maxval=self.maxval,
-                type=flag)
-            return self.__class__(self.like(imt)), self.like(int(threshvalue), maxint=255)
+                src=self.to_int(), thresh=0.0, maxval=self.maxval, type=flag
+            )
+            return self.__class__(self.like(imt)), self.like(
+                int(threshvalue), maxint=255
+            )
 
         elif argcheck.isscalar(t):
             # threshold is given
             _, imt = cv.threshold(
-                src=self.image,
-                thresh=t,
-                maxval=self.maxval,
-                type=flag)
+                src=self.image, thresh=t, maxval=self.maxval, type=flag
+            )
             return self.__class__(imt)
 
         else:
-            raise ValueError(t, 't must be a string or scalar')
+            raise ValueError(t, "t must be a string or scalar")
 
     def ithresh(self):
         """
         Interactive thresholding
 
         .. deprecated::
             Use :meth:`threshold_interactive` instead
         """
-        warn('Deprecated, please use thresh_interactive', DeprecationWarning, stacklevel=2)
+        warn(
+            "Deprecated, please use thresh_interactive",
+            DeprecationWarning,
+            stacklevel=2,
+        )
         return self.thresh_interactive()
 
     def threshold_interactive(self):
         r"""
         Interactive thresholding
 
         :return: selected threshold value
@@ -448,41 +454,41 @@
 
         # ACKNOWLEDGEMENT: https://matplotlib.org/devdocs/gallery/widgets/range_slider.html
         import numpy as np
         import matplotlib.pyplot as plt
         from matplotlib.widgets import Slider
         from matplotlib import colors
 
-        #N = 128
+        # N = 128
         Ncolors = 256
         img = self.image
         t = int((img.max() + img.min()) / 2)
 
         x = np.linspace(self.min(), self.max(), Ncolors)
 
         fig, axs = plt.subplots(1, 2, figsize=(10, 5))
         plt.subplots_adjust(bottom=0.25)
 
         def colormap(t):
-            
+
             X = np.tile(x > t, (3, 1)).T  # N x 3 colormap
-            X = np.hstack([X, np.ones((Ncolors, 1))]) # N x 4
-            return colors.LinearSegmentedColormap.from_list('threshold_colormap', X)
+            X = np.hstack([X, np.ones((Ncolors, 1))])  # N x 4
+            return colors.LinearSegmentedColormap.from_list("threshold_colormap", X)
 
         im = axs[0].imshow(img, cmap="gray")
         im.set_cmap(colormap(t))
-        axs[1].hist(img.flatten(), bins='auto')
-        axs[1].set_title('Histogram of pixel intensities')
+        axs[1].hist(img.flatten(), bins="auto")
+        axs[1].set_title("Histogram of pixel intensities")
 
         # Create the Slider
         slider_ax = plt.axes([0.20, 0.1, 0.60, 0.03])
         slider = Slider(slider_ax, "Threshold", img.min(), img.max(), t)
 
         # Create the Vertical lines on the histogram
-        lower_limit_line = axs[1].axvline(slider.val, color='k')
+        lower_limit_line = axs[1].axvline(slider.val, color="k")
 
         thresh = t
 
         def update(val):
             # The val passed to a callback by the Slider
 
             # Update the image's colormap
@@ -525,15 +531,14 @@
     #     slider_ax = plt.axes([0.20, 0.1, 0.60, 0.03])
     #     slider = RangeSlider(slider_ax, "Threshold", img.min(), img.max())
 
     #     # Create the Vertical lines on the histogram
     #     lower_limit_line = axs[1].axvline(slider.val[0], color='k')
     #     upper_limit_line = axs[1].axvline(slider.val[1], color='k')
 
-
     #     def update(val):
     #         # The val passed to a callback by the RangeSlider will
     #         # be a tuple of (min, max)
 
     #         # Update the image's colormap
     #         im.norm.vmin = val[0]
     #         im.norm.vmax = val[1]
@@ -556,42 +561,41 @@
         :type C: int, optional
         :param h: half-width of window, defaults to 3
         :type h: int, optional
         :return: thresholded image
         :rtype: :class:`Image`
 
         The threshold at each pixel is the mean over a :math:`w \times w, w=2h+1`
-        window minus ``C``.  ``h`` should reflect the scale of the objects 
+        window minus ``C``.  ``h`` should reflect the scale of the objects
         that are to be segmented from the background.
 
         :references:
             - Robotics, Vision & Control for Python, Section 12.1.1.1, P. Corke, Springer 2023.
 
-        :seealso: 
-            :meth:`threshold` 
-            :meth:`threshold_interactive` 
-            :meth:`otsu` 
+        :seealso:
+            :meth:`threshold`
+            :meth:`threshold_interactive`
+            :meth:`otsu`
             `opencv.adaptiveThreshold <https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3>`_
         """
-        #TODO options
+        # TODO options
         # looks like Niblack
 
         im = self.to_int()
 
         out = cv.adaptiveThreshold(
             src=im,
             maxValue=255,
             adaptiveMethod=cv.ADAPTIVE_THRESH_MEAN_C,
             thresholdType=cv.THRESH_BINARY,
-            blockSize=h*2+1,
-            C=C
+            blockSize=h * 2 + 1,
+            C=C,
         )
         return self.__class__(self.like(out))
 
-    
     def otsu(self):
         """
         Otsu threshold selection
 
         :return: Otsu's threshold
         :rtype: scalar
 
@@ -606,29 +610,29 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('street.png')
             >>> img.otsu()
 
         :note:
             - Converts a color image to greyscale.
-            - OpenCV implementation gives slightly different result to 
+            - OpenCV implementation gives slightly different result to
               MATLAB Machine Vision Toolbox.
 
         :references:
             - A Threshold Selection Method from Gray-Level Histograms, N. Otsu.
               IEEE Trans. Systems, Man and Cybernetics Vol SMC-9(1), Jan 1979,
               pp 62-66.
             - An improved method for image thresholding on the valley-emphasis
               method. H-F Ng, D. Jargalsaikhan etal. Signal and Info Proc.
               Assocn. Annual Summit and Conf (APSIPA). 2013. pp1-4
             - Robotics, Vision & Control for Python, Section 12.1.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`thresh` :meth:`ithresh` :meth:`adaptive_threshold`  `opencv.threshold <https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57>`_
         """
-        _, t = self.thresh(t='otsu')
+        _, t = self.thresh(t="otsu")
         return t
 
     def blend(self, image2, alpha, beta=None, gamma=0):
         r"""
         Image blending
 
         :param image2: second image
@@ -641,15 +645,15 @@
         :type gamma: int, optional
         :raises ValueError: images are not same size
         :raises ValueError: images are of different type
         :return: blended image
         :rtype: :class:`Image`
 
         The resulting image is
-        
+
         .. math::
 
             \mathbf{Y} = \alpha \mathbf{X}_1 + \beta \mathbf{X}_2 + \gamma
 
         Example:
 
         .. runblock:: pycon
@@ -663,18 +667,18 @@
             - For integer images the result is saturated.
             - For a multiplane image each plane is processed independently.
 
         :seealso: :meth:`choose` `cv2.addWeighted <https://docs.opencv.org/master/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19>`_
         """
 
         if self.shape != image2.shape:
-            raise ValueError('images are not the same size')
+            raise ValueError("images are not the same size")
         if self.isint != image2.isint:
-            raise ValueError('images must be both int or both floating type')
-            
+            raise ValueError("images must be both int or both floating type")
+
         if beta is None:
             beta = 1 - alpha
         out = cv.addWeighted(self.A, alpha, image2.A, beta, gamma)
         return self.__class__(out, colororder=self.colororder)
 
     def choose(self, image2, mask):
         r"""
@@ -732,25 +736,25 @@
         :seealso: :func:`~machinevisiontoolbox.base.color.name2color` `opencv.bitwise_and <https://docs.opencv.org/master/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14>`_
         """
         im1 = self.image
 
         if isinstance(mask, self.__class__):
             mask = mask.A > 0
         elif not isinstance(mask, np.ndarray):
-            raise ValueError('bad type for mask')
+            raise ValueError("bad type for mask")
 
         mask = mask.astype(np.uint8)
         if im1.shape[:2] != mask.shape:
-            raise ValueError('image and mask must be same size')
+            raise ValueError("image and mask must be same size")
 
         if isinstance(image2, self.__class__):
             # second image is Image type
             im2 = image2.image
             if im1.shape != im2.shape:
-                raise ValueError('image and image2 must be same size')
+                raise ValueError("image and image2 must be same size")
         else:
             # second image is scalar, 3-vector or str
             dt = self.dtype
             shape = self.shape[:2]
             if isinstance(image2, (int, float)):
                 # scalar
                 im2 = np.full(shape, image2, dtype=dt)
@@ -759,39 +763,37 @@
                 if isinstance(image2, str):
                     # it's a colorname, look it up
                     color = self.like(name2color(image2))
                 else:
                     try:
                         color = argcheck.getvector(image2, 3)
                     except:
-                        raise ValueError('expecting a scalar, string or 3-vector')
+                        raise ValueError("expecting a scalar, string or 3-vector")
                 if self.isbgr:
                     color = color[::-1]
-                im2 = np.dstack((
-                    np.full(shape, color[0], dtype=dt),
-                    np.full(shape, color[1], dtype=dt),
-                    np.full(shape, color[2], dtype=dt)))
+                im2 = np.dstack(
+                    (
+                        np.full(shape, color[0], dtype=dt),
+                        np.full(shape, color[1], dtype=dt),
+                        np.full(shape, color[2], dtype=dt),
+                    )
+                )
             if im1.ndim == 2 and im2.ndim > 2:
                 im1 = np.repeat(np.atleast_3d(im1), im2.shape[2], axis=2)
 
         m = cv.bitwise_and(mask, np.uint8([1]))
         m_not = cv.bitwise_xor(mask, np.uint8([1]))
 
-        out = cv.bitwise_and(im1, im1, mask=m_not) \
-              + cv.bitwise_and(im2, im2, mask=mask)
-        
+        out = cv.bitwise_and(im1, im1, mask=m_not) + cv.bitwise_and(im2, im2, mask=mask)
+
         return self.__class__(out, colororder=self.colororder)
 
-    def paste(self,
-              pattern,
-              pt,
-              method='set',
-              position='topleft',
-              copy=False,
-              zero=True):
+    def paste(
+        self, pattern, pt, method="set", position="topleft", copy=False, zero=True
+    ):
         """
         Paste an image into an image
 
         :param pattern: image to be pasted
         :type pattern: :class:`Image`, ndarray(H,W)
         :param pt: coordinates (u,v) where pattern is pasted
         :type pt: array_like(2)
@@ -859,35 +861,35 @@
 
         cw = self.width
         ch = self.height
         pw = pattern.width
         ph = pattern.height
         colororder = self.colororder
 
-        if position in ('centre', 'center'):
+        if position in ("centre", "center"):
             left = pt[0] - pw // 2
             top = pt[1] - ph // 2
-        elif position == 'topleft':
+        elif position == "topleft":
             left = pt[0]  # x
             top = pt[1]  # y
         else:
-            raise ValueError('bad position specified')
+            raise ValueError("bad position specified")
 
         if not zero:
             left += 1
             top += 1
 
         # indices must be integers
         left = int(left)
         top = int(top)
 
-        if (top+ph) > ch:
-            raise ValueError(ph, 'pattern falls off bottom edge')
-        if (left+pw) > cw:
-            raise ValueError(pw, 'pattern falls off right edge')
+        if (top + ph) > ch:
+            raise ValueError(ph, "pattern falls off bottom edge")
+        if (left + pw) > cw:
+            raise ValueError(pw, "pattern falls off right edge")
 
         npc = pattern.nplanes
         nc = self.nplanes
 
         if npc > nc:
             # pattern has multiple planes, replicate the canvas
             # sadly, this doesn't work because repmat doesn't work on 3D
@@ -903,67 +905,71 @@
 
         if npc < nc:
             pim = np.dstack([pattern.A for i in range(nc)])
             # pattern.image = np.matlib.repmat(pattern.image, [1, 1, nc])
         else:
             pim = pattern.image
 
-        if method == 'set':
+        if method == "set":
             if pattern.iscolor:
-                o[top:top+ph, left:left+pw, :] = pim
+                o[top : top + ph, left : left + pw, :] = pim
             else:
-                o[top:top+ph, left:left+pw] = pim
+                o[top : top + ph, left : left + pw] = pim
 
-        elif method == 'add':
+        elif method == "add":
             if pattern.iscolor:
-                o[top:top+ph, left:left+pw, :] = o[top:top+ph,
-                                                    left:left+pw, :] + pim
+                o[top : top + ph, left : left + pw, :] = (
+                    o[top : top + ph, left : left + pw, :] + pim
+                )
             else:
-                o[top:top+ph, left:left+pw] = o[top:top+ph,
-                                                left:left+pw] + pim
-        elif method == 'mean':
+                o[top : top + ph, left : left + pw] = (
+                    o[top : top + ph, left : left + pw] + pim
+                )
+        elif method == "mean":
             if pattern.iscolor:
-                old = o[top:top+ph, left:left+pw, :]
+                old = o[top : top + ph, left : left + pw, :]
                 k = ~np.isnan(pim)
                 old[k] = 0.5 * (old[k] + pim[k])
-                o[top:top+ph, left:left+pw, :] = old
+                o[top : top + ph, left : left + pw, :] = old
             else:
-                old = o[top:top+ph, left:left+pw]
+                old = o[top : top + ph, left : left + pw]
                 k = ~np.isnan(pim)
                 old[k] = 0.5 * (old[k] + pim[k])
-                o[top:top+ph, left:left+pw] = old
+                o[top : top + ph, left : left + pw] = old
 
-        elif method == 'blend':
+        elif method == "blend":
             # compute the mean using float32 to avoid overflow issues
-            bg = o[top:top+ph, left:left+pw].astype(np.float32)
+            bg = o[top : top + ph, left : left + pw].astype(np.float32)
             fg = pim.astype(np.float32)
             blend = 0.5 * (bg + fg)
             blend = blend.astype(self.dtype)
 
             # make masks for foreground and background
             fg_set = (fg > 0).astype(np.uint8)
             bg_set = (bg > 0).astype(np.uint8)
-            
+
             # blend is valid
             blend_mask = cv.bitwise_and(fg_set, bg_set)
 
             # only fg is valid
             fg_mask = cv.bitwise_and(fg_set, cv.bitwise_xor(bg_set, 1))
 
             # only bg is valid
             bg_mask = cv.bitwise_and(cv.bitwise_xor(fg_set, 1), bg_set)
 
             # merge them
-            out = cv.bitwise_and(blend, blend, mask=blend_mask) \
-                + cv.bitwise_and(bg, bg, mask=bg_mask) \
+            out = (
+                cv.bitwise_and(blend, blend, mask=blend_mask)
+                + cv.bitwise_and(bg, bg, mask=bg_mask)
                 + cv.bitwise_and(fg, fg, mask=fg_mask)
-            o[top:top+ph, left:left+pw] = out
+            )
+            o[top : top + ph, left : left + pw] = out
 
         else:
-            raise ValueError('method is not valid')
+            raise ValueError("method is not valid")
 
         if copy:
             return self.__class__(o, copy=copy, colororder=colororder)
         else:
             self.A = o
             return self
 
@@ -990,22 +996,21 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image([[0, 1], [2, 3]])
             >>> img.invert().image
         """
         if self.isint:
-            out = np.where(self.image == 0, self.like(self.maxval), self.like(self.minval))
+            out = np.where(
+                self.image == 0, self.like(self.maxval), self.like(self.minval)
+            )
         elif self.isfloat:
             out = np.where(self.image == 0, 1.0, 0.0)
         return self.__class__(out)
 
-
-
-
     # def scalespace(self, n, sigma=1):
 
     #     im = self.copy()
     #     g = []
     #     scale = 0.5
     #     scales = []
     #     lap = []
@@ -1017,24 +1022,27 @@
     #         g.append(im)
     #         lap.append(im.convolve(L))
     #         scales.append(scale)
 
     #         scale = np.sqrt(scale ** 2 + sigma ** 2)
     #         scales.append(scale)
     #         g.append(im)
-    #         x = (g[-1] - g[-2]) * scale ** 2 
+    #         x = (g[-1] - g[-2]) * scale ** 2
     #         lap.append(x)
 
     #     return g, lap, scales
+
+
 # --------------------------------------------------------------------------- #
 if __name__ == "__main__":
 
     import pathlib
     import os.path
     from machinevisiontoolbox import Image
+
     # a = Image.Read('street.png')
     # a.ithresh()
 
-    a = Image.Read('castle2.png')
+    a = Image.Read("castle2.png")
     b = a.labels_MSER()
 
-    #exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_processing.py").read())  # pylint: disable=exec-used
+    # exec(open(pathlib.Path(__file__).parent.parent.absolute() / "tests" / "test_processing.py").read())  # pylint: disable=exec-used
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageRegionFeatures.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageRegionFeatures.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,39 +14,40 @@
 import cv2 as cv
 import matplotlib.pyplot as plt
 from ansitable import ANSITable, Column
 from spatialmath import SE3
 
 from machinevisiontoolbox.ImagePointFeatures import BaseFeature2D
 
+
 def array_result(func):
     def innerfunc(*args):
         out = func(*args)
         if len(out) == 1:
             return out[0]
         else:
             return out
+
     inner = innerfunc
     inner.__doc__ = func.__doc__  # pass through the doc string
     return inner
 
 
 class ImageRegionFeaturesMixin:
-
     def MSER(self, **kwargs):
         """
         Find MSER features in image
 
         :param kwargs: arguments passed to ``opencv.MSER_create``
         :return: set of MSER features
         :rtype: :class:`MSERFeature`
 
-        Find all the maximally stable extremal regions in the image and 
+        Find all the maximally stable extremal regions in the image and
         return an object that represents the MSERs found. The object behaves
-        like a list and can be indexed, sliced and used as an iterator in 
+        like a list and can be indexed, sliced and used as an iterator in
         for loops and comprehensions.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -63,15 +64,15 @@
 
         return MSERFeature(self, **kwargs)
 
     def ocr(self, minconf=50, plot=False):
         """
         Optical character recognition
 
-        :param minconf: minimum confidence value for text to be returned or 
+        :param minconf: minimum confidence value for text to be returned or
             plotted (percentage), defaults to 50
         :type minconf: int, optional
         :param plot: overlay detected text on the current plot, assumed to be the
             image, defaults to False
         :type plot: bool, optional
         :return: detected strings and metadata
         :rtype: list of :class:`OCRWord`
@@ -88,59 +89,57 @@
         Each recognized text string is described by an :class:`OCRWord` instance
         that contains the string, confidence and bounding box within the image.
 
         .. warning:: `PyTessearct <https://github.com/madmaze/pytesseract>`_ must be installed.
 
         :references:
             - Robotics, Vision & Control for Python, Section 12.4.1, P. Corke, Springer 2023.
-        
+
         :seealso: :class:`OCRWord`
         """
-        # 
+        #
         try:
             import pytesseract
         except:
-            print('you need to install pytesseract:')
+            print("you need to install pytesseract:")
             return
 
-        ocr = pytesseract.image_to_data(
-                self.A,
-                output_type=pytesseract.Output.DICT)
+        ocr = pytesseract.image_to_data(self.A, output_type=pytesseract.Output.DICT)
 
         # create list of dicts, rather than dict of lists
-        n = len(ocr['conf'])
+        n = len(ocr["conf"])
         words = []
         for i in range(n):
-            conf = ocr['conf'][i]
-            if conf == '-1':  # I suspect this was not meant to be a string
+            conf = ocr["conf"][i]
+            if conf == "-1":  # I suspect this was not meant to be a string
                 continue
             if conf < minconf:
                 continue
-            
+
             word = OCRWord(ocr, i)
             if plot:
                 word.plot()
             words.append(word)
         return words
-        
+
     def fiducial(self, dict="4x4_1000", K=None, side=None):
         """
         Find fiducial markers in image
 
         :param dict: marker type, defaults to "4x4_1000"
         :type dict: str, optional
         :param K: camera intrinsics, defaults to None
         :type K: ndarray(3,3), optional
         :param side: side length of the marker, defaults to None
         :type side: float, optional
         :return: markers found in image
         :rtype: list of :class:`Fiducial` instances
 
         Find ArUco or ApriTag markers in the scene and return a list of
-        :class:`Fiducial` objects, one per marker.  If camera intrinsics are 
+        :class:`Fiducial` objects, one per marker.  If camera intrinsics are
         provided then also compute the marker pose with respect to the camera.
 
         ``dict`` specifies the marker family or dictionary and describes the
         number of bits in the tag and the number of usable unique tags.
 
         ============  ========   ===========   =====================
         dict          tag type   marker size   number of unique tags
@@ -174,112 +173,118 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('tags.png')
             >>> fiducials = im.fiducial('5x5_50')
             >>> fiducials
             >>> fiducials[0].corners
 
-        :note: ``side`` is the dimension of the square that contains the 
+        :note: ``side`` is the dimension of the square that contains the
             small white squares inside the black background.
 
         :references:
             - Robotics, Vision & Control for Python, Section 13.6.1, P. Corke, Springer 2023.
-        
+
         :seealso: :class:`Fiducial`
         """
 
         tag_dict = {
-            "4x4_50": cv.aruco.DICT_4X4_50, 
-            "4x4_100": cv.aruco.DICT_4X4_100, 
-            "4x4_250": cv.aruco.DICT_4X4_250, 
-            "4x4_1000": cv.aruco.DICT_4X4_1000, 
-            "5x5_50": cv.aruco.DICT_5X5_50, 
-            "5x5_100": cv.aruco.DICT_5X5_100, 
-            "5x5_250": cv.aruco.DICT_5X5_250, 
-            "5x5_1000": cv.aruco.DICT_5X5_1000, 
-            "6x6_50": cv.aruco.DICT_6X6_50, 
-            "6x6_100": cv.aruco.DICT_6X6_100, 
-            "6x6_250": cv.aruco.DICT_6X6_250, 
-            "6x6_1000": cv.aruco.DICT_6X6_1000, 
-            "7x7_50": cv.aruco.DICT_7X7_50, 
-            "7x7_100": cv.aruco.DICT_7X7_100, 
-            "7x7_250": cv.aruco.DICT_7X7_250, 
-            "7x7_1000": cv.aruco.DICT_7X7_1000, 
+            "4x4_50": cv.aruco.DICT_4X4_50,
+            "4x4_100": cv.aruco.DICT_4X4_100,
+            "4x4_250": cv.aruco.DICT_4X4_250,
+            "4x4_1000": cv.aruco.DICT_4X4_1000,
+            "5x5_50": cv.aruco.DICT_5X5_50,
+            "5x5_100": cv.aruco.DICT_5X5_100,
+            "5x5_250": cv.aruco.DICT_5X5_250,
+            "5x5_1000": cv.aruco.DICT_5X5_1000,
+            "6x6_50": cv.aruco.DICT_6X6_50,
+            "6x6_100": cv.aruco.DICT_6X6_100,
+            "6x6_250": cv.aruco.DICT_6X6_250,
+            "6x6_1000": cv.aruco.DICT_6X6_1000,
+            "7x7_50": cv.aruco.DICT_7X7_50,
+            "7x7_100": cv.aruco.DICT_7X7_100,
+            "7x7_250": cv.aruco.DICT_7X7_250,
+            "7x7_1000": cv.aruco.DICT_7X7_1000,
             "original": cv.aruco.DICT_ARUCO_ORIGINAL,
-            "16h5": cv.aruco.DICT_APRILTAG_16h5, 
-            "25h9": cv.aruco.DICT_APRILTAG_25h9, 
-            "36h10": cv.aruco.DICT_APRILTAG_36h10, 
+            "16h5": cv.aruco.DICT_APRILTAG_16h5,
+            "25h9": cv.aruco.DICT_APRILTAG_25h9,
+            "36h10": cv.aruco.DICT_APRILTAG_36h10,
             "36h11": cv.aruco.DICT_APRILTAG_36h11,
         }
 
         dictionary = cv.aruco.getPredefinedDictionary(tag_dict[dict])
         cornerss, ids, _ = cv.aruco.detectMarkers(self.mono().A, dictionary)
 
         # corners is a list of marker corners, one element per tag
         #  each element is 1x4x2 matrix holding corner coordinates
 
         fiducials = []
         if K is not None and side is not None:
-            rvecs, tvecs, _ = cv.aruco.estimatePoseSingleMarkers(cornerss, side, K, None)
+            rvecs, tvecs, _ = cv.aruco.estimatePoseSingleMarkers(
+                cornerss, side, K, None
+            )
             for id, rvec, tvec, corners in zip(ids, rvecs, tvecs, cornerss):
                 fiducials.append(Fiducial(id[0], corners[0].T, K, rvec, tvec))
         else:
             for id, corners in zip(ids, cornerss):
                 fiducials.append(Fiducial(id[0], corners[0].T))
 
         return fiducials
 
+
 # --------------------- supporting classes -------------------------------- #
 
-class MSERFeature():
+
+class MSERFeature:
     def __init__(self, image=None, **kwargs):
         """
         Find MSERs
 
         :param image: input image
         :type image: :class:`Image`
         :param kwargs: parameters passed to :func:`opencv.MSER_create`
 
-        Find all the maximally stable extremal regions in the image and 
+        Find all the maximally stable extremal regions in the image and
         return an object that represents the MSERs found.
         This class behaves like a list and each MSER is an element of the list.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('shark2.png')
             >>> msers = img.MSER()
             >>> len(msers)
             >>> msers[0]
             >>> msers.bbox
 
-        :references: 
-            - J. Matas, O. Chum, M. Urban, and T. Pajdla. 
+        :references:
+            - J. Matas, O. Chum, M. Urban, and T. Pajdla.
               "Robust wide baseline stereo from maximally stable extremal regions."
               Proc. of British Machine Vision Conference, pages 384-396, 2002.
             - Robotics, Vision & Control for Python, Section 12.1.2.2, P. Corke, Springer 2023.
-        
-        
+
+
         :seealso: :meth:`bbox` :meth:`points`
         """
 
         if image is not None:
             detector = cv.MSER_create(**kwargs)
             msers, bboxes = detector.detectRegions(image.A)
 
-        # msers is a tuple of ndarray(M,2), each row is (u,v)
-        # bbox is ndarray(N,4), each row is l, r, w, h 
-        # returns different things, msers is a list of points
-        # u, v, point=centroid, scale=area
-        # https://www.toptal.com/machine-learning/real-time-object-detection-using-mser-in-ios
-
-            self._points = [mser.T for mser in msers]  # transpose point arrays to be Nx2
-            bboxes[:,2:] = bboxes[:,0:2] + bboxes[:,2:] # convert to lrtb
+            # msers is a tuple of ndarray(M,2), each row is (u,v)
+            # bbox is ndarray(N,4), each row is l, r, w, h
+            # returns different things, msers is a list of points
+            # u, v, point=centroid, scale=area
+            # https://www.toptal.com/machine-learning/real-time-object-detection-using-mser-in-ios
+
+            self._points = [
+                mser.T for mser in msers
+            ]  # transpose point arrays to be Nx2
+            bboxes[:, 2:] = bboxes[:, 0:2] + bboxes[:, 2:]  # convert to lrtb
             self._bboxes = bboxes
 
     def __len__(self):
         """
         Number of MSER features
 
         :return: number of features
@@ -320,23 +325,23 @@
             >>> len(mser)  # number of features
             >>> mser[:5]   # first 5 MSER features
             >>> mser[::50]  # every 50th MSER feature
 
         :seealso: :meth:`len`
         """
         new = self.__class__()
-        
+
         if isinstance(i, int):
             new._points = self._points[i]
             new._bboxes = self._bboxes[np.newaxis, i, :]  # result is 2D
         elif isinstance(i, slice):
             new._points = self._points[i]
             new._bboxes = self._bboxes[i, :]  # result is 2D
         elif isinstance(i, np.ndarray):
-            if np.issubdtype(i.dtype, np.bool):
+            if np.issubdtype(i.dtype, bool):
                 new._points = [self._points[k] for k, true in enumerate(i) if true]
                 new._bboxes = self._bboxes[i, :]
             elif np.issubdtype(i.dtype, np.integer):
                 new._points = [self._points[k] for k in i]
                 new._bboxes = self._bboxes[i, :]
         elif isinstance(i, (list, tuple)):
             new._points = [self._points[k] for k in i]
@@ -348,15 +353,15 @@
         """
         String representation of MSER
 
         :return: Brief readable description of MSER
         :rtype: str
 
         Example:
-        
+
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("castle.png")
             >>> msers = img.MSER()
             >>> str(msers)
             >>> str(msers[0])
@@ -371,15 +376,15 @@
         """
         Representation of MSER
 
         :return: Brief readable description of MSER
         :rtype: str
 
         Example:
-        
+
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("castle.png")
             >>> msers = img.MSER()
             >>> msers
             >>> msers[0]
@@ -395,15 +400,15 @@
         :return: Coordinates of points in (u,v) format that belong to MSER
         :rtype: ndarray(2,N), list of ndarray(2,N)
 
         If the object contains just one region the result is an array, otherwise
         it is a list of arrays (with different numbers of rows).
 
         Example:
-        
+
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> import numpy as np
             >>> img = Image.Read("castle.png")
             >>> msers = img.MSER()
             >>> np.printoptions(threshold=10)
@@ -423,30 +428,30 @@
         :return: Bounding box of MSER in [umin, vmin, umax, vmax] format
         :rtype: ndarray(4) or ndarray(N,4)
 
         If the object contains just one region the result is a 1D array,
         otherwise it is a 2D arrays with one row per bounding box.
 
         Example:
-        
+
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read("castle.png")
             >>> msers = img.MSER()
             >>> msers[0].bbox
             >>> msers[:4].bbox
 
         :seealso: :meth:`points`
 
         """
         return self._bboxes
 
-class OCRWord:
 
+class OCRWord:
     def __init__(self, ocr, i):
         """
         OCR word and metadata
 
         :param ocr: dict from Tesseract
         :type ocr: dict of lists
         :param i: index of word
@@ -464,21 +469,21 @@
         ``conf``    confidence in text recognition (percentage)
         ``l``       left coordinate (umin) of rectangle containing the text
         ``t``       top coordinate (vmin) of rectangle containing the text
         ``w``       height of rectangle containing the text
         ``h``       height of rectangle containing the text
         ``ltrb``    bounding box [left, top, right, bottom]
         ==========  =======================================================
-        
+
         :seealso: :meth:`~machinevisiontoolbox.ImageFeatures.ImageFeaturesMixin.ocr`
         """
         self.dict = {}
         for key in ocr.keys():
             self.dict[key] = ocr[key][i]
-    
+
     def __str__(self):
         """
         String representation of MSER
 
         :return: Brief readable description of OCR word
         :rtype: str
         """
@@ -493,131 +498,132 @@
         Left side of word bounding box
 
         :return: left side coordinate of bounding box in pixels
         :rtype: int
 
         :seealso: :meth:`t` :meth:`ltrb`
         """
-        return self.dict['left']
+        return self.dict["left"]
 
     @property
     def t(self):
         """
         Top side of word bounding box
 
         :return: top side coordinate of bounding box in pixels
         :rtype: int
 
         :seealso: :meth:`l` :meth:`ltrb`
         """
-        return self.dict['top']
+        return self.dict["top"]
 
     @property
     def w(self):
         """
         Width of word bounding box
 
         :return: width of bounding box in pixels
         :rtype: int
 
         :seealso: :meth:`h` :meth:`ltrb`
         """
-        return self.dict['width']
+        return self.dict["width"]
 
     @property
     def h(self):
         """
         Height of word bounding box
 
         :return: height of bounding box in pixels
         :rtype: int
 
         :seealso: :meth:`w` :meth:`ltrb`
         """
-        return self.dict['height']
+        return self.dict["height"]
 
     @property
     def ltrb(self):
         """
         Word bounding box
 
         :return: bounding box [left top right bottom] in pixels
         :rtype: list
 
         :seealso: :meth:`l` :meth:`t` :meth:`w` :meth:`h`
         """
         return [
-            self.dict['left'], self.dict['top'], 
-            self.dict['left'] + self.dict['width'],
-            self.dict['top'] + self.dict['height']
+            self.dict["left"],
+            self.dict["top"],
+            self.dict["left"] + self.dict["width"],
+            self.dict["top"] + self.dict["height"],
         ]
 
     @property
     def conf(self):
         """
         Word confidence
 
         :return: confidence of word (percentage)
         :rtype: int
 
         :seealso: :meth:`text`
         """
-        return self.dict['conf']
-    
+        return self.dict["conf"]
+
     @property
     def text(self):
         """
         Word as a string
 
         :return: word
         :rtype: str
 
         :seealso: :meth:`conf`
         """
-        return self.dict['text']
+        return self.dict["text"]
 
     def plot(self):
         """
         Plot word and bounding box
 
         Plot a label box around the word in the image, and show the OCR string
         in the label field.
 
         :seealso: :func:`~machinevisiontoolbox.base.graphics.plot_labelbox`
         """
         plot_labelbox(
             self.text,
             tl=(self.l, self.t),
             wh=(self.w, self.h),
-            color='y',
-            linestyle='--')
+            color="y",
+            linestyle="--",
+        )
 
 
 class Fiducial:
-
     def __init__(self, id, corners, K=None, rvec=None, tvec=None):
         """
         Properties of a visual fiducial marker
 
         :param id: identity of the marker
         :type id: int
         :param corners: image plane marker corners
         :type corners: ndarray(2, 4)
         :param K: camera intrinsics
         :type K: ndarray(3,3), optional
         :param rvec: translation of marker with respect to camera, as an Euler vector
         :type rvec: ndarray(3), optional
-        :param tvec: translation of marker with respect to camera 
+        :param tvec: translation of marker with respect to camera
         :type tvec: ndarray(3), optional
 
         :seealso: :meth:`id` :meth:`pose` :meth:`draw`
             :meth:`~machinevisiontoolbox.ImageFeatures.ImageFeaturesMixin.fiducial`
         """
         self._id = id
-        self.corners =  corners  # strip first dimensions
+        self.corners = corners  # strip first dimensions
         self.K = K
         self._pose = SE3(tvec) * SE3.EulerVec(rvec.flatten())
         self.rvec = rvec
         self.tvec = tvec
 
     def __str__(self):
         """
@@ -678,60 +684,60 @@
         :raises ValueError: image must have BGR color order
 
         Draws a coordinate frame into the image representing the pose of the
         marker.  The x-, y- and z-axes are drawn as red, green and blue line
         segments.
         """
         if not image.isbgr:
-            raise ValueError('image must have BGR color order')
-        cv.drawFrameAxes(image.A, self.K, np.array([]), self.rvec, self.tvec, length, thick)
+            raise ValueError("image must have BGR color order")
+        cv.drawFrameAxes(
+            image.A, self.K, np.array([]), self.rvec, self.tvec, length, thick
+        )
+
 
 if __name__ == "__main__":
 
     from machinevisiontoolbox import Image
+
     im = Image.Read("castle.png")
     mser = im.MSER()
     print(len(mser))
     print(mser)
     m0 = mser[0]
     print(m0)
     print(m0.bbox.shape)
     print(m0.bbox)
 
     print(m0.points.shape)
     print(m0.points)
 
-    
     mm = mser[:5]
     print(mm)
     print(mm.bbox.shape)
     print(mm.bbox)
     print(len(mm))
     print(mm.points)
 
-
     k = np.arange(len(mser)) < 5
     mm = mser[k]
     print(mm)
     print(mm.bbox.shape)
     print(mm.bbox)
     print(len(mm))
     print(mm.points)
 
-
-    k = [0,2,1,3,4]
+    k = [0, 2, 1, 3, 4]
     mm = mser[k]
     print(mm)
     print(mm.bbox.shape)
     print(mm.bbox)
     print(len(mm))
     print(mm.points)
 
-
-    k = np.array([0,2,1,3,4])
+    k = np.array([0, 2, 1, 3, 4])
     mm = mser[k]
     print(mm)
     print(mm.bbox.shape)
     print(mm.bbox)
     print(len(mm))
     print(mm.points)
-    pass
+    pass
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageReshape.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageReshape.py`

 * *Files 9% similar despite different names*

```diff
@@ -22,25 +22,24 @@
 from machinevisiontoolbox.base import meshgrid, spherical_rotate, idisp, name2color
 import matplotlib.pyplot as plt
 from spatialmath import base as smb
 from spatialmath import SE2
 from matplotlib.widgets import RectangleSelector
 
 _interp_dict = {
+    "nearest": cv.INTER_NEAREST,  # nearest neighbor interpolation
+    "linear": cv.INTER_LINEAR,  # bilinear interpolation
+    "cubic": cv.INTER_CUBIC,  # bicubic interpolation
+    "area": cv.INTER_AREA,  # esampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire'-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.
+    "Lanczos": cv.INTER_LANCZOS4,  # Lanczos interpolation over 8x8 neighborhood
+    "linear exact": cv.INTER_LINEAR_EXACT,  # Bit exact bilinear interpolation
+}
 
-'nearest': cv.INTER_NEAREST, # nearest neighbor interpolation
-'linear': cv.INTER_LINEAR, #bilinear interpolation
-'cubic': cv.INTER_CUBIC, # bicubic interpolation
-'area': cv.INTER_AREA, #esampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire'-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.
-'Lanczos': cv.INTER_LANCZOS4, #Lanczos interpolation over 8x8 neighborhood
-'linear exact': cv.INTER_LINEAR_EXACT, # Bit exact bilinear interpolation
-    }
 
 class ImageReshapeMixin:
-
     def trim(self, left=0, right=0, top=0, bottom=0):
         """
         Trim pixels from the edges of the image
 
         :param left: number of pixels to trim from left side of image, defaults to 0
         :type left: int, optional
         :param right: number of pixels to trim from right side of image, defaults to 0
@@ -58,23 +57,29 @@
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png')
             >>> img
             >>> img.trim(left=100, bottom=100)
+
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            img = Image.Read('flowers1.png').trim(left=100, bottom=100).disp()
+
         """
         image = self.A
-        y = slice(top, self.height-bottom)
+        y = slice(top, self.height - bottom)
         x = slice(left, self.width - right)
         if self.iscolor:
             image = image[y, x, :]
         else:
             image = image[y, x]
-        
+
         return self.__class__(image, colororder=self.colororder)
 
     def pad(self, left=0, right=0, top=0, bottom=0, value=0):
         """
         Pad the edges of the image
 
         :param left: number of pixels to pad on left side of image, defaults to 0
@@ -97,20 +102,25 @@
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('flowers1.png', dtype='float')
             >>> img
             >>> img.pad(left=10, bottom=10, top=10, right=10, value='r')
 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            img = Image.Read('flowers1.png', dtype='float').pad(left=10, bottom=10, top=10, right=10, value='r').disp()
+
         """
-        pw = ((top,bottom),(left,right))
+        pw = ((top, bottom), (left, right))
         if isinstance(value, str):
             value = self.like(name2color(value))
         if self.nplanes != len(value):
-            raise ValueError('value not compatible with image')
+            raise ValueError("value not compatible with image")
 
         planes = []
         for i, v in enumerate(value):
             planes.append(np.pad(self.plane(i).image, pw, constant_values=(v, v)))
         out = np.dstack(planes)
 
         return self.__class__(out, colororder=self.colororder)
@@ -142,15 +152,15 @@
     #     :seealso: :meth:`vcat`
     #     """
 
     #     if isinstance(pos[0], (tuple, list)):
     #         images = pos[0]
     #     else:
     #         images = pos
-        
+
     #     height = max([image.height for image in images])
 
     #     nplanes = images[0].nplanes
     #     if not all([image.nplanes == nplanes for image in images]):
     #         raise ValueError('all images must have same number of planes')
     #     dtype = images[0].dtype
     #     if not all([image.dtype == dtype for image in images]):
@@ -177,42 +187,42 @@
     #             if image.height < height:
     #                 image = np.pad(image.image, ((0, height - image.height), (0, 0), (0, 0)),
     #                     constant_values=(pad,0))
     #             else:
     #                 image = image.image
     #             u.append(combo.shape[1])
     #             combo = np.hstack((combo, image))
-        
+
     #     if return_offsets:
     #         return cls(combo), u
     #     else:
     #         return cls(combo)
 
     # @classmethod
     # def vcat(cls, *pos, pad=0, return_offsets=False):
 
     #     if isinstance(pos[0], (tuple, list)):
     #         images = pos[0]
     #     else:
     #         images = pos
-        
+
     #     width = max([image.width for image in images])
 
     #     combo = np.empty(shape=(0, width))
 
     #     v = []
     #     for image in images:
     #         if image.width < width:
     #             image = np.pad(image.image, ((width - image.width, 0), (0, 0)),
     #                 constant_values=(pad, 0))
     #         else:
     #             image = image.image
     #         v.append(combo.shape[0])
     #         combo = np.vstack((combo, image))
-        
+
     #     if return_offsets:
     #         return cls(combo), v
     #     else:
     #         return cls(combo)
 
     @classmethod
     def Hstack(cls, images, sep=1, bgcolor=None, return_offsets=False):
@@ -247,41 +257,50 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('street.png')
             >>> img
             >>> Image.Hstack((img, img, img))
             >>> Image.Hstack((img, img, img), return_offsets=True)
 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            img = Image.Read('street.png')
+            Image.Hstack((img, img, img)).disp()
+
+
         :seealso: :meth:`Vstack` :meth:`Tile`
         """
         width = (len(images) - 1) * sep
         height = 0
         colororder = None
         for image in images:
             width += image.shape[1]
             if image.shape[0] > height:
                 height = image.shape[0]
             if image.iscolor:
                 if colororder is not None:
                     if colororder != image.colororder:
-                        raise ValueError('all tiles must have same color order')
+                        raise ValueError("all tiles must have same color order")
                 colororder = image.colororder
             if image.dtype != images[0].dtype:
-                raise ValueError('all tiles must have same dtype')
-            #TODO check if colororder matches
+                raise ValueError("all tiles must have same dtype")
+            # TODO check if colororder matches
 
         if bgcolor is None:
             if colororder is None:
                 bgcolor = 0
             else:
-                bgcolor = [0,] * len(colororder)
+                bgcolor = [
+                    0,
+                ] * len(colororder)
         canvas = cls.Constant(width, height, bgcolor, dtype=images[0].dtype)
         # if colororder is not None:
         #     canvas = canvas.colorize(colororder=colororder)
-        
+
         width = 0
         u = []
         for image in images:
             u.append(width)
             if colororder is not None and not image.iscolor:
                 image = image.colorize(colororder=colororder)
             canvas.paste(image, (width, 0))
@@ -325,55 +344,63 @@
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('street.png')
             >>> img
             >>> Image.Vstack((img, img, img))
             >>> Image.Vstack((img, img, img), return_offsets=True)
 
+        .. plot::
+
+            from machinevisiontoolbox import Image
+            img = Image.Read('street.png')
+            Image.Hstack((img, img, img)).disp()
+
         :seealso: :meth:`Hstack` :meth:`Tile`
         """
         height = (len(images) - 1) * sep
         width = 0
         colororder = None
         for image in images:
             height += image.shape[0]
             if image.shape[1] > width:
                 width = image.shape[1]
             if image.iscolor:
                 if colororder is not None:
                     if colororder != image.colororder:
-                        raise ValueError('all tiles must have same color order')
+                        raise ValueError("all tiles must have same color order")
                 colororder = image.colororder
             if image.dtype != images[0].dtype:
-                raise ValueError('all tiles must have same dtype')
-            #TODO check if colororder matches
+                raise ValueError("all tiles must have same dtype")
+            # TODO check if colororder matches
 
         if bgcolor is None:
             if colororder is None:
                 bgcolor = 0
             else:
-                bgcolor = [0,] * len(colororder)
+                bgcolor = [
+                    0,
+                ] * len(colororder)
         canvas = cls.Constant(width, height, bgcolor, dtype=images[0].dtype)
         # if colororder is not None:
         #     canvas = canvas.colorize(colororder=colororder)
-        
+
         height = 0
         v = []
         for image in images:
             v.append(height)
             if colororder is not None and not image.iscolor:
                 image = image.colorize(colororder=colororder)
             canvas.paste(image, (0, height))
             height += image.shape[0] + sep
 
         if return_offsets:
             return cls(canvas, colororder=colororder), v
         else:
             return cls(canvas, colororder=colororder)
-    
+
     @classmethod
     def Tile(cls, tiles, columns=4, sep=2, bgcolor=None):
         """
         Tile images into a grid
 
         :param tiles: images to tile
         :type tiles: iterable of :class:`Image`
@@ -385,60 +412,69 @@
         :type bgcolor: scalar, string, array_like, optional
         :raises ValueError: all images must have the same size
         :raises ValueError: all images must have the same dtype
         :return: grid of images
         :rtype: :class:`Image` instance
 
         Construct a new image by tiling the input images into a grid.
-        
+
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image, ImageCollection
             >>> images = ImageCollection('campus/*.png')  # image iterator
             >>> Image.Tile(images)
 
+        .. plot::
+
+            from machinevisiontoolbox import Image, ImageCollection
+            images = ImageCollection('campus/*.png')  # image iterator
+            Image.Tile(images).disp()
+
         :seealso: :meth:`Hstack` :meth:`Vstack`
         """
         # exemplars, shape=(-1, columns), **kwargs)
 
         # TODO tile a sequence into specified shape
 
         shape = tiles[0].shape
         colororder = tiles[0].colororder
         for tile in tiles[1:]:
             if tile.shape != shape:
-                raise ValueError('all tiles must be same size')
+                raise ValueError("all tiles must be same size")
             if tile.dtype != tiles[0].dtype:
-                raise ValueError('all tiles must have same dtype')
+                raise ValueError("all tiles must have same dtype")
 
         nrows = int(np.ceil(len(tiles) / columns))
         if bgcolor is None:
             if colororder is None:
                 bgcolor = 0
             else:
-                bgcolor = [0,] * len(colororder)
+                bgcolor = [
+                    0,
+                ] * len(colororder)
         canvas = cls.Constant(
-                    columns * shape[1] + (columns - 1) * sep,
-                    nrows * shape[0] + (nrows - 1) * sep,
-                    bgcolor,
-                    dtype=tiles[0].dtype)
+            columns * shape[1] + (columns - 1) * sep,
+            nrows * shape[0] + (nrows - 1) * sep,
+            bgcolor,
+            dtype=tiles[0].dtype,
+        )
         if len(shape) == 3:
             canvas = canvas.colorize(colororder=colororder)
 
         v = 0
         iterator = iter(tiles)
         try:
             while True:
                 u = 0  # start new column
                 for c in range(columns):
                     # for each column
                     im = next(iterator)
-                    canvas.paste(im, (u, v), 'set', 'topleft')
+                    canvas.paste(im, (u, v), "set", "topleft")
                     u += shape[1] + sep
                 v += shape[0] + sep
         except StopIteration:
             # ran out of images
             pass
 
         return canvas
@@ -452,28 +488,29 @@
         :param sigma: standard deviation for Gaussian kernel smoothing, defaults to None
         :type sigma: float, optional
         :raises ValueError: decimation factor m must be an integer
         :return: decimated image
         :rtype: :class:`Image`
 
         Return a decimated version of the image whose size is
-        reduced by subsampling every ``m`` (an integer) pixels in both dimensions.  
-        
+        reduced by subsampling every ``m`` (an integer) pixels in both dimensions.
+
         The image is smoothed
         with a Gaussian kernel with standard deviation ``sigma``.  If
 
         - ``sigma`` is None then  a value of ``m/2`` is used,
         - ``sigma`` is zero then no smoothing is performed.
 
         :note:
 
             - If the image has multiple planes, each plane is decimated.
-            - Smoothing is used to eliminate aliasing artifacts and the
-              standard deviation should be chosen as a function of the maximum
-              spatial frequency in the image.
+            - Smoothing is applied to the image _before_ decimation to reduce
+              high-spatial-frequency components and reduce eliminate aliasing
+              artifacts.  The standard deviation should be chosen as a function
+              of the maximum spatial-frequency in the image.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Random(6)
@@ -482,53 +519,54 @@
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.7.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`replicate` :meth:`scale`
         """
         if (m - np.ceil(m)) != 0:
-            raise ValueError(m, 'decimation factor m must be an integer')
+            raise ValueError(m, "decimation factor m must be an integer")
 
         if sigma is None:
             sigma = m / 2
 
         # smooth image
         if sigma > 0:
             ims = self.smooth(sigma)
         else:
             ims = self
 
-        return self.__class__(ims.image[0:-1:m, 0:-1:m, ...], colororder=self.colororder)
-
+        return self.__class__(
+            ims.image[0:-1:m, 0:-1:m, ...], colororder=self.colororder
+        )
 
     def replicate(self, n=1):
         r"""
         Replicate image pixels
 
         :param n: replication factor, defaults to 1
         :type n: int, optional
         :return: image with replicated pixels
         :rtype: :class:`Image`
 
-        Create an image where each input pixel becomes an :math:`n \times n` 
+        Create an image where each input pixel becomes an :math:`n \times n`
         patch of pixel values. This is a simple way of upscaling an image.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Random(5)
             >>> img.print()
             >>> bigger = img.replicate(2)
             >>> bigger.print()
 
         :note:
             - Works only for greyscale images.
-            - The resulting image is "blocky", apply Gaussian smoothing to 
+            - The resulting image is "blocky", apply Gaussian smoothing to
               reduce this.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.7.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`decimate`
         """
@@ -549,15 +587,15 @@
         :type bbox: array_like(4)
         :return: region of interest, optional bounding box
         :rtype: :class:`Image`, list
 
         Return the specified region of the image.  If ``bbox`` is None the image
         is displayed using Matplotlib and the user can interactively select the
         region, returning the image region and the bounding box ``[umin, umax,
-        vmin, vmax]``. 
+        vmin, vmax]``.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('monalisa.png')
@@ -569,40 +607,52 @@
 
             def line_select_callback(eclick, erelease, roi):
                 # called on rectangle release
                 roi.extend([eclick.xdata, erelease.xdata, eclick.ydata, erelease.ydata])
                 plt.gcf().canvas.stop_event_loop()  # unblock
 
             roi = []
-            rs = RectangleSelector(plt.gca(), lambda e1, e2: line_select_callback(e1, e2, roi),
-                                                drawtype='box', useblit=True,
-                                                button=[1, 3],  # don't use middle button
-                                                minspanx=5, minspany=5,
-                                                spancoords='pixels',
-                                                interactive=True)
+            rs = RectangleSelector(
+                plt.gca(),
+                lambda e1, e2: line_select_callback(e1, e2, roi),
+                drawtype="box",
+                useblit=True,
+                button=[1, 3],  # don't use middle button
+                minspanx=5,
+                minspany=5,
+                spancoords="pixels",
+                interactive=True,
+            )
             rs.set_active(True)
-            plt.gcf().canvas.start_event_loop(timeout=-1)  # block till rectangle released
+            plt.gcf().canvas.start_event_loop(
+                timeout=-1
+            )  # block till rectangle released
             rs.set_active(False)
             roi = np.round(np.r_[roi]).astype(int)  # roound to nearest int
         else:
             # get passed vector
             roi = smb.getvector(bbox, 4, dtype=int)
 
         left, right, top, bot = roi
         if left >= right or top >= bot:
-            raise ValueError('ROI should be top-left and bottom-right corners')
+            raise ValueError("ROI should be top-left and bottom-right corners")
         # TODO check row/column ordering, and ndim check
-        
+
         if self.ndim > 2:
-            roi = self.image[top:bot+1, left:right+1, :]
+            roi = self.image[top : bot + 1, left : right + 1, :]
         else:
-            roi = self.image[top:bot+1, left:right+1]
+            roi = self.image[top : bot + 1, left : right + 1]
 
         if bbox is None:
-            return self.__class__(roi, colororder=self.colororder), [left, right, top, bot]
+            return self.__class__(roi, colororder=self.colororder), [
+                left,
+                right,
+                top,
+                bot,
+            ]
         else:
             return self.__class__(roi, colororder=self.colororder)
 
     def samesize(self, image2, bias=0.5):
         """
         Automatic image trimming
 
@@ -631,20 +681,20 @@
             >>> foreground
             >>> background = Image.Read("road.png", dtype="float")
             >>> background
             >>> background.samesize(foreground)
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.4.1.1, P. Corke, Springer 2023.
-        
+
         :seealso: :meth:`trim` :meth:`scale`
         """
         # check inputs
         if bias < 0 or bias > 1:
-            raise ValueError(bias, 'bias must be in range [0, 1]')
+            raise ValueError(bias, "bias must be in range [0, 1]")
 
         im = self.image
 
         sc = np.r_[image2.shape[:2]] / np.r_[im.shape[:2]]
         o = self.scale(sc.max())
 
         if o.height > image2.width:  # rows then columns
@@ -673,16 +723,16 @@
         :param sigma: standard deviation of kernel for image smoothing, in pixels
         :type sigma: float
         :raises ValueError: bad interpolation string
         :raises ValueError: bad interpolation value
         :return: smoothed image
         :rtype: :class:`Image` instance
 
-        Rescale the image. If ``sfactor> 1`` the image is enlarged. 
-        
+        Rescale the image. If ``sfactor> 1`` the image is enlarged.
+
         If ``sfactor < 1`` the image is made smaller and smoothing can be
         applied to reduce sampling artefacts. If ``sigma`` is None, use default
         for scale by sigma=1/sfactor/2. If ``sigma=0`` perform no smoothing.
 
         =============  ====================================
         interpolation  description
         =============  ====================================
@@ -703,48 +753,47 @@
         :references:
             - Robotics, Vision & Control for Python, Section 11.7.2, P. Corke, Springer 2023.
 
         :seealso: `opencv.resize <https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d>`_
         """
         # check inputs
         if not smb.isscalar(sfactor):
-            raise TypeError(sfactor, 'factor is not a scalar')
+            raise TypeError(sfactor, "factor is not a scalar")
 
         if interpolation is None:
             if sfactor > 1:
                 interpolation = cv.INTER_CUBIC
             else:
                 interpolation = cv.INTER_CUBIC
         elif isinstance(interpolation, str):
-            if interpolation == 'cubic':
+            if interpolation == "cubic":
                 interpolation = cv.INTER_CUBIC
-            elif interpolation == 'linear':
+            elif interpolation == "linear":
                 interpolation = cv.INTER_LINEAR
-            elif interpolation == 'area':
+            elif interpolation == "area":
                 interpolation = cv.INTER_AREA
             else:
-                raise ValueError('bad interpolation string')
+                raise ValueError("bad interpolation string")
         else:
-            raise TypeError('bad interpolation value')
+            raise TypeError("bad interpolation value")
 
         if sfactor < 1:
             if sigma is None:
                 sigma = 1 / sfactor / 2
             if sigma > 0:
                 im = self.smooth(sigma)
         else:
             im = self
-        out = cv.resize(im.image, None, fx=sfactor, fy=sfactor, 
-            interpolation=interpolation)
+        out = cv.resize(
+            im.image, None, fx=sfactor, fy=sfactor, interpolation=interpolation
+        )
 
         return self.__class__(out, colororder=self.colororder)
 
-    def rotate(self,
-               angle,
-               centre=None):
+    def rotate(self, angle, centre=None):
         """
         Rotate an image
 
         :param angle: rotatation angle [radians]
         :type angle: scalar
         :param centre: centre of rotation, defaults to centre of image
         :type centre: array_like(2)
@@ -770,32 +819,30 @@
 
         """
         # TODO note that there is cv.getRotationMatrix2D and cv.warpAffine
         # https://appdividend.com/2020/09/24/how-to-rotate-an-image-in-python-
         # using-opencv/
 
         if not smb.isscalar(angle):
-            raise ValueError(angle, 'angle is not a valid scalar')
+            raise ValueError(angle, "angle is not a valid scalar")
 
         # TODO check optional inputs
 
-
         if centre is None:
             centre = (self.width / 2, self.height / 2)
         elif len(centre) != 2:
-            raise ValueError('centre must be length 2')
+            raise ValueError("centre must be length 2")
 
         shape = (self.width, self.height)
 
         M = cv.getRotationMatrix2D(centre, np.degrees(angle), 1.0)
 
         out = cv.warpAffine(self.A, M, shape)
         return self.__class__(out, colororder=self.colororder)
 
-
     def rotate_spherical(self, R):
         r"""
         Rotate a spherical image
 
         :param R: an SO(3) rotation matrix
         :type R: :class:`spatialmath.pose3d.SO3`
         :return: rotated spherical image
@@ -811,15 +858,15 @@
         :seealso: :meth:`meshgrid` :meth:`uspan` :meth:`vspan` :func:`scipy.interpolate.griddata`
         """
         Phi, Theta = self.meshgrid(*self.domain)
         nPhi, nTheta = spherical_rotate(Phi, Theta, R)
 
         # warp the image
         return self.interp2d(nPhi, nTheta, domain=self.domain)
-        
+
     # ======================= interpolate ============================= #
 
     def meshgrid(self=None, width=None, height=None, step=1):
         """
         Coordinate arrays for image
 
         :param width: width of array in pixels, defaults to width of image
@@ -828,15 +875,15 @@
         :type height: int, optional
         :return: domain of image
         :rtype u: ndarray(H,W), ndarray(H,W)
 
         Create a pair of arrays ``U`` and ``V`` that describe the domain of the
         image. The element ``U(u,v) = u`` and ``V(u,v) = v``. These matrices can
         be used for the evaluation of functions over the image such as
-        interpolation and warping. 
+        interpolation and warping.
 
         Invoking as a class method with ``self=None`` is a convenient way to
         access ``base.meshgrid``.
 
         Example:
 
         .. runblock:: pycon
@@ -851,18 +898,18 @@
             >>> U
 
         :seealso: :func:`~machinevisiontoolbox.base.meshgrid.meshgrid`
         """
         if self is not None:
             u = self.uspan(step)
             v = self.vspan(step)
-        else:                
+        else:
             u = np.arange(0, width, step)
             v = np.arange(0, height, step)
-        
+
         return np.meshgrid(u, v)
 
     def warp(self, U, V, interp=None, domain=None):
         r"""
         Image warping
 
         :param U: u-coordinate array for output image
@@ -894,15 +941,17 @@
             umin = self.domain[0][0]
             umax = self.domain[0][-1]
             vmin = self.domain[1][0]
             vmax = self.domain[1][-1]
             U = (U - umin) / (umax - umin) * self.A.shape[1]
             V = (V - vmin) / (vmax - vmin) * self.A.shape[0]
 
-        img = cv.remap(self.A, U.astype("float32"), V.astype("float32"), cv.INTER_LINEAR)
+        img = cv.remap(
+            self.A, U.astype("float32"), V.astype("float32"), cv.INTER_LINEAR
+        )
         return self.__class__(img, colororder=self.colororder, domain=domain)
 
     def interp2d(self, U, V, Ud=None, Vd=None, **kwargs):
         r"""
         Image warping
 
         :param U: u-coordinate array for output image
@@ -936,15 +985,15 @@
             else:
                 Ud, Vd = np.meshgrid(*self.domain)
 
         points = np.array((Ud.flatten(), Vd.flatten())).T
         values = self.image.flatten()
         xi = np.array((U.flatten(), V.flatten())).T
         Zi = sp.interpolate.griddata(points, values, xi)
-        
+
         return self.__class__(Zi.reshape(U.shape), **kwargs)
 
     # TODO, this should be warp_affine
     def warp_affine(self, M, inverse=False, size=None, bgcolor=None):
         r"""
         Affine warp of image
 
@@ -980,33 +1029,44 @@
         :note: Only the first two rows of ``M`` are used.
 
         :seealso: :meth:`warp` `opencv.warpAffine <https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983>`_
         """
         flags = cv.INTER_CUBIC
         if inverse:
             flags |= cv.WARP_INVERSE_MAP
-        
+
         # TODO interpolation flags
-        
+
         if size is None:
             size = self.size
 
         if bgcolor is not None:
             bordermode = cv.BORDER_CONSTANT
-            bordervalue = [bgcolor,] * self.nplanes
+            bordervalue = [
+                bgcolor,
+            ] * self.nplanes
         else:
             bordermode = None
             bordervalue = None
 
         if isinstance(M, SE2):
             M = M.A
-        out = cv.warpAffine(src=self.image, M=M[:2, :], dsize=size, flags=flags, borderMode=bordermode, borderValue=bordervalue)
+        out = cv.warpAffine(
+            src=self.image,
+            M=M[:2, :],
+            dsize=size,
+            flags=flags,
+            borderMode=bordermode,
+            borderValue=bordervalue,
+        )
         return self.__class__(out, colororder=self.colororder)
 
-    def warp_perspective(self, H, method='linear', inverse=False, tile=False, size=None):
+    def warp_perspective(
+        self, H, method="linear", inverse=False, tile=False, size=None
+    ):
         r"""
         Perspective warp
 
         :param H: homography
         :type H: ndarray(3,3)
         :param method: interpolation mode: 'linear' [default], 'nearest'
         :type method: str, optional
@@ -1016,55 +1076,49 @@
         :type tile: bool, optional
         :param size: size of output image, defaults to size of input image
         :type size: array_like(2), optional
         :raises TypeError: H must be a 3x3 NumPy array
         :return: warped image
         :rtype: :class:`Image`
 
-        Applies a perspective warp to the input image.  
-        
+        Applies a perspective warp to the input image.
+
         .. math:: Y_{u,v} = X_{u^\prime, v^\prime} \mbox{, where } u^\prime=\frac{\tilde{u}}{\tilde{w}}, v^\prime=\frac{\tilde{v}}{\tilde{w}}, \begin{pmatrix} \tilde{u} \\ \tilde{v} \\ \tilde{w} \end{pmatrix} = \mat{H} \begin{pmatrix} u \\ v \\ 1 \end{pmatrix}
 
         The resulting image may
         be smaller or larger than the input image.  If ``tile`` is True then
         the output image is the smallest rectangle that contains the warped
         result, and its position with respect to the origin of the input image,
         and the coordinates of the four corners of the input image.
 
         :references:
             - Robotics, Vision & Control for Python, Section 14.8, P. Corke, Springer 2023.
 
         :seealso: :meth:`warp` `opencv.warpPerspective <https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87>`_
         """
 
-        if not (isinstance(H, np.ndarray) and H.shape == (3,3)):
-            raise TypeError('H must be a 3x3 NumPy array')
+        if not (isinstance(H, np.ndarray) and H.shape == (3, 3)):
+            raise TypeError("H must be a 3x3 NumPy array")
         if size is None:
             size = self.size
-        
+
         if tile:
-            corners = np.array([
-                [0, size[0], size[0],  0],
-                [0, 0,        size[1], size[1]]
-            ])
+            corners = np.array([[0, size[0], size[0], 0], [0, 0, size[1], size[1]]])
             if inverse:
                 # can't use WARP_INVERSE_MAP if we want to compute the output
                 # tile
                 H = np.linalg.inv(H)
                 inverse = False
             wcorners = smb.h2e(H @ smb.e2h(corners))
             tl = np.floor(wcorners.min(axis=1)).astype(int)
             br = np.ceil(wcorners.max(axis=1)).astype(int)
             size = br - tl
-            H = smb.transl2(-tl)  @ H
+            H = smb.transl2(-tl) @ H
 
-        warp_dict = {
-            'linear': cv.INTER_LINEAR,
-            'nearest': cv.INTER_NEAREST
-        }
+        warp_dict = {"linear": cv.INTER_LINEAR, "nearest": cv.INTER_NEAREST}
         flags = warp_dict[method]
         if inverse:
             flags |= cv.WARP_INVERSE_MAP
         out = cv.warpPerspective(src=self.A, M=H, dsize=tuple(size), flags=flags)
 
         if tile:
             return self.__class__(out), tl, wcorners
@@ -1099,31 +1153,29 @@
             >>> distortion = np.array([ -0.293, 0.1077, 0.00131, -3.109e-05, 0.04348])
             >>> out = images[12].undistort(K, distortion)
             >>> out.disp()
 
         :seealso: :meth:`~machinevisiontoolbox.CentralCamera.images2C` `opencv.undistort <https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#ga69f2545a8b62a6b0fc2ee060dc30559d>`_
         """
         undistorted = cv.undistort(self.image, K, dist)
-        return self.__class__(undistorted, colororder=self.colororder)   
+        return self.__class__(undistorted, colororder=self.colororder)
 
-
-
-     # ------------------------- operators ------------------------------ #
+    # ------------------------- operators ------------------------------ #
 
     def column(self):
-        raise DeprecationWarning('please use view1d')
+        raise DeprecationWarning("please use view1d")
 
     def view1d(self):
         """
         Convert image to a column view
 
         :return: column view
         :rtype: ndarray(N,) or ndarray(N, np)
 
-        A greyscale image is converted to a 1D array in row-major (C) order, 
+        A greyscale image is converted to a 1D array in row-major (C) order,
         ie. row 0, row 1 etc.
 
         A color image is converted to a 2D array in row-major (C) order, with
         one row per pixel, and each row is the pixel value, the values of its
         planes.
 
         Example:
@@ -1138,15 +1190,15 @@
             the column will affect the original image.
         """
         image = self.image
         if image.ndim == 2:
             return image.ravel()
         elif image.ndim == 3:
             return image.reshape((-1, self.nplanes))
-            
+
     # def col2im(col, im):
     #     """
     #     Convert pixel vector to image
 
     #     :param col: set of pixel values
     #     :type col: numpy array, shape (N, P)
     #     :param im: image
@@ -1198,21 +1250,22 @@
     #     if nc > 1:
     #         sz = np.hstack((sz, nc))
 
     #     # reshape:
     #     # TODO need to test this
     #     return np.reshape(col, sz)
 
+
 if __name__ == "__main__":
 
     from machinevisiontoolbox import Image, ImageCollection
     from math import pi
-    
+
     mona = Image.Read("monalisa.png")
-    z = Image.Hstack([mona, mona.smooth(sigma=5)]) #.disp(block=True)
+    z = Image.Hstack([mona, mona.smooth(sigma=5)])  # .disp(block=True)
     z.disp()
     pass
 
     # images = ImageCollection('campus/*.png')  # image iterator
     # Image.Tile(images)
     # im = Image.Read('flowers1.png', dtype='float')
     # im.pad(left=10, bottom=10, top=10, right=10, value='r').disp(block=True)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageSpatial.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageSpatial.py`

 * *Files 2% similar despite different names*

```diff
@@ -26,15 +26,15 @@
         :rtype: ndarray(2h+1, 2h+1)
 
         Return the 2-dimensional Gaussian kernel of standard deviation ``sigma``
 
         .. math::
 
             \mathbf{K} = \frac{1}{2\pi \sigma^2} e^{-(u^2 + v^2) / 2 \sigma^2}
-        
+
         The kernel is centred within a square array with side length given by:
 
         - :math:`2 \mbox{ceil}(3 \sigma) + 1`, or
         - :math:`2 \mathtt{h} + 1`
 
         Example:
 
@@ -45,15 +45,15 @@
             >>> K.shape
             >>> K
             >>> K = Kernel.Gauss(sigma=2)
             >>> K.shape
 
         :note:
             - The volume under the Gaussian kernel is one.
-            - If the kernel is strongly truncated, ie. it is non-zero at the 
+            - If the kernel is strongly truncated, ie. it is non-zero at the
               edges of the window then the volume will be less than one.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.1.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`DGauss`
         """
@@ -61,16 +61,19 @@
         # make sure sigma, w are valid input
         if h is None:
             h = np.ceil(3 * sigma)
 
         wi = np.arange(-h, h + 1)
         x, y = np.meshgrid(wi, wi)
 
-        m = 1.0 / (2.0 * np.pi * sigma ** 2) * \
-            np.exp(-(x ** 2 + y ** 2) / 2.0 / sigma ** 2)
+        m = (
+            1.0
+            / (2.0 * np.pi * sigma**2)
+            * np.exp(-(x**2 + y**2) / 2.0 / sigma**2)
+        )
         # area under the curve should be 1, but the discrete case is only
         # an approximation
         return m / np.sum(m)
 
     @staticmethod
     def Laplace():
         r"""
@@ -166,18 +169,18 @@
 
         Return the 2-dimensional difference of Gaussian kernel defined by two
         standard deviation values:
 
         .. math::
 
             \mathbf{K} = G(\sigma_1) - G(\sigma_2)
-            
-        where :math:`\sigma_1 > \sigma_2`. 
-        By default, :math:`\sigma_2 = 1.6 \sigma_1`. 
-        
+
+        where :math:`\sigma_1 > \sigma_2`.
+        By default, :math:`\sigma_2 = 1.6 \sigma_1`.
+
         The kernel is centred within a square array with side length given by:
 
         - :math:`2 \mbox{ceil}(3 \sigma) + 1`, or
         - :math:`2\mathtt{h} + 1`
 
         Example:
 
@@ -255,17 +258,20 @@
         """
 
         if h is None:
             h = np.ceil(3.0 * sigma)
         wi = np.arange(-h, h + 1)
         x, y = np.meshgrid(wi, wi)
 
-        log = 1.0 / (np.pi * sigma ** 4.0) * \
-            ((x ** 2 + y ** 2) / (2.0 * sigma ** 2) - 1) * \
-            np.exp(-(x **2 + y** 2) / (2.0 * sigma ** 2))
+        log = (
+            1.0
+            / (np.pi * sigma**4.0)
+            * ((x**2 + y**2) / (2.0 * sigma**2) - 1)
+            * np.exp(-(x**2 + y**2) / (2.0 * sigma**2))
+        )
 
         # ensure that the mean is zero, for a truncated kernel this may not
         # be the case
         log -= log.mean()
 
         return log
 
@@ -312,19 +318,23 @@
         """
         if h is None:
             h = np.ceil(3.0 * sigma)
 
         wi = np.arange(-h, h + 1)
         x, y = np.meshgrid(wi, wi)
 
-        return -x / sigma ** 2 / (2.0 * np.pi) * \
-            np.exp(-(x ** 2 + y ** 2) / 2.0 / sigma ** 2)
+        return (
+            -x
+            / sigma**2
+            / (2.0 * np.pi)
+            * np.exp(-(x**2 + y**2) / 2.0 / sigma**2)
+        )
 
     @staticmethod
-    def Circle(radius, h=None, normalize=False, dtype='uint8'):
+    def Circle(radius, h=None, normalize=False, dtype="uint8"):
         r"""
         Circular structuring element
 
         :param radius: radius of circular structuring element
         :type radius: scalar, array_like(2)
         :param h: half-width of kernel
         :type h: int
@@ -339,15 +349,15 @@
         to as a tophat kernel. Values inside the circle are set to one,
         outside are set to zero.
 
         If ``radius`` is a 2-element vector the result is an annulus of ones,
         and the two numbers are interpretted as inner and outer radii
         respectively.
 
-        The kernel is centred within a square array with side length given 
+        The kernel is centred within a square array with side length given
         by :math:`2\mathtt{h} + 1`.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Kernel
@@ -377,22 +387,22 @@
         s = np.zeros((int(w), int(w)), dtype=dtype)
         c = np.floor(w / 2.0)
 
         if not argcheck.isscalar(radius):
             # circle case
             x = np.arange(w) - c
             X, Y = np.meshgrid(x, x)
-            r2 = (X ** 2 + Y ** 2)
+            r2 = X**2 + Y**2
             ll = np.where((r2 >= rmin**2) & (r2 <= rmax**2))
             s[ll] = 1
         else:
             # annulus case
             x = np.arange(w) - c
             X, Y = np.meshgrid(x, x)
-            ll = np.where(np.round((X ** 2 + Y ** 2 - radius ** 2) <= 0))
+            ll = np.where(np.round((X**2 + Y**2 - radius**2) <= 0))
             s[ll] = 1
 
         if normalize:
             k /= np.sum(k)
         return s
 
     @staticmethod
@@ -405,15 +415,15 @@
         :param normalize: normalize volume of kernel to one, defaults to True
         :type normalize: bool, optional
         :return: kernel
         :rtype: ndarray(2h+1, 2h+1)
 
         Returns a square kernel with unit volume.
 
-        The kernel is centred within a square array with side length given 
+        The kernel is centred within a square array with side length given
         by :math:`2\mathtt{h} + 1`.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Kernel
@@ -429,115 +439,115 @@
         wi = 2 * h + 1
         k = np.ones((wi, wi))
         if normalize:
             k /= np.sum(k)
 
         return k
 
-class ImageSpatialMixin:
 
+class ImageSpatialMixin:
     @staticmethod
     def _bordertype_cv(border, exclude=None):
         """
         Border handling options for OpenCV
 
-        :param border: border handling option, one of: 'constant', 'replicate', 
+        :param border: border handling option, one of: 'constant', 'replicate',
             'reflect', 'mirror', 'wrap', 'pad', 'none'
         :type border: str
         :param exclude: list of excluded values, defaults to None
         :type exclude: list or tuple, optional
         :raises ValueError: ``border`` value is not valid
         :raises ValueError: ``border`` value is excluded
         :return: OpenCV key
         :rtype: int
 
         Map an MVTB border handling key to the OpenCV flag value
         """
 
         # border options:
         border_opt = {
-            'constant':    cv.BORDER_CONSTANT,
-            'replicate':   cv.BORDER_REPLICATE,
-            'reflect':     cv.BORDER_REFLECT,
-            'mirror':      cv.BORDER_REFLECT_101,
-            'reflect_101': cv.BORDER_REFLECT_101,
-            'wrap':        cv.BORDER_WRAP,
-            'pad':         cv.BORDER_CONSTANT,
-            'none':        cv.BORDER_ISOLATED,
+            "constant": cv.BORDER_CONSTANT,
+            "replicate": cv.BORDER_REPLICATE,
+            "reflect": cv.BORDER_REFLECT,
+            "mirror": cv.BORDER_REFLECT_101,
+            "reflect_101": cv.BORDER_REFLECT_101,
+            "wrap": cv.BORDER_WRAP,
+            "pad": cv.BORDER_CONSTANT,
+            "none": cv.BORDER_ISOLATED,
         }
         if exclude is not None and border in exclude:
-            raise ValueError('border option not supported')
+            raise ValueError("border option not supported")
 
         try:
             return border_opt[border]
         except KeyError:
-            raise ValueError(border, 'border is not a valid option')
+            raise ValueError(border, "border is not a valid option")
 
     # border options:
     _border_opt = {
-        'constant':   cv.BORDER_CONSTANT,
-        'replicate':  cv.BORDER_REPLICATE,
-        'reflect':    cv.BORDER_REFLECT,
-        'mirror':     cv.BORDER_REFLECT_101,
-        'wrap':       cv.BORDER_WRAP,
-        'pad':        cv.BORDER_CONSTANT,
-        'none':       cv.BORDER_ISOLATED,
+        "constant": cv.BORDER_CONSTANT,
+        "replicate": cv.BORDER_REPLICATE,
+        "reflect": cv.BORDER_REFLECT,
+        "mirror": cv.BORDER_REFLECT_101,
+        "wrap": cv.BORDER_WRAP,
+        "pad": cv.BORDER_CONSTANT,
+        "none": cv.BORDER_ISOLATED,
     }
 
     @staticmethod
     def _border_args_cv(border, morpho=False, allow=None, disallow=None):
         if disallow is not None and border in disallow:
             raise ValueError(f"border option {border} not supported")
         if allow is not None and border not in allow:
             raise ValueError(f"border option {border} not supported")
-        
+
         if isinstance(border, str):
             # given as string, convert to OpenCV flag value
             try:
                 return dict(borderType=_border_opt[border])
             except KeyError:
-                raise ValueError(border, 'border is not a valid option')
+                raise ValueError(border, "border is not a valid option")
         elif isinstance(border, int) or isinstance(border, float):
             # given as a numeric value, assume 'pad'
-            return dict(bordertype=_border_opt['pad'], borderValu=border_value)
+            return dict(bordertype=_border_opt["pad"], borderValu=border_value)
 
     @staticmethod
     def _bordertype_sp(border, exclude=None):
         """
         Border handling options for SciPy
 
-        :param border: border handling option, one of: 'constant', 'replicate', 
+        :param border: border handling option, one of: 'constant', 'replicate',
             'reflect', 'mirror', 'wrap'
         :type border: str
         :param exclude: list of excluded values, defaults to None
         :type exclude: list or tuple, optional
         :raises ValueError: ``border`` value is not valid
         :raises ValueError: ``border`` value is excluded
         :return: SciPy key
         :rtype: str
 
         Map an MVTB border handling key to the SciPy ndimage flag value
         """
         # border options:
         border_opt = {
-            'constant':   'constant',
-            'replicate':  'nearest',
-            'reflect':    'reflect',
-            'mirror':     'mirror',
-            'wrap':       'wrap',
+            "constant": "constant",
+            "replicate": "nearest",
+            "reflect": "reflect",
+            "mirror": "mirror",
+            "wrap": "wrap",
         }
         if exclude is not None and border in exclude:
-            raise ValueError('border option not supported')
+            raise ValueError("border option not supported")
 
         try:
             return border_opt[border]
         except KeyError:
-            raise ValueError(border, 'border is not a valid option')
+            raise ValueError(border, "border is not a valid option")
 
-    def smooth(self, sigma, h=None, mode='same', border='reflect', bordervalue=0):
+    def smooth(self, sigma, h=None, mode="same", border="reflect", bordervalue=0):
         r"""
         Smooth image
 
         :param sigma: standard deviation of the Gaussian kernel
         :type sigma: float
         :param h: half-width of the kernel
         :type h: int
@@ -571,22 +581,22 @@
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`machinevisiontoolbox.Kernel.Gauss` :meth:`convolve`
         """
 
         if not argcheck.isscalar(sigma):
-            raise ValueError(sigma, 'sigma must be a scalar')
+            raise ValueError(sigma, "sigma must be a scalar")
 
         # make the smoothing kernel
         K = Kernel.Gauss(sigma, h)
 
         return self.convolve(K, mode=mode, border=border, bordervalue=bordervalue)
 
-    def convolve(self, K, mode='same', border='reflect', bordervalue=0):
+    def convolve(self, K, mode="same", border="reflect", bordervalue=0):
         """
         Image convolution
 
         :param K: kernel
         :type K: ndarray(N,M)
         :param mode: option for convolution, defaults to 'same'
         :type mode: str, optional
@@ -598,15 +608,15 @@
         :rtype: :class:`Image` instance
 
         Computes the convolution of image with the kernel ``K``.
 
         There are two options that control what happens at the edge of the image
         where the convolution window lies outside the image border.  ``mode``
         controls the size of the resulting image, while ``border`` controls how
-        pixel values are extrapolated outside the image border. 
+        pixel values are extrapolated outside the image border.
 
         ===========   ===========================================================================
         ``mode``      description
         ===========   ===========================================================================
         ``'same'``    output image is same size as input image (default)
         ``'full'``    output image is larger than the input image, add border to input image
         ``'valid'``   output image is smaller than the input image and contains only valid pixels
@@ -631,56 +641,59 @@
             >>> import numpy as np
             >>> img = Image.Read('monalisa.png')
             >>> img.convolve(K=np.ones((11,11))).disp()
 
         :note:
             - The kernel is typically square with an odd side length.
             - The result has the same datatype as the input image.  For a kernel
-              where the results could be negative (eg. edge detection kernel) 
+              where the results could be negative (eg. edge detection kernel)
               this will cause issues such as value wraparound.
             - If the image is color (has multiple planes) the kernel is
               applied to each plane, resulting in an output image with the same
               number of planes.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.1, P. Corke, Springer 2023.
 
         :seealso: :class:`Kernel` :meth:`smooth` :func:`opencv.filter2D` :func:`opencv.copyMakeBorder`
         """
 
         if isinstance(K, self.__class__):
             K = K.A
 
-        K = argcheck.getmatrix(K, shape=[None,None], dtype='float32')
+        K = argcheck.getmatrix(K, shape=[None, None], dtype="float32")
 
         # OpenCV does correlation, not convolution, so we flip the kernel
         # to compensate.  Flip horizontally and vertically.
         K = np.flip(K)
         kh, kw = K.shape
         kh //= 2
         kw //= 2
 
         # TODO check images are of the same type
 
         # TODO check opt is valid string based on conv2 options
-        modeopt = ['valid', 'same', 'full']
+        modeopt = ["valid", "same", "full"]
 
         if mode not in modeopt:
-            raise ValueError(mode, 'opt is not a valid option')
+            raise ValueError(mode, "opt is not a valid option")
 
         img = self.A
         if border == "pad" and value != 0:
-            img = cv.copyMakeBorder(a, kv, kv, kh, kh, 
-                    cv.BORDER_CONSTANT, value=bordervalue)
+            img = cv.copyMakeBorder(
+                a, kv, kv, kh, kh, cv.BORDER_CONSTANT, value=bordervalue
+            )
         elif mode == "full":
-            img = cv.copyMakeBorder(a, kv, kv, kh, kh, 
-                    self._bordertype_cv(border), value=bordervalue)
+            img = cv.copyMakeBorder(
+                a, kv, kv, kh, kh, self._bordertype_cv(border), value=bordervalue
+            )
 
-        out = cv.filter2D(img, ddepth=-1, kernel=K, 
-            borderType=self._bordertype_cv(border))
+        out = cv.filter2D(
+            img, ddepth=-1, kernel=K, borderType=self._bordertype_cv(border)
+        )
 
         if mode == "valid":
             if out.ndim == 2:
                 out = out[kh:-kh, kw:-kw]
             else:
                 out = out[kh:-kh, kw:-kw, :]
         return self.__class__(out, colororder=self.colororder)
@@ -689,17 +702,15 @@
     #     if kernel is None:
     #         kernel = Kernel.Sobel()
 
     #     Iu = self.convolve(kernel)
     #     Iv = self.convolve(kernel.T)
     #     return Iu, Iv
 
-
-
-    def gradients(self, kernel=None, mode='same', border='reflect', bordervalue=0):
+    def gradients(self, kernel=None, mode="same", border="reflect", bordervalue=0):
         """
         Compute horizontal and vertical gradients
 
         :param kernel: derivative kerne, defaults to Sobel
         :type kernel: 2D ndarray, optional
         :param mode: option for convolution, see :meth:`convolve`, defaults to 'same'
         :type mode: str, optional
@@ -728,15 +739,17 @@
         if kernel is None:
             kernel = Kernel.Sobel()
 
         Iu = self.convolve(kernel, mode=mode, border=border, bordervalue=bordervalue)
         Iv = self.convolve(kernel.T, mode=mode, border=border, bordervalue=bordervalue)
         return Iu, Iv
 
-    def direction(horizontal, vertical):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
+    def direction(
+        horizontal, vertical
+    ):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
         r"""
         Gradient direction
 
         :param im: vertical gradient image
         :type im: :class:`Image`
         :return: gradient direction in radians
         :rtype: :class:`Image`
@@ -759,15 +772,15 @@
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.1.3, P. Corke, Springer 2023.
 
         :seealso: :meth:`gradients`
         """
         if horizontal.shape != vertical.shape:
-            raise ValueError('images must the same shape')
+            raise ValueError("images must the same shape")
         return horizontal.__class__(np.arctan2(vertical.A, horizontal.A))
 
     def Harris_corner_strength(self, k=0.04, h=2):
         """
         Harris corner strength image
 
         :param k: Harris parameter, defaults to 0.04
@@ -785,15 +798,15 @@
             - Robotics, Vision & Control for Python, Section 12.3.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`gradients` :meth:`Harris`
         """
         dst = cv.cornerHarris(self.mono().image, 2, 2 * h + 1, k)
         return self.__class__(dst)
 
-    def window(self, func, h=None, se=None, border='reflect', bordervalue=0, **kwargs):
+    def window(self, func, h=None, se=None, border="reflect", bordervalue=0, **kwargs):
         r"""
         Generalized spatial operator
 
         :param func: function applied to window
         :type func: callable
         :param h: half width of structuring element
         :type h: int, optional
@@ -810,20 +823,20 @@
         :rtype: :class:`Image`
 
         Returns an image where each pixel is the result of applying the function
         ``func`` to a neighbourhood centred on the corresponding pixel in image.
         The return value of ``func`` becomes the corresponding pixel value.
 
         The neighbourhood is defined in two ways:
-        
+
         - If ``se`` is given then it is the the size of the structuring element
           ``se`` which should have odd side lengths. The elements in the
           neighbourhood corresponding to non-zero elements in ``se`` are packed
           into a vector (in column order from top left) and passed to the
-          specified callable function ``func``. 
+          specified callable function ``func``.
         - If ``se`` is None then ``h`` is the half width of a :math:`w \times
           w` square structuring element of ones, where :math:`w =2h+1`.
 
         Example:
 
         .. runblock:: pycon
 
@@ -840,38 +853,40 @@
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.3, P. Corke, Springer 2023.
 
         :seealso: :func:`scipy.ndimage.generic_filter`
         """
         # replace window's mex function with scipy's ndimage.generic_filter
         if self.iscolor:
-            raise ValueError('single channel images only')
+            raise ValueError("single channel images only")
 
         if not callable(func):
-            raise TypeError(func, 'func not callable')
+            raise TypeError(func, "func not callable")
 
         if h is not None and se is None:
             w = 2 * h + 1
             se = np.ones((w, w))
 
-        out = sp.ndimage.generic_filter(self.A,
-                                            func,
-                                            footprint=se,
-                                            mode=self._bordertype_sp(border),
-                                            cval=bordervalue)
+        out = sp.ndimage.generic_filter(
+            self.A,
+            func,
+            footprint=se,
+            mode=self._bordertype_sp(border),
+            cval=bordervalue,
+        )
         return self.__class__(out)
 
     def zerocross(self):
         """
         Compute zero crossing
 
         :return: boolean image
         :rtype: :class:`Image` instance
-            
-        Compute a zero-crossing image, where pixels are true if they are adjacent to 
+
+        Compute a zero-crossing image, where pixels are true if they are adjacent to
         a change in sign.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -884,19 +899,19 @@
             lead to erroneous values in border pixels.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.1.3, P. Corke, Springer 2023.
 
         :seealso: :meth:`Laplace` :meth:`LoG`
         """
-        min = cv.morphologyEx(self.image, cv.MORPH_ERODE, np.ones((3,3)))
-        max = cv.morphologyEx(self.image, cv.MORPH_DILATE, np.ones((3,3)))
+        min = cv.morphologyEx(self.image, cv.MORPH_ERODE, np.ones((3, 3)))
+        max = cv.morphologyEx(self.image, cv.MORPH_DILATE, np.ones((3, 3)))
         zeroCross = np.logical_or(
-            np.logical_and(min < 0, self.image > 0), 
-            np.logical_and(max > 0, self.image < 0)
+            np.logical_and(min < 0, self.image > 0),
+            np.logical_and(max > 0, self.image < 0),
         )
         return self.__class__(zeroCross)
 
         # modeopt = {
         #     'full': 'full',
         #     'valid': 'valid',
         #     'same': 'same'
@@ -994,29 +1009,28 @@
     #         ir2 = np.zeros((M * nr, M * nc), dtype=im.dtype)
     #         for c in range(M):
     #             ir2[:, c:-1:M] = ir
     #         out.append(ir2)
 
     #     return self.__class__(out)
 
-
     def scalespace(self, n, sigma=1):
         """
         Compute image scalespace sequence
 
         :param n: number of steps
         :type n: omt
         :param sigma: Gaussian filter width, defaults to 1
         :type sigma: scalar, optional
         :return: Gaussian and difference of Gaussian sequences, scale factors
         :rtype: list of :class:`Image`, list of :class:`Image`, list of float
 
         Compute a scalespace image sequence by consecutively smoothing the input
         image with a Gaussian of width ``sigma``.  The difference between
-        consecutive smoothings is the difference of Gaussian which is an 
+        consecutive smoothings is the difference of Gaussian which is an
         approximation to the Laplacian of Gaussian.
 
         Examples::
 
             >>> mona = Image.Read("monalisa.png", dtype="float");
             >>> G, L, scales = mona.scalespace(8, sigma=8);
 
@@ -1030,25 +1044,25 @@
         """
         im = self.copy()
         g = [im]
         scale = 0.5
         scales = [scale]
         lap = []
 
-        for i in range(n-1):
+        for i in range(n - 1):
             im = im.smooth(sigma)
-            scale = np.sqrt(scale ** 2 + sigma ** 2)
+            scale = np.sqrt(scale**2 + sigma**2)
             scales.append(scale)
             g.append(im)
-            x = (g[-1] - g[-2]) * scale ** 2 
+            x = (g[-1] - g[-2]) * scale**2
             lap.append(x)
 
         return g, lap, scales
 
-    def pyramid(self, sigma=1, N=None, border='replicate', bordervalue=0):
+    def pyramid(self, sigma=1, N=None, border="replicate", bordervalue=0):
         """
         Pyramidal image decomposition
 
         :param sigma: standard deviation of Gaussian kernel
         :type sigma: float
         :param N: number of pyramid levels to be computed, defaults to all
         :type N: int, optional
@@ -1084,23 +1098,24 @@
         :seealso: :meth:`smooth` :meth:`scalespace`
         """
 
         # check inputs, greyscale only
         im = self.mono()
 
         if not argcheck.isscalar(sigma):
-            raise ValueError(sigma, 'sigma must be a scalar')
+            raise ValueError(sigma, "sigma must be a scalar")
 
         if N is None:
             N = max(im.shape)
         else:
-            if (not argcheck.isscalar(N)) and (N >= 0) and \
-               (N <= max(im.shape)):
-                raise ValueError(N, 'N must be a scalar and \
-                    0 <= N <= max(im.shape)')
+            if (not argcheck.isscalar(N)) and (N >= 0) and (N <= max(im.shape)):
+                raise ValueError(
+                    N,
+                    "N must be a scalar and 0 <= N <= max(im.shape)",
+                )
 
         # TODO options to accept different border types,
         # note that the Matlab implementation is hard-coded to 'same'
 
         # return cv.buildPyramid(im, N, borderType=cv.BORDER_REPLICATE)
         # Python version does not seem to be implemented
 
@@ -1108,21 +1123,23 @@
         # TODO pyr = [cv.pyrdown(inputs(i)) for i in range(N) if conditional]
 
         impyr = im.image
         pyr = [impyr]
         for i in range(N):
             if impyr.shape[0] == 1 or impyr.shape[1] == 1:
                 break
-            impyr = cv.pyrDown(impyr, borderType=self._bordertype_cv(border, exclude=('constant')))
+            impyr = cv.pyrDown(
+                impyr, borderType=self._bordertype_cv(border, exclude="constant")
+            )
             pyr.append(impyr)
 
         # output list of Image objects
         pyrimlist = [self.__class__(p) for p in pyr]
         return pyrimlist
-        
+
     def canny(self, sigma=1, th0=None, th1=None):
         """
         Canny edge detection
 
         :param sigma: standard deviation for Gaussian kernel smoothing, defaults to 1
         :type sigma: float, optional
         :param th0: lower threshold
@@ -1161,15 +1178,15 @@
         """
 
         # convert to greyscale:
         img = self.mono()
 
         # set defaults (eg thresholds, eg one as a function of the other)
         if th0 is None:
-            if np.issubdtype(th0, np.float):
+            if np.issubdtype(th0, np.floating):
                 th0 = 0.1
             else:
                 # isint
                 th0 = np.round(0.1 * np.iinfo(img.dtype).max)
         if th1 is None:
             th1 = 1.5 * th0
 
@@ -1183,22 +1200,22 @@
 
         # Ix, Iy must be 16-bit input image
         Ix = np.array(Ix.A, dtype=np.int16)
         Iy = np.array(Iy.A, dtype=np.int16)
 
         v = np.mean(self.A)
         # apply automatic Canny edge detection using the computed median
-        lower = (max(0, (1.0 - sigma) * v))
-        upper = (min(1, (1.0 + sigma) * v))
+        lower = max(0, (1.0 - sigma) * v)
+        upper = min(1, (1.0 + sigma) * v)
 
         out = cv.Canny(self.to_int(), lower, upper, L2gradient=False)
 
         return self.__class__(out)
 
-    def rank(self, footprint=None, h=None, rank=-1, border='replicate', bordervalue=0):
+    def rank(self, footprint=None, h=None, rank=-1, border="replicate", bordervalue=0):
         r"""
         Rank filter
 
         :param footprint: filter footprint or structuring element
         :type footprint: ndarray(N,M), optional
         :param h: half width of structuring element
         :type h: int, optional
@@ -1215,15 +1232,15 @@
         non-zero elements of the structuring element are ranked, and the value
         that is ``rank`` in rank becomes the corresponding output pixel value.
         The highest rank, the maximum, is rank 0.  The rank can also be given
         as a string: 'min|imumum', 'max|imum', 'med|ian', long or short versions
         are supported.
 
         The structuring element is given as:
-        
+
             - ``footprint`` a 2D Numpy array containing zero or one values, or
             - ``h`` which is the half width :math:`w=2h+1` of an array of ones
 
         Example:
 
         .. runblock:: pycon
 
@@ -1247,34 +1264,33 @@
         :seealso: :obj:`scipy.ndimage.rank_filter`
         """
         if h is not None:
             w = 2 * h + 1
             footprint = np.ones((w, w))
 
         n = np.sum(footprint)
-            
+
         if isinstance(rank, str):
-            if rank in ('min', 'minimum'):
+            if rank in ("min", "minimum"):
                 rank = n - 1
-            elif rank in ('max', 'maximum'):
+            elif rank in ("max", "maximum"):
                 rank = 0
-            elif rank in ('med', 'median'):
+            elif rank in ("med", "median"):
                 rank = n // 2
         elif not isinstance(rank, int):
-            raise TypeError(rank, 'rank must be int or str')
+            raise TypeError(rank, "rank must be int or str")
 
         if rank < 0:
-            raise ValueError('rank must be >= 0')
+            raise ValueError("rank must be >= 0")
 
         r = int(footprint.sum() - rank - 1)
 
-        out = sp.ndimage.rank_filter(self.A,
-                                    r,
-                                    footprint=footprint,
-                                    mode=self._bordertype_sp(border))
+        out = sp.ndimage.rank_filter(
+            self.A, r, footprint=footprint, mode=self._bordertype_sp(border)
+        )
         return self.__class__(out)
 
     def medianfilter(self, h=1, **kwargs):
         r"""
         Median filter
 
         :param h: half width of structuring element, defaults to 1
@@ -1304,15 +1320,15 @@
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.3, P. Corke,
               Springer 2023.
 
         :seealso: :meth:`rank`
         """
         w = 2 * h + 1
-        r = int((w ** 2 - 1) / 2)
+        r = int((w**2 - 1) / 2)
         return self.rank(h=h, rank=r, **kwargs)
 
     def distance_transform(self, invert=False, norm="L2", h=1):
         """
         Distance transform
 
         :param invert: consider inverted image, defaults to False
@@ -1337,23 +1353,23 @@
             >>> pixels[2, 1:3] = 1
             >>> img = Image(pixels)
             >>> img.distance_transform().print(precision=3)
             >>> img.distance_transform(norm="L1").print()
 
         :note:
             - The output image is the same size as the input image.
-            - Distance is computed using a sliding window and is an 
+            - Distance is computed using a sliding window and is an
               approximation of true distance.
             - For non-zero input pixels the corresponding output pixels are set
               to zero.
             - The signed-distance function is ``image.distance_transform() - image.distance_transform(invert=True)``
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.6.4, P. Corke, Springer 2023.
-        
+
         :seealso: `opencv.distanceTransform <https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#ga8a0b7fdfcb7a13dde018988ba3a43042>`_
         """
         # OpenCV does distance to nearest zero pixel
         # this function does distance to nearest non-zero pixel by default,
         # and the OpenCV thing if invert=True
         if invert:
             # distance to nearest zero pixel
@@ -1363,20 +1379,20 @@
             im = self.invert().to_int()
 
         normdict = {
             "L1": cv.DIST_L1,
             "L2": cv.DIST_L2,
         }
 
-        out = cv.distanceTransform(im, distanceType=normdict[norm], maskSize=2*h+1)
+        out = cv.distanceTransform(im, distanceType=normdict[norm], maskSize=2 * h + 1)
         return self.__class__(out)
 
     # ======================= labels ============================= #
 
-    def labels_binary(self, connectivity=4, ltype='int32'):
+    def labels_binary(self, connectivity=4, ltype="int32"):
         """
         Blob labelling
 
         :param connectivity: number of neighbours used for connectivity: 4 [default] or 8
         :type connectivity: int, optional
         :param ltype: output image type: 'int32' [default], 'uint16'
         :type ltype: string, optional
@@ -1385,15 +1401,15 @@
 
         Compute labels of connected components in the input greyscale or binary
         image. Regions are sets of contiguous pixels with the same value.
 
         The method returns the label image and the number of labels N, so labels
         lie in the range [0, N-1].The value in the label image in an integer
         indicating which region the corresponding input pixel belongs to.  The
-        background has label 0.  
+        background has label 0.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Squares(2, 15)
@@ -1412,38 +1428,35 @@
             - 8-way connectivity introduces ambiguities, a chequerboard is
               two blobs.
 
         :references:
             - Robotics, Vision & Control for Python, Section 12.1.2.1, P. Corke, Springer 2023.
 
         :seealso: :meth:`blobs` `cv2.connectedComponents <https://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#gaedef8c7340499ca391d459122e51bef5>`_
-            :meth:`labels_graphseg` :meth:`labels_MSER` 
+            :meth:`labels_graphseg` :meth:`labels_MSER`
         """
         if not (connectivity in [4, 8]):
-            raise ValueError(conn, 'connectivity must be 4 or 8')
+            raise ValueError(conn, "connectivity must be 4 or 8")
 
         # make labels uint32s, unique and never recycled?
         # set ltype to default to cv.CV_32S
-        if ltype == 'int32':
+        if ltype == "int32":
             ltype = cv.CV_32S
             dtype = np.int32
-        elif ltype == 'uint16':
+        elif ltype == "uint16":
             ltype = cv.CV_16U
             dtype = np.uint16
         else:
-            raise TypeError(ltype, 'ltype must be either int32 or uint16')
+            raise TypeError(ltype, "ltype must be either int32 or uint16")
 
         retval, labels = cv.connectedComponents(
-            image=self.to_int(),
-            connectivity=connectivity,
-            ltype=ltype
+            image=self.to_int(), connectivity=connectivity, ltype=ltype
         )
         return self.__class__(labels), retval
 
-
     def labels_MSER(self, **kwargs):
         """
         Blob labelling using MSER
 
         :param kwargs: arguments passed to ``MSER_create``
         :return: label image, number of regions
         :rtype: :class:`Image`, int
@@ -1451,15 +1464,15 @@
         Compute labels of connected components in the input greyscale image.
         Regions are sets of contiguous pixels that form stable regions across a
         range of threshold values.
 
         The method returns the label image and the number of labels N, so labels
         lie in the range [0, N-1].The value in the label image in an integer
         indicating which region the corresponding input pixel belongs to.  The
-        background has label 0.  
+        background has label 0.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Squares(2, 15)
@@ -1479,21 +1492,21 @@
 
         mser = cv.MSER_create(**kwargs)
         regions, _ = mser.detectRegions(self.to_int())
 
         if len(regions) < 256:
             dtype = np.uint8
         else:
-            dtype=np.uint32
+            dtype = np.uint32
 
         out = np.zeros(self.shape, dtype=dtype)
 
         for i, points in enumerate(regions):
             # print('region ', i, points.shape[0])
-            out[points[:,1], points[:,0]] = i
+            out[points[:, 1], points[:, 0]] = i
 
         return self.__class__(out, dtype=dtype), len(regions)
 
     def labels_graphseg(self, sigma=0.5, k=2000, minsize=100):
         """
         Blob labelling using graph-based segmentation
 
@@ -1504,36 +1517,32 @@
         Compute labels of connected components in the input color image. Regions
         are sets of contiguous pixels that are similar with respect to their
         surrounds.
 
         The method returns the label image and the number of labels N, so labels
         lie in the range [0, N-1].The value in the label image in an integer
         indicating which region the corresponding input pixel belongs to.  The
-        background has label 0.  
+        background has label 0.
 
         :references:
             - Efficient graph-based image segmentation,
               Pedro F Felzenszwalb and Daniel P Huttenlocher,
               volume 59, pages 167–181. Springer, 2004.
             - Robotics, Vision & Control for Python, Section 12.1.2.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`labels_binary` :meth:`labels_MSER` :meth:`blobs` `opencv.createGraphSegmentation <https://docs.opencv.org/3.4/d5/df0/group__ximgproc__segmentation.html#ga5e3e721c5f16e34d3ad52b9eeb6d2860>`_
         """
         # P. Felzenszwalb, D. Huttenlocher: "Graph-Based Image Segmentation
         segmenter = cv.ximgproc.segmentation.createGraphSegmentation(
-            sigma=0.5,
-            k=2000,
-            min_size=100)
+            sigma=0.5, k=2000, min_size=100
+        )
         out = segmenter.processImage(self.to_int())
 
         return self.__class__(out), np.max(out) + 1
 
-
-
-
     # -------------------- similarity operations -------------------------- #
 
     def sad(image1, image2):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
         """
         Sum of absolute differences
 
         :param image2: second image
@@ -1563,20 +1572,20 @@
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`zsad` :meth:`ssd` :meth:`ncc`
         """
 
         if not np.all(image1.shape == image2.shape):
-            raise ValueError('image2 shape is not equal to image1')
+            raise ValueError("image2 shape is not equal to image1")
 
         # out = []
         # for im in self:
-            # m = np.abs(im.image - image2.image)
-            # out.append(np.sum(m))
+        # m = np.abs(im.image - image2.image)
+        # out.append(np.sum(m))
         m = np.abs(image1.image - image2.image)
         out = np.sum(m)
         return out
 
     def ssd(image1, image2):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
         """
         Sum of squared differences
@@ -1608,15 +1617,15 @@
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`zssd` :meth:`sad` :meth:`ncc`
         """
 
         if not np.all(image1.shape == image2.shape):
-            raise ValueError('image2 shape is not equal to image1')
+            raise ValueError("image2 shape is not equal to image1")
         m = np.power((image1.image - image2.image), 2)
         return np.sum(m)
 
     def ncc(image1, image2):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
         """
         Normalised cross correlation
 
@@ -1638,34 +1647,36 @@
             >>> from machinevisiontoolbox import Image
             >>> img1 = Image([[10, 11], [12, 13]])
             >>> img2 = Image([[10, 11], [10, 13]])
             >>> img1.ncc(img2)
             >>> img1.ncc(img2+10)
             >>> img1.ncc(img2*2)
 
-        :note: 
+        :note:
             - The ``ncc`` similarity measure is invariant to scale changes in
               image intensity.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`zncc` :meth:`sad` :meth:`ssd`
         """
         if not np.all(image1.shape == image2.shape):
-            raise ValueError('image2 shape is not equal to image1')
+            raise ValueError("image2 shape is not equal to image1")
 
-        denom = np.sqrt(np.sum(image1.image ** 2) * np.sum(image2.image ** 2))
+        denom = np.sqrt(np.sum(image1.image**2) * np.sum(image2.image**2))
 
         if denom < 1e-10:
             return 0
         else:
             return np.sum(image1.image * image2.image) / denom
 
-    def zsad(image1, image2):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
+    def zsad(
+        image1, image2
+    ):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
         """
         Zero-mean sum of absolute differences
 
         :param image2: second image
         :type image2: :class:`Image`
         :raises ValueError: image2 shape is not equal to self
         :return: sum of absolute differences
@@ -1684,32 +1695,34 @@
             >>> from machinevisiontoolbox import Image
             >>> img1 = Image([[10, 11], [12, 13]])
             >>> img2 = Image([[10, 11], [10, 13]])
             >>> img1.zsad(img2)
             >>> img1.zsad(img2+10)
             >>> img1.zsad(img2*2)
 
-        :note: 
+        :note:
             - The ``zsad`` similarity measure is invariant to changes in image
               brightness offset.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`zsad` :meth:`ssd` :meth:`ncc`
         """
         if not np.all(image1.shape == image2.shape):
-            raise ValueError('image2 shape is not equal to image1')
+            raise ValueError("image2 shape is not equal to image1")
 
         image1 = image1.image - np.mean(image1.image)
         image2 = image2.image - np.mean(image2.image)
         m = np.abs(image1 - image2)
         return np.sum(m)
 
-    def zssd(image1, image2):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
+    def zssd(
+        image1, image2
+    ):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
         """
         Zero-mean sum of squared differences
 
         :param image2: second image
         :type image2: :class:`Image`
         :raises ValueError: image2 shape is not equal to self
         :return: sum of squared differences
@@ -1727,33 +1740,35 @@
             >>> from machinevisiontoolbox import Image
             >>> img1 = Image([[10, 11], [12, 13]])
             >>> img2 = Image([[10, 11], [10, 13]])
             >>> img1.zssd(img2)
             >>> img1.zssd(img2+10)
             >>> img1.zssd(img2*2)
 
-        :note: 
+        :note:
             - The ``zssd`` similarity measure is invariant to changes in image
               brightness offset.
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`zssd` :meth:`sad` :meth:`ncc`
         """
 
         if not np.all(image1.shape == image2.shape):
-            raise ValueError('image2 shape is not equal to image1')
+            raise ValueError("image2 shape is not equal to image1")
 
         image1 = image1.image - np.mean(image1.image)
         image2 = image2.image - np.mean(image2.image)
         m = np.power(image1 - image2, 2)
         return np.sum(m)
 
-    def zncc(image1, image2):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
+    def zncc(
+        image1, image2
+    ):  # lgtm[py/not-named-self] pylint: disable=no-self-argument
         """
         Zero-mean normalized cross correlation
 
         :param image2: second image
         :type image2: :class:`Image`
         :raises ValueError: image2 shape is not equal to self
         :return: normalised cross correlation
@@ -1771,39 +1786,37 @@
             >>> from machinevisiontoolbox import Image
             >>> img1 = Image([[10, 11], [12, 13]])
             >>> img2 = Image([[10, 11], [10, 13]])
             >>> img1.zncc(img2)
             >>> img1.zncc(img2+10)
             >>> img1.zncc(img2*2)
 
-        :note: 
+        :note:
             - The ``zncc`` similarity measure is invariant to affine changes (offset and scale factor)
               in image intensity (brightness offset and scale).
 
         :references:
             - Robotics, Vision & Control for Python, Section 11.5.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`zncc` :meth:`sad` :meth:`ssd`
         """
 
         if not np.all(image1.shape == image2.shape):
-            raise ValueError('image2 shape is not equal to image1')
+            raise ValueError("image2 shape is not equal to image1")
 
         image1 = image1.image - np.mean(image1.image)
         image2 = image2.image - np.mean(image2.image)
-        denom = np.sqrt(np.sum(np.power(image1, 2) *
-                               np.sum(np.power(image2, 2))))
+        denom = np.sqrt(np.sum(np.power(image1, 2) * np.sum(np.power(image2, 2))))
 
         if denom < 1e-10:
             return 0
         else:
             return np.sum(image1 * image2) / denom
-            
 
-    def similarity(self, T, metric='zncc'):
+    def similarity(self, T, metric="zncc"):
         """
         Locate template in image
 
         :param T: template image
         :type T: ndarray(N,M)
         :param metric: similarity metric, one of: 'ssd', 'zssd', 'ncc', 'zncc' [default]
         :type metric: str
@@ -1838,46 +1851,44 @@
             - Robotics, Vision & Control for Python, Section 11.5.2, P. Corke, Springer 2023.
 
         :seealso: `cv2.matchTemplate <https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#ga586ebfb0a7fb604b35a23d85391329be>`_
         """
 
         # check inputs
         if ((T.shape[0] % 2) == 0) or ((T.shape[1] % 2) == 0):
-            raise ValueError('template T must have odd dimensions')
+            raise ValueError("template T must have odd dimensions")
 
         metricdict = {
-            'ssd': cv.TM_SQDIFF,
-            'zssd': cv.TM_SQDIFF,
-            'ncc': cv.TM_CCOEFF_NORMED,
-            'zncc': cv.TM_CCOEFF_NORMED
+            "ssd": cv.TM_SQDIFF,
+            "zssd": cv.TM_SQDIFF,
+            "ncc": cv.TM_CCOEFF_NORMED,
+            "zncc": cv.TM_CCOEFF_NORMED,
         }
 
         im = self.A
         T_im = T.A
-        if metric[0] == 'z':
+        if metric[0] == "z":
             T_im -= np.mean(T_im)  # remove offset from template
             im = im - np.mean(im)  # remove offset from image
 
         try:
             out = cv.matchTemplate(im, T_im, method=metricdict[metric])
         except KeyError:
-            raise ValueError('bad metric specified')
+            raise ValueError("bad metric specified")
         return self.__class__(out)
 
 
-
-
 # --------------------------------------------------------------------------#
-if __name__ == '__main__':
+if __name__ == "__main__":
     from machinevisiontoolbox import *
 
-    img = Image(np.array(np.tile(np.r_[-2, -1, 1, 2, 3], (4,1))), dtype='float')
+    img = Image(np.array(np.tile(np.r_[-2, -1, 1, 2, 3], (4, 1))), dtype="float")
     img.zerocross().A
 
-    print('ImageProcessingKernel.py')
+    print("ImageProcessingKernel.py")
     from machinevisiontoolbox import *
 
-    print(Kernel.Circle([2,3]))
+    print(Kernel.Circle([2, 3]))
 
-    image = Image.Read('monalisa.png', grey=True)
+    image = Image.Read("monalisa.png", grey=True)
     blur = image.convolve(Kernel.Gauss(5))
     blur.disp(block=True)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/ImageWholeFeatures.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/ImageWholeFeatures.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 from matplotlib.patches import Polygon
 from matplotlib.ticker import ScalarFormatter
 
 import cv2 as cv
 from spatialmath import base, SE3
 from machinevisiontoolbox.base import findpeaks, findpeaks2d
 
+
 class ImageWholeFeaturesMixin:
-    
     def hist(self, nbins=256, opt=None):
         """
         Image histogram
 
         :param nbins: number of histogram bins, defaults to 256
         :type nbins: int, optional
         :param opt: histogram option
@@ -67,69 +67,68 @@
 
         :seealso:
             :class:`~machinevisiontoolbox.ImageWholeFeatures.Histogram`
             `opencv.calcHist <https://docs.opencv.org/3.4/d6/dc7/group__imgproc__hist.html#ga4b2b5fd75503ff9e6844cc4dcdaed35d>`_
         """
 
         # check inputs
-        optHist = ['sorted']
+        optHist = ["sorted"]
         if opt is not None and opt not in optHist:
-            raise ValueError(opt, 'opt is not a valid option')
+            raise ValueError(opt, "opt is not a valid option")
 
         if self.isint:
             xrange = [0, np.iinfo(self.dtype).max]
         else:
             # float image
             xrange = [0.0, 1.0]
 
         xc = []
         hc = []
         hcdf = []
         hnormcdf = []
-        
+
         # ensure that float image is converted to float32
-        if self.A.dtype == np.dtype('float64'):
-            implanes = cv.split(self.A.astype('float32'))
+        if self.A.dtype == np.dtype("float64"):
+            implanes = cv.split(self.A.astype("float32"))
         else:
             implanes = cv.split(self.A)
-            
+
         for i in range(self.nplanes):
             # bin coordinates
             x = np.linspace(*xrange, nbins, endpoint=True).T
             # h = cv.calcHist(implanes, [i], None, [nbins], [0, maxrange + 1])
             h = cv.calcHist(implanes, [i], None, [nbins], xrange)
-            if i==0:
+            if i == 0:
                 xc.append(x)
             hc.append(h)
 
         # stack into arrays
         xs = np.vstack(xc).T
         hs = np.hstack(hc)
 
         # TODO this seems too complex, why do we stack stuff as well
         # as have an array of hist tuples??
         # xs, xc are the same, and same for all plots
 
         hhhx = Histogram(hs, xs, self.isfloat)
         hhhx.colordict = self.colororder
-        
-        return hhhx
 
+        return hhhx
 
     # def sum(self):
     #     """
     #     Sum of all pixels
 
     #     :return: sum of all pixel values
     #     :rtype: float or ndarray(P)
 
     #     Computes the sum of pixels in the image:
-        
+
     #     .. math::
-        
+
     #         \sum_{uv} I_{uv}
 
     #     For a P-channel image the result is a P-element array.
 
     #     Example:
 
     #     .. runblock:: pycon
@@ -143,37 +142,37 @@
     #     out = []
     #     for im in self:
     #         out.append(np.sum(im.A))
 
     #     if len(out) == 1:
     #         return out[0]
     #     else:
-    #         return out        
+    #         return out
 
     def mpq(self, p, q):
         r"""
         Image moments
 
         :param p: u exponent
         :type p: int
         :param q: v exponent
         :type q: int
         :return: moment
         :type: scalar
 
         Computes the pq'th moment of the image:
-        
+
         .. math::
-        
+
             m(I) = \sum_{uv} I_{uv} u^p v^q
 
         Example:
 
         .. runblock:: pycon
-    
+
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('shark1.png')
             >>> img.mpq(1, 0)
 
         :note:
             - Supports single channel images only.
             - ``mpq(0, 0)`` is the same as ``sum()`` but less efficient.
@@ -181,43 +180,43 @@
         :references:
             - Robotics, Vision & Control for Python, Section 12.1.3.4, P. Corke, Springer 2023.
 
         :seealso: :meth:`sum` :meth:`npq` :meth:`upq`
         """
 
         if not isinstance(p, int) or not isinstance(q, int):
-            raise TypeError(p, 'p, q must be an int')
+            raise TypeError(p, "p, q must be an int")
 
         im = self.mono().A
         X, Y = self.meshgrid()
-        return np.sum(im * (X ** p) * (Y ** q))
+        return np.sum(im * (X**p) * (Y**q))
 
     def upq(self, p, q):
         r"""
         Central image moments
 
         :param p: u exponent
         :type p: int
         :param q: v exponent
         :type q: int
         :return: moment
         :type: scalar
 
         Computes the pq'th central moment of the image:
-        
+
         .. math::
-        
+
             \mu(I) = \sum_{uv} I_{uv} (u-u_0)^p (v-v_0)^q
 
         where :math:`u_0 = m_{10}(I) / m_{00}(I)` and :math:`v_0 = m_{01}(I) / m_{00}(I)`.
 
         Example:
 
         .. runblock:: pycon
-    
+
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('shark1.png')
             >>> img.upq(2, 2)
 
         :note:
             - The central moments are invariant to translation.
             - Supports single channel images only.
@@ -225,49 +224,48 @@
         :references:
             - Robotics, Vision & Control for Python, Section 12.1.3.4, P. Corke, Springer 2023.
 
         :seealso: :meth:`sum` :meth:`mpq` :meth:`upq`
         """
 
         if not isinstance(p, int) or not isinstance(q, int):
-            raise TypeError(p, 'p, q must be an int')
+            raise TypeError(p, "p, q must be an int")
 
         m00 = self.mpq(0, 0)
         xc = self.mpq(1, 0) / m00
         yc = self.mpq(0, 1) / m00
 
         im = self.mono().A
         X, Y = self.meshgrid()
 
         return np.sum(im * ((X - xc) ** p) * ((Y - yc) ** q))
 
-
     def npq(self, p, q):
         r"""
         Normalized central image moments
 
         :param p: u exponent
         :type p: int
         :param q: v exponent
         :type q: int
         :return: moment
         :type: scalar
 
         Computes the pq'th normalized central moment of the image:
-        
+
         .. math::
-        
-            \nu(I) = \frac{\mu_{pq}(I)}{m_{00}(I)} = \frac{1}{m_{00}(I)} \sum_{uv} I_{uv} (u-u_0)^p (v-v_0)^q 
+
+            \nu(I) = \frac{\mu_{pq}(I)}{m_{00}(I)} = \frac{1}{m_{00}(I)} \sum_{uv} I_{uv} (u-u_0)^p (v-v_0)^q
 
         where :math:`u_0 = m_{10}(I) / m_{00}(I)` and :math:`v_0 = m_{01}(I) / m_{00}(I)`.
 
         Example:
 
         .. runblock:: pycon
-    
+
             >>> from machinevisiontoolbox import Image
             >>> img = Image.Read('shark1.png')
             >>> img.npq(2, 2)
 
         :note:
             - The normalized central moments are invariant to translation and
               scale.
@@ -275,17 +273,17 @@
 
         :references:
             - Robotics, Vision & Control for Python, Section 12.1.3.4, P. Corke, Springer 2023.
 
         :seealso: :meth:`sum` :meth:`mpq` :meth:`upq`
         """
         if not isinstance(p, int) or not isinstance(q, int):
-            raise TypeError(p, 'p, q must be an int')
-        if (p+q) < 2:
-            raise ValueError(p+q, 'normalized moments only valid for p+q >= 2')
+            raise TypeError(p, "p, q must be an int")
+        if (p + q) < 2:
+            raise ValueError(p + q, "normalized moments only valid for p+q >= 2")
 
         g = (p + q) / 2 + 1
 
         return self.upq(p, q) / self.mpq(0, 0) ** g
 
     def moments(self, binary=False):
         """
@@ -293,17 +291,17 @@
 
         :param binary: if True, all non-zero pixels are treated as 1's
         :type binary: bool
         :return: image moments
         :type: dict
 
         Compute multiple moments of the image and return them as a dict
-        
+
         ==========================  ===============================================================================
-        Moment type                 dict keys                                                                         
+        Moment type                 dict keys
         ==========================  ===============================================================================
         moments                     ``m00`` ``m10`` ``m01`` ``m20`` ``m11`` ``m02`` ``m30`` ``m21`` ``m12`` ``m03``
         central moments             ``mu20`` ``mu11`` ``mu02`` ``mu30`` ``mu21`` ``mu12`` ``mu03`` |
         normalized central moments  ``nu20`` ``nu11`` ``nu02`` ``nu30`` ``nu21`` ``nu12`` ``nu03`` |
         ==========================  ===============================================================================
 
         Example:
@@ -384,15 +382,14 @@
             - Robotics, Vision & Control for Python, Section 12.1.3.2, P. Corke, Springer 2023.
 
         :seealso: :meth:`flatnonzero`
         """
         v, u = np.nonzero(self.A)
         return np.vstack((u, v))
 
-
     def flatnonzero(self):
         """
         Find non-zero pixel values as 1D indices
 
         :return: index of non-zero pixels
         :rtype: ndarray(N)
 
@@ -444,24 +441,24 @@
             >>> img.A
             >>> img.peak2d(interp=True)
 
         :note:
             - Edges elements will never be returned as maxima.
             - To find minima, use ``peak2d(-image)``.
             - The ``interp`` option fits points in the neighbourhood about the
-              peak with a paraboloid and its peak position is returned.  
+              peak with a paraboloid and its peak position is returned.
 
         :seealso: :meth:`~machinevisiontoolbox.base.findpeaks.findpeaks2d`
         """
 
         ret = findpeaks2d(self.A, npeaks=npeaks, scale=scale, interp=interp)
         return ret[:, -1], ret[:, :2].T
 
-class Histogram:
 
+class Histogram:
     def __init__(self, h, x, isfloat=False):
         """
         Create histogram instance
 
         :param h: image histogram
         :type h: ndarray(N), ndarray(N,P)
         :param x: image values
@@ -473,17 +470,17 @@
         as Numpy arrays.
 
         :seealso: :meth:`~machinevisiontoolbox.ImageFeatures.ImageFeaturesMixin.hist`
         """
         self.nplanes = h.shape[1]
 
         if self.nplanes == 1:
-            h = h[:,0]
+            h = h[:, 0]
 
-        self._h = h # histogram
+        self._h = h  # histogram
         self._x = x.flatten()  # x value
         self.isfloat = isfloat
         # 'hist', 'h cdf normcdf x')
 
     def __str__(self):
         """
         Histogram summary as a string
@@ -618,15 +615,23 @@
 
         if self.nplanes == 1:
             y = y / y[-1]
         else:
             y = y / y[-1, :]
         return y
 
-    def plot(self, type='frequency', block=False, bar=None, style='stack', alpha=0.5, **kwargs):
+    def plot(
+        self,
+        type="frequency",
+        block=False,
+        bar=None,
+        style="stack",
+        alpha=0.5,
+        **kwargs,
+    ):
         """
         Plot histogram
 
         :param type: histogram type, one of: 'frequency' [default], 'cdf', 'ncdf'
         :type type: str, optional
         :param block: hold plot, defaults to False
         :type block: bool, optional
@@ -638,44 +643,44 @@
         :param alpha: transparency for overlay plot, defaults to 0.5
         :type alpha: float, optional
         :raises ValueError: invalid histogram type
         :raises ValueError: cannot use overlay style for 1-channel histogram
         """
 
         # if type == 'histogram':
-        #     plot_histogram(self.xs.flatten(), self.hs.flatten(), block=block, 
+        #     plot_histogram(self.xs.flatten(), self.hs.flatten(), block=block,
         #     xlabel='pixel value', ylabel='number of pixels', **kwargs)
         # elif type == 'cumulative':
-        #     plot_histogram(self.xs.flatten(), self.cs.flatten(), block=block, 
+        #     plot_histogram(self.xs.flatten(), self.cs.flatten(), block=block,
         #     xlabel='pixel value', ylabel='cumulative number of pixels', **kwargs)
         # elif type == 'normalized':
-        #     plot_histogram(self.xs.flatten(), self.ns.flatten(), block=block, 
+        #     plot_histogram(self.xs.flatten(), self.ns.flatten(), block=block,
         #     xlabel='pixel value', ylabel='normalized cumulative number of pixels', **kwargs)
         # fig = plt.figure()
         x = self._x[:]
 
-        if type == 'frequency':
+        if type == "frequency":
             y = self.h
             maxy = np.max(y)
-            ylabel1 = 'frequency'
-            ylabel2 = 'frequency'
+            ylabel1 = "frequency"
+            ylabel2 = "frequency"
             if bar is not False:
                 bar = True
-        elif type in ('cdf', 'cumulative'):
+        elif type in ("cdf", "cumulative"):
             y = self.cdf
             maxy = np.max(y[-1, :])
-            ylabel1 = 'cumulative frequency'
-            ylabel2 = 'cumulative frequency'
-        elif type in ('ncdf', 'normalized'):
+            ylabel1 = "cumulative frequency"
+            ylabel2 = "cumulative frequency"
+        elif type in ("ncdf", "normalized"):
             y = self.ncdf
-            ylabel1 = 'norm. cumulative freq.'
-            ylabel2 = 'normalized cumulative frequency'
+            ylabel1 = "norm. cumulative freq."
+            ylabel2 = "normalized cumulative frequency"
             maxy = 1
         else:
-            raise ValueError('unknown type')
+            raise ValueError("unknown type")
 
         if self.nplanes == 1:
             y = y[..., np.newaxis]
 
         if self.isfloat:
             xrange = (0.0, 1.0)
         else:
@@ -683,56 +688,62 @@
 
         if self.colordict is not None:
             colors = list(self.colordict.keys())
             n = len(colors)
             # ylabel1 += ' (' + ','.join(colors) + ')'
         else:
             n = 1
-            if style == 'overlay':
-                raise ValueError('cannot use overlay style for monochrome image')
+            if style == "overlay":
+                raise ValueError("cannot use overlay style for monochrome image")
 
-        if style == 'stack':
+        if style == "stack":
             for i in range(n):
                 ax = plt.subplot(n, 1, i + 1)
                 if bar:
                     ax.bar(x, y[:, i], width=x[1] - x[0], bottom=0, **kwargs)
                 else:
                     ax.plot(x, y[:, i], **kwargs)
                 ax.grid()
                 if n == 1:
                     ax.set_ylabel(ylabel1)
                 else:
-                    ax.set_ylabel(ylabel1 + ' (' + colors[i] + ')')
+                    ax.set_ylabel(ylabel1 + " (" + colors[i] + ")")
                 ax.set_xlim(*xrange)
                 ax.set_ylim(0, maxy)
-                ax.yaxis.set_major_formatter(ScalarFormatter(useOffset=False, useMathText=True))
-            ax.set_xlabel('pixel value')
+                ax.yaxis.set_major_formatter(
+                    ScalarFormatter(useOffset=False, useMathText=True)
+                )
+            ax.set_xlabel("pixel value")
 
-        elif style == 'overlay':
+        elif style == "overlay":
             x = np.r_[0, x, 255]
             ax = plt.subplot(1, 1, 1)
 
             patchcolor = []
             goodcolors = [c for c in "rgbykcm"]
             for i, color in colors:
                 if color.lower() in "rgbykcm":
                     patchcolor.append(color.lower())
                 else:
                     patchcolor.append(goodcolors.pop(0))
 
             for i in range(n):
                 yi = np.r_[0, y[:, i], 0]
                 p1 = np.array([x, yi]).T
-                poly1 = Polygon(p1, closed=True, facecolor=patchcolor[i], alpha=alpha, **kwargs)
+                poly1 = Polygon(
+                    p1, closed=True, facecolor=patchcolor[i], alpha=alpha, **kwargs
+                )
                 ax.add_patch(poly1)
             ax.set_xlim(*xrange)
             ax.set_ylim(0, maxy)
-            ax.yaxis.set_major_formatter(ScalarFormatter(useOffset=False, useMathText=True))
+            ax.yaxis.set_major_formatter(
+                ScalarFormatter(useOffset=False, useMathText=True)
+            )
 
-            ax.set_xlabel('pixel value')
+            ax.set_xlabel("pixel value")
             ax.set_ylabel(ylabel2)
 
             ax.grid(True)
             plt.legend(colors)
         plt.show(block=block)
 
     def peaks(self, **kwargs):
@@ -740,15 +751,15 @@
         Histogram peaks
 
         :param kwargs: parameters passed to :func:`~machinevisiontoolbox.base.findpeaks.findpeaks`
         :return: positions of histogram peaks
         :rtype: ndarray(M), list of ndarray
 
         For a greyscale image return an array of grey values corresponding to local
-        maxima.  For a color image return a list of arrays of grey values corresponding 
+        maxima.  For a color image return a list of arrays of grey values corresponding
         to local maxima in each plane.
 
         Example:
 
         .. runblock:: pycon
 
             >>> from machinevisiontoolbox import Image
@@ -758,23 +769,22 @@
 
         :seealso: :func:`~machinevisiontoolbox.base.findpeaks.findpeaks`
         """
         if self.nplanes == 1:
             # greyscale image
             x, _ = findpeaks(self.h, self.x, **kwargs)
             return x
-        
+
         else:
             xp = []
             for i in range(self.nplanes):
-                x, _ = findpeaks(self.h[:,i], self.x, **kwargs)
+                x, _ = findpeaks(self.h[:, i], self.x, **kwargs)
                 xp.append(x)
             return xp
 
-
     # # helper function that was part of hist() in the Matlab toolbox
     # # TODO consider moving this to ImpageProcessingBase.py
     # def plothist(self, title=None, block=False, **kwargs):
     #     """
     #     plot first image histogram as a line plot (TODO as poly)
     #     NOTE convenient, but maybe not a great solution because we then need to
     #     duplicate all the plotting options as for idisp?
@@ -850,14 +860,15 @@
     #     # him = im[2].hist()
     #     # fig, ax = plt.subplots()
     #     # ax.plot(him[i].x[:, 0], him[i].h[:, 0], 'b')
     #     # ax.plot(him[i].x[:, 1], him[i].h[:, 1], 'g')
     #     # ax.plot(him[i].x[:, 2], him[i].h[:, 2], 'r')
     #     # plt.show()
 
+
 if __name__ == "__main__":
 
     from machinevisiontoolbox import Image
     from math import pi
 
     # img = Image.Read('flowers1.png', dtype='float32', grey=True)
     # print(img)
@@ -872,10 +883,10 @@
     # print(h.peaks(scale=0.2))
     # # h.plot('frequency', style='overlay')
     # # plt.figure()
     # h.plot('frequency', block=True)
 
     # print(img.moments())
 
-    im = Image.Read('penguins.png')
+    im = Image.Read("penguins.png")
     z = im.ocr(minconf=90)
     print(z)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/PointCloud.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/PointCloud.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,21 +2,24 @@
 
 import numpy as np
 import spatialmath.base as smbase
 from spatialmath import SE3
 
 try:
     import open3d as o3d
+
     _open3d = True
 except ModuleNotFoundError:
     _open3d = False
 
-class PointCloud:
 
-    def __init__(self, arg, image=None, colors=None, camera=None, depth_scale=1.0, **kwargs):
+class PointCloud:
+    def __init__(
+        self, arg, image=None, colors=None, camera=None, depth_scale=1.0, **kwargs
+    ):
         """
         Create new point cloud object
 
         :param arg: point cloud data
         :type arg: :obj:`open3d.geometry.PointCloud`, ndarray(3,N)
         :param image: image used to create colored point cloud, defaults to None
         :type image: :class:`~machinevisiontoolbox.ImageCore.Image`, optional
@@ -28,69 +31,75 @@
         :type depth_scale: float, optional
         :raises RuntimeError: PointCloud class requires Open3D to be installed: pip install open3d
         :raises ValueError: depth array and image must be same shape
         :raises ValueError: bad arguments
 
         This object wraps an Open3D :obj:`open3d.geometry.PointCloud` object.  It can be
         created from:
-        
+
         - an Open3D point cloud object
         - a depth image as a 2D array
         - an RGBD image as a 2D depth array and a color :class:`~machinevisiontoolbox.Image`.  Camera
           intrinsics can be provided by a :class:`~machinevisiontoolbox.CentralCamera` instance.
 
         .. warning:: Open3D must be installed.
-        
+
         :seealso: :obj:`open3d.geometry.PointCloud` :class:`~machinevisiontoolbox.ImageCore.Image` :class:`~machinevisiontoolbox.Camera.CentralCamera`
         """
         if not _open3d:
-            raise RuntimeError("PointCloud class requires Open3D to be installed: pip install open3d")
+            raise RuntimeError(
+                "PointCloud class requires Open3D to be installed: pip install open3d"
+            )
 
         if isinstance(arg, o3d.geometry.PointCloud):
             pcd = arg
 
         elif isinstance(arg, np.ndarray):
 
-            arg = arg.astype('float32')
+            arg = arg.astype("float32")
 
             if arg.ndim == 2 and arg.shape[0] == 3:
                 # simple point cloud:
                 # passed a 3xN array of point coordinates
                 pcd = o3d.geometry.PointCloud()
                 pcd.points = o3d.utility.Vector3dVector(arg.T)
 
                 if colors is not None and colors.shape == arg.shape:
                     if np.issubdtype(colors.dtype, np.integer):
                         colors = colors / np.iinfo(colors.dtype).max
                     pcd.colors = o3d.utility.Vector3dVector(colors.T)
 
-            elif isinstance(arg, np.ndarray) and image is not None and camera is not None:
+            elif (
+                isinstance(arg, np.ndarray) and image is not None and camera is not None
+            ):
                 # colored point cloud:
                 # passed a WxH array of depth plus a WxH image
                 if arg.shape != image.shape[:2]:
                     print(arg.shape, image.image.shape)
-                    raise ValueError('depth array and image must be same shape')
+                    raise ValueError("depth array and image must be same shape")
 
                 if image.iscolor and "convert_rgb_to_intensity" not in kwargs:
                     kwargs["convert_rgb_to_intensity"] = False
                 rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(
-                    o3d.geometry.Image(image.image), 
-                    o3d.geometry.Image(arg), 
+                    o3d.geometry.Image(image.image),
+                    o3d.geometry.Image(arg),
                     depth_scale=depth_scale,
-                    **kwargs)
+                    **kwargs,
+                )
 
                 pcd = o3d.geometry.PointCloud.create_from_rgbd_image(
                     rgbd_image,
                     o3d.camera.PinholeCameraIntrinsic(
-                        image.width, image.height, 
-                        *camera.fpix, *camera.pp))
+                        image.width, image.height, *camera.fpix, *camera.pp
+                    ),
+                )
             else:
-                raise ValueError('bad arguments')
+                raise ValueError("bad arguments")
         else:
-            raise ValueError('arg must be PointCloud or ndarray')
+            raise ValueError("arg must be PointCloud or ndarray")
 
         self._pcd = pcd
 
     def copy(self):
         """
         Copy point cloud
 
@@ -122,31 +131,31 @@
         If ``P`` is a :class:`PointCloud` then ``P.name`` invokes
         attribute ``name`` of the underlying :obj:`open3d.geometry.PointCloud`
         object.
 
         :note: This is an alternative to explicitly wrapping all
             those properties and methods.
         """
+
         def wrapper(*args, **kwargs):
             meth = getattr(self._pcd, name)
             return meth(*args, **kwargs)
 
         if hasattr(self._pcd, name):
             return wrapper
 
-
     def __str__(self):
         """
         Concise string representation of point cloud parameters
 
         :return: _description_
         :rtype: _type_
         """
         return str(self._pcd)
-    
+
     def __repr__(self):
         return str(self)
 
     @property
     def pcd(self):
         return self._pcd
 
@@ -170,15 +179,15 @@
         :return: point color
         :rtype: ndarray(3,N)
 
         Point colors are returned as columns of the array.
 
         """
         return np.asarray(self._pcd.colors).T
-    
+
     @classmethod
     def Read(cls, filename, *args, **kwargs):
         """
         Create point cloud from file
 
         :param filename: name of file
         :type filename: str
@@ -352,30 +361,30 @@
         """
         return self.__class__(self._pcd.voxel_down_sample(voxel_size))
 
     # random downsample
     def downsample_random(self, fraction, seed=None):
         """
         Downsample point cloud by random selection
-        
+
         :param fraction: fraction of points to retain
         :type fraction: float
         :param seed: random number seed, defaults to None
         :type seed: int, optional
         :return: downsampled point cloud
         :rtype: :class:`PointCloud`
 
         Point cloud resolution is reduced by randomly selecting
         a subset of points.
 
         :seealso: :meth:`downsample_random`
         """
         if seed is None:
             return self.__class__(self._pcd.random_down_sample(fraction))
-        
+
         if seed >= 0:
             np.random.seed(seed)
         n = len(self)
         ind = np.random.choice(n, int(fraction * n), replace=False)
         return self.__class__(self._pcd.select_by_index(ind))
 
     def normals(self, **kwargs):
@@ -385,15 +394,16 @@
         Normals are computed and stored within the Open3D point cloud
         object.  They are displayed when the point cloud is displayed.
 
         :seealso: :meth:`disp` :meth:`open3d.geometry.PointCloud.estimate_normals`
         """
         # radius=0.1, max_nn=30
         self._pcd.estimate_normals(
-                search_param=o3d.geometry.KDTreeSearchParamHybrid(**kwargs))
+            search_param=o3d.geometry.KDTreeSearchParamHybrid(**kwargs)
+        )
 
     def remove_outlier(self, **kwargs):
         """
         Remove point cloud outliers
 
         :return: cleaned up point cloud
         :rtype: :class:`PointCloud`
@@ -472,21 +482,17 @@
 
         if T0 is None:
             T0 = np.eye(4)
         else:
             T0 = T0.A
 
         status = o3d.pipelines.registration.registration_icp(
-            self._pcd, 
-            data._pcd, 
-            max_correspondence_distance,
-            T0,
-            estimation, 
-            criteria)
-            #voxel_size, save_loss_log)
+            self._pcd, data._pcd, max_correspondence_distance, T0, estimation, criteria
+        )
+        # voxel_size, save_loss_log)
 
         T = SE3(smbase.trnorm(status.transformation))
 
         return T, status
 
     def voxel_grid(self, voxel_size):
         """
@@ -495,30 +501,32 @@
         :param voxel_size: voxel dimension
         :type voxel_size: float
         :return: voxel grid
         :rtype: :class:`VoxelGrid`
         """
         return VoxelGrid(self, voxel_size)
 
-class VoxelGrid:
 
+class VoxelGrid:
     def __init__(self, pcd, voxel_size):
-        self._voxels = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd._pcd, voxel_size=voxel_size)
+        self._voxels = o3d.geometry.VoxelGrid.create_from_point_cloud(
+            pcd._pcd, voxel_size=voxel_size
+        )
 
     def write(self, filename):
         """
         Write voxel grid to file
 
         :param filename: filename
         :type filename: str
 
         :seealso: :obj:`open3d.io.write_voxel_grid`
         """
         o3d.io.write_voxel_grid(filename, self._voxels)
-        
+
     def disp(self, block=True, file=None, **kwargs):
         """
         Display voxel grid
 
         :param block: block until window is dismissed, defaults to True
         :type block: bool, optional
         :param file: save display to this filename, defaults to None
@@ -552,16 +560,17 @@
             vis.poll_events()
             vis.update_renderer()
 
             # save to file if requested
             if file is not None:
                 vis.capture_screen_image(str(file), do_render=False)
 
+
 if __name__ == "__main__":
     from machinevisiontoolbox import mvtb_path_to_datafile
 
-    pcd = PointCloud.Read(mvtb_path_to_datafile('data/bunny.ply'))
+    pcd = PointCloud.Read(mvtb_path_to_datafile("data/bunny.ply"))
     print(pcd)
-    pcd.disp(block=False, file='bun.png')
+    pcd.disp(block=False, file="bun.png")
 
     # import time
-    # time.sleep(4)
+    # time.sleep(4)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/Sources.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/Sources.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import os
 import cv2 as cv
 import zipfile
 import numpy as np
 import fnmatch
 from numpy.core.numeric import _rollaxis_dispatcher
+
 # from machinevisiontoolbox.ImageCore import ImageCoreMixin
 # from machinevisiontoolbox.ImageIO import ImageIOMixin
 # from machinevisiontoolbox.ImageConstants import ImageConstantsMixin
 # from machinevisiontoolbox.ImageProcessing import ImageProcessingMixin
 # from machinevisiontoolbox.ImageMorph import ImageMorphMixin
 # from machinevisiontoolbox.ImageSpatial import ImageSpatialMixin
 # from machinevisiontoolbox.ImageColor import ImageColorMixin
@@ -17,14 +18,15 @@
 # from machinevisiontoolbox.ImageLineFeatures import ImageLineFeaturesMixin
 # from machinevisiontoolbox.ImagePointFeatures import ImagePointFeaturesMixin
 
 from machinevisiontoolbox.base import mvtb_path_to_datafile, iread, convert
 from machinevisiontoolbox import Image
 from numpy.lib.arraysetops import isin
 from abc import ABC, abstractmethod
+
 # class Image(
 #             ImageCoreMixin,
 #             ImageIOMixin,
 #             ImageConstantsMixin,
 #             ImageProcessingMixin,
 #             ImageMorphMixin,
 #             ImageSpatialMixin,
@@ -33,20 +35,21 @@
 #             ImageBlobsMixin,
 #             ImageFeaturesMixin,
 #             ImageLineFeaturesMixin,
 #             ImagePointFeaturesMixin
 #             ):
 #     pass
 
-class ImageSource(ABC):
 
+class ImageSource(ABC):
     @abstractmethod
     def __init__():
         pass
 
+
 class VideoFile(ImageSource):
     """
     Iterate images from a video file
 
     :param filename: Path to video file
     :type filename: str
     :param kwargs: options applied to image frames, see :func:`~machinevisiontoolbox.base.imageio.convert`
@@ -65,24 +68,24 @@
 
         >>> from machinevisiontoolbox import VideoFile
         >>> video = VideoFile("traffic_sequence.mpg")
         >>> len(video)
         >>> for im in video:
         >>>   # process image
 
-    :references: 
+    :references:
         - Robotics, Vision & Control for Python, Section 11.1.4, P. Corke, Springer 2023.
 
     :seealso: :func:`~machinevisiontoolbox.base.imageio.convert`
         `opencv.VideoCapture <https://docs.opencv.org/master/d8/dfe/classcv_1_1VideoCapture.html#a57c0e81e83e60f36c83027dc2a188e80>`_
     """
 
     def __init__(self, filename, **kwargs):
 
-        self.filename = str(mvtb_path_to_datafile('images', filename))
+        self.filename = str(mvtb_path_to_datafile("images", filename))
 
         # get the number of frames in the video
         #  not sure it's always correct
         cap = cv.VideoCapture(self.filename)
         ret, frame = cap.read()
         self.nframes = int(cap.get(cv.CAP_PROP_FRAME_COUNT))
         self.shape = frame.shape
@@ -103,37 +106,38 @@
         ret, frame = self.cap.read()
         if ret is False:
             self.cap.release()
             raise StopIteration
         else:
             im = convert(frame, **self.args)
             if im.ndim == 3:
-                im = Image(im, id=self.i, name=self.filename, colororder='RGB')
+                im = Image(im, id=self.i, name=self.filename, colororder="RGB")
             else:
                 im = Image(im, id=self.i, name=self.filename)
             self.i += 1
             return im
 
     def __len__(self):
         return self.nframes
 
     def __repr__(self):
         return f"VideoFile({os.path.basename(self.filename)}) {self.shape[1]} x {self.shape[0]}, {self.nframes} frames @ {self.fps}fps"
 
+
 class VideoCamera(ImageSource):
     """
     Iterate images from a local video camera
 
     :param id: Identity of local camera
     :type id: int
     :param kwargs: options applied to image frames, see :func:`~machinevisiontoolbox.base.imageio.convert`
 
     Connect to a local video camera.  For some cameras this will cause
     the recording light to come on.
-    
+
     The resulting object is an iterator over the frames from the video
     camera. The iterator returns :class:`Image` objects.
 
     Example::
 
         >>> from machinevisiontoolbox import VideoCamera
         >>> video = VideoCamera(0)
@@ -144,15 +148,15 @@
 
         >>> img = video.grab()
 
     :note: The value of ``id`` is system specific but generally 0 is the
         first attached video camera.
 
 
-    :references: 
+    :references:
         - Robotics, Vision & Control for Python, Section 11.1.3, P. Corke, Springer 2023.
 
     :seealso: :func:`~machinevisiontoolbox.base.imageio.convert`
         `cv2.VideoCapture <https://docs.opencv.org/master/d8/dfe/classcv_1_1VideoCapture.html#a57c0e81e83e60f36c83027dc2a188e80>`_,
     """
 
     def __init__(self, id=0, rgb=True, **kwargs):
@@ -167,17 +171,17 @@
         self.i = 0
         if self.cap is not None:
             self.cap.release()
         self.cap = cv.VideoCapture(self.id)
         return self
 
     def __next__(self):
-        ret, frame = self.cap.read() # frame will be in BGR order
+        ret, frame = self.cap.read()  # frame will be in BGR order
         if ret is False:
-            print('camera read fail, camera is released')
+            print("camera read fail, camera is released")
             self.cap.release()
             raise StopIteration
         else:
             if self.rgb:
                 # RGB required, invert the planes
                 im = convert(frame, rgb=True, copy=True, **self.args)
                 img = Image(im, id=self.i, colororder="RGB")
@@ -201,15 +205,15 @@
         stream = iter(self)
         return next(stream)
 
     def release(self):
         """
         Release the camera
 
-        Disconnect from the local camera, and for cameras with a recording 
+        Disconnect from the local camera, and for cameras with a recording
         light, turn off that light.
         """
         self.cap.release()
 
     def __repr__(self):
         backend = self.cap.getBackendName()
         return f"VideoCamera({self.id}) {self.width} x {self.height} @ {self.framerate}fps using {backend}"
@@ -262,15 +266,18 @@
 
 
         :seealso: :meth:`set`
         """
         if property is not None:
             return self.cap.get(self.properties[property])
         else:
-            return {property: self.cap.get(self.properties[property]) for property in self.properties}
+            return {
+                property: self.cap.get(self.properties[property])
+                for property in self.properties
+            }
 
     def set(self, property, value):
         """
         Set camera property
 
         :param prop: camera property name
         :type prop: str
@@ -318,15 +325,15 @@
     @property
     def height(self):
         """
         Height of video frame
 
         :return: height of video frame in pixels
         :rtype: int
-        
+
         :seealso: :meth:`width` :meth:`shape`
         """
         return int(self.cap.get(cv.CAP_PROP_FRAME_HEIGHT))
 
     @property
     def framerate(self):
         """
@@ -350,26 +357,27 @@
 
         :return: height and width of video frame in pixels
         :rtype: int, int
 
         :seealso: :meth:`height` :meth:`width`
         """
         return (self.height, self.width)
-        
+
+
 class ImageCollection(ImageSource):
-    """ 
+    """
     Iterate images from a collection of files
 
     :param filename: wildcard path to image files
     :type filename: str
     :param loop: Endlessly loop over the files, defaults to False
     :type loop: bool, optional
     :param kwargs: options applied to image frames, see :func:`~machinevisiontoolbox.base.imageio.convert`
 
-    The resulting object is an iterator over the image files that match the 
+    The resulting object is an iterator over the image files that match the
     wildcard description. The iterator returns :class:`Image` objects where
     the ``name`` attribute is the name of the image file
 
     If the path is not absolute, the video file is first searched for
     relative to the current directory, and if not found, it is searched for
     in the ``images`` folder of the ``mvtb-data`` package, installed as a
     Toolbox dependency.
@@ -382,66 +390,66 @@
         >>> for image in images:  # iterate over images
         >>>   # process image
 
     alternatively::
 
         >>> img = files[i]  # load i'th file from the collection
 
-    :references: 
+    :references:
         - Robotics, Vision & Control for Python, Section 11.1.2, P. Corke, Springer 2023.
 
     :seealso: :func:`~machinevisiontoolbox.base.imageio.convert`
         `cv2.imread <https://docs.opencv.org/master/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56>`_
     """
 
-    def __init__(self, filename = None, loop=False, **kwargs):
+    def __init__(self, filename=None, loop=False, **kwargs):
 
         if filename is not None:
             self.images, self.names = iread(filename)
         self.args = kwargs
         self.loop = loop
 
     def __getitem__(self, i):
 
-            if isinstance(i, slice):
-                # slice of a collection -> ImageCollection
-                new = self.__class__()
-                new.images = self.images[i]
-                new.names = self.names[i]
-                new.args = self.args
-                return new
+        if isinstance(i, slice):
+            # slice of a collection -> ImageCollection
+            new = self.__class__()
+            new.images = self.images[i]
+            new.names = self.names[i]
+            new.args = self.args
+            return new
+        else:
+            # element of a collection -> Image
+            data = self.images[i]
+            im = convert(data, **self.args)
+            if im.ndim == 3:
+                return Image(im, name=self.names[i], id=i, colororder="RGB")
             else:
-                # element of a collection -> Image
-                data = self.images[i]
-                im = convert(data, **self.args)
-                if im.ndim == 3:
-                    return Image(im, name=self.names[i], id=i, colororder='RGB')
-                else:
-                    return Image(im, id=i, name=self.names[i])
+                return Image(im, id=i, name=self.names[i])
 
     def __iter__(self):
         self.i = 0
         return self
 
     def __str__(self):
-        return '\n'.join([str(f) for f in self.names])
+        return "\n".join([str(f) for f in self.names])
 
     def __repr__(self):
         return str(self)
 
     def __next__(self):
         if self.i >= len(self.names):
             if self.loop:
                 self.i = 0
             else:
                 raise StopIteration
         data = self.images[self.i]
         im = convert(data, **self.args)
         if im.ndim == 3:
-            im = Image(im, id=self.i, name=self.names[self.i], colororder='BGR')
+            im = Image(im, id=self.i, name=self.names[self.i], colororder="BGR")
         else:
             im = Image(im, id=self.i, name=self.names[self.i])
         self.i += 1
         return im
 
     def __len__(self):
         return len(self.images)
@@ -475,29 +483,29 @@
         >>> for image in images:  # iterate over files
         >>>   # process image
 
     alternatively::
 
         >>> image = images[i]  # load i'th file from the archive
 
-    :references: 
+    :references:
         - Robotics, Vision & Control for Python, Section 11.1.2, P. Corke, Springer 2023.
 
     :note:  ``filter`` is a Unix style wildcard expression, not a Python
         regexp, so expressions like ``*.png`` would select all PNG files in
         the archive for iteration.
 
     :seealso: :meth:`open` :func:`~machinevisiontoolbox.base.imageio.convert`
         `cv2.imread <https://docs.opencv.org/master/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56>`_
     """
 
     def __init__(self, filename, filter=None, loop=False, **kwargs):
 
-        filename = mvtb_path_to_datafile('images', filename)
-        self.zipfile = zipfile.ZipFile(filename, 'r')
+        filename = mvtb_path_to_datafile("images", filename)
+        self.zipfile = zipfile.ZipFile(filename, "r")
         if filter is None:
             files = self.zipfile.namelist()
         else:
             files = fnmatch.filter(self.zipfile.namelist(), filter)
         self.files = sorted(files)
         self.args = kwargs
         self.loop = loop
@@ -523,50 +531,53 @@
         """
         List all files within the archive to stdout.
         """
         for name in self.zipfile.namelist():
             print(name)
 
     def __getitem__(self, i):
-            im = self._read(i)
-            if im.ndim == 3:
-                return Image(im, name=self.files[i], id=i, colororder='BGR')
-            else:
-                return Image(im, id=i, name=self.files[i])
+        im = self._read(i)
+        if im.ndim == 3:
+            return Image(im, name=self.files[i], id=i, colororder="BGR")
+        else:
+            return Image(im, id=i, name=self.files[i])
 
     def __iter__(self):
         self.i = 0
         return self
 
     def __repr__(self):
-        return '\n'.join(self.files)
+        return "\n".join(self.files)
 
     def __next__(self):
         if self.i >= len(self.files):
             if self.loop:
                 self.i = 0
             else:
                 raise StopIteration
 
         im = self._read(self.i)
         if im.ndim == 3:
-            im = Image(im, id=self.i, name=self.files[self.i], colororder='BGR')
+            im = Image(im, id=self.i, name=self.files[self.i], colororder="BGR")
         else:
             im = Image(im, id=self.i, name=self.files[self.i])
         self.i += 1
         return im
 
     def __len__(self):
         return len(self.files)
-        
+
     def _read(self, i):
         data = self.zipfile.read(self.files[i])
-        img = cv.imdecode(np.frombuffer(data, np.uint8),  cv.IMREAD_ANYDEPTH | cv.IMREAD_UNCHANGED) 
+        img = cv.imdecode(
+            np.frombuffer(data, np.uint8), cv.IMREAD_ANYDEPTH | cv.IMREAD_UNCHANGED
+        )
         return convert(img, **self.args)
 
+
 class WebCam(ImageSource):
     """
     Iterate images from an internet web camera
 
     :param url: URL of the camera
     :type url: str
     :param kwargs: options applied to image frames, see :func:`~machinevisiontoolbox.base.imageio.convert`
@@ -586,15 +597,15 @@
         >>> img = webcam.grab()  # grab next frame
 
     :note: Manu webcameras accept a query string in the URL to specify
         image resolution, image format, codec and other parameters. There
         is no common standard for this, see the manufacturer's datasheet
         for details.
 
-    :references: 
+    :references:
         - Robotics, Vision & Control for Python, Section 11.1.5, P. Corke, Springer 2023.
 
     :seealso: :func:`~machinevisiontoolbox.base.imageio.convert`
         `cv2.VideoCapture <https://docs.opencv.org/master/d8/dfe/classcv_1_1VideoCapture.html#a57c0e81e83e60f36c83027dc2a188e80>`_
     """
 
     def __init__(self, url, **kwargs):
@@ -613,15 +624,15 @@
         ret, frame = self.cap.read()
         if ret is False:
             self.cap.release()
             raise StopIteration
         else:
             im = convert(frame, **self.args)
             if im.ndim == 3:
-                return Image(im, colororder='RGB')
+                return Image(im, colororder="RGB")
             else:
                 return Image(im)
 
     def grab(self):
         """
         Grab frame from web camera
 
@@ -629,16 +640,18 @@
         :rtype: :class:`Image`
 
         This is an alternative interface to the class iterator.
         """
         stream = iter(self)
         return next(stream)
 
+
 # dartmouth = WebCam('https://webcam.dartmouth.edu/webcam/image.jpg')
 
+
 class EarthView(ImageSource):
     """
     Iterate images from GoogleEarth
 
     :param key: Google API key, defaults to None
     :type key: str
     :param type: type of map (API ``maptype``): 'satellite' [default], 'map', 'roads', 'hybrid', and 'terrain'.
@@ -674,40 +687,52 @@
         >>> earth = EarthView()  # create an Earth viewer
         >>> image = earth(-27.475722, 153.0285, zoom=17 # make a view
         >>> # process image
 
     .. warning:: You must have a Google account and a valid key, backed
         by a credit card, to access this service.
         `Getting started <https://developers.google.com/maps/documentation/maps-static>`_
-    
+
     :note:
-        - If the key is not passed in, a value is sought from the 
+        - If the key is not passed in, a value is sought from the
             environment variable ``GOOGLE_KEY``.
         - Uses the `Google Maps Static API <https://developers.google.com/maps/documentation/maps-static/start>`_
 
-    :references: 
+    :references:
         - Robotics, Vision & Control for Python, Section 11.1.6, P. Corke, Springer 2023.
 
     :seealso: :meth:`grab` :func:`~machinevisiontoolbox.base.imageio.convert`
     """
 
-    def __init__(self, key=None, type='satellite', zoom=18, scale=1, shape=(500, 500), **kwargs):
+    def __init__(
+        self, key=None, type="satellite", zoom=18, scale=1, shape=(500, 500), **kwargs
+    ):
 
         if key is None:
-            self.key = os.getenv('GOOGLE_KEY')
+            self.key = os.getenv("GOOGLE_KEY")
         else:
             self.key = key
 
         self.type = type
         self.scale = scale
         self.zoom = zoom
         self.shape = shape
         self.args = kwargs
 
-    def grab(self, lat, lon, zoom=None, type=None, scale=None, shape=None, roadnames=False, placenames=False):
+    def grab(
+        self,
+        lat,
+        lon,
+        zoom=None,
+        type=None,
+        scale=None,
+        shape=None,
+        roadnames=False,
+        placenames=False,
+    ):
         """
         Google map view as an image
 
         :param lat: lattitude (degrees)
         :type lat: float
         :param lon: longitude (degrees)
         :type lon: float
@@ -736,75 +761,80 @@
         if scale is None:
             scale = self.scale
         if zoom is None:
             zoom = self.zoom
         if shape is None:
             shape = self.shape
 
-        # type: satellite map hybrid terrain roadmap roads
+        # type is one of: satellite map hybrid terrain roadmap roads
         occggrid = False
-        if type == 'map':
-            type = 'roadmap'
-        elif type == 'roads':
-            type = 'roadmap'
+        if type == "map":
+            type = "roadmap"
+        elif type == "roads":
+            type = "roadmap"
             occggrid = True
 
         # https://developers.google.com/maps/documentation/maps-static/start#URL_Parameters
 
         # now read the map
         url = f"https://maps.googleapis.com/maps/api/staticmap?center={lat},{lon}&zoom={zoom}&size={shape[0]}x{shape[1]}&scale={scale}&format=png&maptype={type}&key={self.key}&sensor=false"
 
         opturl = []
-        
+
         if roadnames:
-            opturl.append('style=feature:road|element:labels|visibility:off')
+            opturl.append("style=feature:road|element:labels|visibility:off")
         if placenames:
-            opturl.append('style=feature:administrative|element:labels.text|visibility:off&style=feature:poi|visibility:off')
-        
+            opturl.append(
+                "style=feature:administrative|element:labels.text|visibility:off&style=feature:poi|visibility:off"
+            )
+
         if occggrid:
-            opturl.extend([
-                'style=feature:landscape|element:geometry.fill|color:0x000000|visibility:on',
-                'style=feature:landscape|element:labels|visibility:off',
-                'style=feature:administrative|visibility:off',
-                'style=feature:road|element:geometry|color:0xffffff|visibility:on',
-                'style=feature:road|element:labels|visibility:off',
-                'style=feature:poi|element:all|visibility:off',
-                'style=feature:transit|element:all|visibility:off',
-                'style=feature:water|element:all|visibility:off',
-                ])
+            opturl.extend(
+                [
+                    "style=feature:landscape|element:geometry.fill|color:0x000000|visibility:on",
+                    "style=feature:landscape|element:labels|visibility:off",
+                    "style=feature:administrative|visibility:off",
+                    "style=feature:road|element:geometry|color:0xffffff|visibility:on",
+                    "style=feature:road|element:labels|visibility:off",
+                    "style=feature:poi|element:all|visibility:off",
+                    "style=feature:transit|element:all|visibility:off",
+                    "style=feature:water|element:all|visibility:off",
+                ]
+            )
 
         if len(opturl) > 0:
-            url += '&' + '&'.join(opturl)
+            url += "&" + "&".join(opturl)
         data = iread(url)
 
         if data[0].shape[2] == 4:
-            colororder = 'RGBA'
+            colororder = "RGBA"
         elif data[0].shape[2] == 3:
-            colororder = 'RGB'
+            colororder = "RGB"
         else:
             colororder = None
         im = convert(data[0], **self.args)
         return Image(im, colororder=colororder)
 
+
 # if __name__ == "__main__":
 
 #     import machinevisiontoolbox as mvtb
 #     campus = ImageCollection("campus/*.png")
 
 #     a  = campus[3]
 #     print(a)
 #     # campus/*.png
 #     # traffic_sequence.mpg
 
 #     # v = VideoFile("traffic_sequence.mpg")
-    
+
 #     # f = FileCollection("campus/*.png")
 #     # print(f)
 
 #     zf = ZipArchive('bridge-l.zip', filter='*02*')
 #     print(zf)
 #     print(len(zf))
 #     # print(zf)
 #     print(zf[12])
 #     for im in zf:
 #         print(im, im.max)
-#     pass
+#     pass
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/VisualServo.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/VisualServo.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,40 @@
 #!/usr/bin/env python3
 from abc import ABC
+
 # from machinevisiontoolbox.Camera import P
 import numpy as np
 import matplotlib.pyplot as plt
 from machinevisiontoolbox.base import mkgrid
 from machinevisiontoolbox import CentralCamera
 import spatialmath.base as smbase
 from spatialmath import SE3
 
-class VisualServo(ABC):
 
+class VisualServo(ABC):
     class _history:
         pass
 
-    def __init__(self, camera, niter=100, graphics=True, fps=5, pose_g=None, 
-            pose_0=None, pose_d=None, P=None, p_d=None, 
-            title=None, plotvol=None, movie=None, type=None, verbose=False):
+    def __init__(
+        self,
+        camera,
+        niter=100,
+        graphics=True,
+        fps=5,
+        pose_g=None,
+        pose_0=None,
+        pose_d=None,
+        P=None,
+        p_d=None,
+        title=None,
+        plotvol=None,
+        movie=None,
+        type=None,
+        verbose=False,
+    ):
         """
         Visual servo abstract superclass
 
         :param camera: camera model
         :type camera: Camera subclass
         :param niter: number of simulation iterations, can be overridden with ``run``, defaults to 100
         :type niter: int, optional
@@ -43,19 +58,19 @@
         :type movie: [type], optional
         :param type: [description], defaults to None
         :type type: [type], optional
         :param verbose: rint out extra information during simulation, defaults to False
         :type verbose: bool, optional
 
         Two windows are shown and animated:
-        - The camera view, showing the desired view (*) and the 
+        - The camera view, showing the desired view (*) and the
           current view (o)
         - The external view, showing the target points and the camera
 
-        .. warning:: The pose of the camera object is modified while the simulation runs. 
+        .. warning:: The pose of the camera object is modified while the simulation runs.
 
         """
 
         self.camera = camera
         self.history = []
 
         self.niter = niter
@@ -63,15 +78,15 @@
         self.graphics = graphics
         self.fps = fps
         self.verbose = verbose
         self.pose_d = pose_d
         self.pose_g = pose_g
 
         self.pose_0 = pose_0
-            
+
         self.P = P
         if P is not None:
             self.npoints = P.shape[1]
         if p_d is None:
             p_d = camera.project_point(P, pose=pose_d)
         self.p_star = p_d
 
@@ -85,39 +100,41 @@
 
             # First subplot
             ax = fig.add_subplot(1, 2, 1)
             self.camera._init_imageplane(ax=ax)
             self.ax_camera = ax
 
             # Second subplot
-            ax = fig.add_subplot(1, 2, 2, projection='3d')
+            ax = fig.add_subplot(1, 2, 2, projection="3d")
             ax = smbase.plotvol3(plotvol, ax=ax)
             # smbase.plot_sphere(0.06, self.P, color='r', ax=ax)
             # self.camera.plot(self.pose, label=True, ax=ax)
             ax.view_init(16, 28)
             plt.grid(True)
             self.ax_3dview = ax
 
-            self.camera_args = dict(shape='camera', color='b', scale=0.3, ax=self.ax_3dview)
+            self.camera_args = dict(
+                shape="camera", color="b", scale=0.3, ax=self.ax_3dview
+            )
 
-            fig.patch.set_color('#f0f0f0')
-            self.ax_3dview.set_facecolor('#f0f0f0')
+            fig.patch.set_color("#f0f0f0")
+            self.ax_3dview.set_facecolor("#f0f0f0")
 
             if title is not None:
                 self.fig.canvas.manager.set_window_title(title)
 
     def init(self):
         """
         Initialize visual servo simulation.
 
         This is common initialization used by derived classes.  It initializes
         the image plane and world view graphics.
 
         If ``pose_0`` was specified at constructor time, the camera is set
-        to that pose.  Otherwise the camera is ``reset`` which returns it to 
+        to that pose.  Otherwise the camera is ``reset`` which returns it to
         the pose it has when constructed.
 
         :meth:`Camera.reset`
         """
 
         # initialize the camera pose
         if self.pose_0 is not None:
@@ -126,23 +143,25 @@
             self.camera.reset()
 
         # do graphics setup
         if self.graphics:
 
             # show the initial image plane projections as circles
             self.camera.clf()
-            self.camera.plot_point(self.P, objpose=self.pose_g, markersize=8, markerfacecolor='none')
+            self.camera.plot_point(
+                self.P, objpose=self.pose_g, markersize=8, markerfacecolor="none"
+            )
 
             # show the points in the world view
             if self.pose_g is not None:
                 P = self.pose_g * self.P
             else:
                 P = self.P
-            smbase.plot_sphere(0.05, P, color='r', ax=self.ax_3dview)
-            self.camera.plot(**{**self.camera_args, **dict(color='k')})
+            smbase.plot_sphere(0.05, P, color="r", ax=self.ax_3dview)
+            self.camera.plot(**{**self.camera_args, **dict(color="k")})
 
         # clear the history
         self.history = []
 
     def run(self, niter=None):
         """
         Run visual servo simulation
@@ -152,120 +171,142 @@
         :type niter: int, optional
 
         Concrete method that invokes the ``step`` method of the derived
         class which returns
         a flag to indicate if the simulation is complete.
         """
         self.init()
-        
+
         if self.movie is not None:
             self.anim = Animate(self.movie)
-        
+
         if niter is None:
             niter = self.niter
 
         alpha_min = 0.1
         for step in range(niter):
-            
+
             status = self.step(step)
 
             if self.graphics:
-                if self.type == 'point':
+                if self.type == "point":
                     self.plot_point(self.history[-1].p, markersize=4)
 
                 self.clear_3dview()
                 alpha = alpha_min + (1 - alpha_min) * step / niter
                 self.camera.plot(alpha=alpha, **self.camera_args)
 
                 if self.movie is not None:
                     self.anim.add()
                 else:
                     plt.pause(1 / self.fps)
-            
+
             if status > 0:
-                print('completed on error tolerance')
+                print("completed on error tolerance")
                 break
             elif status < 0:
-                print('failed on error\n')
+                print("failed on error\n")
                 break
 
         else:
             # exit on iteration limit
-            print('completed on iteration count')
-        
+            print("completed on iteration count")
+
         if self.movie is not None:
             self.anim.close()
 
     def plot_p(self):
         """
         Plot feature trajectory from simulation
 
         Show image feature points versus time.
 
         :seealso: :meth:`plot_vel` :meth:`self.plot_pose` :meth:`plot_jcond` :meth:`plot_z` :meth:`plot_error`
         """
-        
+
         if len(self.history) == 0:
             return
 
-        if self.type != 'point':
-            print('Can only plot image plane trajectories for point-based IBVS')
+        if self.type != "point":
+            print("Can only plot image plane trajectories for point-based IBVS")
             return
 
         # result is a vector with row per time step, each row is u1, v1, u2, v2 ...
         for i in range(self.npoints):
             u = [h.p[0, i] for h in self.history]  # get data for i'th point
             v = [h.p[1, i] for h in self.history]
-            plt.plot(u, v, 'b')
-        
+            plt.plot(u, v, "b")
+
         # mark the initial target shape
-        smbase.plot_polygon(self.history[0].p, 'o--', close=True, markeredgecolor='k', markerfacecolor='w', label='initial')
-        
+        smbase.plot_polygon(
+            self.history[0].p,
+            "o--",
+            close=True,
+            markeredgecolor="k",
+            markerfacecolor="w",
+            label="initial",
+        )
+
         # mark the goal target shape
         if isinstance(self, IBVS):
-            smbase.plot_polygon(self.p_star, 'k*:', close=True, markeredgecolor='k', markerfacecolor='k', label='goal')
+            smbase.plot_polygon(
+                self.p_star,
+                "k*:",
+                close=True,
+                markeredgecolor="k",
+                markerfacecolor="k",
+                label="goal",
+            )
 
         if isinstance(self, PBVS):
             p = self.camera.project_point(self.P, pose=self.pose_d.inv())
-            smbase.plot_polygon(p, 'k*:', close=True, markeredgecolor='k', markerfacecolor='k', label='goal')
-            
+            smbase.plot_polygon(
+                p,
+                "k*:",
+                close=True,
+                markeredgecolor="k",
+                markerfacecolor="k",
+                label="goal",
+            )
 
         # axis([0 self.camera.npix[0] 0 self.camera.npix[1]])
         # daspect([1 1 1])
         plt.grid(True)
-        plt.xlabel('u (pixels)')
-        plt.ylabel('v (pixels)')
+        plt.xlabel("u (pixels)")
+        plt.ylabel("v (pixels)")
         plt.xlim(0, self.camera.width)
         plt.ylim(0, self.camera.height)
         plt.legend()
         ax = plt.gca()
         ax.invert_yaxis()
-        ax.set_aspect('equal')  
-        ax.set_facecolor('lightyellow')
-    
+        ax.set_aspect("equal")
+        ax.set_facecolor("lightyellow")
 
     def plot_vel(self):
         """
         Plot camera velocity from simulation
 
         Show camera velocity versus time.
 
         :seealso: :meth:`plot_p` :meth:`self.plot_pose` ::meth:`plot_jcond` :meth:`plot_z` :meth:`plot_error`
         """
         if len(self.history) == 0:
             return
 
         vel = np.array([h.vel for h in self.history])
-        plt.plot(vel[:, :3], '-')
-        plt.plot(vel[:, 3:], '--')
-        plt.ylabel('Cartesian velocity')
+        plt.plot(vel[:, :3], "-")
+        plt.plot(vel[:, 3:], "--")
+        plt.ylabel("Cartesian velocity")
         plt.grid(True)
-        plt.xlabel('Time step')
+        plt.xlabel("Time step")
         plt.xlim(0, len(self.history) - 1)
-        plt.legend(['$v_x$', '$v_y$', '$v_z$', r'$\omega_x$', r'$\omega_y$', r'$\omega_z$'], loc='upper right')
+        plt.legend(
+            ["$v_x$", "$v_y$", "$v_z$", r"$\omega_x$", r"$\omega_y$", r"$\omega_z$"],
+            loc="upper right",
+        )
 
     def plot_pose(self):
         """
         Plot camera trajectory from simulation
 
         Show camera pose versus time, as two plots: translation and rotation
         in RPY angles.
@@ -274,113 +315,112 @@
         """
 
         if len(self.history) == 0:
             return
 
         # Cartesian camera position vs timestep
         T = SE3([h.pose for h in self.history])
-        
+
         plt.subplot(211)
         plt.plot(T.t)
         plt.xlim(0, len(self.history) - 1)
-        plt.ylabel('Camera position (m)')
-        plt.legend(['x', 'y', 'z'])
+        plt.ylabel("Camera position (m)")
+        plt.legend(["x", "y", "z"])
         plt.grid(True)
-        
+
         plt.subplot(212)
-        plt.plot(T.rpy(order='camera'))
-        plt.ylabel('Camera orientation (rad)')
+        plt.plot(T.rpy(order="camera"))
+        plt.ylabel("Camera orientation (rad)")
         plt.grid(True)
-        plt.xlabel('Time step')
+        plt.xlabel("Time step")
         plt.xlim(0, len(self.history) - 1)
-        plt.legend([r'$\alpha$', r'$\beta$', r'$\gamma$'])
-
+        plt.legend([r"$\alpha$", r"$\beta$", r"$\gamma$"])
 
     def plot_jcond(self):
         """
         Plot image Jacobian condition from simulation.
 
         Show image Jacobian condition versus time. Indicates whether the point configuration is close to
         singular.
 
         :seealso: :meth:`plot_p` :meth:`self.plot_vel` :meth:`self.plot_pose` :meth:`plot_z` :meth:`plot_error`
         """
-        
+
         if len(self.history) == 0:
             return
-        
+
         Jcond = [h.jcond for h in self.history]
         # Image Jacobian condition number vs time
         plt.plot(Jcond)
         plt.grid(True)
-        plt.ylabel('Jacobian condition number')
-        plt.xlabel('Time step')
+        plt.ylabel("Jacobian condition number")
+        plt.xlabel("Time step")
         plt.xlim(0, len(self.history) - 1)
 
     def plot_z(self):
         """
         Plot feature depth from simulation
 
         Show depth of all features versus time. If a depth estimator is
         used it shows true and estimated depth.
 
         :seealso: :meth:`plot_p` :meth:`self.plot_vel`  :meth:`self.plot_pose` :meth:`plot_jcond` :meth:`plot_error`
         """
         if len(self.history) == 0:
             return
-            
-        if self.type != 'point':
-            print('Z-estimator data only computed for point-based IBVS')
+
+        if self.type != "point":
+            print("Z-estimator data only computed for point-based IBVS")
             return
 
         Z_est = np.array([h.Z_est for h in self.history])
         Z_true = np.array([h.Z_true for h in self.history])
-        plt.plot(Z_true, '-', label='true')
-        plt.plot(Z_est, '--', label='estimate')
+        plt.plot(Z_true, "-", label="true")
+        plt.plot(Z_est, "--", label="estimate")
         plt.grid()
-        plt.ylabel('Depth (m)')
-        plt.xlabel('Time step')
+        plt.ylabel("Depth (m)")
+        plt.xlabel("Time step")
         plt.xlim(0, len(self.history) - 1)
         plt.legend()
 
     def plot_error(self):
         """
         Plot feature error from simulation
 
         Show error of all features, norm of (desired - actual) versus time. If a depth estimator is
         used it shows true and estimated depth.
 
         :seealso: :meth:`plot_p` :meth:`self.plot_vel`  :meth:`self.plot_pose` :meth:`plot_jcond` :meth:`plot_z`
         """
-        
+
         if len(self.history) == 0:
             return
-        
+
         e = np.array([h.e for h in self.history])
-        if self.type == 'point':
-            plt.plot(e[:, 0::2], 'r')
-            plt.plot(e[:, 1::2], 'b')
-            plt.ylabel('Feature error (pixel)')
-            
-            plt.legend('u', 'v')
+        if self.type == "point":
+            plt.plot(e[:, 0::2], "r")
+            plt.plot(e[:, 1::2], "b")
+            plt.ylabel("Feature error (pixel)")
+
+            plt.legend("u", "v")
         else:
             plot(e)
-            plt.ylabel('Feature error')
+            plt.ylabel("Feature error")
 
         plt.grid(True)
-        plt.xlabel('Time')
+        plt.xlabel("Time")
         plt.xlim(0, len(self.history))
 
         return e
 
     def plot_all(self):
         """
         Plot all data from simulation
 
-        Show simulation results, in separate figures, feature values, velocity, 
+        Show simulation results, in separate figures, feature values, velocity,
         error and camera pose versus time.
 
         :seealso: :meth:`plot_p` :meth:`self.plot_vel`  :meth:`self.plot_pose` :meth:`plot_jcond` :meth:`plot_z` :meth:`plot_error`
         """
 
         plt.figure()
         self.plot_p()
@@ -391,55 +431,54 @@
         plt.figure()
         self.plotpose()
 
         plt.figure()
         self.plot_error()
 
         # optional plots depending on what history was recorded
-        if hasattr(history[0], 'Z_est'):
+        if hasattr(history[0], "Z_est"):
             plt.figure()
             self.plot_z()
-        
-        if hasattr(self.history[0], 'jcond'):
+
+        if hasattr(self.history[0], "jcond"):
             plt.figure()
             self.plot_jcond()
 
     def __str__(self):
         """
         String representation of visual servo object
 
         :return: compact string representation
         :rtype: str
         """
         s = f"Visual servo object: camera={self.camera.name}\n  {self.niter} iterations, {len(self.history)} history'"
 
-        s += np.array2string(self.P, prefix='P = ')
+        s += np.array2string(self.P, prefix="P = ")
         if self.pose_0 is not None:
-            s +=  "\n" + self.pose_0.strline(label='cT', orient='camera')
+            s += "\n" + self.pose_0.strline(label="cT", orient="camera")
         if self.pose_d is not None:
-            s +=  "\n" + self.pose_d.strline(label='cdTg', orient='camera')
+            s += "\n" + self.pose_d.strline(label="cdTg", orient="camera")
         return s
 
     def __repr__(self):
         return str(self)
 
     def plot_point(self, *args, **kwargs):
         return self.camera.plot_point(*args, **kwargs)
 
     def plot(self, *args, **kwargs):
         return self.camera.plot(*args, ax=self.ax_3dview, **kwargs)
 
     def clear_3dview(self):
-        for child in self.ax_3dview.get_children(): # ax.lines:
-            if __class__.__name__ == 'Line3DCollection':
+        for child in self.ax_3dview.get_children():  # ax.lines:
+            if __class__.__name__ == "Line3DCollection":
                 child.remove()
 
 
 class PBVS(VisualServo):
-
     def __init__(self, camera, eterm=0, lmbda=0.05, **kwargs):
         """
         Position-based visual servo class
 
         :param camera: central camera mode
         :type camera: CentralCamera instance
         :param eterm: termination threshold on residual error, defaults to 0
@@ -458,86 +497,96 @@
             cam = CentralCamera('default');
             Tc0 = transl(1,1,-3)*trotz(0.6);
             TcStar_t = transl(0, 0, 1);
             pbvs = PBVS(cam, 'T0', Tc0, 'Tf', TcStar_t);
             pbself.plot_p
 
         References::
-        - Robotics, Vision & Control, Chap 15
-        P. Corke, Springer 2011.
+        - Robotics, Vision & Control for Python, Chap 15
+          P. Corke, Springer 2023.
 
         .. note:: The history attribute is a vector of structures each of which is a snapshot at
-            each simulation step of information about the image plane, camera pose, error, 
-            Jacobian condition number, error norm, image plane size and desired feature 
+            each simulation step of information about the image plane, camera pose, error,
+            Jacobian condition number, error norm, image plane size and desired feature
             locations.
 
         :seealso: :class:`IBVS` :class:`IBVS_l` :class:`IBVS_e` :class:`IBVS_polar` :class:`IBVS_sph`
         """
-        
+
         # invoke superclass constructor
-        super().__init__(camera, type='point', title='PBVS simulation', **kwargs)
+        super().__init__(camera, type="point", title="PBVS simulation", **kwargs)
 
         self.eterm = eterm
         self.lmbda = lmbda
 
         if self.pose_d is None:
             self.pose_d = SE3(0, 0, 1)
-            print('setting Tf to default')
+            print("setting Tf to default")
 
     def step(self, t):
         """
         Compute one timestep of PBVS simulation.
 
         :param t: simulation time
         :type t: float
         :return: simulation status, 0 if OK, 1 if terminating
         :rtype: int
 
         Called by the ``run`` method and performs the following steps:
 
         * find projections in current camera view
-        * using world point data, estimate goal pose {G} with respect to camera pose 
+        * using world point data, estimate goal pose {G} with respect to camera pose
         * incrementally update the camera pose.
 
         :seealso: :meth:`run` :meth:`VisualServo.run`
         """
-        
-        status = 0;
+
+        status = 0
 
         # compute the current view
         uv = self.camera.project_point(self.P, objpose=self.pose_g)
 
         # estimate pose of goal wrt camera
         Te_C_G = self.camera.estpose(self.P, uv, frame="camera")
 
         # estimate motion to desired relative pose
-        T_delta =  Te_C_G * self.pose_d.inv()
-        
+        T_delta = Te_C_G * self.pose_d.inv()
+
         # update the camera pose
         Td = T_delta.interp1(self.lmbda)
 
-        self.camera.pose @= Td      # apply it to current pose
+        self.camera.pose @= Td  # apply it to current pose
 
         # update the history variables
         hist = self._history()
         hist.p = uv
         vel = Td.delta()
         hist.vel = vel
         hist.pose = self.camera.pose
 
         self.history.append(hist)
-        
+
         if np.linalg.norm(vel) < self.eterm:
             status = 1
 
         return status
 
-class IBVS(VisualServo):
 
-    def __init__(self, camera, eterm=0.5, lmbda=0.08, depth=None, depthest=False, vmax=None, smoothstart=None, **kwargs):
+class IBVS(VisualServo):
+    def __init__(
+        self,
+        camera,
+        eterm=0.5,
+        lmbda=0.08,
+        depth=None,
+        depthest=False,
+        vmax=None,
+        smoothstart=None,
+        **kwargs,
+    ):
         r"""
         Image-based visual servo class
 
         :param camera: central camera mode
         :type camera: CentralCamera instance
         :param P: world points in frame {G}, defaults to None
         :type P: array_like(3,N), optional
@@ -568,46 +617,46 @@
                 self.run[]
                 self.plot_p[]
 
         If point depth is a scalar, it applies to all points.  If an array, the
         elements are the depth for the corresponding world points.
 
         References::
-            - Robotics, Vision & Control, Chap 15
-              P. Corke, Springer 2011.
+            - Robotics, Vision & Control for Python, Chap 15
+              P. Corke, Springer 2023.
 
         .. note::
             - The history property is a vector of structures each of which is a
               snapshot at each simulation step of information about the image
               plane, camera pose, error, Jacobian condition number, error norm,
               image plane size and desired feature locations.
             - This implementation has a sign change compared to the task
               function notation (Chaumette papers), the the error in this code is
               desired-actual which means the control gain is positive.
         """
 
         # invoke superclass constructor
-        super().__init__(camera, type='point', title='IBVS simulation', **kwargs)
+        super().__init__(camera, type="point", title="IBVS simulation", **kwargs)
 
         self.lmbda = lmbda
         self.eterm = eterm
         self.theta = 0
         self.smoothing = 0.80
         self.depth = depth
         self.depthest = depthest
         self.vmax = vmax
         self.smoothstart = smoothstart
-        
+
     @classmethod
     def Example(cls, camera):
-        print('Canned example: point-based IBVS with four feature points')
+        print("Canned example: point-based IBVS with four feature points")
         if camera is None:
-            camera = CentralCamera.Default(name='')
+            camera = CentralCamera.Default(name="")
 
-        P = mkgrid(2, 0.5, pose=SE3[-1,-1,2])
+        P = mkgrid(2, 0.5, pose=SE3[-1, -1, 2])
         pose_0 = SE3(1, 1, -3) * SE3.Rz(0.6)
         pose_d = SE3(0, 0, 1)
         self = cls(camera, P=P, pose_0=pose_0, pose_d=pose_d, depth=3)
 
         return self
 
     def init(self):
@@ -621,37 +670,36 @@
         # initialize the vservo variables
         super().init()
 
         self.vel_prev = None
         self.uv_prev = None
         self.e0 = None
 
-
     def step(self, t):
         """
         Compute one timestep of IBVS simulation.
 
         :param t: simulation time
         :type t: float
         :return: simulation status, 0 if OK, 1 if terminating
         :rtype: int
 
         Called by the ``run`` method and performs the following steps:
 
         * find projections of world points in current camera view
         * optionally estimate point depth
-        * compute the image Jacobian and camera velocity 
+        * compute the image Jacobian and camera velocity
         * incrementally update the camera pose.
 
         :seealso: :meth:`run` :meth:`VisualServo.run`
         """
-        
+
         status = 0
         Z_est = None
-        
+
         uv = self.camera.project_point(self.P)
 
         hist = self._history()
 
         # optionally estimate depth
         if self.depthest:
             # run the depth estimator
@@ -678,22 +726,22 @@
             J = self.camera.visjac_p(uv, Z_est)
         else:
             # use the default depth
             J = self.camera.visjac_p(uv, self.depth)
 
         # compute image plane error as a column
         e = uv - self.p_star  # feature error
-        e = e.flatten(order='F')  # convert columnwise to a 1D vector
+        e = e.flatten(order="F")  # convert columnwise to a 1D vector
 
         if np.linalg.norm(e) < self.eterm:
             status = 1
 
         # do the smoothstart trick
-        #  N. Mansard and F. Chaumette, 
-        #  "Task Sequencing for High-Level Sensor-Based Control," 
+        #  N. Mansard and F. Chaumette,
+        #  "Task Sequencing for High-Level Sensor-Based Control,"
         #  in IEEE Transactions on Robotics, vol. 23, no. 1, pp. 60-72, Feb. 2007,
         #  doi: 10.1109/TRO.2006.889487.
         if self.smoothstart is not None:
             if self.e0 is None:
                 self.e0 = e
             e -= self.e0 * np.exp(-self.smoothstart * t)
 
@@ -709,32 +757,32 @@
             if np.linalg.norm(v) > self.vmax:
                 v = smbase.unitvec(v) * self.vmax
 
         if self.verbose:
             print(v)
 
         # update the camera pose
-        Td = SE3.Delta(v) # differential motion
-        # Td = SE3(trnorm(delta2tr(v)))    
-        #Td = expm( skewa(v) )
-        #Td = SE3( delta2tr(v) )
-        self.camera.pose @= Td       # apply it to current pose
+        Td = SE3.Delta(v)  # differential motion
+        # Td = SE3(trnorm(delta2tr(v)))
+        # Td = expm( skewa(v) )
+        # Td = SE3( delta2tr(v) )
+        self.camera.pose @= Td  # apply it to current pose
 
         # update the history variables
         hist.p = uv
         vel = Td.delta()
         hist.vel = vel
         hist.e = e
         hist.enorm = np.linalg.norm(e)
         hist.jcond = np.linalg.cond(J)
         hist.pose = self.camera.pose
 
         self.history.append(hist)
 
-        #TODO not really needed, its in the history
+        # TODO not really needed, its in the history
         self.vel_prev = vel
         self.uv_prev = uv
 
         return status
 
     def depth_estimator(self, uv):
         """
@@ -745,58 +793,60 @@
         :return: estimated and true depth of world points
         :rtype: array_like(N), array_like(N)
 
         Estimate point depth using a recursive least-squares update based on
         optical flow and camera incremental motion over two frames.
 
         """
-        #TODO:
-        # should have some way to initialize depth rather than assuming zero 
+        # TODO:
+        # should have some way to initialize depth rather than assuming zero
         # should keep Z_est as an instance variable
-        
+
         # test if first frame
         if self.uv_prev is None:
             Z_est = None
 
         else:
             # compute Jacobian for unit depth, z=1
             J = self.camera.visjac_p(uv, 1)
             Jv = J[:, :3]  # velocity part, depends on 1/z
             Jw = J[:, 3:]  # rotational part, indepedent of 1/z
 
             # estimate image plane velocity
-            uv_d =  uv.flatten(order='F') - self.uv_prev.flatten(order='F')
-            
+            uv_d = uv.flatten(order="F") - self.uv_prev.flatten(order="F")
+
             # estimate coefficients for A (1/z) = b
             b = uv_d - Jw @ self.vel_prev[3:]
             A = Jv @ self.vel_prev[:3]
 
-            AA = np.zeros((A.shape[0], A.shape[0]//2))
-            for i in range(A.shape[0]//2):
-                AA[2*i:(i+1)*2, i] = A[2*i:(i+1)*2]
-
-            eta, resid, *_ = np.linalg.lstsq(AA, b.ravel(), rcond=None)         # least squares solution
+            AA = np.zeros((A.shape[0], A.shape[0] // 2))
+            for i in range(A.shape[0] // 2):
+                AA[2 * i : (i + 1) * 2, i] = A[2 * i : (i + 1) * 2]
+
+            eta, resid, *_ = np.linalg.lstsq(
+                AA, b.ravel(), rcond=None
+            )  # least squares solution
             # eta2 = A(1:2) \ B(1:2)
 
             # first order smoothing
             self.theta = (1 - self.smoothing) * 1 / eta + self.smoothing * self.theta
             Z_est = self.theta
 
         # true depth
         P_CT = self.camera.pose.inv() * self.P
         Z_true = P_CT[2, :]
 
         if self.verbose:
-            print('depth', Z_true)
-            print('est depth', Z_est)
+            print("depth", Z_true)
+            print("est depth", Z_est)
 
         return Z_est, Z_true
 
-class IBVS_l(VisualServo):
 
+class IBVS_l(VisualServo):
     def __init__(self, camera, eterm=0.01, plane=None, lmbda=0.08, **kwargs):
         r"""
         Image-based visual servo for line features class
 
         :param camera: central camera mode
         :type camera: CentralCamera instance
         :param P: world points in frame {G} define lines, defaults to None
@@ -833,119 +883,121 @@
                 ibvs = IBVS(cam, 'T0', Tc0, 'p_f', p_f)
                 self.run[]
                 self.plot_p[]
 
         The plane applies to all lines.
 
         References::
-            - Robotics, Vision & Control, Chap 15
-              P. Corke, Springer 2011.
+            - Robotics, Vision & Control for Python, Chap 15
+              P. Corke, Springer 2023.
 
         .. note::
             - The history property is a vector of structures each of which is a
               snapshot at each simulation step of information about the image
               plane, camera pose, error, Jacobian condition number, error norm,
               image plane size and desired feature locations.
             - This implementation has a sign change compared to the task
               function notation (Chaumette papers), the the error in this code is
               desired-actual which means the control gain is positive.
         """
 
         # invoke superclass constructor
-        super().__init__(camera, type='line', **kwargs)
-        
+        super().__init__(camera, type="line", **kwargs)
+
         self.eterm = eterm
         self.plane = plane
         self.lmbda = lmbda
-                
+
     @classmethod
     def Example(cls, camera):
         # setup for a canned example
-        print('Canned example: line-based IBVS with three lines')
+        print("Canned example: line-based IBVS with three lines")
         if camera is None:
-            camera = CentralCamera.Default(name='')
+            camera = CentralCamera.Default(name="")
 
         P = smbase.circle([0, 0, 3], 1, resolution=3)
         # self.planes = np.tile([0, 0, 1, -3], (3, 1)).T
         pose_0 = SE3(1, 1, -3) * SE3.Rz(0.6)
         pose_d = SE3(0, 0, 1)
         self = cls(camera, P=P, pose_0=pose_0, pose_d=pose_d)
         self.plane = [0, 0, 1, -3]
 
         return self
 
-
     def init(self, pose_d=None):
         """
         Initialize IBVS line simulation.
 
         Implicitly called by ``run`` to initialize state variables.
 
         :seealso: :meth:`run` :meth:`VisualServo.init`
         """
         super().init()
         self.camera.clf()
 
         # final pose is specified in terms of a camera-target pose
-        self.f_star_retinal = self.getlines(self.pose_d, np.linalg.inv(self.camera.K)) # in retinal coordinates
-        self.f_star = self.getlines(self.pose_d) # in image coordinates
-
+        self.f_star_retinal = self.getlines(
+            self.pose_d, np.linalg.inv(self.camera.K)
+        )  # in retinal coordinates
+        self.f_star = self.getlines(self.pose_d)  # in image coordinates
 
     def step(self, t):
         """
         Compute one timestep of IBVS line simulation.
 
         :param t: simulation time
         :type t: float
         :return: simulation status, 0 if OK, 1 if terminating
         :rtype: int
 
         Called by the ``run`` method and performs the following steps:
 
         * find projections of world lines in current camera view
-        * compute the image Jacobian and camera velocity 
+        * compute the image Jacobian and camera velocity
         * incrementally update the camera pose.
 
         :seealso: :meth:`run` :meth:`VisualServo.run`
         """
         status = 0
         Z_est = []
-        
+
         # compute the lines
         f = self.getlines(self.camera.pose)
 
         # now plot them
         if self.graphics:
-            #self.camera.clf()
-            colors = 'rgb'
+            # self.camera.clf()
+            colors = "rgb"
             for i in range(f.shape[1]):
                 # plot current line
                 self.plot_line_tr(self.camera, f[:, i], color=colors[i])
                 # plot demanded line
-                self.plot_line_tr(self.camera, self.f_star[:, i], color=colors[i], linestyle='--')
+                self.plot_line_tr(
+                    self.camera, self.f_star[:, i], color=colors[i], linestyle="--"
+                )
 
         f_retinal = self.getlines(self.camera.pose, scale=np.linalg.inv(self.camera.K))
 
         # compute image plane error as a column
-        e = f_retinal - self.f_star_retinal   # feature error on retinal plane
-        e = e.ravel('F')
+        e = f_retinal - self.f_star_retinal  # feature error on retinal plane
+        e = e.ravel("F")
         for i in range(0, len(e), 2):
             e[i] = smbase.angdiff(e[i])
-    
+
         J = self.camera.visjac_l(f_retinal, self.plane)
 
         # compute the velocity of camera in camera frame
         v = -self.lmbda * np.linalg.pinv(J) @ e
         if self.verbose:
-            print('v:', v)
+            print("v:", v)
 
         # update the camera pose
-        Td = SE3.Delta(v)    # differential motion
+        Td = SE3.Delta(v)  # differential motion
 
-        self.camera.pose = self.camera.pose @ Td       # apply it to current pose
+        self.camera.pose = self.camera.pose @ Td  # apply it to current pose
         # update the history variables
         hist = self._history()
         hist.f = f.ravel()
         hist.vel = v
         hist.e = e
         hist.enorm = np.linalg.norm(e)
         hist.jcond = np.linalg.cond(J)
@@ -989,41 +1041,38 @@
             theta = np.arctan2(p[0, j] - p[0, i], p[1, i] - p[1, j])
             rho = np.cos(theta) * p[0, i] + np.sin(theta) * p[1, i]
             lines.append((theta, rho))
         return np.array(lines).T
 
     @staticmethod
     def plot_line_tr(camera, lines, **kwargs):
-    # %CentralCamera.plot_line_tr  Plot line in theta-rho format
-    # %
-    # % CentralCamera.plot_line_tr(L) plots lines on the camera's image plane that
-    # % are described by columns of L with rows theta and rho respectively.
-    # %
-    # % See also Hough.
+        # %CentralCamera.plot_line_tr  Plot line in theta-rho format
+        # %
+        # % CentralCamera.plot_line_tr(L) plots lines on the camera's image plane that
+        # % are described by columns of L with rows theta and rho respectively.
+        # %
+        # % See also Hough.
 
         ax = camera._ax
         x = np.r_[ax.get_xlim()]
         y = np.r_[ax.get_ylim()]
 
         lines = smbase.getmatrix(lines, (2, None))
         # plot it
         for theta, rho in lines.T:
-            #print(f'{theta=}, {rho=}')
+            # print(f'{theta=}, {rho=}')
             if np.abs(np.cos(theta)) > 0.5:
                 # horizontalish lines
                 ax.plot(x, -x * np.tan(theta) + rho / np.cos(theta), **kwargs)
             else:
                 # verticalish lines
                 ax.plot(-y / np.tan(theta) + rho / np.sin(theta), y, **kwargs)
 
 
-
-
 class IBVS_e(VisualServo):
-
     def __init__(self, camera, eterm=0.08, plane=None, lmbda=0.04, **kwargs):
         r"""
         Image-based visual servo for ellipse features class
 
         :param camera: central camera mode
         :type camera: CentralCamera instance
         :param P: world points in frame {G} define lines, defaults to None
@@ -1060,49 +1109,50 @@
                 ibvs = IBVS(cam, 'T0', Tc0, 'p_f', p_f)
                 self.run[]
                 self.plot_p[]
 
         The plane applies to all lines.
 
         References::
-            - Robotics, Vision & Control, Chap 15
-              P. Corke, Springer 2011.
+            - Robotics, Vision & Control for Python, Chap 15
+              P. Corke, Springer 2023.
 
         .. note::
             - The history property is a vector of structures each of which is a
               snapshot at each simulation step of information about the image
               plane, camera pose, error, Jacobian condition number, error norm,
               image plane size and desired feature locations.
             - This implementation has a sign change compared to the task
               function notation (Chaumette papers), the the error in this code is
               desired-actual which means the control gain is positive.
         """
 
-        
         # invoke superclass constructor
-        print('IBVS_e constructor')
-        super().__init__(camera, type='point', **kwargs)
+        print("IBVS_e constructor")
+        super().__init__(camera, type="point", **kwargs)
 
         self.eterm = eterm
         self.plane = plane
-        self.lmbda = lmbda        
+        self.lmbda = lmbda
 
     @classmethod
     def Example(cls, camera=None, **kwargs):
         # run a canned example
-        print('canned example, ellipse + point-based IBVS')
+        print("canned example, ellipse + point-based IBVS")
         if camera is None:
-            camera = CentralCamera.Default(name='')
+            camera = CentralCamera.Default(name="")
 
-        self = cls(camera, 
+        self = cls(
+            camera,
             P=smbase.circle(radius=0.5, centre=[0, 0, 3], resolution=10),
             pose_d=SE3(0.5, 0.5, 1),
             pose_0=SE3(0.5, 0.5, 0) * SE3.Rx(0.3),
-            plane = [0, 0, 1, -3],  # plane Z=3
-            **kwargs)
+            plane=[0, 0, 1, -3],  # plane Z=3
+            **kwargs,
+        )
 
         return self
 
     def init(self):
         """
         Initialize IBVS ellipse simulation.
 
@@ -1112,99 +1162,98 @@
         """
 
         # desired feature coordinates.  This vector comprises the ellipse
         # parameters (5) and the coordinaes of 1 point
         super().init()
 
         self.f_star = np.r_[
-                self.get_ellipse_parameters(self.pose_d),
-                self.camera.project_point(self.P[:, 0], pose=self.pose_d).ravel()
-            ]
-        
+            self.get_ellipse_parameters(self.pose_d),
+            self.camera.project_point(self.P[:, 0], pose=self.pose_d).ravel(),
+        ]
+
         self.ellipse_star = self.camera.project_point(self.P, pose=self.pose_d)
         # self.ellipse_star = self.camera.project([self.P self.P(:,1)], pose=self.pose_d)
 
-
     def get_ellipse_parameters(self, pose):
-        p = self.camera.project_point(self.P, pose=pose) #, retinal=True)
+        p = self.camera.project_point(self.P, pose=pose)  # , retinal=True)
 
         # # convert to normalized image-plane coordinates
         p = smbase.homtrans(np.linalg.inv(self.camera.K), p)
         x, y = p
 
         # solve for the ellipse parameters
         # x^2 + A1 y^2 - 2 A2 xy + 2 A3 x + 2 A4 y + A5 = 0
-        A = np.column_stack([y**2, -2*x*y, 2*x, 2*y, np.ones(x.shape)])
+        A = np.column_stack([y**2, -2 * x * y, 2 * x, 2 * y, np.ones(x.shape)])
         b = -(x**2)
-        theta, resid, *_ = np.linalg.lstsq(A, b, rcond=None)         # least squares solution
+        theta, resid, *_ = np.linalg.lstsq(A, b, rcond=None)  # least squares solution
         return theta
 
     def step(self, t):
         """
         Compute one timestep of IBVS line simulation.
 
         :param t: simulation time
         :type t: float
         :return: simulation status, 0 if OK, 1 if terminating
         :rtype: int
 
         Called by the ``run`` method and performs the following steps:
 
         * find projections of world lines in current camera view
-        * compute the image Jacobian and camera velocity 
+        * compute the image Jacobian and camera velocity
         * incrementally update the camera pose.
 
         :seealso: :meth:`run` :meth:`VisualServo.run`
         """
-        
+
         status = 0
         Z_est = []
 
         # compute feature vector
         f = np.r_[
-                self.get_ellipse_parameters(self.camera.pose),
-                self.camera.project_point(self.P[:, 0]).flatten(order="F")
-            ]
-        
+            self.get_ellipse_parameters(self.camera.pose),
+            self.camera.project_point(self.P[:, 0]).flatten(order="F"),
+        ]
+
         # compute image plane error as a column
-        e = f - self.f_star   # feature error
-        
+        e = f - self.f_star  # feature error
+
         # compute the Jacobians and stack them
         Je = self.camera.visjac_e(f[:5], self.plane)  # ellipse
-        Jp = self.camera.visjac_p(f[5:], -self.plane[3]) # point
+        Jp = self.camera.visjac_p(f[5:], -self.plane[3])  # point
         J = np.vstack([Je, Jp])
 
         # compute the velocity of camera in camera frame
         v = -self.lmbda * np.linalg.pinv(J) @ e
 
         # update the camera pose
         self.camera.pose @= SE3.Delta(v)
 
         if self.verbose:
-            #print(f"{cond=}, {v=}")
+            # print(f"{cond=}, {v=}")
             self.pose.printline()
 
         # update the history variables
         hist = self._history()
         hist.f = f
         hist.p = self.camera.project_point(self.P)
         hist.vel = v
         hist.e = e
         hist.enorm = np.linalg.norm(e)
         hist.jcond = np.linalg.cond(J)
         hist.pose = self.camera.pose
         self.history.append(hist)
-        
+
         if hist.enorm < self.eterm:
             status = 1
 
         return status
 
-class IBVS_sph(VisualServo):
 
+class IBVS_sph(VisualServo):
     def __init__(self, camera, eterm=0.001, lmbda=0.1, depth=None, **kwargs):
         r"""
         Image-based visual servo for ellipse features class
 
         :param camera: central camera mode
         :type camera: CentralCamera instance
         :param P: world points in frame {G} define lines, defaults to None
@@ -1241,86 +1290,84 @@
                 ibvs = IBVS(cam, 'T0', Tc0, 'p_f', p_f)
                 self.run[]
                 self.plot_p[]
 
         The plane applies to all lines.
 
         References::
-            - Robotics, Vision & Control, Chap 15
-              P. Corke, Springer 2011.
+            - Robotics, Vision & Control for Python, Chap 15
+              P. Corke, Springer 2023.
 
         .. note::
             - The history property is a vector of structures each of which is a
               snapshot at each simulation step of information about the image
               plane, camera pose, error, Jacobian condition number, error norm,
               image plane size and desired feature locations.
             - This implementation has a sign change compared to the task
               function notation (Chaumette papers), the the error in this code is
               desired-actual which means the control gain is positive.
         """
 
         # invoke superclass constructor
-        super().__init__(camera, type='point', **kwargs)
-        
+        super().__init__(camera, type="point", **kwargs)
+
         self.lmbda = lmbda
         self.eterm = eterm
         self.depth = depth
-        
-                
+
     @classmethod
     def Example(cls):
         # run a canned example
-        print('canned example, spherical IBVS with 4 points');
+        print("canned example, spherical IBVS with 4 points")
         if camera is None:
-            camera = SphericalCamera.Default(name='')
+            camera = SphericalCamera.Default(name="")
         self = cls(camera, **kwargs)
         self.P = mkgrid(2, side=1.5, pose=SE3(0, 0, 0.5))
         self.pose_d = SE3(0, 0, -1.5) * SE3.Rz(1)
         self.pose_0 = SE3(0.3, 0.3, -2) * SE3.Rz(0.2)
         # self.T0 = transl(-1,-0.1,-3);%*trotx(0.2)
 
     def init(self):
 
         super().init()
 
         # final pose is specified in terms of a camera-target pose
         #   convert to image coords
         self.p_star = self.camera.project_point(self.P, pose=self.pose_d)
 
-
     def step(self, t):
         """
         Compute one timestep of IBVS line simulation.
 
         :param t: simulation time
         :type t: float
         :return: simulation status, 0 if OK, 1 if terminating
         :rtype: int
 
         Called by the ``run`` method and performs the following steps:
 
         * find projections of world lines in current camera view
-        * compute the image Jacobian and camera velocity 
+        * compute the image Jacobian and camera velocity
         * incrementally update the camera pose.
 
         :seealso: :meth:`run` :meth:`VisualServo.run`
         """
-        status = 0;
-        Z_est = [];
-        
+        status = 0
+        Z_est = []
+
         # compute image plane error as a column
         p = self.camera.project_point(self.P)  # (phi, theta)
         # if self.verbose:
         #     print(f"{p=}")
 
-        e = self.p_star - p   # feature error
+        e = self.p_star - p  # feature error
         e[0, :] = smbase.wrap_mpi_pi(e[0, :])
         e[1, :] = smbase.wrap_0_pi(e[1, :])
-        e = e.flatten(order='F')
-    
+        e = e.flatten(order="F")
+
         # compute the Jacobian
         if self.depth is None:
             # exact depth from simulation (not possible in practice)
             P_C = self.camera.pose.inv() * self.P
             J = self.camera.visjac_p(p, P_C[2, :])
         else:
             J = self.camera.visjac_p(pt, self.depth)
@@ -1331,27 +1378,25 @@
         except np.linalg.LinAlgError:
             status = -1
 
         # if self.verbose:
         #     print(f"{v=}")
 
         # update the camera pose
-        self.camera.pose @= SE3.Delta(v) 
+        self.camera.pose @= SE3.Delta(v)
 
         # draw lines from points to centre of camera
         if self.graphics:
             centre = self.camera.pose.t
             plt.sca(self.ax_3dview)
             for (phi, theta), P in zip(p.T, self.P.T):
-                plt.plot(*[(centre[i], P[i]) for i in range(3)], 'k', linewidth=0.5)
+                plt.plot(*[(centre[i], P[i]) for i in range(3)], "k", linewidth=0.5)
                 # pc = [np.sin(theta) * np.cos(phi), np.sin(theta) * np.sin(phi), np.cos(theta)] + centre
                 pc = centre + smbase.unitvec(P - centre)
-                smbase.plot_sphere(0.02, pc, color='r', ax=self.ax_3dview)
-
-                # self.plot_ray(centre, P, color='k')
+                smbase.plot_sphere(0.02, pc, color="r", ax=self.ax_3dview)
 
         # update the history variables
         hist = self._history()
         hist.p = p
         hist.vel = v
         hist.e = e
         hist.enorm = np.linalg.norm(e)
@@ -1359,57 +1404,60 @@
         hist.pose = self.camera.pose
         self.history.append(hist)
 
         if hist.enorm < self.eterm:
             status = 1
         return status
 
-    def plot_ray(self, centre, P, **kwargs):
-        dir = smbase.unitvec(P - centre)
-        plt.plot(*[(centre[i] + dir[i], P[i]) for i in range(3)], **kwargs)
-
-
     def plot_p(self):
         # result is a vector with row per time step, each row is u1, v1, u2, v2 ...
         for i in range(self.npoints):
             u = [h.p[0, i] for h in self.history]  # get data for i'th point
             v = [h.p[1, i] for h in self.history]
-            plt.plot(u, v, 'b')
-        
+            plt.plot(u, v, "b")
+
         # mark the initial target shape
-        smbase.plot_point(self.history[0].p, 'o', markeredgecolor='k', markerfacecolor='w', label='initial')
-        
+        smbase.plot_point(
+            self.history[0].p,
+            "o",
+            markeredgecolor="k",
+            markerfacecolor="w",
+            label="initial",
+        )
+
         # mark the goal target shape
-        smbase.plot_point(self.p_star, 'k*', markeredgecolor='k', markerfacecolor='k', label='goal')
+        smbase.plot_point(
+            self.p_star, "k*", markeredgecolor="k", markerfacecolor="k", label="goal"
+        )
 
         # axis([0 self.camera.npix[0] 0 self.camera.npix[1]])
         # daspect([1 1 1])
         ax = plt.gca()
 
         plt.grid(True)
-        ax.set_xlabel('Azimuth φ (rad)')
-        ax.set_ylabel('Colatitude θ (rad)')
+        ax.set_xlabel("Azimuth φ (rad)")
+        ax.set_ylabel("Colatitude θ (rad)")
         ax.set_xlim(-np.pi, np.pi)
         ax.set_ylim(0, np.pi)
         ax.invert_yaxis()
-        plt.legend(loc='lower right')
-        ax.set_facecolor('lightyellow')
+        plt.legend(loc="lower right")
+        ax.set_facecolor("lightyellow")
 
 
 # %IBVS   Implement classical IBVS for point features
 # %
 # %  results = ibvs(T)
 # %  results = ibvs(T, params)
 # %
-# %  Simulate IBVS with for a square target comprising 4 points is placed 
+# %  Simulate IBVS with for a square target comprising 4 points is placed
 # %  in the world XY plane. The camera/robot is initially at pose T and is
 # %  driven to the orgin.
 # %
 # %  Two windows are shown and animated:
-# %   1. The camera view, showing the desired view (*) and the 
+# %   1. The camera view, showing the desired view (*) and the
 # %      current view (o)
 # %   2. The external view, showing the target points and the camera
 # %
 # % The results structure contains time-history information about the image
 # % plane, camera pose, error, Jacobian condition number, error norm, image
 # % plane size and desired feature locations.
 # %
@@ -1432,16 +1480,16 @@
 # %
 # % 1.  As per task function notation (Chaumette papers) the error is
 # %     defined as actual-demand, the reverse of normal control system
 # %     notation.
 # % 2.  The gain, lambda, is always positive
 # % 3.  The negative sign is written into the control law
 
-class IBVS_polar(VisualServo):
 
+class IBVS_polar(VisualServo):
     def __init__(self, camera, eterm=0.01, lmbda=0.02, depth=None, **kwargs):
         r"""
         Image-based visual servo for ellipse features class
 
         :param camera: central camera mode
         :type camera: CentralCamera instance
         :param P: world points in frame {G} define lines, defaults to None
@@ -1478,40 +1526,40 @@
                 ibvs = IBVS(cam, 'T0', Tc0, 'p_f', p_f)
                 self.run[]
                 self.plot_p[]
 
         The plane applies to all lines.
 
         References::
-            - Robotics, Vision & Control, Chap 15
-              P. Corke, Springer 2011.
+            - Robotics, Vision & Control for Python, Chap 15
+              P. Corke, Springer 2023.
 
         .. note::
             - The history property is a vector of structures each of which is a
               snapshot at each simulation step of information about the image
               plane, camera pose, error, Jacobian condition number, error norm,
               image plane size and desired feature locations.
             - This implementation has a sign change compared to the task
               function notation (Chaumette papers), the the error in this code is
               desired-actual which means the control gain is positive.
         """
         # monkey patch the plot setup for the CentralCamera object
         import types
+
         camera._init_imageplane = types.MethodType(self._init_imageplane, camera)
         camera._project_point = camera.project_point
         camera.project_point = types.MethodType(self._project_polar, camera)
 
         # invoke superclass constructor
-        super().__init__(camera, type='point', **kwargs)
-        
+        super().__init__(camera, type="point", **kwargs)
+
         self.lmbda = lmbda
         self.eterm = eterm
         self.depth = depth
 
-
     def init(self):
 
         # initialize the vservo variables
         super().init()
 
         # if 0 % isempty(self.h_rt) || ~ishandle(self.h_rt)
         #     fprintf('create rt axes\n');
@@ -1525,20 +1573,19 @@
         #     ylabel('r (pix)');
         #     title('polar coordinate feature space');
         #     grid
         # end
         # %axes(self.h_rt)
         # %cla
 
-
         # final pose is specified in terms of a camera-target pose
         #  convert to image coords
         self.th_r_star = self.camera.project_point(self.P, pose=self.pose_d)
 
-        self.plot_point(self.p_star, '*')
+        self.plot_point(self.p_star, "*")
 
         if smbase.isscalar(self.lmbda):
             self.lmbda = np.diag([self.lmbda] * 6)
 
         # show the reference location, this is the view we wish to achieve
         # when Tc = Tct_star
         # if 0
@@ -1556,32 +1603,31 @@
         # % this is the 'external' view of the points and the camera
         # %plot_sphere(self.P, 0.05, 'b')
         # %cam2 = showcamera(T0);
         # clf
         # self.camera.plot_camera(self.P, 'label');
         # # %camup([0,-1,0]);
 
-        self.history = [];
-
+        self.history = []
 
     def step(self, t):
-        status = 0;
-        Zest = [];
-        
+        status = 0
+        Zest = []
+
         hist = self._history()
 
         # compute the polar projection view (phi, r)
         p = self.camera.project_point(self.P)
 
         # compute image plane error as a column
         e = self.p_star - p  # feature error
 
         e[0, :] = smbase.wrap_mpi_pi(e[0, :])
-        e = e.flatten(order='F')  # convert columnwise to a 1D vector 
-        
+        e = e.flatten(order="F")  # convert columnwise to a 1D vector
+
         # compute the Jacobian
         if self.depth is None:
             # exact depth from simulation (not possible in practice)
             pt = self.camera.pose.inv() * self.P
             J = self.camera.visjac_p_polar(p, pt[2, :])
         else:
             # use the default depth
@@ -1597,19 +1643,19 @@
             print(v)
 
         vmax = 0.02
         if np.linalg.norm(v) > vmax:
             v = smbase.unitvec(v) * vmax
 
         # update the camera pose
-        Td = SE3.Delta(v) # differential motion
-        # Td = SE3(trnorm(delta2tr(v)))    
-        #Td = expm( skewa(v) )
-        #Td = SE3( delta2tr(v) )
-        self.camera.pose @= Td       # apply it to current pose
+        Td = SE3.Delta(v)  # differential motion
+        # Td = SE3(trnorm(delta2tr(v)))
+        # Td = expm( skewa(v) )
+        # Td = SE3( delta2tr(v) )
+        self.camera.pose @= Td  # apply it to current pose
 
         # update the history variables
         hist.p = p
         vel = Td.delta()
         hist.vel = vel
         hist.e = e
         hist.enorm = np.linalg.norm(e)
@@ -1624,49 +1670,62 @@
         return status
 
     def plot_p(self):
         # result is a vector with row per time step, each row is u1, v1, u2, v2 ...
         for i in range(self.npoints):
             u = [h.p[0, i] for h in self.history]  # get data for i'th point
             v = [h.p[1, i] for h in self.history]
-            plt.plot(u, v, 'b')
-        
+            plt.plot(u, v, "b")
+
         # mark the initial target shape
-        smbase.plot_point(self.history[0].p, 'o', markeredgecolor='k', markerfacecolor='w', label='initial')
-        
+        smbase.plot_point(
+            self.history[0].p,
+            "o",
+            markeredgecolor="k",
+            markerfacecolor="w",
+            label="initial",
+        )
+
         # mark the goal target shape
-        smbase.plot_point(self.p_star, 'k*', markeredgecolor='k', markerfacecolor='k', label='goal')
+        smbase.plot_point(
+            self.p_star, "k*", markeredgecolor="k", markerfacecolor="k", label="goal"
+        )
 
         # axis([0 self.camera.npix[0] 0 self.camera.npix[1]])
         # daspect([1 1 1])
         ax = plt.gca()
 
         plt.grid(True)
-        ax.set_xlabel('Azimuth φ (rad)')
-        ax.set_ylabel('normalized radius r')
+        ax.set_xlabel("Azimuth φ (rad)")
+        ax.set_ylabel("normalized radius r")
         ax.set_xlim(-np.pi, np.pi)
-        rmax = np.linalg.norm(np.r_[self.camera.width, self.camera.height] - self.camera.pp) * 2 / self.camera.width
+        rmax = (
+            np.linalg.norm(
+                np.r_[self.camera.width, self.camera.height] - self.camera.pp
+            )
+            * 2
+            / self.camera.width
+        )
         ax.set_ylim(0, rmax)
         plt.legend()
-        ax.set_facecolor('lightyellow')
+        ax.set_facecolor("lightyellow")
 
     @staticmethod
     def _project_polar(self, P, pose=None, objpose=None):
         # bound to project_point()
 
         # overloaded projection method, projects to polar coordinates
 
         p = self._project_point(P, pose=pose, objpose=objpose)
         # %p = homtrans( inv(self.camera.K), p);
 
         pp = self.pp
         u = p[0, :] - pp[0]
         v = p[1, :] - pp[1]
-        th_r = np.array([np.arctan2(v,u),
-                         np.sqrt(u**2 + v**2) / self.width * 2])
+        th_r = np.array([np.arctan2(v, u), np.sqrt(u**2 + v**2) / self.width * 2])
 
         # %line(rt(:,2), rt(:,1), 'Marker', 'o', 'MarkerFaceColor', 'k', 'Parent', self.h_rt)
         # % plot points on rt plane
 
         return th_r
 
     @staticmethod
@@ -1679,16 +1738,16 @@
         ax.set_xlim(-np.pi, np.pi)
         rmax = np.linalg.norm(np.r_[self.width, self.height] - self.pp) * 2 / self.width
         ax.set_ylim(0, rmax)
 
         ax.autoscale(False)
         ax.grid(True)
 
-        ax.set_xlabel('Azimuth φ (rad)')
-        ax.set_ylabel('normalized radius')
+        ax.set_xlabel("Azimuth φ (rad)")
+        ax.set_ylabel("normalized radius")
 
         ax.set_title(self.name)
-        ax.set_facecolor('lightyellow')
-        ax.figure.canvas.set_window_title('Machine Vision Toolbox for Python')
+        ax.set_facecolor("lightyellow")
+        ax.figure.canvas.set_window_title("Machine Vision Toolbox for Python")
 
         # TODO figure out axes ticks, etc
         return ax  # likely this return is not necessary
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/color.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/color.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 #!/usr/bin/env python
 # import io as io
 from machinevisiontoolbox.base.data import mvtb_path_to_datafile
 import numpy as np
 import re
-from spatialmath import base 
+from spatialmath import base
 import cv2 as cv
 import matplotlib.pyplot as plt
 import matplotlib.path as mpath
 import matplotlib.colors as colors
 import warnings
 
 import urllib.request
@@ -41,39 +41,41 @@
 
     .. note::
 
         - Comments are assumed to be as original data files were part of the
           MATLAB machine vision toolbox, which can be changed using kwargs.
 
     """
-    path = mvtb_path_to_datafile('data', filename)
+    path = mvtb_path_to_datafile("data", filename)
 
     try:
         # import filename, which we expect to be a .dat file
         # columns for wavelength and spectral data
         # assume column delimiters are whitespace, so for .csv files,
         # replace , with ' '
         with open(path.as_posix()) as file:
-            clean_lines = (line.replace(',', ' ') for line in file)
+            clean_lines = (line.replace(",", " ") for line in file)
             # default delimiter whitespace
             data = np.genfromtxt(clean_lines, **kwargs)
     except IOError:
         raise ValueError(f"Cannot open {filename}")
 
     if verbose:
         print(f"_loaddata: {path}, {data.shape}")
 
     if data is None:
-        raise ValueError('Could not read the specified data filename')
+        raise ValueError("Could not read the specified data filename")
 
     return data
 
+
 _spectra = {}
 
-def loadspectrum(λ, filename, verbose=False, method='linear', **kwargs):
+
+def loadspectrum(λ, filename, verbose=False, method="linear", **kwargs):
     """
     Load spectrum data
 
     :param λ: wavelength 𝜆 [m]
     :type λ: array_like(N)
     :param filename: filename, an extension of ``.dat`` will be added if not
         provided
@@ -90,15 +92,15 @@
 
     .. runblock:: pycon
 
         >>> from machinevisiontoolbox import loadspectrum
         >>> import numpy as np
         >>> l = np.linspace(380, 700, 10) * 1e-9  # visible spectrum
         >>> sun = loadspectrum(l, "solar")
-        >>> print(sun[:5])       
+        >>> print(sun[:5])
 
     .. note::
 
         - The file contains columns of data, white space separated, and the
           first column is wavelength in metres. The remaining columns are
           linearly interpolated and returned as columns of S.
         - The files are kept in the private folder inside the ``mvtb_data``
@@ -112,37 +114,45 @@
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
     """
     global _spectra
 
     if filename not in _spectra:
         # save an interpolator for every spectrum
-        if not filename.endswith('.dat'):
-            filename += '.dat'
-        _spectra[filename] = _loaddata(filename,
-            comments='%', verbose=verbose, **kwargs)
+        if not filename.endswith(".dat"):
+            filename += ".dat"
+        _spectra[filename] = _loaddata(
+            filename, comments="%", verbose=verbose, **kwargs
+        )
 
     # check valid input
     λ = base.getvector(λ)
-    
+
     # interpolate data
     data = _spectra[filename]
-    f = interpolate.interp1d(data[:, 0], data[:, 1:],
-                        axis=0, kind=method, 
-                        bounds_error=False, 
-                        fill_value=0, **kwargs)
+    f = interpolate.interp1d(
+        data[:, 0],
+        data[:, 1:],
+        axis=0,
+        kind=method,
+        bounds_error=False,
+        fill_value=0,
+        **kwargs,
+    )
 
     spectrum = f(λ)
     if spectrum.shape[1] == 1:
         return spectrum.flatten()
     else:
         return spectrum
 
+
 # ------------------------------------------------------------------------- #
 
+
 def blackbody(λ, T):
     """
     Compute blackbody emission spectrum
 
     :param λ: wavelength 𝜆 [m]
     :type λ: float, array_like(N)
     :param T: blackbody temperature [K]
@@ -167,26 +177,27 @@
         >>> print(e[:5])
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
     """
 
     # physical constants
-    c = 2.99792458e8   # m/s         (speed of light)
-    h = 6.626068e-34   # m2 kg / s   (Planck's constant)
+    c = 2.99792458e8  # m/s         (speed of light)
+    h = 6.626068e-34  # m2 kg / s   (Planck's constant)
     k = 1.3806503e-23  # J K-1      (Boltzmann's constant)
 
     λ = base.getvector(λ)
 
     e = 2.0 * h * c**2 / (λ**5 * (np.exp(h * c / k / T / λ) - 1))
     if len(e) == 1:
         return e[0]
     else:
         return e
 
+
 def lambda2rg(λ, e=None, **kwargs):
     r"""
     RGB chromaticity coordinates
 
     :param λ: wavelength 𝜆 [m]
     :type λ: float, array_like(N)
     :param e: illlumination spectrum defined at the wavelengths 𝜆
@@ -243,24 +254,25 @@
     λ = base.getvector(λ)
 
     if e is None:
         rgb = cmfrgb(λ, **kwargs)
     else:
         e = base.getvector(e)
         if len(e) != len(λ):
-            raise ValueError('number of wavelengths and intensities must match')
+            raise ValueError("number of wavelengths and intensities must match")
         rgb = cmfrgb(λ, e, **kwargs)
 
     cc = tristim2cc(rgb)
 
     if cc.shape[0] == 1:
         return cc[0, :]
     else:
         return cc
 
+
 def cmfrgb(λ, e=None, **kwargs):
     r"""
     RGB color matching function
 
     :param λ: wavelength 𝜆 [m]
     :type λ: array_like(N)
     :param e: illlumination spectrum defined at the wavelengths 𝜆
@@ -270,15 +282,15 @@
 
     The color matching function is the CIE RGB tristimulus required to match a
     particular wavelength excitation.
 
     Compute the CIE RGB color matching function for illumination at wavelength
     :math:`\lambda` [m]. This is the RGB tristimulus that has the same visual
     sensation as the single wavelength :math:`\lambda`.
-    
+
     If 𝜆 is an array then each row of the result is the color matching function
     of the corresponding element of :math:`\lambda`.
 
     If ``e`` is given, compute the CIE color matching function for an
     illumination spectrum :math:`\texttt{e}(\lambda)` defined at corresponding
     wavelengths of :math:`\lambda`. This is the tristimulus that has the same
     visual sensation as :math:`\texttt{e}(\lambda)`.
@@ -298,28 +310,29 @@
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`~lambda2rg`
     """
 
     λ = base.getvector(λ)  # λ is (N,1)
 
-    cmf = loadspectrum(λ, 'cmfrgb', **kwargs)
+    cmf = loadspectrum(λ, "cmfrgb", **kwargs)
     # approximate rectangular integration
     # assume steps are equal sized
     if e is not None:
-        e = base.getvector(e, out='row')  # e is a vector Nx1
+        e = base.getvector(e, out="row")  # e is a vector Nx1
         dλ = λ[1] - λ[0]
         ret = (e @ cmf) / cmf.shape[0] * dλ
     else:
         ret = cmf
 
     if ret.shape[0] == 1:
         ret = ret[0, :]
     return ret
 
+
 def tristim2cc(tri):
     r"""
     Tristimulus to chromaticity coordinates
 
     :param tri: RGB or XYZ tristimulus
     :type tri: array_like(3), array_like(N,3), ndarray(N,M,3)
     :return: chromaticity coordinates
@@ -375,24 +388,24 @@
 
         #  / np.sum(XYZ, axis=1)[..., np.newaxis];
 
     elif tri.ndim == 3 and tri.shape[-1] == 3:
         # N x M x 3 case
 
         # tri is given as an image
-        s = np.sum(tri, axis=2)  
+        s = np.sum(tri, axis=2)
         ss = np.stack((s, s), axis=-1)  # could also use np.tile
         cc = tri[0:, 0:, :2] / ss
 
     elif base.isvector(tri, 3):
         tri = base.getvector(tri)
         cc = tri[:2] / np.sum(tri)
 
     else:
-        raise ValueError('bad shape input')
+        raise ValueError("bad shape input")
 
     return cc
 
 
 def lambda2xy(λ, *args):
     r"""
     XY-chromaticity coordinates for a given wavelength 𝜆 [meters]
@@ -429,14 +442,15 @@
     xy = tristim2cc(cmf)
 
     if xy.shape[0] == 1:
         return xy[0, :]
     else:
         return xy
 
+
 def cmfxyz(λ, e=None, **kwargs):
     r"""
     Color matching function for xyz tristimulus
 
     :param λ: wavelength 𝜆 [m]
     :type λ: array_like(N)
     :param e: illlumination spectrum defined at the wavelengths 𝜆
@@ -446,15 +460,15 @@
 
     The color matching function is the XYZ tristimulus required to match a
     particular wavelength excitation.
 
     Compute the CIE XYZ color matching function for illumination at wavelength
     :math:`\lambda` [m]. This is the XYZ tristimulus that has the same visual
     sensation as the single wavelength :math:`\lambda`.
-    
+
     If :math:`\lambda` is an array then each row of the result is the color
     matching function of the corresponding element of :math:`\lambda`.
 
     If ``e`` is given, compute the CIE XYZ color matching function for an
     illumination spectrum :math:`\texttt{e}(\lambda)` defined at corresponding
     wavelengths of :math:`\lambda`. This is the XYZ tristimulus that has the
     same visual sensation as :math:`\texttt{e}(\lambda)`.
@@ -476,24 +490,25 @@
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`lambda2xy` :func:`ccxyz`
     """
     λ = base.getvector(λ)
 
-    cmfxyz = loadspectrum(λ, 'cmfxyz')
+    cmfxyz = loadspectrum(λ, "cmfxyz")
 
     if e is not None:
         # approximate rectangular integration
         dλ = λ[1] - λ[0]
-        XYZ = e.reshape((1,-1)) @ cmfxyz * dλ
+        XYZ = e.reshape((1, -1)) @ cmfxyz * dλ
         return XYZ
     else:
         return cmfxyz
 
+
 def luminos(λ, **kwargs):
     r"""
     Photopic luminosity function
 
     :param λ: wavelength 𝜆 [m]
     :type λ: float, array_like(N)
     :return: luminosity
@@ -520,15 +535,15 @@
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`rluminos`
     """
     λ = base.getvector(λ)
 
-    luminos = loadspectrum(λ, 'photopicluminosity')
+    luminos = loadspectrum(λ, "photopicluminosity")
 
     if len(luminos) == 1:
         luminos = luminos[0]
     return luminos * 683  # photopic luminosity is the Y color matching function
 
 
 def rluminos(λ, **kwargs):
@@ -619,72 +634,77 @@
         e = base.getvector(e)
         xyz = xyz / (e * np.ones((1, 3)))
         xyz = np.sum(xyz)
         cc = xyz / (np.sum(xyz) * np.ones((1, 3)))
 
     return cc
 
+
 # ------------------------------------------------------------------------- #
 
+
 def _loadrgbdict(fname):
     """
     Load file as rgb dictionary
 
     :param fname: filename
     :type fname: string
     :return: rgbdict
     :rtype: dictionary
 
     ``_loadrgbdict(fname)`` returns ``rgbdict`` from ``fname``, otherwise
     returns Empty
 
     .. note::
-    
+
         - Assumes the file is organized as four columns: R, G, B, name.
         - Color names are converted to lower case
         - # comment lines and blank lines are ignored
         - Values in the range [0,255] are mapped to [0,1.0]
 
     """
 
     if not isinstance(fname, str):
-        raise ValueError(fname, 'file name must be a string')
+        raise ValueError(fname, "file name must be a string")
 
-    data = _loaddata(fname, comments='#',
-                     dtype=None, encoding='ascii')
+    data = _loaddata(fname, comments="#", dtype=None, encoding="ascii")
 
     # result is an ndarray of tuples
     # convert data to a dictionary
     rgbdict = {}
     for *rgb, name in data:
         rgbdict[str(name).lower()] = [x / 255.0 for x in rgb]
 
     return rgbdict
 
 
 _rgbdict = None
 
+
 def color_bgr(color):
     rgb = name2color(color)
     return [int(x * 255) for x in reversed(rgb)]
 
-def name2color(name, colorspace='RGB', dtype='float'):
+
+def name2color(name, colorspace="RGB", dtype="float"):
     """
     Map color name to value
 
     :param name: name of a color
     :type name: str
     :param colorspace: name of colorspace, one of: ``'rgb'`` [default], ``'xyz'``, ``'xy'``, ``'ab'``
     :type colorspace: str, optional
+    :param dtype: datatype of returned numeric values
+    :type: str
     :return: color tristimulus or chromaticity value
     :rtype: ndarray(3), ndarray(2)
 
     Looks up the RGB tristimulus for this color using ``matplotlib.colors`` and
-    converts it to the desired ``colorspace``.  
-    
+    converts it to the desired ``colorspace``.
+
     RGB tristimulus values are in the range [0,1].  If ``dtype`` is specified,
     the values are scaled to the range [0,M] where M is the maximum positive
     value of ``dtype`` and cast to type ``dtype``.
 
     Colors can have long names like ``'red'`` or ``'sky blue'`` as well as single character
     names like ``'r'``, ``'g'``, ``'b'``, ``'c'``, ``'m'``, ``'y'``, ``'w'``, ``'k'``.
 
@@ -702,49 +722,55 @@
         >>> name2color('lime green')
         >>> name2color('.*burnt.*')
 
     .. note:: Uses color database from Matplotlib.
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
-    
+
     :seealso: :func:`~color2name`
     """
     colorspace = colorspace.lower()
 
     def csconvert(name, cs):
 
         rgb = colors.to_rgb(name)
 
-        if cs == 'rgb':
+        if cs == "rgb":
             return np.r_[rgb]
-        elif cs in ('xyz', 'lab', 'l*a*b*'):
-            return colorspace_convert(rgb, 'rgb', cs)
-        elif cs == 'xy':
-            xyz = colorspace_convert(rgb, 'rgb', 'xyz')
+        elif cs in ("xyz", "lab", "l*a*b*"):
+            return colorspace_convert(rgb, "rgb", cs)
+        elif cs == "xy":
+            xyz = colorspace_convert(rgb, "rgb", "xyz")
             return xyz[:2] / np.sum(xyz)
-        elif cs == 'ab':
-            Lab = colorspace_convert(rgb, 'rgb', 'lab')
+        elif cs == "ab":
+            Lab = colorspace_convert(rgb, "rgb", "lab")
             return Lab[1:]
         else:
-            raise ValueError('unknown colorspace')
+            raise ValueError("unknown colorspace")
 
     if any([c in ".?*" for c in name]):
         # has a wildcard
-        return list(filter(re.compile(name).match, [key for key in colors.get_named_colors_mapping().keys()]))
+        return list(
+            filter(
+                re.compile(name).match,
+                [key for key in colors.get_named_colors_mapping().keys()],
+            )
+        )
     else:
         try:
             color = csconvert(name, colorspace)
             if np.issubdtype(dtype, np.integer):
                 color = (color * np.iinfo(dtype).max).astype(dtype)
             return color
         except ValueError:
             return None
 
-def color2name(color, colorspace='RGB'):
+
+def color2name(color, colorspace="RGB"):
     """
     Map color value to color name
 
     :param color: color value
     :type color: array_like(3), array_like(2)
     :param colorspace: name of colorspace, one of: ``'rgb'`` [default], ``'xyz'``, ``'xy'``, ``'ab'``
     :type colorspace: str, optional
@@ -774,79 +800,71 @@
     :seealso: :func:`~name2color`
     """
 
     # map numeric tuple to color name
     colorspace = colorspace.lower()
 
     color = np.array(color).flatten()  # convert tuple or list into np array
-    table = np.vstack([colors.to_rgb(color) for color in colors.get_named_colors_mapping().keys()])
+    table = np.vstack(
+        [colors.to_rgb(color) for color in colors.get_named_colors_mapping().keys()]
+    )
 
-    if colorspace in ('rgb', 'xyz', 'lab', 'l*a*b*'):
+    if colorspace in ("rgb", "xyz", "lab", "l*a*b*"):
         if len(color) != 3:
-            raise ValueError('color value must have 3 elements')
-        if colorspace in ('xyz', 'lab'):
-            table = colorspace_convert(table, 'rgb', colorspace)
+            raise ValueError("color value must have 3 elements")
+        if colorspace in ("xyz", "lab"):
+            table = colorspace_convert(table, "rgb", colorspace)
         dist = np.linalg.norm(table - color, axis=1)
         k = np.argmin(dist)
         return list(colors.get_named_colors_mapping())[k]
 
-    elif colorspace in ('xy', 'ab', 'a*b*'):
+    elif colorspace in ("xy", "ab", "a*b*"):
         if len(color) != 2:
-            raise ValueError('color value must have 2 elements')
+            raise ValueError("color value must have 2 elements")
+
+        if colorspace == "xy":
+            table = colorspace_convert(table, "rgb", "xyz")
+            with np.errstate(divide="ignore", invalid="ignore"):
+                table = table[:, 0:2] / np.tile(np.sum(table, axis=1), (2, 1)).T
+        elif colorspace in ("ab", "a*b*"):
+            table = colorspace_convert(table, "rgb", "Lab")
+            table = table[:, 1:3]
 
-        if colorspace == 'xy':
-            table = colorspace_convert(table, 'rgb', 'xyz')
-            with np.errstate(divide='ignore',invalid='ignore'):
-                table = table[:,0:2] / np.tile(np.sum(table, axis=1), (2,1)).T
-        elif colorspace in ('ab', 'a*b*'):
-            table = colorspace_convert(table, 'rgb', 'Lab')
-            table = table[:,1:3]
-        
         dist = np.linalg.norm(table - color, axis=1)
         k = np.nanargmin(dist)
         return list(colors.get_named_colors_mapping())[k]
     else:
-        raise ValueError('unknown colorspace')
+        raise ValueError("unknown colorspace")
+
 
+def colorname(arg, colorspace="RGB"):
+    raise DeprecationWarning("please use name2color or color2name")
 
-def colorname(arg, colorspace='RGB'):
-    raise DeprecationWarning('please use name2color or color2name')
 
 # ------------------------------------------------------------------------- #
 
-_white = {
-    'd65': [0.3127, 0.3290],  #D65 2 deg
-    'e':   [0.33333, 0.33333]  # E
-}
+_white = {"d65": [0.3127, 0.3290], "e": [0.33333, 0.33333]}  # D65 2 deg  # E
 
 _xy_primaries = {
-    'itu-709': np.array([
-        [0.64, 0.33],
-        [0.30, 0.60],
-        [0.15, 0.06]]),
-    'cie': np.array([
-        [0.6400, 0.3300], 
-        [0.3000, 0.6000], 
-        [0.1500, 0.0600]]),
-    'srgb': np.array([
-        [0.6400, 0.3300], 
-        [0.3000, 0.6000],
-        [0.1500, 0.0600]])
+    "itu-709": np.array([[0.64, 0.33], [0.30, 0.60], [0.15, 0.06]]),
+    "cie": np.array([[0.6400, 0.3300], [0.3000, 0.6000], [0.1500, 0.0600]]),
+    "srgb": np.array([[0.6400, 0.3300], [0.3000, 0.6000], [0.1500, 0.0600]]),
 }
 
-def XYZ2RGBxform(white='D65', primaries='sRGB'):
+
+def XYZ2RGBxform(white="D65", primaries="sRGB"):
     r"""
     Transformation matrix from XYZ to RGB colorspace
 
     :param white: illuminant: 'E' or 'D65' [default]
     :type white: str, optional
     :param primaries: xy coordinates of primaries to use: ``'CIE'``, ``'ITU=709'`` or
         ``'sRGB'`` [default]
     :type primaries: str, optional
-    :raises ValueError: bad white point, bad primaries 
+    :raises ValueError: bad white point, bad primaries
     :return: transformation matrix
     :rtype: ndarray(3,3)
 
     Return a :math:`3 \times 3` matrix that transforms an XYZ tristimulus value
     to an RGB tristimulus value.  The transformation applies to linear, non
     gamma encoded, tristimulus values.
 
@@ -854,99 +872,105 @@
 
     .. runblock:: pycon
 
         >>> from machinevisiontoolbox import XYZ2RGBxform
         >>> XYZ2RGBxform()
 
     .. note::
-    
+
         - Use the inverse of the transform for RGB to XYZ.
         - Works with linear RGB colorspace, not gamma encoded
 
     :seealso: :func:`gamma_decode`
     """
-    
+
     if isinstance(white, str):
         try:
             white = _white[white.lower()]
         except:
-            raise ValueError('unknown white value, must be one of'
-                ', '.join(_white.keys()))
+            raise ValueError(
+                "unknown white value, must be one of" ", ".join(_white.keys())
+            )
     else:
         white = base.getvector(white, 2)
 
     if isinstance(primaries, str):
         try:
             primaries = _xy_primaries[primaries.lower()]
         except:
-            raise ValueError('unknown primary value, must be one of'
-                ', '.join(_xy_primaries.keys()))
+            raise ValueError(
+                "unknown primary value, must be one of" ", ".join(_xy_primaries.keys())
+            )
     else:
-        white = base.getmatrix(primaries, (3,2))
+        white = base.getmatrix(primaries, (3, 2))
 
     def column(primaries, i):
         primaries = base.getmatrix(primaries, (None, 2))
-        return np.array([
-            primaries[i,0] / primaries[i,1],
-            1,
-            (1 - primaries[i,0] - primaries[i,1]) / primaries[i,1]
-        ])
+        return np.array(
+            [
+                primaries[i, 0] / primaries[i, 1],
+                1,
+                (1 - primaries[i, 0] - primaries[i, 1]) / primaries[i, 1],
+            ]
+        )
 
     # build the columns of the inverse transform
     Xr = column(primaries, 0)
     Xg = column(primaries, 1)
     Xb = column(primaries, 2)
     M = np.array([Xr, Xg, Xb]).T
 
     # determine the white point
     Xw = column(white, 0)
     J = np.linalg.inv(M) @ Xw
     M = np.array([Xr, Xg, Xb]).T @ np.diag(J)
 
     return M
 
+
 # ------------------------------------------------------------------------- #
 
-def _xy_chromaticity_diagram(N = 500, Y=1):
+
+def _xy_chromaticity_diagram(N=500, Y=1):
     ex = 0.8
     ey = 0.9
     e0 = 0.0
 
     Nx = round(N * (ex - e0))
     Ny = round(N * (ey - e0))
     # generate colors in xyY color space
     x, y = np.meshgrid(np.linspace(e0, ex, Nx), np.linspace(e0, ey, Ny))
     # hack to prevent divide by zero errors
-    y[0,:] = 1e-3
+    y[0, :] = 1e-3
 
     # convert xyY to XYZ
     Y = np.ones((Ny, Nx)) * Y
     X = Y * x / y
-    Z = Y * (1.0 - x - y) /  y
+    Z = Y * (1.0 - x - y) / y
     XYZ = np.dstack((X, Y, Z)).astype(np.float32)
 
-    RGB = colorspace_convert(XYZ, 'xyz', 'rgb')
+    RGB = colorspace_convert(XYZ, "xyz", "rgb")
     RGB = _normalize(RGB)  # fit to interval [0, 1]
     RGB = gamma_encode(RGB)  # gamma encode
 
     # define the spectral locus boundary as xy points, Mx2 matrix
     nm = 1e-9
     λ = np.arange(400, 700, step=5) * nm
     xyz = ccxyz(λ)
     xy_locus = xyz[:, :2]
 
     ## make a smooth boundary with spline interpolation
 
     # set up interpolators for x and y
     M = xy_locus.shape[0]
     drange = np.arange(M)
-    fxi = interpolate.interp1d(drange, xy_locus[:, 0], kind='cubic')
-    fyi = interpolate.interp1d(drange, xy_locus[:, 1], kind='cubic')
+    fxi = interpolate.interp1d(drange, xy_locus[:, 0], kind="cubic")
+    fyi = interpolate.interp1d(drange, xy_locus[:, 1], kind="cubic")
 
-    # interpolate in steps of 0.1 
+    # interpolate in steps of 0.1
     irange = np.arange(0, M - 1, step=0.1)
     xi = fxi(irange)
     yi = fyi(irange)
 
     # close the path
     xi = np.append(xi, xi[0])
     yi = np.append(yi, yi[0])
@@ -955,55 +979,59 @@
     ## defined by xi, yi
 
     # create a polygon
     p = np.stack((xi, yi), axis=-1)
     polypath = mpath.Path(p)
 
     # flatten x/y grids into array columnwise
-    xc = x.flatten('F')
-    yc = y.flatten('F')
+    xc = x.flatten("F")
+    yc = y.flatten("F")
 
     # check if these xy points are contained in the polygon
     # returns a bool array
     pts_in = polypath.contains_points(np.stack((xc, yc), axis=-1))
     # reshape it to size of original grids
-    outside = np.reshape(~pts_in, x.shape, 'F')
+    outside = np.reshape(~pts_in, x.shape, "F")
 
     # set outside pixels to white
     outside3 = np.dstack((outside, outside, outside))
     RGB[outside3] = 1.0
 
     return np.flip(RGB, axis=0)  # flip top to bottom
 
+
 def _ab_chromaticity_diagram(L=100, N=256):
     a, b = np.meshgrid(np.linspace(-127, 127, N), np.linspace(-127, 127, N))
 
     # convert from Lab to RGB
 
     L = np.ones(a.shape) * L
     Lab = np.dstack((L, a, b)).astype(np.float32)
 
-    RGB = colorspace_convert(Lab, 'lab', 'rgb')
+    RGB = colorspace_convert(Lab, "lab", "rgb")
     # this exactly matches the MATLAB function lab2rgb with default whitespace
     # its doco says it converts to SRGB gamma encoded RGB.
- 
+
     RGB = _normalize(RGB)  # fit to interval [0, 1]
 
     outside = np.sqrt(a**2 + b**2) > 128
     # set outside pixels to white
     outside3 = np.dstack((outside, outside, outside))
     RGB[outside3] = 1.0
 
     return np.flip(RGB, axis=0)  # flip top to bottom
 
-def plot_chromaticity_diagram(colorspace='xy', brightness=1, N=500, alpha=1, block=False):
+
+def plot_chromaticity_diagram(
+    colorspace="xy", brightness=1, N=500, alpha=1, block=False
+):
     """
     Display chromaticity diagram
 
-    :param colorspace: colorspace to show: 'xy' [default], 'lab', 'ab' 
+    :param colorspace: colorspace to show: 'xy' [default], 'lab', 'ab'
     :type colorspace: string
     :param brightness: for xy this is Y, for ab this is L, defaults to 1
     :type brightness: float, optional
     :param N: number of points to sample in the x- and y-directions, defaults to 500
     :type N: integer, optional
     :param alpha: alpha value for plot in the range [0,1], defaults to 1
     :type alpha: float, optional
@@ -1031,34 +1059,36 @@
             colors, due to the gamut of the display device.
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`plot_spectral_locus`
     """
-    if colorspace.lower() == 'xy':
+    if colorspace.lower() == "xy":
         CS = _xy_chromaticity_diagram(Y=brightness, N=N)
-        plt.imshow(CS, extent=(0,0.8, 0, 0.9), alpha=alpha)
-        plt.xlabel('x')
-        plt.ylabel('y')
-    elif colorspace.lower() in ('ab', 'l*a*b*', 'ab', 'a*b*'):
-        CS = _ab_chromaticity_diagram(L=brightness*100, N=N)
+        plt.imshow(CS, extent=(0, 0.8, 0, 0.9), alpha=alpha)
+        plt.xlabel("x")
+        plt.ylabel("y")
+    elif colorspace.lower() in ("ab", "l*a*b*", "ab", "a*b*"):
+        CS = _ab_chromaticity_diagram(L=brightness * 100, N=N)
         plt.imshow(CS, extent=(-128, 127, -128, 127), alpha=alpha)
-        plt.xlabel('a*')
-        plt.ylabel('b*')
+        plt.xlabel("a*")
+        plt.ylabel("b*")
     else:
-        raise ValueError('bad colorspace')
+        raise ValueError("bad colorspace")
 
     if plt.isinteractive() and block is not None:
-        print('plt.show')
+        print("plt.show")
         plt.show(block=block)
     return CS
 
-def plot_spectral_locus(colorspace='xy', labels=True, ax=None, block=False,
-    lambda_ticks=None):
+
+def plot_spectral_locus(
+    colorspace="xy", labels=True, ax=None, block=False, lambda_ticks=None
+):
     r"""
     Plot spectral locus
 
     :param colorspace: the color space: 'xy' [default] or 'rg'
     :type colorspace: str, optional
     :param labels: display wavelength labels, defaults to True
     :type labels: bool, optional
@@ -1091,18 +1121,18 @@
     :seealso: :func:`plot_chromaticity_diagram`
     """
 
     nm = 1e-9
 
     λ = np.arange(400, 700) * nm
 
-    if colorspace in ('XY', 'xy'):
+    if colorspace in ("XY", "xy"):
         locus = ccxyz(λ)[:, :2]
-    elif colorspace in ('rg'):
-        locus = lambda2rg(λ, method='cubic')
+    elif colorspace in ("rg"):
+        locus = lambda2rg(λ, method="cubic")
 
     if ax is None:
         ax = plt.subplot(1, 1, 1)
 
     ax.plot(locus[:, 0], locus[:, 1])
 
     if labels:
@@ -1111,34 +1141,35 @@
         # well-spaced points around the locus
         if lambda_ticks is None:
             λ = np.arange(460, 550, 10)
             λ = np.hstack((λ, np.arange(560, 620, 20)))
         else:
             λ = lambda_ticks
 
-        if colorspace in ('XY', 'xy'):
+        if colorspace in ("XY", "xy"):
             xyz = cmfxyz(λ * 1e-9)
             x = xyz[:, 0] / np.sum(xyz, axis=1)
             y = xyz[:, 1] / np.sum(xyz, axis=1)
-        elif colorspace in ('rg',):
+        elif colorspace in ("rg",):
             rgb = cmfrgb(λ * 1e-9)
             x = rgb[:, 0] / np.sum(rgb, axis=1)
             y = rgb[:, 1] / np.sum(rgb, axis=1)
         else:
-            raise ValueError('bad colorspace')
+            raise ValueError("bad colorspace")
 
-        ax.plot(x, y, 'ko')
+        ax.plot(x, y, "ko")
 
         for i in range(len(λ)):
-            ax.text(x[i], y[i], '  {0}'.format(λ[i]))
+            ax.text(x[i], y[i], "  {0}".format(λ[i]))
 
     if plt.isinteractive() and block is not None:
-        print('plt.show')
+        print("plt.show")
         plt.show(block=block)
 
+
 def cie_primaries():
     """
     CIE primary wavelengths
 
     ``cie_primaries`` is a 3-vector with the wavelengths [m] of the
     CIE-1976 red, green and blue primaries respectively.
 
@@ -1148,29 +1179,31 @@
 
         >>> from machinevisiontoolbox import cie_primaries
         >>> cie_primaries()*1e9
 
     """
     return np.array([700, 546.1, 435.8]) * 1e-9
 
+
 # ------------------------------------------------------------------------- #
 
+
 def colorspace_convert(image, src, dst):
     """
     Convert images between colorspaces
 
     :param image: input image
     :type image: ndarray(H,W,3), (N,3)
     :param src: input colorspace name
     :type src: str
     :param dst: output colorspace name
     :type dst: str
     :return: output image
     :rtype: ndarray(N,M,3), (N,3)
-    
+
     Convert images or rowwise color coordinates from one color space to another.
     The work is done by OpenCV and assumes that the input image is linear, not
     gamma encoded, and the result is also linear.
 
     Color space names (synonyms listed on the same line) are:
 
     =======================     ========================
@@ -1208,93 +1241,96 @@
         image = image.reshape((-1, 1, 3))
         converted = cv.cvtColor(image, code=operation)
         if converted.shape[0] == 1:
             return converted.flatten().astype(np.float64)
         else:
             return converted.reshape((-1, 3)).astype(np.float64)
 
+
 def _convertflag(src, dst):
 
-    src = src.replace(':', '').lower()
-    dst = dst.replace(':', '').lower()
+    src = src.replace(":", "").lower()
+    dst = dst.replace(":", "").lower()
 
-    if src == 'rgb':
-        if dst in ('grey', 'gray'):
+    if src == "rgb":
+        if dst in ("grey", "gray"):
             return cv.COLOR_RGB2GRAY
-        elif dst in ('xyz', 'xyz_709'):
+        elif dst in ("xyz", "xyz_709"):
             return cv.COLOR_RGB2XYZ
-        elif dst == 'ycrcb':
+        elif dst == "ycrcb":
             return cv.COLOR_RGB2YCrCb
-        elif dst == 'hsv':
+        elif dst == "hsv":
             return cv.COLOR_RGB2HSV
-        elif dst == 'hls':
+        elif dst == "hls":
             return cv.COLOR_RGB2HLS
-        elif dst in ('lab', 'l*a*b*'):
+        elif dst in ("lab", "l*a*b*"):
             return cv.COLOR_RGB2Lab
-        elif dst in ('luv', 'l*u*v*'):
+        elif dst in ("luv", "l*u*v*"):
             return cv.COLOR_RGB2Luv
         else:
             raise ValueError(f"destination colorspace {dst} not known")
-    elif src == 'bgr':
-        if dst in ('grey', 'gray'):
+    elif src == "bgr":
+        if dst in ("grey", "gray"):
             return cv.COLOR_BGR2GRAY
-        elif dst in ('xyz', 'xyz_709'):
+        elif dst in ("xyz", "xyz_709"):
             return cv.COLOR_BGR2XYZ
-        elif dst == 'ycrcb':
+        elif dst == "ycrcb":
             return cv.COLOR_BGR2YCrCb
-        elif dst == 'hsv':
+        elif dst == "hsv":
             return cv.COLOR_BGR2HSV
-        elif dst == 'hls':
+        elif dst == "hls":
             return cv.COLOR_BGR2HLS
-        elif dst in ('lab', 'l*a*b*'):
+        elif dst in ("lab", "l*a*b*"):
             return cv.COLOR_BGR2Lab
-        elif dst in ('luv', 'l*u*v*'):
+        elif dst in ("luv", "l*u*v*"):
             return cv.COLOR_BGR2Luv
 
-    elif src in ('xyz', 'xyz_709'):
-        if dst == 'rgb':
+    elif src in ("xyz", "xyz_709"):
+        if dst == "rgb":
             return cv.COLOR_XYZ2RGB
-        elif dst == 'bgr':
+        elif dst == "bgr":
             return cv.COLOR_XYZ2BGR
 
-    elif src == 'ycrcb':
-        if dst == 'rgb':
+    elif src == "ycrcb":
+        if dst == "rgb":
             return cv.COLOR_YCrCb2RGB
-        elif dst == 'bgr':
+        elif dst == "bgr":
             return cv.COLOR_YCrCbBGR
 
-    elif src == 'hsv':
-        if dst == 'rgb':
+    elif src == "hsv":
+        if dst == "rgb":
             return cv.COLOR_HSVRGB
-        elif dst == 'bgr':
+        elif dst == "bgr":
             return cv.COLOR_HSV2BGR
 
-    elif src == 'hls':
-        if dst == 'rgb':
+    elif src == "hls":
+        if dst == "rgb":
             return cv.COLOR_HLS2RGB
-        elif dst == 'bgr':
+        elif dst == "bgr":
             return cv.COLOR_HLS2BGR
 
-    elif src in ('lab', 'l*a*b*'):
-        if dst == 'rgb':
+    elif src in ("lab", "l*a*b*"):
+        if dst == "rgb":
             return cv.COLOR_Lab2RGB
-        elif dst == 'bgr':
+        elif dst == "bgr":
             return cv.COLOR_Lab2BGR
 
-    elif src in ('luv', 'l*u*v*'):
-        if dst == 'rgb':
+    elif src in ("luv", "l*u*v*"):
+        if dst == "rgb":
             return cv.COLOR_Luv2RGB
-        elif dst == 'bgr':
+        elif dst == "bgr":
             return cv.COLOR_Luv2BGR
 
     raise ValueError(f"unknown conversion {src} -> {dst}")
 
+
 # ------------------------------------------------------------------------- #
 
-def gamma_encode(image, gamma='sRGB'):
+
+def gamma_encode(image, gamma="sRGB"):
     r"""
     Gamma encoding
 
     :param image: input image
     :type image: ndarray(H,W), ndarray(H,W,N)
     :param gamma: gamma exponent or "srgb"
     :type gamma: float, str
@@ -1319,54 +1355,55 @@
           range 0 to 1.
         - For images of type int, the pixels are assumed in the range 0 to
           the maximum value of their class.  Pixels are converted first to
           double, encoded, then converted back to the integer class.
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
-    
+
     :seealso: :func:`gamma_decode` :func:`colorspace_convert`
     """
 
     if not (base.isscalar(gamma) or isinstance(gamma, str)):
-        raise ValueError('gamma must be string or scalar')
+        raise ValueError("gamma must be string or scalar")
 
-    if isinstance(gamma, str) and gamma.lower() == 'srgb':
+    if isinstance(gamma, str) and gamma.lower() == "srgb":
 
         imagef = float_image(image)
 
         if imagef.ndim == 2:
             # greyscale
             return _srgb(imagef)
         elif imagef.ndim == 3:
             # multi-dimensional
             out = np.empty(imagef.shape, dtype=imagef.dtype)
             for p in range(imagef.ndim):
-                out[:,:,p] = _srgb(imagef[:,:,p])
+                out[:, :, p] = _srgb(imagef[:, :, p])
         else:
-            raise ValueError('expecting 2d or 3d image')
+            raise ValueError("expecting 2d or 3d image")
 
         if np.issubdtype(image.dtype, np.integer):
             # original image was float, convert back
             return int_image(out)
         else:
             return out
 
     else:
         # normal power law:
         # import code
         # code.interact(local=dict(globals(), **locals()))
         if np.issubdtype(image.dtype, np.floating):
-            return image ** gamma
+            return image**gamma
         else:
             # int image
             maxg = np.float32((np.iinfo(image.dtype).max))
             return ((image.astype(np.float32) / maxg) ** gamma) * maxg
 
-def gamma_decode(image, gamma='sRGB'):
+
+def gamma_decode(image, gamma="sRGB"):
     r"""
     Gamma decoding
 
     :param image: input image
     :type image: ndarray(H,W), ndarray(H,W,N)
     :param gamma: gamma exponent or "srgb"
     :type gamma: float, str
@@ -1395,48 +1432,48 @@
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`gamma_encode`
     """
 
     if not (base.isscalar(gamma) or isinstance(gamma, str)):
-        raise ValueError('gamma must be string or scalar')
+        raise ValueError("gamma must be string or scalar")
 
-    if isinstance(gamma, str) and gamma.lower() == 'srgb':
+    if isinstance(gamma, str) and gamma.lower() == "srgb":
 
         imagef = float_image(image)
 
         if imagef.ndim == 2:
             # greyscale
             return _srgb_inverse(imagef)
         elif imagef.ndim == 3:
             # multi-dimensional
             out = np.empty(imagef.shape, dtype=imagef.dtype)
             for p in range(imagef.ndim):
-                out[:,:,p] = _srgb_inverse(imagef[:,:,p])
+                out[:, :, p] = _srgb_inverse(imagef[:, :, p])
         else:
-            raise ValueError('expecting 2d or 3d image')
+            raise ValueError("expecting 2d or 3d image")
 
         if np.issubdtype(image.dtype, np.integer):
             # original image was integer, convert back
             return int_image(out)
         else:
             return out
 
     else:
 
         # normal power law:
         if np.issubdtype(image.dtype, np.floating):
-            return image ** gamma
+            return image**gamma
         else:
             # int image
             maxg = np.float32((np.iinfo(image.dtype).max))
-            return ((image.astype(np.float32) / maxg) ** gamma) * maxg # original
+            return ((image.astype(np.float32) / maxg) ** gamma) * maxg  # original
             # return ((image.astype(np.float32) / maxg) ** gamma) * maxg
-        
+
 
 def _srgb_inverse(Rg):
     """
     Inverse sRGB gamma correction
 
     :param Rg: 2D image
     :type Rg: numpy array, shape (N,M)
@@ -1461,24 +1498,25 @@
     a = 0.0404482362771076
     i = np.where(Rg <= a)
     noti = np.where(Rg > a)
     R[i] = Rg[i] / 12.92
     R[noti] = ((Rg[noti] + 0.055) / 1.055) ** 2.4
     return R
 
+
 def _srgb(R):
     """
     sRGB Gamma correction
 
     :param R: 2D image
     :type R: numpy array, shape (N,M)
     :return: Rg
     :rtype: numpy array
 
-    - ``_srgb(R)`` maps linear tristimulus values to an sRGB gamma encoded 
+    - ``_srgb(R)`` maps linear tristimulus values to an sRGB gamma encoded
         image.
 
     Example:
 
     .. runblock:: pycon
 
     .. note::
@@ -1492,16 +1530,18 @@
     b = 0.416666666666666667
     i = np.where(R <= a)
     noti = np.where(R > a)
     Rg[i] = R[i] * 12.92
     Rg[noti] = np.real(1.055 * (R[noti] ** b) - 0.055)
     return Rg
 
+
 # ------------------------------------------------------------------------- #
 
+
 def _normalize(rgb):
     """
     Normalize the pixel values
 
     :param rgb: [description]
     :type rgb: [type]
 
@@ -1524,15 +1564,18 @@
 
     # find maximum of (r, g, b, 1)
     mx = np.maximum(np.amax(rgb, axis=2), 1)
     # and scale the pixel
     rgb = rgb / mx[..., np.newaxis]
     return rgb
 
-def shadow_invariant(image, θ=None, geometricmean=True, exp=False, sharpen=None, primaries=None):
+
+def shadow_invariant(
+    image, θ=None, geometricmean=True, exp=False, sharpen=None, primaries=None
+):
     r"""
     Shadow invariant image
 
     :param image: linear color image
     :type image: ndarray(H,W,3) float
     :param geometricmean: normalized with geometric mean of color channels, defaults to True
     :type geometricmean: bool, optional
@@ -1570,49 +1613,49 @@
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
     """
 
     # Convert the image into a vector (h*w,channel)
     if image.ndim == 3 and image.shape[2] == 3:
         im = image.reshape(-1, 3).astype(float)
     else:
-        raise ValueError('must pass an RGB image')
+        raise ValueError("must pass an RGB image")
 
     # compute chromaticity
 
     if sharpen is not None:
         im = im @ opt.sharpen
-        im = max(0, im);
+        im = max(0, im)
 
     if geometricmean:
         # denom = prod(im, 2).^(1/3);
         A = np.prod(im, axis=1)
         denom = np.abs(A) ** (1.0 / 3)
     else:
         denom = im[:, 1]
 
-    # this next bit will generate divide by zero errors, suppress any 
+    # this next bit will generate divide by zero errors, suppress any
     # error messages. The results will be nan which we can deal with later.
     with warnings.catch_warnings():
-        warnings.filterwarnings('ignore')
+        warnings.filterwarnings("ignore")
         r_r = im[:, 0] / denom
-        r_b = im[:, 2] /denom
+        r_b = im[:, 2] / denom
 
     # Take the log
     r_rp = np.log(r_r)
     r_bp = np.log(r_b)
 
     # figure the illumination invariant direction shape=(2,)
 
     # create an array of logs (2,N)
     d = np.array([r_rp, r_bp])
 
     if θ is None:
         # compute direction from the spectral peaks of the camera filters
         if primaries is None:
-            # Planckian illumination constant 
+            # Planckian illumination constant
             c2 = 1.4388e-2
 
             #  spectral peaks of the Sony ICX204 sensor used in BB2 camera
             primaries = [610, 538, 460] * 1e-9
 
             e_r = -c2 / primaries[0]
             e_b = -c2 / primaries[2]
@@ -1630,14 +1673,15 @@
 
     # reshape the gs vector to the original image size
     if image.ndim == 3:
         gs = gs.reshape(image.shape[:2])
 
     return gs
 
+
 def esttheta(im, sharpen=None):
     """
     Estimate theta for shadow invariance
 
     :param im: input image
     :type im: ndarray(H,W,3)
     :param sharpen: a sharpening transform, defaults to None
@@ -1657,42 +1701,45 @@
 
         im.disp()
 
         clicks = plt.ginput(n=-1)
 
         xy = np.array(clicks)
         print(xy)
-        
-        base.plot_poly(xy.T, 'g', close=True)
+
+        base.plot_poly(xy.T, "g", close=True)
 
         polygon = Polygon2(xy.T)
-        polygon.plot('g')
-        
+        polygon.plot("g")
+
         X, Y = im.meshgrid()
         inside = polygon.contains(np.c_[X.ravel(), Y.ravel()].T)
-        
+
         return inside
 
     k_region = pickregion(im)
 
     imcol = im.column()
 
     z = imcol[k_region, :]
     print(z.shape)
     # k = find(in);
     plt.show(block=True)
 
 
-if __name__ == '__main__':  # pragma: no cover
+if __name__ == "__main__":  # pragma: no cover
 
     import pathlib
     import os.path
 
-    exec(open(os.path.join(pathlib.Path(__file__).parent.absolute(),
-    "test_color.py")).read())
+    exec(
+        open(
+            os.path.join(pathlib.Path(__file__).parent.absolute(), "test_color.py")
+        ).read()
+    )
 
     # import machinevisiontoolbox.color as color
 
     # rg = color.lambda2rg(555e-9)
     # print(rg)
 
     # wcc = color.tristim2cc(np.r_[1, 1, 1])
@@ -1705,25 +1752,24 @@
     # img = np.float32(np.r_[0.5, 0.2, 0.1]).reshape((1,1,3))
     # print(img.shape)
     # # print(cv.cvtColor(img, cv.COLOR_RGB2HSV))
     # print(cv.cvtColor(img, _convertflag('rgb', 'hsv')))
     # print(colorname([0.5,0.2, 0.5]))
     # print(colorname([0.5,0.2], 'xy'))
 
-
     # rg = lambda2rg(λ=np.array([555e-9, 666e-9]),
     #                          e=np.array([4, 2]))
 
     # z = colorname('chocolate', 'xy')
     # print(z)
     # bs = colorname('burntsienna', 'xy')
     # print(bs)
 
     # colorname('?burnt')
-    
+
     # z = colorname('burntsienna')
     # print(z)
     # bs = colorname('burntsienna', 'xy')
     # print(bs)
 
     # green_cc = lambda2rg(500 * 1e-9)
     # print(green_cc)
@@ -1741,8 +1787,8 @@
     # print(name2color('orange', 'xy'))
     # print(name2color('.*coral.*'))
     # print(color2name([0.45, 0.48], 'xy'))
 
     # print(cmfrgb([500*nm, 600*nm]))
     # green_cc = lambda2rg(500 * nm)
 
-    # pass
+    # pass
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/data.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,53 +10,55 @@
 which is a dependency.  This is to sidestep PyPI package size limits, and
 reflect the reality that the data changes much less frequently than the code.
 
 The functions in this module locate the specified files within the separately
 installed package in the user's filesystem.
 """
 
+
 def mvtb_load_matfile(filename):
     """
     Load toolbox mat format data file
 
     :param filename: relative pathname of datafile
     :type filename: str
     :raises ValueError: File does not exist
     :return: contents of mat data file
     :rtype: dict
 
-    Reads a MATLAB format *mat* file which can contain multiple variables, in 
+    Reads a MATLAB format *mat* file which can contain multiple variables, in
     a binary or ASCII format.  Returns a dict where the keys are the variable
     names and the values are NumPy arrays.
 
     .. note::
         - Uses SciPy ``io.loadmat`` to do the work.
-        - If the filename has no path component it will be 
+        - If the filename has no path component it will be
           first be looked for in the folder ``machinevisiontoolbox/data``, then
           the current working directory.
-    
+
     :seealso: :func:`mvtb_path_to_datafile` :func:`scipy.io.loadmat`
     """
     from scipy.io import loadmat
     from scipy.io.matlab.mio5_params import mat_struct
     from collections import namedtuple
 
     # get results as a dict
     data = mvtb_load_data(filename, loadmat, squeeze_me=True, struct_as_record=False)
 
     # if elements are a scipy.io.matlab.mio5_params.mat_struct, that is, they
     # were a MATLAB struct, convert them to a namedtuple
     for key, value in data.items():
         if isinstance(value, mat_struct):
-            print('fixing')
+            print("fixing")
             nt = namedtuple("matstruct", value._fieldnames)
             data[key] = nt(*[getattr(value, n) for n in value._fieldnames])
-        
+
     return data
 
+
 def mvtb_load_jsonfile(filename):
     """
     Load toolbox JSON format data file
 
     :param filename: relative pathname of datafile
     :type filename: str
     :raises ValueError: File does not exist
@@ -64,23 +66,24 @@
     :rtype: dict
 
     Reads a JSON format file which can contain multiple variables and return a
     dict where the keys are the variable names and the values are Python data
     types.
 
     .. note::
-        - If the filename has no path component it will be 
+        - If the filename has no path component it will be
           first be looked for in the folder ``machinevisiontoolbox/data``, then
           the current working directory.
-    
-    :seealso: :func:`mvtb_path_to_datafile` 
+
+    :seealso: :func:`mvtb_path_to_datafile`
     """
     import json
 
-    return mvtb_load_data(filename, lambda f: json.load(open(f, 'r')))
+    return mvtb_load_data(filename, lambda f: json.load(open(f, "r")))
+
 
 def mvtb_load_data(filename, handler, **kwargs):
     """
     Load toolbox data file
 
     :param filename: relative pathname of datafile
     :type filename: str
@@ -94,45 +97,46 @@
 
         handler(abs_file_name, **kwargs)
 
     For example::
 
         data = mvtb_load_data('data/foo.dat', lambda f: data_load(open(f, 'r')))
 
-    .. note:: If the filename has no path component it will 
+    .. note:: If the filename has no path component it will
         first be looked for in the folder ``machinevisiontoolbox/data``, then
         the current working directory.
 
     :seealso: :func:`mvtb_path_to_datafile`
     """
     path = mvtb_path_to_datafile(filename)
     return handler(path, **kwargs)
 
+
 def mvtb_path_to_datafile(*filename, local=True, string=False):
     """
     Get absolute path to file in MVTB data package
 
     :param filename: pathname of image file
     :type filename: str
     :param local: search for file locally first, default True
     :type local: bool
     :raises FileNotFoundError: File does not exist
     :return: Absolute path
     :rtype: Path
 
     The data associated with the Machine Vision Toolbox for Python is shipped
     as a separate package.
-    
+
     The positional arguments are joined, like ``os.path.join``, for example::
 
         mvtb_path_to_datafile('data', 'solar.dat')  # data/solar.dat
 
     If ``local`` is True then ``~`` is expanded and if the file exists, the
     path is made absolute, and symlinks resolved::
-        
+
         mvtb_path_to_datafile('foo.dat')         # find ./foo.dat
         mvtb_path_to_datafile('~/foo.dat')       # find $HOME/foo.dat
 
     Otherwise, the file is sought within the ``mvtbdata`` package and if found,
     return that absolute path.
 
     Example:
@@ -159,15 +163,15 @@
     # otherwise, look for it in mvtbdata
 
     mvtbdata = importlib.import_module("mvtbdata")
     root = Path(mvtbdata.__path__[0])
     # if folder:
     #     root = root / folder
     # root = Path(__file__).parent.parent / "images"
-    
+
     path = root / filename
     if path.exists():
         p = path.resolve()
         if string:
             p = str(p)
         return p
     else:
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/esttheta.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/esttheta.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,39 +13,41 @@
 # % See also INVARIANT, SIMILARITY
 
 from machinevisiontoolbox import Image
 import matplotlib.pyplot as plt
 import numpy as np
 from spatialmath import base, Polygon2
 
+
 def esttheta(im, sharpen=None):
 
     k_region = pickregion(im)
 
     imcol = im.column()
 
     z = imcol[k_region, :]
     print(z.shape)
     # k = find(in);
     plt.show(block=True)
 
+
 #     if isempty(opt.mask)
 #         fprintf('pick shaded/lit region of same material\nclick several points on the perimeter of the region then hit RETURN\n'); beep;
 #         k_region = pickregion(im);
 #         drawnow
 #         im = im2col(im, k_region);
 #     else
 #         im = im2col(im, opt.mask);
 #     end
 
 #     if ~isempty(opt.sharpen)
 #         im = double(im) * opt.sharpen;
 #         im = max(0, im);
 #     end
-    
+
 #     theta_v = [0:0.02:pi];
 #     sim = [];
 
 #     %for theta = theta_v
 #     for i=1:numel(theta_v)
 #         theta = theta_v(i);
 #         gs = invariant(im, theta, args{:});
@@ -57,37 +59,39 @@
 #     plot(theta_v, sim);
 #     xlabel('invariant line angle (rad)');
 #     ylabel('invariance image variance');
 
 #     [~,k] = min(sim);
 #     fprintf('best angle = %f rad\n', theta_v(k));
 #     %idisp( invariant(gs, theta) );
-    
+
 #     if nargout > 0
 #         th = theta_v(k);
 #     end
 # end
 
+
 def pickregion(im):
 
     im.disp()
 
     clicks = plt.ginput(n=-1)
 
     xy = np.array(clicks)
     print(xy)
-    
-    base.plot_poly(xy.T, 'g', close=True)
+
+    base.plot_poly(xy.T, "g", close=True)
 
     polygon = Polygon2(xy.T)
-    polygon.plot('g')
-    
+    polygon.plot("g")
+
     X, Y = im.meshgrid()
     inside = polygon.contains(np.c_[X.ravel(), Y.ravel()].T)
-    
+
     return inside
 
+
 if __name__ == "__main__":
 
-    im = Image.Read('parks.png')
+    im = Image.Read("parks.png")
 
-    esttheta(im)
+    esttheta(im)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/findpeaks.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/findpeaks.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,13 @@
-
-
 import numpy as np
 import spatialmath.base as base
 import scipy as sp
 from numpy.polynomial import Polynomial
 
+
 def findpeaks(y, x=None, npeaks=None, scale=1, interp=0, return_poly=False):
     r"""
     Find peaks in a 1D signal
 
     :param y: 1D-signal :math:`y(x)`
     :type y: ndarray(N)
     :param x: corresponding dependent variable, defaults to the integer
@@ -35,15 +34,15 @@
         >>> from machinevisiontoolbox.base import *
         >>> import numpy as np
         >>> y = np.array([0, 0, 1, 2, 0, 0, 0, 3, 1, 0, 0, 0, 0])
         >>> findpeaks(y, scale=3)
         >>> findpeaks(y, scale=3, interp=True)
 
     .. note::
-        - A maxima is defined as an element that is larger than its ``scale`` 
+        - A maxima is defined as an element that is larger than its ``scale``
           neighbours on either side.  This is the largest value in a 2*scale+1
           sliding window.
         - The first and last ``scale`` elements will never be returned as maxima.
         - To find minima, use ``findpeak(-y)``.
         - The ``interp`` options fits points in the neighbourhood about the peak with
           an M'th order polynomial and its peak position is returned.  Typically
           choose M to be even. Setting ``interp`` to True uses ``M=2``.
@@ -65,73 +64,75 @@
 
     # find the maxima
     if scale > 0:
         dx = x[1] - x[0]
         # compare to a moving window max filtered version
         n = round(scale / dx) * 2 + 1
         kernel = np.ones((n,))
-        k, = np.nonzero(y == sp.signal.order_filter(y, kernel, n - 1))
-        k = np.array([kk for kk in k if kk >= scale and kk <= len(y)-scale])
+        (k,) = np.nonzero(y == sp.signal.order_filter(y, kernel, n - 1))
+        k = np.array([kk for kk in k if kk >= scale and kk <= len(y) - scale])
     else:
         # take the zero crossings
         dy = np.diff(y)
         # TODO: I think itertools can do this?
-        k, = np.nonzero([v and w for v, w in zip(np.r_[dy, 0] < 0, np.r_[0, dy] > 0)])
+        (k,) = np.nonzero([v and w for v, w in zip(np.r_[dy, 0] < 0, np.r_[0, dy] > 0)])
 
     # sort the maxima into descending magnitude
     i = np.argsort(-y[k])
-    k = k[i]    # indices of the maxima
+    k = k[i]  # indices of the maxima
 
     if npeaks is not None:
         k = k[:npeaks]
 
     # interpolate the peaks if required
     if interp is True:
         interp = 2
 
     if interp > 0:
         if interp < 2:
-            raise ValueError('interpolation polynomial must be at least second order')
-        
+            raise ValueError("interpolation polynomial must be at least second order")
+
         n2 = round(interp / 2)
 
         # for each previously identified peak x(i), y(i)
         refined_x = []
         refined_y = []
         polys = []
         for i in k:
             # fit a polynomial to the local neighbourhood
             try:
-                poly, *_ = Polynomial.fit(x[i-n2:i+n2+1], y[i-n2:i+n2+1], interp, full=True)
+                poly, *_ = Polynomial.fit(
+                    x[i - n2 : i + n2 + 1], y[i - n2 : i + n2 + 1], interp, full=True
+                )
             except:
-                #handle situation where neighbourhood falls off the data
-                #vector
+                # handle situation where neighbourhood falls off the data
+                # vector
                 print(f"Peak at {x[i]} couldn't be fitted, skipping")
                 continue
 
             # find the roots of the polynomial closest to the coarse peak
             r = poly.deriv(1).roots()
             if len(r) == 0:
                 # no roots found
                 continue
             j = np.argmin(abs(r - x[i]))
             xp = r[j]
-            
-            #store x, y for the refined peak
+
+            # store x, y for the refined peak
             refined_x.append(xp)
             refined_y.append(poly(xp))
             polys.append(poly)
-        
+
         if return_poly:
             return np.array(refined_x), np.array(refined_y), polys
         else:
             return np.array(refined_x), np.array(refined_y)
     else:
         return x[k], y[k]
-    
+
 
 def findpeaks2d(z, npeaks=2, scale=1, interp=False, positive=True):
     r"""
     Find peaks in a 2D signal
 
     :param z: 2D-signal :math:`z(x,y)`
     :type z: ndarray(H,W)
@@ -159,15 +160,15 @@
         >>> z[4,4] = 1
         >>> findpeaks2d(z)
         >>> findpeaks2d(z, interp=True)
 
     .. note::
 
         - A maxima is defined as an element that larger than its neighbours
-          in a 2*scale+1 square window. 
+          in a 2*scale+1 square window.
         - Elements where the window falls off the edge of the input array
           will never be returned as maxima.
         - To find minima, use ``findpeaks2d(-image)``.
         - The interp options fits points in the neighbourhood about the
           peak with a paraboloid and its peak position is returned.
 
     :seealso: :func:`findpeaks` :func:`findpeaks3d`
@@ -175,25 +176,25 @@
 
     # TODO check valid input
 
     # create a neighbourhood mask for non-local maxima suppression
 
     # scale is taken as half-width of the window
     w = 2 * scale + 1
-    M = np.ones((w, w), dtype='uint8')
+    M = np.ones((w, w), dtype="uint8")
     M[scale, scale] = 0  # set middle pixel to zero
 
     # compute the neighbourhood maximum
     # znh = self.window(self.float(z), M, 'max', 'wrap')
     # image = self.asint()
     # nh_max = cv.morphologyEx(image, cv.MORPH_DILATE, M)
     nhood_max = sp.ndimage.maximum_filter(z, footprint=M)
 
     # find all pixels greater than their neighbourhood
-    
+
     if positive:
         k = np.flatnonzero((z > nhood_max) & (z > 0))
     else:
         k = np.flatnonzero(z > nhood_max)
 
     # sort these local maxima into descending order
     image_flat = z.ravel()
@@ -209,31 +210,34 @@
 
     y, x = np.unravel_index(k, z.shape)
 
     # interpolate peaks if required
     if interp:
         refined = []
         for xk, yk in zip(x, y):
-        # now try to interpolate the peak over a 3x3 window
+            # now try to interpolate the peak over a 3x3 window
             try:
-                zc = z[yk,   xk]
-                zn = z[yk-1, xk]
-                zs = z[yk+1, xk]
-                ze = z[yk,   xk+1]
-                zw = z[yk,   xk-1]
+                zc = z[yk, xk]
+                zn = z[yk - 1, xk]
+                zs = z[yk + 1, xk]
+                ze = z[yk, xk + 1]
+                zw = z[yk, xk - 1]
             except IndexError:
                 continue
 
             dx = (ze - zw) / (2 * (2 * zc - ze - zw))
             dy = (zs - zn) / (2 * (2 * zc - zn - zs))
 
-            zest = zc - (ze - zw)**2 / (8 * (ze - 2 * zc + zw)) \
-                - (zn - zs)**2 / (8 * (zn - 2 * zc + zs))
-            
-            aest = np.min(np.abs(np.r_[ze/2 - zc + zw/2, zn/2 - zc + zs/2]))
+            zest = (
+                zc
+                - (ze - zw) ** 2 / (8 * (ze - 2 * zc + zw))
+                - (zn - zs) ** 2 / (8 * (zn - 2 * zc + zs))
+            )
+
+            aest = np.min(np.abs(np.r_[ze / 2 - zc + zw / 2, zn / 2 - zc + zs / 2]))
             refined.append([xk + dx, yk + dy, zest, aest])
         return np.array(refined)
     else:
         # xy = np.stack((y, x), axis=0)
         return np.column_stack((x, y, image_flat[k]))
 
 
@@ -270,44 +274,45 @@
     # absolute value of Laplacian as a 3D matrix, with scale along axis 2
 
     # find maxima within all 26 neighbouring pixels
     # create 3x3x3 structuring element and maximum filter
     se_nhood = np.ones((3, 3, 3))
     se_nhood[1, 1, 1] = 0
     eps = np.finfo(np.float64).eps
-    maxima = (v > sp.ndimage.maximum_filter(v, footprint=se_nhood, mode='nearest'))
+    maxima = v > sp.ndimage.maximum_filter(v, footprint=se_nhood, mode="nearest")
 
     # find the locations of the minima
     i, j, k = np.nonzero(maxima)
-    
+
     # create result matrix, one row per feature: i, j, k, L
     # where k is index into scale
     result = np.column_stack((i, j, k, v[i, j, k]))
 
     # sort the rows on strength column, descending order
     k = np.argsort(-result[:, 3])
     result = result[k, :]
 
     if npeaks is not None:
         result = result[:npeaks, :]
 
     return result
 
+
 if __name__ == "__main__":
 
     from machinevisiontoolbox.base import *
     import numpy as np
 
     y = np.array([0, 0, 1, 2, 0, 0, 0, 3, 1, 0, 0, 0, 0])
     print(findpeaks(y, scale=3))
     print(findpeaks(y, scale=3, interp=True))
 
-    z = np.zeros((10,10))
-    z[3,4] = 2
-    z[4,4] = 1
+    z = np.zeros((10, 10))
+    z[3, 4] = 2
+    z[4, 4] = 1
     print(findpeaks2d(z))
     print(findpeaks2d(z, interp=True))
 
     # y = mvtb_load_matfile('data/peakfit.mat')["y"]
     # plt.plot(y, '-o')
     # xmax, ymax = findpeaks(y, interp=2)
     # print(xmax, ymax)
@@ -320,16 +325,15 @@
 
     # a = [1, 1, 5, 1, 1]
     # print(findpeaks(a))
 
     # a = [1, 1, 5, 1, 1]
     # print(findpeaks(a, [10, 11, 12, 13, 14]))
 
-
     # a = [1, 2, 3, 4, 3, 2, 1]
     # print(findpeaks(a))
 
     # a.extend(a)
     # print(findpeaks(a))
 
     # a = [1, 1, 1, 2, 1, 4, 1, 1, 2]
-    # print(findpeaks(a))
+    # print(findpeaks(a))
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/graphics.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/graphics.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,33 +3,35 @@
 from machinevisiontoolbox.base import color_bgr
 import matplotlib.pyplot as plt
 import numpy as np
 import spatialmath.base as smb
 from collections.abc import Iterable
 
 
-def draw_box(image,
+def draw_box(
+    image,
     l=None,
     r=None,
     t=None,
     b=None,
     w=None,
     h=None,
-
     lb=None,
     lt=None,
     rb=None,
     rt=None,
     wh=None,
     centre=None,
-
     ax=None,
     bbox=None,
     ltrb=None,
-    color=None, thickness=1, antialias=False):
+    color=None,
+    thickness=1,
+    antialias=False,
+):
     """
     Draw a box in an image
 
     :param image: image to draw into, greyscale or color
     :type image: ndarray(H,W), ndarray(H,W,P)
 
     :param l: left side coordinate
@@ -39,15 +41,15 @@
     :param t: top side coordinate
     :type t: int, optional
     :param b: bottom side coordinate
     :type b: int, optional
 
     :param bbox: bounding box [xmin, xmax, ymin, ymax]
     :type bbox: array_like(4), optional
-    :param ltrb: bounding box [xmin, ymin, xmax, ymax] 
+    :param ltrb: bounding box [xmin, ymin, xmax, ymax]
     :type ltrb: array_like(4), optional
 
     :param lb: left-bottom corner [x,y]
     :type lb: array_like(2), optional
     :param lt: left-top corner [x,y]
     :type lt: array_like(2), optional
     :param rb: right-bottom corner (x,y)
@@ -108,16 +110,16 @@
         draw_box(img, ltrb=[100, 300, 700, 500], thickness=2, color=200)
         draw_box(img, ltrb=[100, 300, 700, 500], thickness=-1, color=50)
         idisp(img)
 
     .. note::
         - For images y increases downwards so :math:`y_{top} < y_{bottom}`
         - if ``image`` is a 3-plane image then ``color`` should be a 3-vector
-          or colorname string and the corresponding elements are used in 
-          each plane. 
+          or colorname string and the corresponding elements are used in
+          each plane.
 
     :seealso: :func:`~smtb.base.graphics.plot_box`  `opencv.rectangle <https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9>`_
     """
 
     # if not isinstance(color, (int, float)) and len(image.shape) == 2:
     #     raise TypeError("can't draw color into a greyscale image")
 
@@ -163,15 +165,15 @@
             except:
                 pass
         if r is None:
             try:
                 r = cx + w / 2
             except:
                 pass
-        
+
         if t is None:
             try:
                 t = b + h
             except:
                 pass
         if t is None:
             try:
@@ -189,17 +191,17 @@
                 b = cy - h / 2
             except:
                 pass
 
     if l >= r:
         raise ValueError("left must be less than right")
     if b >= t:
-        #raise ValueError("bottom must be less than top")
+        # raise ValueError("bottom must be less than top")
         b, t = t, b
-        
+
     # TODO need to do this?
     bl = tuple([int(x) for x in (l, b)])
     tr = tuple([int(x) for x in (r, t)])
 
     if isinstance(color, str):
         color = color_bgr(color)
 
@@ -250,32 +252,47 @@
     """
 
     rect = smb.plot_box(**boxargs)
 
     bbox = rect.get_bbox()
 
     if labelcolor is None:
-        labelcolor = boxargs.get('color')
-    smb.plot_text((bbox.xmin, bbox.ymin), text, color=textcolor, verticalalignment='bottom', 
-        bbox=dict(facecolor=labelcolor, linewidth=0, edgecolor=None))
+        labelcolor = boxargs.get("color")
+    smb.plot_text(
+        (bbox.xmin, bbox.ymin),
+        text,
+        color=textcolor,
+        verticalalignment="bottom",
+        bbox=dict(facecolor=labelcolor, linewidth=0, edgecolor=None),
+    )
+
 
 _fontdict = {
-    'simplex': cv.FONT_HERSHEY_SIMPLEX, 
-    'plain': cv.FONT_HERSHEY_PLAIN, 
-    'duplex': cv.FONT_HERSHEY_DUPLEX, 
-    'complex': cv.FONT_HERSHEY_COMPLEX, 
-    'triplex': cv.FONT_HERSHEY_TRIPLEX, 
-    'complex-small': cv.FONT_HERSHEY_COMPLEX_SMALL, 
-    'script-simplex': cv.FONT_HERSHEY_SCRIPT_SIMPLEX, 
-    'script-complex': cv.FONT_HERSHEY_SCRIPT_COMPLEX, 
-    'italic': cv.FONT_ITALIC,         
+    "simplex": cv.FONT_HERSHEY_SIMPLEX,
+    "plain": cv.FONT_HERSHEY_PLAIN,
+    "duplex": cv.FONT_HERSHEY_DUPLEX,
+    "complex": cv.FONT_HERSHEY_COMPLEX,
+    "triplex": cv.FONT_HERSHEY_TRIPLEX,
+    "complex-small": cv.FONT_HERSHEY_COMPLEX_SMALL,
+    "script-simplex": cv.FONT_HERSHEY_SCRIPT_SIMPLEX,
+    "script-complex": cv.FONT_HERSHEY_SCRIPT_COMPLEX,
+    "italic": cv.FONT_ITALIC,
 }
 
-def draw_labelbox(image, text, textcolor=None, labelcolor=None,
-    font='simplex', fontsize=0.9, fontthickness=2, **boxargs):
+
+def draw_labelbox(
+    image,
+    text,
+    textcolor=None,
+    labelcolor=None,
+    font="simplex",
+    fontsize=0.9,
+    fontthickness=2,
+    **boxargs,
+):
     """
     Draw a labelled box in an image
 
     :param text: text label
     :type text: str
     :param textcolor: text color, defaults to black
     :type textcolor: str, array_like(3), optional
@@ -312,16 +329,16 @@
         import numpy as np
         img = np.zeros((1000, 1000), dtype='uint8')
         draw_labelbox(img, 'labelled box', bbox=[100, 500, 300, 600], textcolor=0, labelcolor=100, color=200, thickness=2, fontsize=1)
         idisp(img)
 
     .. note::
         - if ``image`` is a 3-plane image then ``color`` should be a 3-vector
-          or colorname string and the corresponding elements are used in 
-          each plane. 
+          or colorname string and the corresponding elements are used in
+          each plane.
 
     :seealso: :func:`draw_box`, :func:`draw_text`
     """
 
     # get size of text:  ((w,h), baseline)
     twh = cv.getTextSize(text, _fontdict[font], fontsize, fontthickness)
 
@@ -330,23 +347,42 @@
 
     # a bit of margin, 1/2 the text height
     h = round(twh[0][1] / 2)
     h2 = round(twh[0][1] / 4)
 
     # draw background of the label
     if labelcolor is None:
-        labelcolor = boxargs.get('color')
-    draw_box(image, lt=bl, wh=(twh[0][0] + h, twh[0][1] + h), color=labelcolor, thickness=-1)
+        labelcolor = boxargs.get("color")
+    draw_box(
+        image, lt=bl, wh=(twh[0][0] + h, twh[0][1] + h), color=labelcolor, thickness=-1
+    )
 
     # draw the text over the background
-    draw_text(image, (bl[0] + h2, bl[1] - h2), text, color=textcolor,
-        font=font, fontsize=fontsize, fontthickness=fontthickness)
+    draw_text(
+        image,
+        (bl[0] + h2, bl[1] - h2),
+        text,
+        color=textcolor,
+        font=font,
+        fontsize=fontsize,
+        fontthickness=fontthickness,
+    )
     return image
 
-def draw_text(image, pos, text=None, color=None, font='simplex', fontsize=0.3, fontthickness=2, antialias=False):
+
+def draw_text(
+    image,
+    pos,
+    text=None,
+    color=None,
+    font="simplex",
+    fontsize=0.3,
+    fontthickness=2,
+    antialias=False,
+):
     """
     Draw text in image
 
     :param image: image to draw into, greyscale or color
     :type image: ndarray(H,W), ndarray(H,W,P)
     :param pos: position of text (u,v)
     :type pos: array_like(2)
@@ -370,21 +406,21 @@
     vector (stroke) font.
 
     ====================  =============================================
     Font name             OpenCV font name
     ====================  =============================================
     ``'simplex'``         Hershey Roman simplex
     ``'plain'``           Hershey Roman plain
-    ``'duplex'``          Hershey Roman duplex (double stroke) 
-    ``'complex'``         Hershey Roman complex 
+    ``'duplex'``          Hershey Roman duplex (double stroke)
+    ``'complex'``         Hershey Roman complex
     ``'triplex'``         Hershey Romantriplex
     ``'complex-small'``   Hershey Roman complex (small)
     ``'script-simplex'``  Hershey script
     ``'script-complex'``  Hershey script complex
-    ``'italic'``          Hershey italic   
+    ``'italic'``          Hershey italic
     ====================  =============================================
 
     Example:
 
     .. runblock:: pycon
 
         >>> from machinevisiontoolbox import draw_text, idisp
@@ -399,16 +435,16 @@
         import numpy as np
         img = np.zeros((1000, 1000), dtype='uint8')
         draw_text(img, (100, 150), 'hello world!', color=200, fontsize=2)
         idisp(img)
 
     .. note::
         - if ``image`` is a 3-plane image then ``color`` should be a 3-vector
-          or colorname string and the corresponding elements are used in 
-          each plane. 
+          or colorname string and the corresponding elements are used in
+          each plane.
 
     :seealso: :func:`~spatialmath.base.graphics.plot_text` `opencv.putText <https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576>`_
     """
 
     if not isinstance(color, int) and len(image.shape) == 2:
         raise TypeError("can't draw color into a greyscale image")
 
@@ -418,15 +454,25 @@
     if antialias:
         lt = cv.LINE_AA
     else:
         lt = cv.LINE_8
     cv.putText(image, text, pos, _fontdict[font], fontsize, color, fontthickness, lt)
     return image
 
-def draw_point(image, pos, marker='+', text=None, color=None, font='simplex', fontsize=0.3, fontthickness=2):
+
+def draw_point(
+    image,
+    pos,
+    marker="+",
+    text=None,
+    color=None,
+    font="simplex",
+    fontsize=0.3,
+    fontthickness=2,
+):
     r"""
     Draw a marker in image
 
     :param image: image to draw into, greyscale or color
     :type image: ndarray(H,W), ndarray(H,W,P)
     :param pos: position of marker
     :type pos: array_like(2), ndarray(2,n), list of 2-tuples
@@ -446,37 +492,37 @@
     :return: passed image as modified
     :rtype: ndarray(H,W), ndarray(H,W,P)
 
     The ``text`` label is placed to the right of the marker, and vertically centred.
     The color of the marker can be different to the color of the text, the
     marker color is specified by a single letter in the marker string, eg. 'b+'.
 
-    Multiple points can be marked if ``pos`` is a :math:`2 \times n` array or a list of 
+    Multiple points can be marked if ``pos`` is a :math:`2 \times n` array or a list of
     coordinate pairs.  In this case:
-    
+
     * if ``text`` is a string it is processed with ``text.format(i)`` where ``i`` is
       the point index (starting at zero).  "{0}" within text will be substituted
       by the point index.
     * if ``text`` is a list, its elements are used to label the points
 
     The font is specified by a string which selects a Hershey
     vector (stroke) font.
 
     ====================  =============================================
     Font name             OpenCV font name
     ====================  =============================================
     ``'simplex'``         Hershey Roman simplex
     ``'plain'``           Hershey Roman plain
-    ``'duplex'``          Hershey Roman duplex (double stroke) 
-    ``'complex'``         Hershey Roman complex 
+    ``'duplex'``          Hershey Roman duplex (double stroke)
+    ``'complex'``         Hershey Roman complex
     ``'triplex'``         Hershey Romantriplex
     ``'complex-small'``   Hershey Roman complex (small)
     ``'script-simplex'``  Hershey script
     ``'script-complex'``  Hershey script complex
-    ``'italic'``          Hershey italic   
+    ``'italic'``          Hershey italic
     ====================  =============================================
 
     Example::
 
         >>> from machinevisiontoolbox import draw_point, idisp
         >>> import numpy as np
         >>> img = np.zeros((1000, 1000), dtype='uint8')
@@ -493,46 +539,46 @@
         draw_point(img, (100, 300), '*', fontsize=1, color=200)
         draw_point(img, (500, 300), '*', 'labelled point', fontsize=1, color=200)
         draw_point(img, np.random.randint(1000, size=(2,10)), '+', 'point {0}', 100, fontsize=0.8)
         idisp(img)
 
     .. note::
         - if ``image`` is a 3-plane image then ``color`` should be a 3-vector
-          or colorname string and the corresponding elements are used in 
-          each plane. 
+          or colorname string and the corresponding elements are used in
+          each plane.
 
     :seealso: :func:`~spatialmath.base.graphics.plot_point` `opencv.putText <https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576>`_
     """
     fontdict = {
-        'simplex': cv.FONT_HERSHEY_SIMPLEX, 
-        'plain': cv.FONT_HERSHEY_PLAIN, 
-        'duplex': cv.FONT_HERSHEY_DUPLEX, 
-        'complex': cv.FONT_HERSHEY_COMPLEX, 
-        'triplex': cv.FONT_HERSHEY_TRIPLEX, 
-        'complex-small': cv.FONT_HERSHEY_COMPLEX_SMALL, 
-        'script-simplex': cv.FONT_HERSHEY_SCRIPT_SIMPLEX, 
-        'script-complex': cv.FONT_HERSHEY_SCRIPT_COMPLEX, 
-        'italic': cv.FONT_ITALIC,         
+        "simplex": cv.FONT_HERSHEY_SIMPLEX,
+        "plain": cv.FONT_HERSHEY_PLAIN,
+        "duplex": cv.FONT_HERSHEY_DUPLEX,
+        "complex": cv.FONT_HERSHEY_COMPLEX,
+        "triplex": cv.FONT_HERSHEY_TRIPLEX,
+        "complex-small": cv.FONT_HERSHEY_COMPLEX_SMALL,
+        "script-simplex": cv.FONT_HERSHEY_SCRIPT_SIMPLEX,
+        "script-complex": cv.FONT_HERSHEY_SCRIPT_COMPLEX,
+        "italic": cv.FONT_ITALIC,
     }
     if not isinstance(color, int) and len(image.shape) == 2:
         raise TypeError("can't draw color into a greyscale image")
-    
+
     if isinstance(pos, np.ndarray) and pos.shape[0] == 2:
-        x = pos[0,:]
-        y = pos[1,:]
+        x = pos[0, :]
+        y = pos[1, :]
     elif isinstance(pos, (tuple, list)):
         if smb.islistof(pos, (tuple, list)):
             x = [z[0] for z in pos]
             y = [z[1] for z in pos]
         else:
             x = [pos[0]]
             y = [pos[1]]
 
-    newmarker = ''
-    markercolor = ''
+    newmarker = ""
+    markercolor = ""
     for m in marker:
         if m in "rgbcmykw":
             markercolor += m
         else:
             newmarker += m
     marker = newmarker
     if color is None:
@@ -543,20 +589,29 @@
 
     for i, xy in enumerate(zip(x, y)):
         if isinstance(text, str):
             label = text.format(i)
         elif isinstance(text, Iterable):
             label = text[i]
         else:
-            label = ''
-        
+            label = ""
+
         xy = [int(_) for _ in xy]
-        cv.putText(image, f"{marker} {label}", xy, fontdict[font], fontsize, color, fontthickness)
+        cv.putText(
+            image,
+            f"{marker} {label}",
+            xy,
+            fontdict[font],
+            fontsize,
+            color,
+            fontthickness,
+        )
     return image
 
+
 def draw_line(image, start, end, color, thickness=1, antialias=False):
     """
     Draw line in image
 
     :param image: image to draw into, greyscale or color
     :type image: ndarray(H,W), ndarray(H,W,P)
     :param start: start coordinate (u,v)
@@ -589,28 +644,29 @@
         import numpy as np
         img = np.zeros((1000, 1000), dtype='uint8')
         draw_line(img, (100, 300), (700, 900), color=200, thickness=10)
         idisp(img)
 
     .. note::
         - if ``image`` is a 3-plane image then ``color`` should be a 3-vector
-          or colorname string and the corresponding elements are used in 
-          each plane. 
+          or colorname string and the corresponding elements are used in
+          each plane.
 
     :seealso: :func:`~spatialmath.base.graphics.plot_line` `opencv.line <https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2>`_
     """
     if not isinstance(color, int) and len(image.shape) == 2:
         raise TypeError("can't draw color into a greyscale image")
     if antialias:
         lt = cv.LINE_AA
     else:
         lt = cv.LINE_8
     cv.line(image, start, end, color, thickness, lt)
     return image
 
+
 def draw_circle(image, centre, radius, color, thickness=1, antialias=False):
     """
     Draw line in image
 
     :param image: image to draw into, greyscale or color
     :type image: ndarray(H,W), ndarray(H,W,P)
     :param centre: centre coordinate
@@ -643,28 +699,29 @@
         img = np.zeros((1000, 1000), dtype='uint8')
         draw_circle(img, (400,600), 150, thickness=2, color=200)
         draw_circle(img, (400,600), 150, thickness=-1, color=50)
         idisp(img)
 
     .. note::
         - if ``image`` is a 3-plane image then ``color`` should be a 3-vector
-          or colorname string and the corresponding elements are used in 
-          each plane. 
+          or colorname string and the corresponding elements are used in
+          each plane.
 
     :seealso: :func:`~spatialmath.base.graphics.plot_circle` `opencv.circle <https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670>`_
     """
     if not isinstance(color, int) and len(image.shape) == 2:
         raise TypeError("can't draw color into a greyscale image")
     if antialias:
         lt = cv.LINE_AA
     else:
         lt = cv.LINE_8
     cv.circle(image, centre, radius, color, thickness, lt)
     return image
 
+
 # def plot_histogram(c, n, clip=False, ax=None, block=False, xlabel=None, ylabel=None, grid=False, **kwargs):
 #     if ax is None:
 #         plt.figure()
 #         ax = plt.gca()
 
 #     # n = hist.h  # number of pixels per class
 #     # c = hist.x  # class value
@@ -679,15 +736,15 @@
 #     ax.bar(c, n, **kwargs)
 #     if xlabel is not None:
 #         ax.set_xlabel(xlabel)
 #     if ylabel is not None:
 #         ax.set_ylabel(ylabel)
 #     ax.grid(grid)
 
-    # plt.show(block=block)
+# plt.show(block=block)
 
 # if __name__ == "__main__":
 
 #     import numpy as np
 #     from machinevisiontoolbox import idisp, iread, Image
 
 #     from machinevisiontoolbox import draw_labelbox
@@ -702,9 +759,7 @@
 
 #     draw_box(im, color=(255,0,0), centre=(50,50), wh=(20,20))
 
 #     draw_point(im, [(200,200), (300, 300), (400,400)], color='blue')
 
 #     draw_labelbox(im, "box", thickness=3, centre=(100,100), wh=(100,30), color='red', textcolor='white')
 #     idisp(im, block=True)
-
-
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/imageio.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/imageio.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,60 +12,56 @@
 from matplotlib.backend_tools import ToolBase, ToolToggleBase
 from machinevisiontoolbox.base.color import gamma_decode, colorspace_convert
 from machinevisiontoolbox.base.types import float_image, int_image
 from machinevisiontoolbox.base.data import mvtb_path_to_datafile
 
 
 # for getting screen resolution
-#import pyautogui  # requires pip install pyautogui
+# import pyautogui  # requires pip install pyautogui
 from spatialmath.base import islistof
 
 __last_windowname = None
+__last_window_number = 0
 
-def idisp(im,
-          colororder="RGB",
-          matplotlib=True,
-          block=False,
-          fps=None,
-
-          fig=None,
-          ax=None,
-          reuse=False,
-
-          colormap=None,
-          ncolors=None,
-
-          black=0,
-          darken=None,
-          powernorm=False,
-          gamma=None,
-          vrange=None,
-
-          badcolor=None,
-          undercolor=None,
-          overcolor=None,
-
-          title='Machine Vision Toolbox for Python',
-          grid=False,
-          axes=True,
-          gui=True,
-          frame=True,
-          plain=False,
-          colorbar=False,
-
-          square=True,
-          width=None,
-          height=None,
-          flatten=False,
-          ynormal=False,
-          extent=None,
-
-          coordformat=None,
-          savefigname=None,
-          **kwargs):
+def idisp(
+    im,
+    colororder="RGB",
+    matplotlib=True,
+    block=None,
+    fps=None,
+    fig=None,
+    ax=None,
+    reuse=False,
+    colormap=None,
+    ncolors=None,
+    black=0,
+    darken=None,
+    powernorm=False,
+    gamma=None,
+    vrange=None,
+    badcolor=None,
+    undercolor=None,
+    overcolor=None,
+    title=None,
+    grid=False,
+    axes=True,
+    gui=True,
+    frame=True,
+    plain=False,
+    colorbar=False,
+    square=True,
+    width=None,
+    height=None,
+    flatten=False,
+    ynormal=False,
+    extent=None,
+    coordformat=None,
+    savefigname=None,
+    **kwargs,
+):
 
     """
     Interactive image display tool
 
     :param im: image to display
     :type im: ndarray(H,W), ndarray(H,W,3)
     :param colororder: color order, defaults to "RGB"
@@ -94,15 +90,15 @@
     :param darken: darken the image by scaling pixel values by this amount,
         if ``darken`` is True then darken by 0.5
     :type darken: float, bool, optional
     :param powernorm: Matplotlib power-law normalization
     :type powernorm: array_like(2), optional
     :param gamma: gamma correction applied before display
     :type gamma: float, optional
-    :param vrange: minimum and maximum values for colormap, defaults to minimum 
+    :param vrange: minimum and maximum values for colormap, defaults to minimum
         and maximum values from image data.
     :type vrange: array_like(2), optional
 
     :param badcolor: name of color to display when value is NaN
     :type badcolor: str, optional
     :param undercolor: name of color to display when value is less than colormap minimum
     :type undercolor: str, optional
@@ -161,23 +157,24 @@
     signed     negative is red, 0 is white, positive is blue
     invsigned  negative is red, 0 is black, positive is blue
     random     random values
     =========  ===============================================
 
     The argument ``block`` has the following functions
 
+    ===================  ==================================================================================
     ``block``            Action after display
     ===================  ==================================================================================
     ``False`` (default)  Call ``plt.show(block=False)``, don't block
     ``True``             Call ``plt.show(block=True)``, block
     ``None``             Don't call ``plt.show()``, don't block, in Jupyter subsequents plots will be added
     t:float              Block for set time, calls ``plt.pause(t)``
     ===================  ==================================================================================
 
-    The ``coordformat`` function is called with (u, v) coordinates and the image is in the variable ``im`` which 
+    The ``coordformat`` function is called with (u, v) coordinates and the image is in the variable ``im`` which
     is in scope, but not passed, and is an ndarray(H,W) or ndarray(H,W,P).
 
     Example::
 
         >>> from machinevisiontoolbox import iread, idisp
         >>> im, file = iread('monalisa.png')
         >>> idisp(im)
@@ -188,15 +185,15 @@
           mapped to the first and last element of the color map, which by
           default ('grey') is the range black to white. To set your own
           scaling between displayed grey level and pixel value use the ``vrange``
           option.
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
-    
+
     :seealso: :func:`matplotlib.imshow` `cv2.imshow <https://docs.opencv.org/4.x/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563>`_
     """
 
     # options yet to implement
     #    'axis': False,
     #    'here': False,
     #    'clickfunc': None,
@@ -207,79 +204,83 @@
 
     # plain: hide GUI, frame and axes:
     if plain:
         gui = False
         axes = False
         frame = False
 
-    if fps is not None:
-        block = 1 / fps
+    # if fps is not None:
+    #     block = 1 / fps
 
     # if we are running in a Jupyter notebook, print to matplotlib,
     # otherwise print to opencv imshow/new window. This is done because
     # cv.imshow does not play nicely with .ipynb
-    if matplotlib:  # _isnotebook() and 
+    if matplotlib:  # _isnotebook() and
         ## display using matplotlib
 
-
-
         # if flatten:
         #     # either make new subplots for each channel
         #     # or concatenate all into one large image and display
         #     # TODO can we make axes as a list?
 
         #     # for now, just concatenate:
         #     # first check how many channels:
         #     if im.ndim > 2:
         #         # create list of image channels
         #         imcl = [im[:, :, i] for i in range(im.shape[2])]
         #         # stack horizontally
         #         im = np.hstack(imcl)
         #     # else just plot the regular image - only one channel
 
+        if title is None:
+            title = "Machine Vision Toolbox for Python"
+
         if len(plt.get_fignums()) == 0:
             # there are no figures, create one
             fig, ax = plt.subplots()  # fig creates a new window
         else:
             # there are existing figures
 
             if reuse:
                 # attempt to reuse an axes, saves all the setup overhead
                 if ax is None:
                     ax = plt.gca()
                 for c in ax.get_children():
                     if isinstance(c, mpl.image.AxesImage):
                         c.set_data(im)
                         try:
-                            plt.gcf().canvas.manager.set_window_title(title)  # for 3.4 onward
+                            plt.gcf().canvas.manager.set_window_title(
+                                title
+                            )  # for 3.4 onward
                         except:
                             pass
 
-                if block is None:
-                    pass
-                elif isinstance(block, bool):
+                if fps is not None:
+                    print("pausing", 1.0 / fps)
+                    plt.pause(1.0 / fps)
+
+                if block is not None:
                     plt.show(block=block)
-                else:
-                    plt.pause(block)
+
+                return
 
             if fig is not None:
                 # make this figure the current one
                 plt.figure(fig)
-                
+
             if ax is None:
                 fig, ax = plt.subplots()  # fig creates a new window
-            
 
         # aspect ratio:
         if not square:
-            mpl.rcParams["image.aspect"] = 'auto'
+            mpl.rcParams["image.aspect"] = "auto"
 
         # hide interactive toolbar buttons (must be before figure creation)
         if not gui:
-            mpl.rcParams['toolbar'] = 'None'
+            mpl.rcParams["toolbar"] = "None"
 
         if darken is True:
             darken = 0.5
 
         # # experiment with addign buttons to the navigation bar
         # matplotlib.rcParams["toolbar"] = "toolmanager"
         # class LineTool(ToolToggleBase):
@@ -288,16 +289,15 @@
         #         print('hello from trigger')
 
         # tm = fig.canvas.manager.toolmanager
         # tm.add_tool('newtool', LineTool)
         # fig.canvas.manager.toolbar.add_tool(tm.get_tool("newtool"), "toolgroup")
 
         # get screen resolution:
-        #swidth, sheight = pyautogui.size()  # pixels  TODO REPLACE THIS WITH STUFF FROM BDSIM
-
+        # swidth, sheight = pyautogui.size()  # pixels  TODO REPLACE THIS WITH STUFF FROM BDSIM
 
         # mpl_backend = mpl.get_backend()
 
         # if mpl_backend == 'Qt5Agg':
         #     from PyQt5 import QtWidgets
         #     app = QtWidgets.QApplication([])
         #     screen = app.primaryScreen()
@@ -319,29 +319,28 @@
         # else:
         #     print('unknown backend, cant find width', mpl_backend)
 
         # dpi = None  # can make this an input option
         # if dpi is None:
         #     dpi = mpl.rcParams['figure.dpi']  # default is 100
 
-
         if width is not None:
             fig.set_figwidth(width / 25.4)  # inches
 
         if height is not None:
             fig.set_figheight(height / 25.4)  # inches
 
         ## Create the colormap and normalizer
         norm = None
         cmap = None
-        if colormap == 'invert':
-            cmap = 'Greys'
-        elif colormap == 'signed':
+        if colormap == "invert":
+            cmap = "Greys"
+        elif colormap == "signed":
             # signed color map, red is negative, blue is positive, zero is white
-            cmap = 'bwr_r'  # blue -> white -> red
+            cmap = "bwr_r"  # blue -> white -> red
             min = np.min(im)
             max = np.max(im)
 
             # ensure min/max are symmetric about zero, so that zero is white
             if abs(max) >= abs(min):
                 min = -max  # lgtm[py/multiple-definition]
             else:
@@ -351,36 +350,25 @@
                 norm = mpl.colors.PowerNorm(gamma=0.45)
             else:
                 # if abs(min) > abs(max):
                 #     norm = mpl.colors.Normalize(vmin=min, vmax=abs(min / max) * max)
                 # else:
                 #     norm = mpl.colors.Normalize(vmin=abs(max / min) * min, vmax=max)
                 norm = mpl.colors.CenteredNorm()
-        elif colormap == 'invsigned':
+        elif colormap == "invsigned":
             # inverse signed color map, red is negative, blue is positive, zero is black
             cdict = {
-                'red': [
-                            (0, 1, 1),
-                            (0.5, 0, 0),
-                            (1, 0, 0)
-                        ],
-                'green': [
-                            (0, 0, 0),
-                            (1, 0, 0)
-                        ],
-                'blue': [
-                            (0, 0, 0),
-                            (0.5, 0, 0),
-                            (1, 1, 1)
-                        ]
+                "red": [(0, 1, 1), (0.5, 0, 0), (1, 0, 0)],
+                "green": [(0, 0, 0), (1, 0, 0)],
+                "blue": [(0, 0, 0), (0.5, 0, 0), (1, 1, 1)],
             }
             if ncolors is None:
-                cmap = mpl.colors.LinearSegmentedColormap('signed', cdict)
+                cmap = mpl.colors.LinearSegmentedColormap("signed", cdict)
             else:
-                cmap = mpl.colors.LinearSegmentedColormap('signed', cdict, N=ncolors)
+                cmap = mpl.colors.LinearSegmentedColormap("signed", cdict, N=ncolors)
             min = np.min(im)
             max = np.max(im)
 
             # ensure min/max are symmetric about zero, so that zero is black
             if abs(max) >= abs(min):
                 min = -max
             else:
@@ -389,32 +377,32 @@
             if powernorm:
                 norm = mpl.colors.PowerNorm(gamma=0.45)
             else:
                 if abs(min) > abs(max):
                     norm = mpl.colors.Normalize(vmin=min, vmax=abs(min / max) * max)
                 else:
                     norm = mpl.colors.Normalize(vmin=abs(max / min) * min, vmax=max)
-        elif colormap == 'grey':
-            cmap = 'gray'
-        elif colormap == 'random':
+        elif colormap == "grey":
+            cmap = "gray"
+        elif colormap == "random":
             x = np.random.rand(256 if ncolors is None else ncolors, 3)
-            cmap =  mpl.colors.LinearSegmentedColormap.from_list('my_colormap', x)
+            cmap = mpl.colors.LinearSegmentedColormap.from_list("my_colormap", x)
         else:
             cmap = colormap
 
         # choose default grey scale map for non-color image
         if cmap is None and len(im.shape) == 2:
-            cmap = 'gray'
+            cmap = "gray"
 
         # TODO not sure why exclusion for color, nor why float conversion
         if im.ndim == 3 and darken is not None:
             im = float_image(im) / darken
 
         if isinstance(cmap, str):
-            #cmap = cm.get_cmap(cmap, lut=ncolors)
+            # cmap = cm.get_cmap(cmap, lut=ncolors)
             cmap = mpl.colormaps[cmap]
             if ncolors is not None:
                 cmap = cmap.resampled(ncolors)
 
         # handle values outside of range
         #
         #  - undercolor, below vmin
@@ -436,50 +424,50 @@
 
         if black != 0:
             if np.issubdtype(im.dtype, np.floating):
                 m = 1 - black
                 c = black
                 im = m * im + c
                 norm = mpl.colors.Normalize(0, 1)
-            elif np.issubdtype(im.dtype, np.bool_):
+            elif np.issubdtype(im.dtype, bool):
                 norm = mpl.colors.Normalize(0, 1)
                 ncolors = 2
             else:
-                 max = np.iinfo(im.dtype).max
-                 black = black * max
-                 c = black
-                 m = (max - c) / max
-                 im = (m * im + c).astype(im.dtype)
-                 norm = mpl.colors.Normalize(0, max)
+                max = np.iinfo(im.dtype).max
+                black = black * max
+                c = black
+                m = (max - c) / max
+                im = (m * im + c).astype(im.dtype)
+                norm = mpl.colors.Normalize(0, max)
             # else:
             #     # lift the displayed intensity of black pixels.
             #     # set the greyscale mapping [0,M] to [black,1]
             #     M = np.max(im)
             #     norm = mpl.colors.Normalize(-black * M / (1 - black), M)
         if darken:
             norm = mpl.colors.Normalize(np.min(im), np.max(im) / darken)
 
         if gamma:
             cmap.set_gamma(gamma)
-            
+
         # print('Colormap is ', cmap)
 
         # build up options for imshow
         options = kwargs
         if ynormal:
-            options['origin'] = 'lower'
+            options["origin"] = "lower"
 
         if extent is not None:
-            options['extent'] = extent
+            options["extent"] = extent
 
         # display the image
         if len(im.shape) == 3:
             # reverse the color planes if it's color
             if colororder not in ("RGB", "BGR"):
-                raise ValueError('unknown colororder ', colororder)
+                raise ValueError("unknown colororder ", colororder)
             if colororder == "BGR":
                 im = im[:, :, ::-1]
             h = ax.imshow(im, norm=norm, cmap=cmap, **options)
         else:
             if norm is None:
                 # exclude NaN values
                 if vrange is None:
@@ -497,90 +485,87 @@
 
             h = ax.imshow(im, norm=norm, cmap=cmap, **options)
 
         # display the color bar
         if colorbar is not False:
             cbargs = {}
             if ncolors:
-                cbargs['ticks'] = range(ncolors + 1)
+                cbargs["ticks"] = range(ncolors + 1)
 
             if isinstance(colorbar, dict):
                 # passed options have priority
                 cbargs = {**cbargs, **colorbar}
 
             cb = fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax, **cbargs)
 
-
         # set title of figure window
         try:
             plt.gcf().canvas.manager.set_window_title(title)  # for 3.4 onward
         except:
             pass
 
         # set title in figure plot:
         # fig.suptitle(title)  # slightly different positioning
         # ax.set_title(title)
-        
 
         # hide image axes - by default also removes frame
         # back with ax.spines['top'].set_visible(True) ?
         if not axes:
-            ax.axis('off')
+            ax.axis("off")
 
         if extent is None:
-            ax.set_xlabel('u (pixels)')
-            ax.set_ylabel('v (pixels)')
+            ax.set_xlabel("u (pixels)")
+            ax.set_ylabel("v (pixels)")
         if grid is not False:
             # if grid is True:
             #     ax.grid(True)
             # elif isinstance(grid, str):
-            ax.grid(color='y', alpha=0.5, linewidth=0.5)
-
+            ax.grid(color="y", alpha=0.5, linewidth=0.5)
 
         # no frame:
         if not frame:
             # NOTE: for frame tweaking, see matplotlib.spines
             # https://matplotlib.org/3.3.2/api/spines_api.html
             # note: can set spines linewidth:
             # ax.spines['top'].set_linewidth(2.0)
-            ax.spines['top'].set_visible(False)
-            ax.spines['bottom'].set_visible(False)
-            ax.spines['left'].set_visible(False)
-            ax.spines['right'].set_visible(False)
+            ax.spines["top"].set_visible(False)
+            ax.spines["bottom"].set_visible(False)
+            ax.spines["left"].set_visible(False)
+            ax.spines["right"].set_visible(False)
 
         if savefigname is not None:
             # TODO check valid savefigname
             # set default save file format
-            mpl.rcParams["savefig.format"] = 'eps'
+            mpl.rcParams["savefig.format"] = "eps"
             plt.draw()
 
             # savefig must be called before plt.show
             # after plt.show(), a new fig is automatically created
             plt.savefig(savefigname)
 
         # format the pixel value display
         def format_coord(u, v):
             u = int(u + 0.5)
             v = int(v + 0.5)
-            
+
             try:
                 if im.ndim == 2:
                     # monochrome image
                     x = im[v, u]
                     if isinstance(x, np.integer):
                         val = f"{x:d}"
                     elif isinstance(x, np.floating):
                         val = f"{x:.3f}"
-                    elif isinstance(x, np.bool_):
+                    elif isinstance(x, bool):
                         val = f"{x}"
 
                     return f"({u}, {v}): {val} {x.dtype}"
                 else:
                     # color image
-                    x = im[v, u, :] # in RGB order
+                    x = im[v, u, :]  # in RGB order
                     if colororder == "BGR":
                         x = x[::-1]
                     if np.issubdtype(x.dtype, np.integer):
                         val = [f"{_:d}" for _ in x]
                     elif np.issubdtype(x.dtype, np.floating):
                         val = [f"{_:.3f}" for _ in x]
                     val = "[" + ", ".join(val) + "]"
@@ -594,52 +579,64 @@
             ax.format_coord = format_coord
         else:
             ax.format_coord = coordformat
 
         # don't display data
         h.format_cursor_data = lambda x: ""
 
-        if block is None:
-            pass
-        elif isinstance(block, bool):
+        if fps is not None:
+            print("pausing", 1.0 / fps)
+            plt.pause(1.0 / fps)
+
+        if block is not None:
             plt.show(block=block)
-        else:
-            plt.pause(block)
+
         return h
     else:
         ## display using OpenCV
-        global __last_windowname
+        global __last_window_number
 
-        if reuse:
-            if __last_windowname is not None:
-                title = __last_windowname
-            else:
-                title = 'idisp'
-        else:
-            __last_windowname = title
+        if not reuse and title is None:
+            # create a unique window name for each call
+            title = "idisp." + str(__last_window_number)
+            __last_window_number += 1
 
         cv.namedWindow(title, cv.WINDOW_AUTOSIZE)
         cv.imshow(title, im)  # make sure BGR format image
+        cv.waitKey(1)
+
+        if fps is not None:
+            # wait one frame time
+            cv.waitKey(round(1000.0 / fps))
 
         if block is True:
             while True:
                 k = cv.waitKey(delay=0)  # wait forever for keystroke
-                if k == ord('q'):
+                if k == ord("q"):
                     cv.destroyWindow(title)
                     cv.waitKey(1)
                     break
-        elif isinstance(block, (int, float)):
-            cv.waitKey(round(block * 1000))
-            
+
         # TODO fig, ax equivalent for OpenCV? how to print/plot to the same
         # window/set of axes?
-        fig = None
-        ax = None
 
-    return fig, ax
+
+
+def cv_destroy_window(title=None, block=True):
+
+    if title == "all":
+        cv.destroyAllWindows()
+    else:
+        if block:
+            while True:
+                k = cv.waitKey(delay=0)  # wait forever for keystroke
+                if k == ord("q"):
+                    break
+        cv.destroyWindow(title)
+    cv.waitKey(1)  # run the event loop
 
 
 def _isnotebook():
     """
     Determine if code is being run from a Jupyter notebook
 
     ``_isnotebook`` is True if running Jupyter notebook, else False
@@ -647,46 +644,51 @@
     :references:
 
         - https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-
           is-executed-in-the-ipython-notebook/39662359#39662359
     """
     try:
         shell = get_ipython().__class__.__name__
-        if shell in ('Shell', 'ZMQInteractiveShell'):
-            return True   # Jupyter notebook or qtconsole or CoLab
-        elif shell == 'TerminalInteractiveShell':
+        if shell in ("Shell", "ZMQInteractiveShell"):
+            return True  # Jupyter notebook or qtconsole or CoLab
+        elif shell == "TerminalInteractiveShell":
             return False  # Terminal running IPython
         else:
             return False  # Other type (?)
     except NameError:
-        return False      # Probably standard Python interpreter
+        return False  # Probably standard Python interpreter
 
 
 def iread(filename, *args, **kwargs):
     r"""
     Read image from file or URL
 
     :param filename: file name or URL
     :type filename: str
     :param kwargs: key word arguments passed to :func:`convert`
     :return: image and filename
     :rtype: tuple (ndarray, str) or list of tuples, image is
         a 2D or 3D NumPy ndarray
 
     Loads an image from a file or URL, and returns the
-    image as a NumPy array, as well as the absolute path name.  The
-    image can by greyscale or color in any of the wide range of formats
-    supported by the OpenCV ``imread`` function.
+    image as a NumPy array, as well as the absolute path name.  
 
+    If the path is not absolute it is first searched for relative
+    to the current directory, and if not found, it is searched for in
+    the ``images`` folder of the 
+    ```mvtb_data`` package <https://github.com/petercorke/machinevision-toolbox-python/tree/master/mvtb-data>`_.
+    
     If ``file`` is a list or contains a wildcard, the result will be a list of
     ``(image, path)`` tuples.  They will be sorted by path.
 
-    Extra options can be passsed to perform datatype conversion, color to
-    grey scale conversion, gamma correction, image decimation or region of
-    interest windowing.  Details are given at :func:`convert`.
+    The image can by greyscale or color in any of the wide range of formats
+    supported by the OpenCV ``imread`` function. Extra options can be passsed to
+    perform datatype conversion, color to grey scale conversion, gamma
+    correction, image decimation or region of interest windowing.  Details are
+    given at :func:`convert`.
 
     Example:
 
     .. runblock:: pycon
 
         >>> from machinevisiontoolbox import iread
         >>> im, file = iread('flowers1.png')
@@ -707,15 +709,17 @@
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`convert` `cv2.imread <https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56>`_
     """
 
-    if isinstance(filename, str) and (filename.startswith("http://") or filename.startswith("https://")):
+    if isinstance(filename, str) and (
+        filename.startswith("http://") or filename.startswith("https://")
+    ):
         # reading from a URL
 
         resp = urllib.request.urlopen(filename)
         array = np.asarray(bytearray(resp.read()), dtype="uint8")
         image = cv.imdecode(array, -1)
         image = convert(image, **kwargs)
         return (image, filename)
@@ -725,25 +729,25 @@
 
         path = Path(filename).expanduser()
 
         if any([c in "?*" for c in str(path)]):
             # contains wildcard characters, glob it
             # recurse and return a list
             # https://stackoverflow.com/questions/51108256/how-to-take-a-pathname-string-with-wildcards-and-resolve-the-glob-with-pathlib
-    
+
             parts = path.parts[1:] if path.is_absolute() else path.parts
             p = Path(path.root).glob(str(Path("").joinpath(*parts)))
             pathlist = list(p)
 
             if len(pathlist) == 0 and not path.is_absolute():
                 # look in the toolbox image folder
                 parts = path.parts
-                path = mvtb_path_to_datafile('images', Path("").joinpath(*parts[:-1]))
+                path = mvtb_path_to_datafile("images", Path("").joinpath(*parts[:-1]))
                 pathlist = list(path.glob(parts[-1]))
-            
+
             if len(pathlist) == 0:
                 raise ValueError("can't expand wildcard")
 
             # convert to strings
             pathlist = [str(p) for p in pathlist]
 
             images = []
@@ -751,31 +755,44 @@
             for p in pathlist:
                 image = cv.imread(p, -1)  # default read-in as BGR
                 images.append(convert(image, **kwargs))
             return images, pathlist
 
         else:
             # read single file
-            path = mvtb_path_to_datafile('images', path)
+            path = mvtb_path_to_datafile("images", path)
 
             # read the image
             # TODO not sure the following will work on Windows
             image = cv.imread(path.as_posix(), -1)  # default read-in as BGR
             image = convert(image, **kwargs)
             if image is None:
                 # TODO check ValueError
                 raise ValueError(f"Could not read {filename}")
 
             return (image, str(path))
 
     else:
-        raise ValueError(filename, 'invalid filename')
+        raise ValueError(filename, "invalid filename")
 
 
-def convert(image, mono=False, gray=False, grey=False, rgb=True, dtype=None, gamma=None, alpha=False, reduce=None, roi=None, maxintval=None, copy=False):
+def convert(
+    image,
+    mono=False,
+    gray=False,
+    grey=False,
+    rgb=True,
+    dtype=None,
+    gamma=None,
+    alpha=False,
+    reduce=None,
+    roi=None,
+    maxintval=None,
+    copy=False,
+):
     """
     Convert image
 
     :param image: input image
     :type image: ndarray(H,W), ndarray(H,W,P)
     :param grey: convert to grey scale, default False
     :type grey: bool or 'ITU601' [default] or 'ITU709'
@@ -812,19 +829,23 @@
 
     The ``grey``/``gray`` option converts a color image to greyscale and is ignored if the
     image is already greyscale.  Note that this conversions requires knowledge of the color
     plane order specified by ``colororder``.  The planes are inverted by ``invertplanes`` before
     this step.
     """
     if grey:
-        warnings.warn("grey option to Image.Read/iread is deprecated, use mono instead",
-        DeprecationWarning)
+        warnings.warn(
+            "grey option to Image.Read/iread is deprecated, use mono instead",
+            DeprecationWarning,
+        )
     if gray:
-        warnings.warn("gray option to Image.Read/iread is deprecated, use mono instead",
-        DeprecationWarning)
+        warnings.warn(
+            "gray option to Image.Read/iread is deprecated, use mono instead",
+            DeprecationWarning,
+        )
     image_original = image
 
     if image.ndim == 3 and image.shape[2] in (3, 4):
         # is color image RGB, RGBA, BGR, BGRA
         if not alpha:
             # optionally remove the alpha plane
             image = image[:, :, :3]
@@ -834,62 +855,62 @@
             # np.copy() is required to make torchvision happy
             colororder = "RGB"
         else:
             colororder = "BGR"
 
     mono = mono or gray or grey
     if mono and len(image.shape) == 3:
-        image = colorspace_convert(image, colororder, 'grey')
+        image = colorspace_convert(image, colororder, "grey")
 
     dtype_alias = {
-        'int':    'uint8',
-        'float':  'float32',
-        'double': 'float64',
-        'half':   'float16',
+        "int": "uint8",
+        "float": "float32",
+        "double": "float64",
+        "half": "float16",
     }
 
     if dtype is not None:
         # default types
         try:
             dtype = dtype_alias[dtype]
         except KeyError:
             pass
 
-        if 'int' in dtype:
+        if "int" in dtype:
             image = int_image(image, intclass=dtype, maxintval=maxintval)
-        elif 'float' in dtype:
+        elif "float" in dtype:
             image = float_image(image, floatclass=dtype, maxintval=maxintval)
         else:
             raise ValueError(f"unknown dtype: {dtype}")
 
     if reduce is not None:
         n = int(reduce)
-        if len(image.shape)  == 2:
+        if len(image.shape) == 2:
             image = image[::n, ::n]
         else:
             image = image[::n, ::n, :]
-    
+
     if roi is not None:
         umin, umax, vmin, vmax = roi
-        if len(image.shape)  == 2:
+        if len(image.shape) == 2:
             image = image[vmin:vmax, umin:umax]
         else:
             image = image[vmin:vmax, umin:umax, :]
-    
+
     if gamma is not None:
         image = gamma_decode(image, gamma)
 
     if image is not image_original and copy:
         image = image.copy()
 
     return image
 
 
 def iwrite(im, filename, colororder="RGB", **kwargs):
-    """          
+    """
     Write NumPy array to an image file
 
     :param filename: filename to write to
     :type filename: string
     :param colororder: color order, defaults to "RGB"
     :type colororder: str
     :param kwargs: additional arguments, see ImwriteFlags
@@ -909,35 +930,36 @@
 
     .. note::
         - supports 8-bit greyscale and color images
         - supports uint16 for PNG, JPEG 2000, and TIFF formats
         - supports float32
         - image must be in BGR or RGB format
 
-    :seealso: :func:`iread` `cv2.imwrite <https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce>`_ 
+    :seealso: :func:`iread` `cv2.imwrite <https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce>`_
     """
     if im.ndim > 2 and colororder == "RGB":
         # put image into OpenCV BGR order for writing
         return cv.imwrite(filename, im[:, :, ::-1], **kwargs)
     else:
         return cv.imwrite(filename, im, **kwargs)
 
+
 def pickpoints(self, n=None, matplotlib=True):
     """
     Pick points on image
 
     :param n: number of points to input, defaults to infinite number
     :type n: int, optional
     :param matplotlib: plot using Matplotlib (True) or OpenCV (False), defaults to True
     :type matplotlib: bool, optional
     :return: Picked points, one per column
     :rtype: ndarray(2,n)
 
-    Allow the user to select points on the displayed image.  
-    
+    Allow the user to select points on the displayed image.
+
     For Matplotlib, a marker is displayed at each point selected with a
     left-click.  Points can be removed by a right-click, like an undo function.
     middle-click or Enter-key will terminate the entry process.  If ``n`` is
     given, the entry process terminates after ``n`` points are entered, but can
     terminated prematurely as above.
 
     .. note:: Picked coordinates have floating point values.
@@ -946,77 +968,90 @@
     """
 
     if matplotlib:
         points = plt.ginput(n)
         return np.c_[points].T
     else:
 
-        def click_event(event, x, y, flags, params): 
+        def click_event(event, x, y, flags, params):
 
-            # checking for left mouse clicks 
-            if event == cv2.EVENT_LBUTTONDOWN: 
-        
-                # displaying the coordinates 
-                # on the Shell 
-                print(x, ' ', y) 
+            # checking for left mouse clicks
+            if event == cv2.EVENT_LBUTTONDOWN:
 
-        cv.setMouseCallback('image', click_event) 
-    
-        # wait for a key to be pressed to exit 
+                # displaying the coordinates
+                # on the Shell
+                print(x, " ", y)
+
+        cv.setMouseCallback("image", click_event)
+
+        # wait for a key to be pressed to exit
         cv.waitKey(0)
-            
+
+
 if __name__ == "__main__":
+    from machinevisiontoolbox import *
+    from machinevisiontoolbox.base import *
 
+    images = ImageCollection("seq/*.png")
+
+    im, file = iread("street.png", dtype="float")
+    idisp(im, matplotlib=False)
+    idisp(im, matplotlib=False)
+
+    for image in images:
+        image.disp(
+            title="sequence", reuse=True, fps=5, matplotlib=False
+        )  # do some operation
+
+    # type 'q' in the image animation window to close it
+    cv_destroy_window("sequence", block=True)
 
     # filename = "~/code/machinevision-toolbox-python/machinevisiontoolbox/images/campus/*.png"
 
     # im = iread(filename)
     # print(im[0])
 
-    from machinevisiontoolbox import VideoCamera, Image
-    from machinevisiontoolbox.base import idisp
-    import numpy as np
-    c = VideoCamera(0, rgb=False)
-    x = c.grab()
+    # from machinevisiontoolbox import VideoCamera, Image
+    # from machinevisiontoolbox.base import idisp
+    # import numpy as np
+
+    # c = VideoCamera(0, rgb=False)
+    # x = c.grab()
 
-    x.disp(block=True)
-    #x.disp(block=True)
+    # x.disp(block=True)
+    # x.disp(block=True)
     # idisp(x.image, colororder="BGR", block=True)
 
     # a = np.eye(2)
     # b = np.dstack([a, a*0, a*0])
     # # idisp(b)
     # # idisp(b, colororder="RGB", title="RGB")
     # # idisp(b, colororder="BGR", title="BGR", block=True)
 
     # x = Image(b)
     # y = Image(b, colororder="BGR")
     # x.disp()
     # y.disp(block=True)
 
-
-
-
     # im = np.zeros((4,4))
     # im[:,0] = 0.2
     # im[:,3] = -0.4
     # idisp(im, colormap='signed', block=True)
     # for i in range(100):
     #     im[:,i] = i - 40
     # idisp(im, matplotlib=True, title='default')
     # idisp(im, matplotlib=True, colormap='random', title='random')
     # idisp(im, matplotlib=True, colormap='grey', darken=4, title='dark')
     # idisp(im, matplotlib=True, colormap='signed', title='signed')
     # idisp(im, matplotlib=True, colormap='invsigned', title='invsigned')
     # idisp(im, matplotlib=True, colormap='grey', ncolors=4, title='solarize')
     # idisp(im, matplotlib=True, block=True, colormap='invert', title='grey')
-   
 
     # for i in range(50):
     #     im[:,i] = 10
     # idisp(im, matplotlib=True, block=False, colormap='grey', black=5, title='black=5')
     # idisp(im, matplotlib=True, block=False, colormap='grey', ynormal=True, title='grey')
     # idisp(im, matplotlib=True, block=False, colormap='grey', xydata=np.r_[10,20,30,40], title='grey')
     # idisp(im, matplotlib=True, block=True, colormap='grey', ynormal=True, title='grey')
 
-    # im, file = iread('street.png', dtype='float')
-    # idisp(im, title='Boo!', block=True)
+    # im, file = iread("street.png", dtype="float")
+    # idisp(im, title="Boo!", block=True)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/meshgrid.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/meshgrid.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import numpy as np
 
+
 def meshgrid(width, height):
     """
     Coordinate arrays for an image
 
     :param width: image width in pixels
     :type width: int
     :param height: image height in pixels
@@ -24,15 +25,16 @@
         >>> Z
 
     :seealso: :func:`Image.warp` :func:`~numpy.meshgrid`
     """
     u = np.arange(width)
     v = np.arange(height)
 
-    return np.meshgrid(u, v)#, indexing='ij')
+    return np.meshgrid(u, v)  # , indexing='ij')
+
 
 def spherical_rotate(Phi, Theta, R):
     r"""
     Rotate coordinate matrices for a spherical image
 
     :param Phi: coordinate array for azimuth
     :type Phi: ndarray(H,W)
@@ -43,15 +45,15 @@
     :return: transformed coordinate arrays
     :rtype: ndarray(H,W), ndarray(H,W)
 
     The coordinates of points in a spherical image can be represented by a pair
     of coordinate matrices that describe azimuth :math:`\phi \in [0, 2\pi]` and
     colatitude :math:`\theta \in [0, \pi]` for each pixel: ``Phi[u,v]``
     :math:`=\phi_{u,v}`, ``Theta[u,v]`` :math:`=\theta_{u,v}`.
-    
+
     This function rotates the spherical image about its centre by
     transforming the coordinate arrays
 
     .. math:: \begin{pmatrix} \phi^\prime_{u,v} \\ \theta^\prime_{u,v} \end{pmatrix} =
         \mat{R} \begin{pmatrix} \phi_{u,v} \\ \theta_{u,v} \end{pmatrix}, \forall u, v
 
     :seealso: :class:`spatialmath.pose3d.SO3`
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/shapes.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/shapes.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,88 +2,95 @@
 
 import numpy as np
 import scipy
 
 from spatialmath import SE3
 from spatialmath.base import base
 
+
 def mkgrid(n=2, side=1, pose=None):
     """
     Create planar grid of points
 
     :param n: number of points in each dimension, defaults to 2
     :type n: int, array_like(2)
     :param s: side length of the whole grid, defaults to 1
     :type s: float, array_like(2)
     :param pose: pose of the grid, defaults to None
     :type pose: SE3, optional
     :return: 3D coordinates
     :rtype: ndarray(3,n**2), ndarray(3,n[0]*n[1])
- 
+
     Compute a set of coordinates, as column vectors, that define a
     uniform grid of points over a planar region of given size.
 
     If ``n`` or ``s`` are scalar it is assumed to apply in the x- and y-directions.
 
     Example:
 
     .. runblock:: pycon
 
         >>> from machinevisiontoolbox import mkgrid
         >>> from spatialmath import SE3
         >>> mkgrid()  # 2x2 grid, side length 1m
         >>> mkgrid(side=2)  # 2x2 grid, side length 2m
-        >>> mkgrid([2, 3], [4, 6]) # 2x3 grid, side length 4x6m 
+        >>> mkgrid([2, 3], [4, 6]) # 2x3 grid, side length 4x6m
         >>> mkgrid(pose=SE3.Trans(1,2,3))
 
     .. note:: By default the grid lies in the xy-plane, symmetric about the origin.  The
         ``pose`` argument can be used to transform all the points.
- 
+
     """
     side = base.getvector(side)
     if len(side) == 1:
         sx = side[0]
         sy = side[0]
     elif len(side) == 2:
         sx = side[0]
         sy = side[1]
     else:
-        raise ValueError('bad s')
+        raise ValueError("bad s")
 
     n = base.getvector(n)
     if len(n) == 1:
         nx = n[0]
         ny = n[0]
     elif len(n) == 2:
         nx = n[0]
         ny = n[1]
     else:
-        raise ValueError('bad number of points')
+        raise ValueError("bad number of points")
 
     if n[0] == 2:
         # special case, we want the points in specific order
-        P = np.array([
-            [-sx, -sy, 0],
-            [-sx,  sy, 0],
-            [ sx,  sy, 0],
-            [ sx, -sy, 0],
-        ]).T / 2
+        P = (
+            np.array(
+                [
+                    [-sx, -sy, 0],
+                    [-sx, sy, 0],
+                    [sx, sy, 0],
+                    [sx, -sy, 0],
+                ]
+            ).T
+            / 2
+        )
     else:
-        X, Y = np.meshgrid(np.arange(nx), np.arange(ny), sparse=False, indexing='ij')
-        X = ( X / (nx-1) - 0.5 ) * sx
-        Y = ( Y / (ny-1) - 0.5 ) * sy
+        X, Y = np.meshgrid(np.arange(nx), np.arange(ny), sparse=False, indexing="ij")
+        X = (X / (nx - 1) - 0.5) * sx
+        Y = (Y / (ny - 1) - 0.5) * sy
         Z = np.zeros(X.shape)
         P = np.column_stack((X.flatten(), Y.flatten(), Z.flatten())).T
-    
+
     # optionally transform the points
     if pose is not None:
         P = pose * P
 
     return P
 
+
 def mkcube(s=1, facepoint=False, pose=None, centre=None, edge=False, **kwargs):
     """
     Create a cube
 
     :param s: side length, defaults to 1
     :type s: float
     :param facepoint: add extra point in the centre of each face, defaults to False
@@ -102,23 +109,23 @@
     **Vertex mode**
 
     :return: vertex coordinates
     :rtype: ndarray(3,8), ndarray(3,14)
 
     Compute the eight vertex coordinates. If facepoint is True then add
     an extra point in the centre of each face.
-    
+
     By default, the cube is drawn centred at the origin but its centre
     can be changed using ``centre`` or it can be arbitrarily positioned and
     oriented by specifying its ``pose``.
 
     Example:
 
     .. runblock:: pycon
-    
+
         >>> from machinevisiontoolbox import mkcube
         >>> from spatialmath import SE3
         >>> mkcube()  # cube of side length 1
         >>> mkcube(pose=SE3.Trans(1,2,3))  # cube of side length 1
 
     **Edge mode**
 
@@ -144,62 +151,62 @@
     We can also use MATLAB-like syntax::
 
         >>> X, Y, Z = mkcube(edge=True)
         >>> ax.plot_wireframe(X, Y, Z)
 
     :seealso: :func:`mksphere`, :func:`mkcylinder`
     """
-    
+
     if pose is not None and centre is not None:
-        raise ValueError('Cannot specify centre and pose options')
+        raise ValueError("Cannot specify centre and pose options")
 
     # offset it
     if centre is not None:
         pose = SE3(base.getvector(centre, 3))
 
     # vertices of a unit cube with one corner at origin
-    cube = np.array([
-       [ -1,    -1,     1,     1,    -1,    -1,     1,     1],
-       [ -1,     1,     1,    -1,    -1,     1,     1,    -1],
-       [ -1,    -1,    -1,    -1,     1,     1,     1,     1]
-       ])
+    cube = np.array(
+        [
+            [-1, -1, 1, 1, -1, -1, 1, 1],
+            [-1, 1, 1, -1, -1, 1, 1, -1],
+            [-1, -1, -1, -1, 1, 1, 1, 1],
+        ]
+    )
 
     if facepoint:
         # append face centre points if required
-        faces = np.array([
-          [1,    -1,     0,     0,     0,     0],
-          [0,     0,     1,    -1,     0,     0],
-          [0,     0,     0,     0,     1,    -1]
-        ])
+        faces = np.array(
+            [[1, -1, 0, 0, 0, 0], [0, 0, 1, -1, 0, 0], [0, 0, 0, 0, 1, -1]]
+        )
         cube = np.hstack((cube, faces))
 
     # vertices of cube about the origin
     if base.isvector(s, 3):
         s = np.diagonal(getvector(s, 3))
         cube = s @ cube / 2
     else:
         cube = s * cube / 2
-    
+
     # optionally transform the vertices
     if pose is not None:
         cube = pose * cube
 
     if edge:
         # edge model, return coordinate matrices
-        cube = cube[:,[0,1,2,3,0,4,5,6,7,4]]
-        o1 = np.reshape(cube[0,:], (2,5))
-        o2 = np.reshape(cube[1,:], (2,5))
-        o3 = np.reshape(cube[2,:], (2,5))
+        cube = cube[:, [0, 1, 2, 3, 0, 4, 5, 6, 7, 4]]
+        o1 = np.reshape(cube[0, :], (2, 5))
+        o2 = np.reshape(cube[1, :], (2, 5))
+        o3 = np.reshape(cube[2, :], (2, 5))
         return o1, o2, o3
 
     else:
         return cube
 
 
-def mksphere(r=1, n=20, centre=[0,0,0]):
+def mksphere(r=1, n=20, centre=[0, 0, 0]):
     """
     Create a sphere
 
     :param r: radius, defaults to 1
     :type r: float, optional
     :param n: number of points around the equator, defaults to 20
     :type n: int, optional
@@ -224,28 +231,28 @@
 
         >>> X, Y, Z = mksphere()
         >>> ax.plot_wireframe(X, Y, Z)
 
     :seealso: :func:`mkcube`, :func:`mkcylinder`
     """
 
-    theta = np.linspace(-pi, pi, n).reshape((1,n))
-    phi = np.linspace(-pi / 2, pi / 2, n).reshape((n,1))
+    theta = np.linspace(-pi, pi, n).reshape((1, n))
+    phi = np.linspace(-pi / 2, pi / 2, n).reshape((n, 1))
     cosphi = np.cos(phi)
     sintheta = np.sin(theta)
 
     # fix rounding errors
-    cosphi[0,0] = 0
-    cosphi[0,n-1] = 0
-    sintheta[0,0] = 0
-    sintheta[n-1,0] = 0
+    cosphi[0, 0] = 0
+    cosphi[0, n - 1] = 0
+    sintheta[0, 0] = 0
+    sintheta[n - 1, 0] = 0
 
     X = r * cosphi @ cos(theta) + centre[0]
     Y = r * cosphi @ sintheta + centre[1]
-    Z = r * sin(phi) @ np.ones((1,n)) + centre[2]
+    Z = r * sin(phi) @ np.ones((1, n)) + centre[2]
 
     return X, Y, Z
 
 
 def mkcylinder(r=1, h=1, n=20, symmetric=False, pose=None):
     """
     Create a cylinder
@@ -266,15 +273,15 @@
     `plot_wireframe` to draw a cylinder of radius ``r`` about the z-axis from
     z=0 to z=``h``. The cylinder can be repositioned or reoriented using the
     ``pose`` option.
 
     If radius ``r`` is array_like(2) then it represents the radius at the bottom
     and top of the cylinder and can be used to create a cone or conical frustum.
     If len(r)>2 then it allows the creation of a more complex shape with radius
-    as a function of z. 
+    as a function of z.
 
     Example::
 
         >>> from machinevisiontoolbox import mkcylinder
         >>> import matplotlib.pyplot as plt
         >>> # draw a horizontal diablo shape
         >>> r = np.linspace(0, 2*pi, 50)
@@ -290,42 +297,43 @@
         >>> ax.plot_wireframe(X, Y, Z)
 
     :seealso: :func:`mkcube`, :func:`mksphere`
     """
 
     if isinstance(r, (int, float)):
         r = [r, r]
-    r = np.array(r).reshape((-1,1))
+    r = np.array(r).reshape((-1, 1))
 
-    theta = np.linspace(0, 2 * pi, n).reshape((1,n))
+    theta = np.linspace(0, 2 * pi, n).reshape((1, n))
     sintheta = np.sin(theta)
-    sintheta[0,n-1] = 0
+    sintheta[0, n - 1] = 0
 
     X = r @ np.cos(theta)
     Y = r @ sintheta
     m = len(r)
-    Z = h  * np.linspace(0, 1, m).reshape((m,1)) @ np.ones((1,n))
+    Z = h * np.linspace(0, 1, m).reshape((m, 1)) @ np.ones((1, n))
     if symmetric:
         Z = Z - h / 2
 
     if pose is not None:
         P = np.row_stack((X.flatten(), Y.flatten(), Z.flatten()))
         P = pose * P
-        X = P[0,:].reshape(X.shape)
-        Y = P[1,:].reshape(X.shape)
-        Z = P[2,:].reshape(X.shape)
+        X = P[0, :].reshape(X.shape)
+        Y = P[1, :].reshape(X.shape)
+        Z = P[2, :].reshape(X.shape)
 
     return X, Y, Z
 
+
 # if __name__ == "__main__":
 
 #     from spatialmath import SE3
 
 #     S = mkcylinder(pose=SE3())
 
 #     r = np.linspace(0, 2*pi, 50)
 #     import matplotlib.pyplot as plt
 #     S = mkcylinder(r=np.cos(r) + 1.5, symmetric=True, pose=SE3.Rx(pi/2))
 #     fig = plt.figure()
 #     ax = fig.gca(projection='3d')
 #     ax.plot_wireframe(*S)
-#     plt.show()
+#     plt.show()
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/base/types.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/base/types.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 import numpy as np
 
-def int_image(image, intclass='uint8', maxintval=None):
+
+def int_image(image, intclass="uint8", maxintval=None):
     """
     Convert image to integer type
 
     :param image: input image
     :type image: ndarray(H,W), ndarray(H,W,P)
-    :param intclass: integer class to convert to, the name of any integer 
+    :param intclass: integer class to convert to, the name of any integer
         class supported by NumPy, defaults to ``'uint8'``
     :type intclass: str
     :param maxintval: maximum value of integer, defaults to maximum positive
         value of ``image`` datatype
     :type maxintval: int
     :return: image with integer pixel types
     :rtype: ndarray(H,W), ndarray(H,W,P)
@@ -42,31 +43,31 @@
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`float_image`
     """
 
-    if np.issubdtype(image.dtype, np.bool_):
+    if np.issubdtype(image.dtype, bool):
         return image.astype(intclass) * np.iinfo(intclass).max
 
     elif np.issubdtype(image.dtype, np.floating):
         # rescale to integer
         scaled = image * np.float64(np.iinfo(intclass).max)
         return np.rint(scaled).astype(intclass)
 
     elif np.issubdtype(image.dtype, np.integer):
         # scale and cast to different integer type
         if maxintval is None:
             maxintval = np.iinfo(image.dtype).max
         image = image * (np.iinfo(intclass).max / maxintval)
         return image.astype(intclass)
- 
 
-def float_image(image, floatclass='float32', maxintval=None):
+
+def float_image(image, floatclass="float32", maxintval=None):
     """
     Convert image to float type
 
     :param image: input image
     :type image: ndarray(H,W), ndarray(H,W,P)
     :param floatclass: 'single', 'double', 'float32' [default], 'float64'
     :type floatclass: str
@@ -101,28 +102,36 @@
 
     :references:
         - Robotics, Vision & Control for Python, Section 10.1, P. Corke, Springer 2023.
 
     :seealso: :func:`int_image`
     """
 
-    if floatclass not in ('float', 'single', 'double', 'half', 'float16', 'float32', 'float64'):
-        raise ValueError('bad float type')
+    if floatclass not in (
+        "float",
+        "single",
+        "double",
+        "half",
+        "float16",
+        "float32",
+        "float64",
+    ):
+        raise ValueError("bad float type")
 
     if np.issubdtype(image.dtype, np.integer):
         # rescale the pixel values
         if maxintval is None:
             maxintval = np.iinfo(image.dtype).max
         return image.astype(floatclass) / maxintval
     elif np.issubdtype(image.dtype, np.floating):
         # cast to different float type
         return image.astype(floatclass)
-    elif np.issubdtype(image.dtype, np.bool_):
+    elif np.issubdtype(image.dtype, bool):
         return image.astype(floatclass)
 
     def image_to_dtype(image, dtype):
         dtype = np.dtype(dtype)  # convert to dtype if it's a string
 
         if np.issubdtype(dtype, np.integer):
-           return int_image(dtype)
+            return int_image(dtype)
         elif np.issubdtype(dtype, np.floating):
-            return float_image(dtype)
+            return float_image(dtype)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/blocks/aside_test_blocks.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/blocks/test_blocks.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 from machinevisiontoolbox import CentralCamera, mkcube
 from spatialmath import SE3
 
 from machinevisiontoolbox.blocks import *
 
 
 class CameraBlockTest(unittest.TestCase):
-
     def test_camera(self):
 
         cam = CentralCamera.Default()
         block = Camera(cam)
 
         P = np.array([1, 2, 5])
         T = SE3()
@@ -36,35 +35,34 @@
 
         P = np.array([1, 2, 5])
         p = cam.project_point(P)
 
         J = cam.visjac_p(p, 5)
         nt.assert_array_almost_equal(block._output(p)[0], J)
 
-
     def test_estpose(self):
 
         cam = CentralCamera.Default()
 
         P = mkcube(0.2)
-        T_unknown = SE3.Trans(0.1,0.2,1.5) * SE3.RPY(0.1,0.2,0.3);
+        T_unknown = SE3.Trans(0.1, 0.2, 1.5) * SE3.RPY(0.1, 0.2, 0.3)
         p = cam.project_point(P, objpose=T_unknown)
 
         T_est = cam.estpose(P, p)
 
         block = EstPose_p(cam, P)
 
         nt.assert_array_almost_equal(block._output(p)[0], T_est)
 
-
     def test_imageplane(self):
 
         cam = CentralCamera.Default()
         block = ImagePlane(cam)
 
         # block._start()
         # block._step()
 
+
 # ---------------------------------------------------------------------------------------#
-if __name__ == '__main__':
+if __name__ == "__main__":
 
     unittest.main()
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/blocks/camera.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/blocks/camera.py`

 * *Files 13% similar despite different names*

```diff
@@ -33,16 +33,16 @@
     | SE3        | ndarray |         |
     | ndarray    |         |         |
     +------------+---------+---------+
     """
 
     nin = 2
     nout = 1
-    inlabels = ('P', 'ξ')
-    outlabels = ('p',)
+    inlabels = ("P", "ξ")
+    outlabels = ("p",)
 
     def __init__(self, camera=None, args={}, **blockargs):
         """
         :param camera: Camera model, defaults to None
         :type camera: Camera subclass, optional
         :param blockargs: |BlockOptions|
         :type blockargs: dict
@@ -55,27 +55,27 @@
 
             :input pose: Camera pose as an SE3 object.
             :input P: world points as ndarray(3,N)
 
             :output p: image plane points as ndarray(2,N)
         """
         if camera is None:
-            raise ValueError('camera is not defined')
+            raise ValueError("camera is not defined")
 
         super().__init__(**blockargs)
-        self.type = "camera"
 
         self.camera = camera
 
-    def output(self, t=None):
-        return [self.camera.project_point(self.inputs[0], pose=self.inputs[1])]
+    def output(self, t, inports, x):
+        return [self.camera.project_point(inports[0], pose=inports[1])]
 
 
 # ------------------------------------------------------------------------ #
 
+
 class Visjac_p(FunctionBlock):
     """
     :blockname:`VISJAC_P`
 
     .. table::
        :align: left
 
@@ -87,15 +87,15 @@
     | ndarray    | ndarray |         |
     |            | float   |         |
     +------------+---------+---------+
     """
 
     nin = 1
     nout = 1
-    inlabels = ('p',)
+    inlabels = ("p",)
     outlabels = ()
 
     def __init__(self, camera, depth=1, depthest=False, **blockargs):
         """
         :param camera: Camera model, defaults to None
         :type camera: Camera subclass, optional
         :param depth: Point depth
@@ -103,36 +103,34 @@
         :param depthest: Use depth estimation, defaults to True
         :type depthest: bool, optional
         :param blockargs: |BlockOptions|
         :type blockargs: dict
         :return: a VISJAC_P block
         :rtype: Visjac_p instance
 
-        If the Jacobian 
+        If the Jacobian
 
 
         """
 
         # TODO allow a depth input
 
         if camera is None:
-            raise ValueError('camera is not defined')
-            
+            raise ValueError("camera is not defined")
+
         super().__init__(**blockargs)
-        self.type = "visjac_p"
 
         self.camera = camera
         self.depthest = depthest
         self.depth = depth
 
-
-    def output(self, t=None):
+    def output(self, t, inports, x):
         # do depth estimation here
 
-        J = self.camera.visjac_p(self.inputs[0], self.depth)
+        J = self.camera.visjac_p(inports[0], self.depth)
         return [J]
 
 
 # ------------------------------------------------------------------------ #
 
 
 class EstPose_p(FunctionBlock):
@@ -149,18 +147,18 @@
     +------------+---------+---------+
     | ndarray    | SE3     |         |
     +------------+---------+---------+
     """
 
     nin = 1
     nout = 1
-    inlabels = ('p',)
-    outlabels = ('ξ',)
+    inlabels = ("p",)
+    outlabels = ("ξ",)
 
-    def __init__(self, camera, P, frame='world', method='iterative', **blockargs):
+    def __init__(self, camera, P, frame="world", method="iterative", **blockargs):
         """
         :param camera: Camera model, defaults to None
         :type camera: Camera subclass, optional
         :param P: World point coordinates
         :type P: ndarray(2,N)
         :param frame: return pose of points with respect to reference frame which is one of: 'world' [default] or 'camera'
         :type frame: str, optional
@@ -169,55 +167,64 @@
         :param blockargs: |BlockOptions|
         :type blockargs: dict
         :return: a ESTPOSE_P block
         :rtype: EstPose_p instance
 
         """
         if camera is None:
-            raise ValueError('camera is not defined')
+            raise ValueError("camera is not defined")
 
         super().__init__(**blockargs)
-        self.type = "estpose_p"
 
         self.camera = camera
         self.P = P
         self.method = method
 
-    def output(self, t=None):
-        p = self.inputs[0]
+    def output(self, t, inports, x):
+        p = inports[0]
         T = self.camera.estpose(self.P, p, method=self.method)
         return [T]
 
 
 # ------------------------------------------------------------------------ #
 
 
 class ImagePlane(GraphicsBlock):
     """
     :blockname:`IMAGEPLANE`
-    
+
     .. table::
        :align: left
-    
+
        +--------------+---------+---------+
        | inputs       | outputs |  states |
        +--------------+---------+---------+
        | 1            | 0       | 0       |
        +--------------+---------+---------+
-       | ndarray(2,N) |         |         | 
+       | ndarray(2,N) |         |         |
        +--------------+---------+---------+
     """
-    
+
     nin = 1
     nout = 0
 
-    def __init__(self, camera, style=None, labels=None, grid=True, retain=False, watch=False, init=None, **blockargs):
+    def __init__(
+        self,
+        camera,
+        style=None,
+        labels=None,
+        grid=True,
+        retain=False,
+        watch=False,
+        init=None,
+        **blockargs,
+    ):
         """
         Create a block that plots image plane coordinates.
-        
+
         :param camera: a camera model
         :type camera: Camera instance
         :param style: styles for each point to be plotted
         :type style: str or dict, list of strings or dicts; one per line, optional
         :param grid: draw a grid, defaults to True. Can be boolean or a tuple of
                      options for grid()
         :type grid: bool or sequence
@@ -228,111 +235,112 @@
         :param init: function to initialize the graphics, defaults to None
         :type init: callable, optional
         :param blockargs: |BlockOptions|
         :type blockargs: dict
         :return: An IMAGEPLANE block
         :rtype: ImagePlane instance
 
-        Create a block that plots points on a camera object's virtual image plane.  
-        
+        Create a block that plots points on a camera object's virtual image plane.
+
         Examples::
-            
+
             SCOPE()
             SCOPE(nin=2)
             SCOPE(nin=2, scale=[-1,2])
             SCOPE(styles='k--')
             SCOPE(styles=[{'color': 'blue'}, {'color': 'red', 'linestyle': '--'}])
             SCOPE(styles=['k', 'r--'])
 
-            
+
         .. figure:: ../../figs/Figure_1.png
            :width: 500px
            :alt: example of generated graphic
 
            Example of scope display.
         """
         if camera is None:
-            raise ValueError('camera is not defined')
+            raise ValueError("camera is not defined")
 
         self.camera = camera
 
         if style is None:
             style = {}
         if isinstance(style, dict):
-            default_style = dict(linestyle='none', marker='o', markersize=4, markeredgecolor='black', markerfacecolor='black')
+            default_style = dict(
+                linestyle="none",
+                marker="o",
+                markersize=4,
+                markeredgecolor="black",
+                markerfacecolor="black",
+            )
             self.kwargs = {**default_style, **style}
             self.args = []
         elif isinstance(style, str):
             self.args = [style]
             self.kwargs = {}
         else:
-            raise ValueError('bad style, must be str or dict')
+            raise ValueError("bad style, must be str or dict")
 
         if init is not None:
-            assert callable(init), 'graphics init function must be callable'
+            assert callable(init), "graphics init function must be callable"
         self.init = init
         self.retain = retain
-        
+
         super().__init__(nin=1, **blockargs)
-        
+
         self.grid = grid
 
         self.watch = watch
 
         # TODO, wire width
         # inherit names from wires, block needs to be able to introspect
-        
-    def start(self, state=None):        
+
+    def start(self, simstate):
+        super().start(simstate)
+
         # init the arrays that hold the data
         self.u_data = []
         self.v_data = []
         self.t_data = []
 
         # create the figures
-        self.fig = self.create_figure(state)
+        self.fig = self.create_figure(simstate)
         self.ax = self.fig.add_subplot(111)
         self.camera._init_imageplane(ax=self.ax)
 
         self.ax.set_title(self.name_tex)
 
-        print('@@@@@@', self.args, self.kwargs)
-        self.line, = self.ax.plot(self.u_data, self.v_data, *self.args, **self.kwargs)
+        print("@@@@@@", self.args, self.kwargs)
+        (self.line,) = self.ax.plot(self.u_data, self.v_data, *self.args, **self.kwargs)
 
         # grid control
         if self.grid is True:
             self.ax.grid(self.grid)
         elif isinstance(self.grid, (list, tuple)):
             self.ax.grid(True, *self.grid)
 
         if self.init is not None:
             self.init(self.camera)
-         
+
         if self.watch:
             for wire in self.inports:
                 plug = wire.start  # start plug for input wire
 
                 # append to the watchlist, bdsim.run() will do the rest
                 state.watchlist.append(plug)
                 state.watchnamelist.append(str(plug))
 
-        super().start()
-        
-    def step(self, state=None):
+    def step(self, t, inports):
         # inputs are set
-        self.t_data.append(state.t)
-        u, v = self.inputs[0]
+        self.t_data.append(t)
+        u, v = inports[0]
 
         if self.retain:
             self.u_data.append(u)
             self.v_data.append(v)
         else:
             self.u_data = u
             self.v_data = v
 
         self.line.set_data(self.u_data, self.v_data)
-        
-        if self.bd.runtime.options.animation:
-            self.fig.canvas.flush_events()
-
-    
-        super().step(state=state)
-        
+
+        super().step(t, inports)
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/camera_derivatives.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/camera_derivatives.py`

 * *Files identical despite different names*

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/fiducial.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/fiducial.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,41 +1,37 @@
-
-
 # import cv2
 
 # _aruco_dict = {
-#     "4x4_50", cv2.DICT_4X4_50 = 0, 
-#     "4x4_100", cv2.DICT_4X4_100, 
-#     "4x4_250", cv2.DICT_4X4_250, 
-#     "4x4_1000", cv2.DICT_4X4_1000, 
-#     "5x5_50", cv2.DICT_5X5_50, 
-#     "5x5_100", cv2.DICT_5X5_100, 
-#     "5x5_250", cv2.DICT_5X5_250, 
-#     "5x5_1000", cv2.DICT_5X5_1000, 
-#     "6x6_50", cv2.DICT_6X6_50, 
-#     "6x6_100", cv2.DICT_6X6_100, 
-#     "6x6_250", cv2.DICT_6X6_250, 
-#     "6x6_1000", cv2.DICT_6X6_1000, 
-#     "7x7_50", cv2.DICT_7X7_50, 
-#     "7x7_100", cv2.DICT_7X7_100, 
-#     "7x7_250", cv2.DICT_7X7_250, 
-#     "7x7_1000", cv2.DICT_7X7_1000, 
+#     "4x4_50", cv2.DICT_4X4_50 = 0,
+#     "4x4_100", cv2.DICT_4X4_100,
+#     "4x4_250", cv2.DICT_4X4_250,
+#     "4x4_1000", cv2.DICT_4X4_1000,
+#     "5x5_50", cv2.DICT_5X5_50,
+#     "5x5_100", cv2.DICT_5X5_100,
+#     "5x5_250", cv2.DICT_5X5_250,
+#     "5x5_1000", cv2.DICT_5X5_1000,
+#     "6x6_50", cv2.DICT_6X6_50,
+#     "6x6_100", cv2.DICT_6X6_100,
+#     "6x6_250", cv2.DICT_6X6_250,
+#     "6x6_1000", cv2.DICT_6X6_1000,
+#     "7x7_50", cv2.DICT_7X7_50,
+#     "7x7_100", cv2.DICT_7X7_100,
+#     "7x7_250", cv2.DICT_7X7_250,
+#     "7x7_1000", cv2.DICT_7X7_1000,
 #     original, cv2.DICT_ARUCO_ORIGINAL,
 # }
 
 # _april_dict = {
-#     "16h5", cv2.DICT_APRILTAG_16h5, 
-#     "25h9", cv2.DICT_APRILTAG_25h9, 
-#     "36h10", cv2.DICT_APRILTAG_36h10, 
+#     "16h5", cv2.DICT_APRILTAG_16h5,
+#     "25h9", cv2.DICT_APRILTAG_25h9,
+#     "36h10", cv2.DICT_APRILTAG_36h10,
 #     "36h11", cv2.DICT_APRILTAG_36h11,
 # }
 
 
-
-
 # class Fiducial2dMixin(Feature2d):
 
 
 #     def arucotag(self, dict="4x4_1000", K=None, side=None):
 
 #         dictionary = cv2.aruco.getPredefinedDictionary(_aruco_dict[dict])
 #         markers, ids, _ = cv2.aruco.detectMarkers(scene.image, dictionary)
@@ -43,8 +39,8 @@
 #         if K is not None and side is not None:
 #             rvecs, tvecs, _ = cv2.aruco.estimatePoseSingleMarkers(markers, side, K, None)
 #             for rvec, tvec in zip(rvec, tvecs):
 #                 T = SE3(tvec) * SE3.EulerVec(rvec.flatten())
 
 
 #     def apriltag(self):
-#         pass
+#         pass
```

### Comparing `machinevision-toolbox-python-0.9.4/machinevisiontoolbox/newcameras.py` & `machinevision-toolbox-python-0.9.6/machinevisiontoolbox/newcameras.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,17 +1,20 @@
 import numpy as np
 import scipy as sp
 from math import pi
 from spatialmath import SE3
 from spatialmath.base import e2h, h2e, plot_sphere
 from machinevisiontoolbox import *
 
-u0 = 528.1214; v0 = 384.0784; l = 2.7899; m = 996.4617;
+u0 = 528.1214
+v0 = 384.0784
+l = 2.7899
+m = 996.4617
 
-im_fisheye = Image('fisheye_target.png', dtype='float', grey=True)
+im_fisheye = Image("fisheye_target.png", dtype="float", grey=True)
 im_fisheye.disp()
 
 
 n = 500
 theta_range = np.linspace(0, pi, n)
 phi_range = np.linspace(-pi, pi, n)
 
@@ -20,29 +23,31 @@
 r = (l + m) * np.sin(Theta) / (l - np.cos(Theta))
 Us = r * np.cos(Phi) + u0
 Vs = r * np.sin(Phi) + v0
 
 im_spherical = im_fisheye.interp2d(Us, Vs)
 # im_spherical = f(theta_range, phi_range)
 
-im_spherical.disp(badcolor='red')
+im_spherical.disp(badcolor="red")
 # plt.show(block=True)
 
 
 # sphere
 R = 1
 x = R * np.sin(Theta) * np.cos(Phi)
 y = R * np.sin(Theta) * np.sin(Phi)
 z = R * np.cos(Theta)
 
 # create 3d Axes
 fig = plt.figure()
-ax = fig.add_subplot(111, projection='3d')
+ax = fig.add_subplot(111, projection="3d")
 img = im_spherical.colorize()
-ax.plot_surface(x.T, y.T, z.T, facecolors=img.image, cstride=1, rstride=1) # we've already pruned ourselves
+ax.plot_surface(
+    x.T, y.T, z.T, facecolors=img.image, cstride=1, rstride=1
+)  # we've already pruned ourselves
 
 for az in np.arange(-180, 180, 30):
     for el in np.arange(-180, 180, 30):
         print(az, el)
         ax.view_init(azim=az, elev=el)
         plt.show()
-        plt.savefig(f"az{az}el{el}.png")
+        plt.savefig(f"az{az}el{el}.png")
```

### Comparing `machinevision-toolbox-python-0.9.4/setup.py` & `machinevision-toolbox-python-0.9.6/pyproject.toml`

 * *Files 22% similar despite different names*

```diff
@@ -1,77 +1,98 @@
-from setuptools import setup, find_packages
-import os
+[project]
+name = "machinevision-toolbox-python"
+version = "0.9.6"
+authors = [
+  { name="Peter Corke", email="rvc@petercorke.com" },
+  { name="Dorian Tsai"},
+]
+description = "Python tools for machine vision - education and research"
+readme = "README.md"
+requires-python = ">=3.7"
+classifiers = [
+    "Development Status :: 5 - Production/Stable",
+    # Indicate who your project is intended for
+    "Intended Audience :: Developers",
+    # Specify the Python versions you support here.
+    "Programming Language :: Python :: 3.7",
+    "Programming Language :: Python :: 3.8",
+    "Programming Language :: Python :: 3.9",
+    "Programming Language :: Python :: 3.10",
+    "Programming Language :: Python :: 3.11",
 
-here = os.path.abspath(os.path.dirname(__file__))
+    "License :: OSI Approved :: MIT License",
+    "Operating System :: OS Independent",
+]
+keywords = [
+    "machine vision",
+    "computer vision",
+    "multiview geometry",
+    "stereo vision",
+    "bundle adjustment",
+    "visual servoing",
+    "image features",
+    "color",
+    "blobs",
+    "morphology",
+    "image segmentation",
+    "opencv",
+    "open3d"
+]
 
-req = [
-    "numpy",
+dependencies = [
+    "numpy>=1.17.4",
     "scipy",
     "matplotlib",
     "opencv-python",
+    "open3d",
     "opencv-contrib-python",
     "spatialmath-python",
     "pgraph-python",
     "ansitable",
-    "mvtb-data"
-    ]
+    "mvtb-data",
+]
 
-docs_req = [
+[project.urls]
+"Homepage" = "https://github.com/petercorke/machinevision-toolbox-python"
+"Bug Tracker" = "https://github.com/pypa/sampleproject/issues"
+"Documentation" = "https://petercorke.github.io/machinevision-toolbox-python"
+"Source" = "https://github.com/petercorke/machinevision-toolbox-python"
+
+[project.optional-dependencies]
+
+dev = [
+    "pytest",
+    "coverage",
+    "flake8"
+]
+
+docs = [
     "sphinx",
-    "sphinx_rtd_theme",
-    "sphinx-autorun",
+    "recommonmark",
+    "sphinx-rtd-theme", 
+    "sphinx-autorun", 
+    "sphinxcontrib-jsmath", 
+    "sphinx-markdown-tables",
+    "sphinx-favicon",
 ]
 
-dev_req = ["pytest", "pytest-cov", "flake8", "pyyaml"]
+[build-system]
 
-# Get the long description from the README file
-with open(os.path.join(here, "README.md"), encoding="utf-8") as f:
-    long_description = f.read()
-
-# Get the release/version string
-with open(os.path.join(here, "RELEASE"), encoding="utf-8") as f:
-    release = f.read()
-
-setup(
-    name="machinevision-toolbox-python",
-    version=release,
-    description="A machine vision for education and research",
-    long_description=long_description,
-    long_description_content_type="text/markdown",
-    url="https://github.com/petercorke/machinevision-toolbox-python",
-    author="Peter Corke and Dorian Tsai",
-    license="MIT",
-    classifiers=[
-        #   3 - Alpha
-        #   4 - Beta
-        #   5 - Production/Stable
-        "Development Status :: 5 - Production/Stable",
-        # Indicate who your project is intended for
-        "Intended Audience :: Developers",
-        # Pick your license as you wish (should match "license" above)
-        "License :: OSI Approved :: MIT License",
-
-        # Specify the Python versions you support here. In particular, ensure
-        # that you indicate whether you support Python 2, Python 3 or both.
-        "Programming Language :: Python :: 3.7",
-        "Programming Language :: Python :: 3.8",
-        "Programming Language :: Python :: 3.9",
-        "Programming Language :: Python :: 3.10",
-    ],
-    python_requires=">=3.7",
-    project_urls={
-        "Documentation": "https://petercorke.github.io/machinevision-toolbox-python",
-        "Source": "https://github.com/petercorke/machinevision-toolbox-python",
-        "Tracker": "https://github.com/petercorke/machinevision-toolbox-python/issues",
-        "Coverage": "https://codecov.io/gh/petercorke/machinevision-toolbox-python",
-    },
-    keywords="python machine-vision computer-vision multiview-geometry features color blobs",
-    packages=find_packages(),
-    install_requires=req,
-    extras_require={
-        "docs": docs_req,
-        "dev": dev_req,
-    },
-    data_files=[('.', ['RELEASE'])],
-)
+requires = ["setuptools", "oldest-supported-numpy"]
+build-backend = "setuptools.build_meta"
 
+[tool.setuptools]
+
+packages = [
+    "machinevisiontoolbox",
+    "machinevisiontoolbox.base",
+    "machinevisiontoolbox.blocks",
+]
 
+[tool.black]
+line-length = 88
+target-version = ['py37']
+exclude = "camera_derivatives.py"
+
+[tool.coverage.run]
+omit = [
+]
```


# Comparing `tmp/pypws-2.5.6.0.tar.gz` & `tmp/pypws-2.5.9.0.tar.gz`

## Comparing `pypws-2.5.6.0.tar` & `pypws-2.5.9.0.tar`

### file list

```diff
@@ -1,22 +1,22 @@
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pypws-2.5.6.0/__init__.py
--rw-r--r--   0        0        0       90 2020-02-02 00:00:00.000000 pypws-2.5.6.0/requirements.txt
--rw-r--r--   0        0        0       23 2020-02-02 00:00:00.000000 pypws-2.5.6.0/version.py
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pypws-2.5.6.0/src/pypws/__init__.py
--rw-r--r--   0        0        0   379373 2020-02-02 00:00:00.000000 pypws-2.5.6.0/src/pypws/calculations.py
--rw-r--r--   0        0        0     7768 2020-02-02 00:00:00.000000 pypws-2.5.6.0/src/pypws/constants.py
--rw-r--r--   0        0        0   126938 2020-02-02 00:00:00.000000 pypws-2.5.6.0/src/pypws/entities.py
--rw-r--r--   0        0        0    11091 2020-02-02 00:00:00.000000 pypws-2.5.6.0/src/pypws/enums.py
--rw-r--r--   0        0        0     3526 2020-02-02 00:00:00.000000 pypws-2.5.6.0/src/pypws/materials.py
--rw-r--r--   0        0        0     5710 2020-02-02 00:00:00.000000 pypws-2.5.6.0/src/pypws/utilities.py
--rw-r--r--   0        0        0    27684 2020-02-02 00:00:00.000000 pypws-2.5.6.0/tests/Bund_avg_time.py
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pypws-2.5.6.0/tests/__init__.py
--rw-r--r--   0        0        0     5536 2020-02-02 00:00:00.000000 pypws-2.5.6.0/tests/flash_ammonia.py
--rw-r--r--   0        0        0      989 2020-02-02 00:00:00.000000 pypws-2.5.6.0/tests/flash_ammonia.zip
--rw-r--r--   0        0        0      228 2020-02-02 00:00:00.000000 pypws-2.5.6.0/tests/test_constants.py
--rw-r--r--   0        0        0    13269 2020-02-02 00:00:00.000000 pypws-2.5.6.0/tests/test_peteABS_mod.py
--rw-r--r--   0        0        0     6263 2020-02-02 00:00:00.000000 pypws-2.5.6.0/tests/test_workflow1.py
--rw-r--r--   0        0        0     1250 2020-02-02 00:00:00.000000 pypws-2.5.6.0/.gitignore
--rw-r--r--   0        0        0    17543 2020-02-02 00:00:00.000000 pypws-2.5.6.0/LICENSE
--rw-r--r--   0        0        0      859 2020-02-02 00:00:00.000000 pypws-2.5.6.0/README.md
--rw-r--r--   0        0        0     1079 2020-02-02 00:00:00.000000 pypws-2.5.6.0/pyproject.toml
--rw-r--r--   0        0        0     1653 2020-02-02 00:00:00.000000 pypws-2.5.6.0/PKG-INFO
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pypws-2.5.9.0/__init__.py
+-rw-r--r--   0        0        0       90 2020-02-02 00:00:00.000000 pypws-2.5.9.0/requirements.txt
+-rw-r--r--   0        0        0       23 2020-02-02 00:00:00.000000 pypws-2.5.9.0/version.py
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pypws-2.5.9.0/src/pypws/__init__.py
+-rw-r--r--   0        0        0   387307 2020-02-02 00:00:00.000000 pypws-2.5.9.0/src/pypws/calculations.py
+-rw-r--r--   0        0        0     7768 2020-02-02 00:00:00.000000 pypws-2.5.9.0/src/pypws/constants.py
+-rw-r--r--   0        0        0   155869 2020-02-02 00:00:00.000000 pypws-2.5.9.0/src/pypws/entities.py
+-rw-r--r--   0        0        0    11490 2020-02-02 00:00:00.000000 pypws-2.5.9.0/src/pypws/enums.py
+-rw-r--r--   0        0        0    14428 2020-02-02 00:00:00.000000 pypws-2.5.9.0/src/pypws/materials.py
+-rw-r--r--   0        0        0     6079 2020-02-02 00:00:00.000000 pypws-2.5.9.0/src/pypws/utilities.py
+-rw-r--r--   0        0        0    27684 2020-02-02 00:00:00.000000 pypws-2.5.9.0/tests/Bund_avg_time.py
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pypws-2.5.9.0/tests/__init__.py
+-rw-r--r--   0        0        0     5536 2020-02-02 00:00:00.000000 pypws-2.5.9.0/tests/flash_ammonia.py
+-rw-r--r--   0        0        0      989 2020-02-02 00:00:00.000000 pypws-2.5.9.0/tests/flash_ammonia.zip
+-rw-r--r--   0        0        0      228 2020-02-02 00:00:00.000000 pypws-2.5.9.0/tests/test_constants.py
+-rw-r--r--   0        0        0    13269 2020-02-02 00:00:00.000000 pypws-2.5.9.0/tests/test_peteABS_mod.py
+-rw-r--r--   0        0        0     6263 2020-02-02 00:00:00.000000 pypws-2.5.9.0/tests/test_workflow1.py
+-rw-r--r--   0        0        0     1250 2020-02-02 00:00:00.000000 pypws-2.5.9.0/.gitignore
+-rw-r--r--   0        0        0    17543 2020-02-02 00:00:00.000000 pypws-2.5.9.0/LICENSE
+-rw-r--r--   0        0        0      859 2020-02-02 00:00:00.000000 pypws-2.5.9.0/README.md
+-rw-r--r--   0        0        0     1079 2020-02-02 00:00:00.000000 pypws-2.5.9.0/pyproject.toml
+-rw-r--r--   0        0        0     1653 2020-02-02 00:00:00.000000 pypws-2.5.9.0/PKG-INFO
```

### Comparing `pypws-2.5.6.0/src/pypws/calculations.py` & `pypws-2.5.9.0/src/pypws/calculations.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 #
 # This code has been auto-generated by the MDE Workbench
-# Version: 3.1.24.
+# Version: 3.1.28.
 #
 # File: calculations.py
-# Date: 2023-03-16 16:04
-# Time: 16:04
+# Date: 2023-04-04 12:37
+# Time: 12:37
 #
 
 
 import requests
 import jsons
 from requests import Response
 
@@ -29,22 +29,22 @@
         # Messages generated by the calculation.
         self.messages = []
 
         # Time taken to run the calculation.
         self.elapsedTime = 0.0
 
     # Post json to url and time the call
-    def post_request(self, url, json, accessToken) -> Response:
+    def post_request(self, url: str, data: str, accessToken: str) -> Response:
 
         headers = {
             'Content-Type': 'application/json',
             'Authorization': 'Bearer {}'.format(accessToken)
         }
 
-        response = requests.post(url, json=json, headers=headers, verify=True)
+        response = requests.post(url, data=data, headers=headers, verify = 'localhost' not in url)
 
         return response
 
     # Print out the messages
     def print_messages(self):
 
         for message in self.messages:
@@ -92,15 +92,15 @@
         # Dispersion parameters
         self.dispersionParameters = DispersionParameters()
 
 
 # Late explosion calculation class.
 class LateExplosionCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material with post-discharge composition
@@ -178,48 +178,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             lateExplosionCalculationResponse = LateExplosionCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                lateExplosionCalculationResponse.initialiseFromDictionary(jsonDoc)
+                lateExplosionCalculationResponse.initialiseFromDictionary(json)
 
                 self.explosionUnifConfOverpressureResult = lateExplosionCalculationResponse.explosionUnifConfOverpressureResult
                 self.explosionUnconfOverpressureResult = lateExplosionCalculationResponse.explosionUnconfOverpressureResult
                 self.resultCode = lateExplosionCalculationResponse.resultCode
                 self.messages = lateExplosionCalculationResponse.messages
                 self.calculationElapsedTime = lateExplosionCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the LateExplosion calculation object to print itself.
     def print(self):
 
@@ -305,16 +305,17 @@
         # Unconfined explosion overpressure result
         self.explosionUnconfOverpressureResult.initialiseFromDictionary(data['explosionUnconfOverpressureResult'])
 
         # Eror code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel leak flammable linked run calculation.
 class VesselLeakFlammableLinkedRunCalculationRequest(object):
@@ -373,15 +374,15 @@
         # Number of confined explosion sources
         self.explosionConfinedVolumeCount = 0
 
 
 # Vessel leak flammable linked run calculation class.
 class VesselLeakFlammableLinkedRunCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel definition
@@ -526,22 +527,22 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselLeakFlammableLinkedRunCalculationResponse = VesselLeakFlammableLinkedRunCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselLeakFlammableLinkedRunCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselLeakFlammableLinkedRunCalculationResponse.initialiseFromDictionary(json)
 
                 self.dischargeRecord = vesselLeakFlammableLinkedRunCalculationResponse.dischargeRecord
                 self.exitMaterial = vesselLeakFlammableLinkedRunCalculationResponse.exitMaterial
                 self.dischargeResult = vesselLeakFlammableLinkedRunCalculationResponse.dischargeResult
                 self.distancesToJetFireRadiation = vesselLeakFlammableLinkedRunCalculationResponse.distancesToJetFireRadiation
                 self.jetContourPoints = vesselLeakFlammableLinkedRunCalculationResponse.jetContourPoints
                 self.nJetCountourPoints = vesselLeakFlammableLinkedRunCalculationResponse.nJetCountourPoints
@@ -560,31 +561,31 @@
                 self.poolFireFlameResult = vesselLeakFlammableLinkedRunCalculationResponse.poolFireFlameResult
                 self.resultCode = vesselLeakFlammableLinkedRunCalculationResponse.resultCode
                 self.messages = vesselLeakFlammableLinkedRunCalculationResponse.messages
                 self.calculationElapsedTime = vesselLeakFlammableLinkedRunCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselLeakFlammableLinkedRun calculation object to print itself.
     def print(self):
 
@@ -794,89 +795,104 @@
         # Description for entry point parameter exitMaterial not found.
         self.exitMaterial.initialiseFromDictionary(data['exitMaterial'])
 
         # Description for entry point parameter dischargeResult not found.
         self.dischargeResult.initialiseFromDictionary(data['dischargeResult'])
 
         # Distances to jet fire radiation levels
-        for dataItem in data['distancesToJetFireRadiation']:
-            self.distancesToJetFireRadiation.append(float(dataItem))
+        if data['distancesToJetFireRadiation'] != None:
+            for dataItem in data['distancesToJetFireRadiation']:
+                self.distancesToJetFireRadiation.append(float(dataItem))
 
         # Ellipses to jet fire radiation levels
-        for dataItem in data['jetContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.jetContourPoints.append(localPosition)
+        if data['jetContourPoints'] != None:
+            for dataItem in data['jetContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.jetContourPoints.append(localPosition)
 
         # Number of contour points for jet fire ellipses per radiation level
-        for dataItem in data['nJetCountourPoints']:
+        if data['nJetCountourPoints'] != None:
+            for dataItem in data['nJetCountourPoints']:
                 self.nJetCountourPoints.append(int(dataItem))
 
         # Areas of jet fire ellipses
-        for dataItem in data['areaEllipseJet']:
-            self.areaEllipseJet.append(float(dataItem))
+        if data['areaEllipseJet'] != None:
+            for dataItem in data['areaEllipseJet']:
+                self.areaEllipseJet.append(float(dataItem))
 
         # Distances to concentration levels
-        for dataItem in data['distancesToConcentration']:
-            self.distancesToConcentration.append(float(dataItem))
+        if data['distancesToConcentration'] != None:
+            for dataItem in data['distancesToConcentration']:
+                self.distancesToConcentration.append(float(dataItem))
 
         # Concentration levels
-        for dataItem in data['concentrationsUsed']:
-            self.concentrationsUsed.append(float(dataItem))
+        if data['concentrationsUsed'] != None:
+            for dataItem in data['concentrationsUsed']:
+                self.concentrationsUsed.append(float(dataItem))
 
         # Maximum concentration footprints at given concentration levels
-        for dataItem in data['concContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.concContourPoints.append(localPosition)
+        if data['concContourPoints'] != None:
+            for dataItem in data['concContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.concContourPoints.append(localPosition)
 
         # Number of contour points per concentration level
-        for dataItem in data['nConcCountourPoints']:
+        if data['nConcCountourPoints'] != None:
+            for dataItem in data['nConcCountourPoints']:
                 self.nConcCountourPoints.append(int(dataItem))
 
         # Areas of maximum concentration footprints
-        for dataItem in data['areaFootprintConc']:
-            self.areaFootprintConc.append(float(dataItem))
+        if data['areaFootprintConc'] != None:
+            for dataItem in data['areaFootprintConc']:
+                self.areaFootprintConc.append(float(dataItem))
 
         # Distances to pool fire radiation levels
-        for dataItem in data['distancesToPoolFireRadiation']:
-            self.distancesToPoolFireRadiation.append(float(dataItem))
+        if data['distancesToPoolFireRadiation'] != None:
+            for dataItem in data['distancesToPoolFireRadiation']:
+                self.distancesToPoolFireRadiation.append(float(dataItem))
 
         # Ellipses to pool fire radiation levels
-        for dataItem in data['poolContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.poolContourPoints.append(localPosition)
+        if data['poolContourPoints'] != None:
+            for dataItem in data['poolContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.poolContourPoints.append(localPosition)
 
         # Number of contour points for pool fire ellipses per radiation level
-        for dataItem in data['nPoolCountourPoints']:
+        if data['nPoolCountourPoints'] != None:
+            for dataItem in data['nPoolCountourPoints']:
                 self.nPoolCountourPoints.append(int(dataItem))
 
         # Areas of pool fire ellipses
-        for dataItem in data['areaEllipsePool']:
-            self.areaEllipsePool.append(float(dataItem))
+        if data['areaEllipsePool'] != None:
+            for dataItem in data['areaEllipsePool']:
+                self.areaEllipsePool.append(float(dataItem))
 
         # Explosion overpressure results
-        for dataItem in data['explosionOverpressureResults']:
-            explosionOverpressureResult = ExplosionOverpressureResult()
-            explosionOverpressureResult.initialiseFromDictionary(dataItem)
-            self.explosionOverpressureResults.append(explosionOverpressureResult)
+        if data['explosionOverpressureResults'] != None:
+            for dataItem in data['explosionOverpressureResults']:
+                explosionOverpressureResult = ExplosionOverpressureResult()
+                explosionOverpressureResult.initialiseFromDictionary(dataItem)
+                self.explosionOverpressureResults.append(explosionOverpressureResult)
 
         # Flame results for jet fire
         self.jetFireFlameResult.initialiseFromDictionary(data['jetFireFlameResult'])
 
         # Flame results for pool fire
         self.poolFireFlameResult.initialiseFromDictionary(data['poolFireFlameResult'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a sideview at time calculation.
 class SideviewAtTimeCalculationRequest(object):
@@ -908,15 +924,15 @@
         # Dispersion parameters
         self.dispersionParameters = DispersionParameters()
 
 
 # Sideview at time calculation class.
 class SideviewAtTimeCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # UDM scalar outputs
@@ -980,48 +996,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             sideviewAtTimeCalculationResponse = SideviewAtTimeCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                sideviewAtTimeCalculationResponse.initialiseFromDictionary(jsonDoc)
+                sideviewAtTimeCalculationResponse.initialiseFromDictionary(json)
 
                 self.concUsed = sideviewAtTimeCalculationResponse.concUsed
                 self.contourPoints = sideviewAtTimeCalculationResponse.contourPoints
                 self.resultCode = sideviewAtTimeCalculationResponse.resultCode
                 self.messages = sideviewAtTimeCalculationResponse.messages
                 self.calculationElapsedTime = sideviewAtTimeCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the SideviewAtTime calculation object to print itself.
     def print(self):
 
@@ -1091,25 +1107,27 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Concentration of interest
         self.concUsed = float(data['concUsed'])
 
         # Array of sideview results
-        for dataItem in data['contourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.contourPoints.append(localPosition)
+        if data['contourPoints'] != None:
+            for dataItem in data['contourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.contourPoints.append(localPosition)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel leak max flammable cloud calculation.
 class VesselLeakMaxFlammableCloudCalculationRequest(object):
@@ -1138,15 +1156,15 @@
         # Options for controlling dispersion results (here used to set height of interest only)
         self.dispersionOutputConfig = DispersionOutputConfig()
 
 
 # Vessel leak max flammable cloud calculation class.
 class VesselLeakMaxFlammableCloudCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel (pressurised or atmospheric)
@@ -1205,47 +1223,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselLeakMaxFlammableCloudCalculationResponse = VesselLeakMaxFlammableCloudCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselLeakMaxFlammableCloudCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselLeakMaxFlammableCloudCalculationResponse.initialiseFromDictionary(json)
 
                 self.vesselLeakMaxFlammableCloudResults = vesselLeakMaxFlammableCloudCalculationResponse.vesselLeakMaxFlammableCloudResults
                 self.resultCode = vesselLeakMaxFlammableCloudCalculationResponse.resultCode
                 self.messages = vesselLeakMaxFlammableCloudCalculationResponse.messages
                 self.calculationElapsedTime = vesselLeakMaxFlammableCloudCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselLeakMaxFlammableCloud calculation object to print itself.
     def print(self):
 
@@ -1311,16 +1329,17 @@
         # Collated discharge and flammable cloud characterisation results
         self.vesselLeakMaxFlammableCloudResults.initialiseFromDictionary(data['vesselLeakMaxFlammableCloudResults'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a pool fire calculation.
 class PoolFireCalculationRequest(object):
@@ -1346,15 +1365,15 @@
         # Flammable parameters
         self.flammableParameters = FlammableParameters()
 
 
 # Pool fire calculation class.
 class PoolFireCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material with post-discharge composition
@@ -1410,48 +1429,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             poolFireCalculationResponse = PoolFireCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                poolFireCalculationResponse.initialiseFromDictionary(jsonDoc)
+                poolFireCalculationResponse.initialiseFromDictionary(json)
 
                 self.poolFireFlameResult = poolFireCalculationResponse.poolFireFlameResult
                 self.flameRecords = poolFireCalculationResponse.flameRecords
                 self.resultCode = poolFireCalculationResponse.resultCode
                 self.messages = poolFireCalculationResponse.messages
                 self.calculationElapsedTime = poolFireCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the PoolFire calculation object to print itself.
     def print(self):
 
@@ -1515,25 +1534,27 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Flame scalar result
         self.poolFireFlameResult.initialiseFromDictionary(data['poolFireFlameResult'])
 
         # Array of pool fire flame records
-        for dataItem in data['flameRecords']:
-            flameRecord = FlameRecord()
-            flameRecord.initialiseFromDictionary(dataItem)
-            self.flameRecords.append(flameRecord)
+        if data['flameRecords'] != None:
+            for dataItem in data['flameRecords']:
+                flameRecord = FlameRecord()
+                flameRecord.initialiseFromDictionary(dataItem)
+                self.flameRecords.append(flameRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a corqa flash calculation.
 class CorqaFlashCalculationRequest(object):
@@ -1547,15 +1568,15 @@
         # Describes the fluid pressure, temperature, liquid fraction
         self.materialState = State()
 
 
 # Corqa flash calculation class.
 class CorqaFlashCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # User-defined input material, pure component or mixture (max 20 components)
@@ -1597,48 +1618,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             corqaFlashCalculationResponse = CorqaFlashCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                corqaFlashCalculationResponse.initialiseFromDictionary(jsonDoc)
+                corqaFlashCalculationResponse.initialiseFromDictionary(json)
 
                 self.constMatResult = corqaFlashCalculationResponse.constMatResult
                 self.flashResult = corqaFlashCalculationResponse.flashResult
                 self.resultCode = corqaFlashCalculationResponse.resultCode
                 self.messages = corqaFlashCalculationResponse.messages
                 self.calculationElapsedTime = corqaFlashCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the CorqaFlash calculation object to print itself.
     def print(self):
 
@@ -1698,16 +1719,17 @@
         # Fluid properties at given conditions
         self.flashResult.initialiseFromDictionary(data['flashResult'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a distances and ellipses to radiation levels calculation.
 class DistancesAndEllipsesToRadiationLevelsCalculationRequest(object):
@@ -1736,15 +1758,15 @@
         # Number of radiation levels
         self.flammableOutputConfigCount = 0
 
 
 # Distances and ellipses to radiation levels calculation class.
 class DistancesAndEllipsesToRadiationLevelsCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Scalar flame results
@@ -1805,49 +1827,49 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             distancesAndEllipsesToRadiationLevelsCalculationResponse = DistancesAndEllipsesToRadiationLevelsCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                distancesAndEllipsesToRadiationLevelsCalculationResponse.initialiseFromDictionary(jsonDoc)
+                distancesAndEllipsesToRadiationLevelsCalculationResponse.initialiseFromDictionary(json)
 
                 self.distances = distancesAndEllipsesToRadiationLevelsCalculationResponse.distances
                 self.contourPoints = distancesAndEllipsesToRadiationLevelsCalculationResponse.contourPoints
                 self.nCountourPoints = distancesAndEllipsesToRadiationLevelsCalculationResponse.nCountourPoints
                 self.resultCode = distancesAndEllipsesToRadiationLevelsCalculationResponse.resultCode
                 self.messages = distancesAndEllipsesToRadiationLevelsCalculationResponse.messages
                 self.calculationElapsedTime = distancesAndEllipsesToRadiationLevelsCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the DistancesAndEllipsesToRadiationLevels calculation object to print itself.
     def print(self):
 
@@ -1917,33 +1939,37 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Distances to radiation levels
-        for dataItem in data['distances']:
-            self.distances.append(float(dataItem))
+        if data['distances'] != None:
+            for dataItem in data['distances']:
+                self.distances.append(float(dataItem))
 
         # Contour points of radiation ellipses to radiation levels
-        for dataItem in data['contourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.contourPoints.append(localPosition)
+        if data['contourPoints'] != None:
+            for dataItem in data['contourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.contourPoints.append(localPosition)
 
         # Number of contour points per radiation level
-        for dataItem in data['nCountourPoints']:
+        if data['nCountourPoints'] != None:
+            for dataItem in data['nCountourPoints']:
                 self.nCountourPoints.append(int(dataItem))
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel leak tox simple linked run calculation.
 class VesselLeakToxSimpleLinkedRunCalculationRequest(object):
@@ -1981,15 +2007,15 @@
         # Number of concentration levels
         self.dispersionOutputConfigCount = 0
 
 
 # Vessel leak tox simple linked run calculation class.
 class VesselLeakToxSimpleLinkedRunCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel definition
@@ -2079,22 +2105,22 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselLeakToxSimpleLinkedRunCalculationResponse = VesselLeakToxSimpleLinkedRunCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselLeakToxSimpleLinkedRunCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselLeakToxSimpleLinkedRunCalculationResponse.initialiseFromDictionary(json)
 
                 self.dischargeRecord = vesselLeakToxSimpleLinkedRunCalculationResponse.dischargeRecord
                 self.exitMaterial = vesselLeakToxSimpleLinkedRunCalculationResponse.exitMaterial
                 self.dischargeResult = vesselLeakToxSimpleLinkedRunCalculationResponse.dischargeResult
                 self.distancesToConcentration = vesselLeakToxSimpleLinkedRunCalculationResponse.distancesToConcentration
                 self.concentrationsUsed = vesselLeakToxSimpleLinkedRunCalculationResponse.concentrationsUsed
                 self.concContourPoints = vesselLeakToxSimpleLinkedRunCalculationResponse.concContourPoints
@@ -2102,31 +2128,31 @@
                 self.areaFootprintConc = vesselLeakToxSimpleLinkedRunCalculationResponse.areaFootprintConc
                 self.resultCode = vesselLeakToxSimpleLinkedRunCalculationResponse.resultCode
                 self.messages = vesselLeakToxSimpleLinkedRunCalculationResponse.messages
                 self.calculationElapsedTime = vesselLeakToxSimpleLinkedRunCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselLeakToxSimpleLinkedRun calculation object to print itself.
     def print(self):
 
@@ -2248,41 +2274,47 @@
         # Description for entry point parameter exitMaterial not found.
         self.exitMaterial.initialiseFromDictionary(data['exitMaterial'])
 
         # Description for entry point parameter dischargeResult not found.
         self.dischargeResult.initialiseFromDictionary(data['dischargeResult'])
 
         # Distances to concentration levels
-        for dataItem in data['distancesToConcentration']:
-            self.distancesToConcentration.append(float(dataItem))
+        if data['distancesToConcentration'] != None:
+            for dataItem in data['distancesToConcentration']:
+                self.distancesToConcentration.append(float(dataItem))
 
         # Concentration levels
-        for dataItem in data['concentrationsUsed']:
-            self.concentrationsUsed.append(float(dataItem))
+        if data['concentrationsUsed'] != None:
+            for dataItem in data['concentrationsUsed']:
+                self.concentrationsUsed.append(float(dataItem))
 
         # Maximum concentration footprints at given concentration levels
-        for dataItem in data['concContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.concContourPoints.append(localPosition)
+        if data['concContourPoints'] != None:
+            for dataItem in data['concContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.concContourPoints.append(localPosition)
 
         # Number of contour points per concentration level
-        for dataItem in data['nConcCountourPoints']:
+        if data['nConcCountourPoints'] != None:
+            for dataItem in data['nConcCountourPoints']:
                 self.nConcCountourPoints.append(int(dataItem))
 
         # Areas of maximum concentration footprints
-        for dataItem in data['areaFootprintConc']:
-            self.areaFootprintConc.append(float(dataItem))
+        if data['areaFootprintConc'] != None:
+            for dataItem in data['areaFootprintConc']:
+                self.areaFootprintConc.append(float(dataItem))
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a distances to radiation levels calculation.
 class DistancesToRadiationLevelsCalculationRequest(object):
@@ -2311,15 +2343,15 @@
         # Number of flammable output configurations
         self.flammableOutputConfigCount = 0
 
 
 # Distances to radiation levels calculation class.
 class DistancesToRadiationLevelsCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Scalar flame results
@@ -2374,47 +2406,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             distancesToRadiationLevelsCalculationResponse = DistancesToRadiationLevelsCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                distancesToRadiationLevelsCalculationResponse.initialiseFromDictionary(jsonDoc)
+                distancesToRadiationLevelsCalculationResponse.initialiseFromDictionary(json)
 
                 self.distances = distancesToRadiationLevelsCalculationResponse.distances
                 self.resultCode = distancesToRadiationLevelsCalculationResponse.resultCode
                 self.messages = distancesToRadiationLevelsCalculationResponse.messages
                 self.calculationElapsedTime = distancesToRadiationLevelsCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the DistancesToRadiationLevels calculation object to print itself.
     def print(self):
 
@@ -2471,23 +2503,25 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Distances to radiation level
-        for dataItem in data['distances']:
-            self.distances.append(float(dataItem))
+        if data['distances'] != None:
+            for dataItem in data['distances']:
+                self.distances.append(float(dataItem))
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a flash calculation.
 class FlashCalculationRequest(object):
@@ -2501,15 +2535,15 @@
         # Describes the fluid pressure, temperature, liquid fraction
         self.materialState = State()
 
 
 # Flash calculation class.
 class FlashCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # User-defined input material, pure component or mixture (max 20 components)
@@ -2548,47 +2582,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             flashCalculationResponse = FlashCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                flashCalculationResponse.initialiseFromDictionary(jsonDoc)
+                flashCalculationResponse.initialiseFromDictionary(json)
 
                 self.flashResult = flashCalculationResponse.flashResult
                 self.resultCode = flashCalculationResponse.resultCode
                 self.messages = flashCalculationResponse.messages
                 self.calculationElapsedTime = flashCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the Flash calculation object to print itself.
     def print(self):
 
@@ -2639,16 +2673,17 @@
         # Fluid properties at given conditions
         self.flashResult.initialiseFromDictionary(data['flashResult'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel leak flam tox simple linked run calculation.
 class VesselLeakFlamToxSimpleLinkedRunCalculationRequest(object):
@@ -2716,15 +2751,15 @@
         # Number of confined explosion sources
         self.explosionConfinedVolumeCount = 0
 
 
 # Vessel leak flam tox simple linked run calculation class.
 class VesselLeakFlamToxSimpleLinkedRunCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel definition
@@ -2888,22 +2923,22 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselLeakFlamToxSimpleLinkedRunCalculationResponse = VesselLeakFlamToxSimpleLinkedRunCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselLeakFlamToxSimpleLinkedRunCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselLeakFlamToxSimpleLinkedRunCalculationResponse.initialiseFromDictionary(json)
 
                 self.dischargeRecord = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.dischargeRecord
                 self.distancesToJetFireRadiation = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.distancesToJetFireRadiation
                 self.jetContourPoints = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.jetContourPoints
                 self.nJetCountourPoints = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.nJetCountourPoints
                 self.areaEllipseJet = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.areaEllipseJet
                 self.distancesToFlamConcentration = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.distancesToFlamConcentration
@@ -2925,31 +2960,31 @@
                 self.poolFireFlameResult = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.poolFireFlameResult
                 self.resultCode = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.resultCode
                 self.messages = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.messages
                 self.calculationElapsedTime = vesselLeakFlamToxSimpleLinkedRunCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselLeakFlamToxSimpleLinkedRun calculation object to print itself.
     def print(self):
 
@@ -3182,111 +3217,131 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Discharge data for table
         self.dischargeRecord.initialiseFromDictionary(data['dischargeRecord'])
 
         # Distances to jet fire radiation levels
-        for dataItem in data['distancesToJetFireRadiation']:
-            self.distancesToJetFireRadiation.append(float(dataItem))
+        if data['distancesToJetFireRadiation'] != None:
+            for dataItem in data['distancesToJetFireRadiation']:
+                self.distancesToJetFireRadiation.append(float(dataItem))
 
         # Ellipses to jet fire radiation levels
-        for dataItem in data['jetContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.jetContourPoints.append(localPosition)
+        if data['jetContourPoints'] != None:
+            for dataItem in data['jetContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.jetContourPoints.append(localPosition)
 
         # Number of contour points for jet fire ellipses per radiation level
-        for dataItem in data['nJetCountourPoints']:
+        if data['nJetCountourPoints'] != None:
+            for dataItem in data['nJetCountourPoints']:
                 self.nJetCountourPoints.append(int(dataItem))
 
         # Areas of jet fire ellipses
-        for dataItem in data['areaEllipseJet']:
-            self.areaEllipseJet.append(float(dataItem))
+        if data['areaEllipseJet'] != None:
+            for dataItem in data['areaEllipseJet']:
+                self.areaEllipseJet.append(float(dataItem))
 
         # Distances to concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['distancesToFlamConcentration']:
-            self.distancesToFlamConcentration.append(float(dataItem))
+        if data['distancesToFlamConcentration'] != None:
+            for dataItem in data['distancesToFlamConcentration']:
+                self.distancesToFlamConcentration.append(float(dataItem))
 
         # Concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['flamConcentrationsUsed']:
-            self.flamConcentrationsUsed.append(float(dataItem))
+        if data['flamConcentrationsUsed'] != None:
+            for dataItem in data['flamConcentrationsUsed']:
+                self.flamConcentrationsUsed.append(float(dataItem))
 
         # Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['flamConcContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.flamConcContourPoints.append(localPosition)
+        if data['flamConcContourPoints'] != None:
+            for dataItem in data['flamConcContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.flamConcContourPoints.append(localPosition)
 
         # Number of contour points per concentration level (LFL fraction, LFL and UFL)
-        for dataItem in data['nFlamConcCountourPoints']:
+        if data['nFlamConcCountourPoints'] != None:
+            for dataItem in data['nFlamConcCountourPoints']:
                 self.nFlamConcCountourPoints.append(int(dataItem))
 
         # Areas of maximum concentration footprints (LFL fraction, LFL and UFL)
-        for dataItem in data['areaFootprintFlamConc']:
-            self.areaFootprintFlamConc.append(float(dataItem))
+        if data['areaFootprintFlamConc'] != None:
+            for dataItem in data['areaFootprintFlamConc']:
+                self.areaFootprintFlamConc.append(float(dataItem))
 
         # Distances to pool fire radiation levels
-        for dataItem in data['distancesToPoolFireRadiation']:
-            self.distancesToPoolFireRadiation.append(float(dataItem))
+        if data['distancesToPoolFireRadiation'] != None:
+            for dataItem in data['distancesToPoolFireRadiation']:
+                self.distancesToPoolFireRadiation.append(float(dataItem))
 
         # Ellipses to pool fire radiation levels
-        for dataItem in data['poolContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.poolContourPoints.append(localPosition)
+        if data['poolContourPoints'] != None:
+            for dataItem in data['poolContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.poolContourPoints.append(localPosition)
 
         # Number of contour points for pool fire ellipses per radiation level
-        for dataItem in data['nPoolCountourPoints']:
+        if data['nPoolCountourPoints'] != None:
+            for dataItem in data['nPoolCountourPoints']:
                 self.nPoolCountourPoints.append(int(dataItem))
 
         # Areas of pool fire ellipses
-        for dataItem in data['areaEllipsePool']:
-            self.areaEllipsePool.append(float(dataItem))
+        if data['areaEllipsePool'] != None:
+            for dataItem in data['areaEllipsePool']:
+                self.areaEllipsePool.append(float(dataItem))
 
         # Explosion overpressure results
-        for dataItem in data['explosionOverpressureResults']:
-            explosionOverpressureResult = ExplosionOverpressureResult()
-            explosionOverpressureResult.initialiseFromDictionary(dataItem)
-            self.explosionOverpressureResults.append(explosionOverpressureResult)
+        if data['explosionOverpressureResults'] != None:
+            for dataItem in data['explosionOverpressureResults']:
+                explosionOverpressureResult = ExplosionOverpressureResult()
+                explosionOverpressureResult.initialiseFromDictionary(dataItem)
+                self.explosionOverpressureResults.append(explosionOverpressureResult)
 
         # Distance to concentration of interest (using toxic averaging time)
-        for dataItem in data['distancesToToxicConcentration']:
-            self.distancesToToxicConcentration.append(float(dataItem))
+        if data['distancesToToxicConcentration'] != None:
+            for dataItem in data['distancesToToxicConcentration']:
+                self.distancesToToxicConcentration.append(float(dataItem))
 
         # Concentration of interest
-        for dataItem in data['toxicConcentrationUsed']:
-            self.toxicConcentrationUsed.append(float(dataItem))
+        if data['toxicConcentrationUsed'] != None:
+            for dataItem in data['toxicConcentrationUsed']:
+                self.toxicConcentrationUsed.append(float(dataItem))
 
         # Maximum concentration footprint to concentration of interest (using toxic averaging time)
-        for dataItem in data['toxicConcContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.toxicConcContourPoints.append(localPosition)
+        if data['toxicConcContourPoints'] != None:
+            for dataItem in data['toxicConcContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.toxicConcContourPoints.append(localPosition)
 
         # Number of contour points for maximum concentration footprint to concentration of interest
-        for dataItem in data['nToxicConcCountourPoints']:
+        if data['nToxicConcCountourPoints'] != None:
+            for dataItem in data['nToxicConcCountourPoints']:
                 self.nToxicConcCountourPoints.append(int(dataItem))
 
         # Area of maximum concentration footprints to concentration of interest (using toxic averaging time)
-        for dataItem in data['areaFootprintToxicConc']:
-            self.areaFootprintToxicConc.append(float(dataItem))
+        if data['areaFootprintToxicConc'] != None:
+            for dataItem in data['areaFootprintToxicConc']:
+                self.areaFootprintToxicConc.append(float(dataItem))
 
         # Flame results for jet fire
         self.jetFireFlameResult.initialiseFromDictionary(data['jetFireFlameResult'])
 
         # Flame results for pool fire
         self.poolFireFlameResult.initialiseFromDictionary(data['poolFireFlameResult'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a max conc distance calculation.
 class MaxConcDistanceCalculationRequest(object):
@@ -3318,15 +3373,15 @@
         # Dispersion parameters
         self.dispersionParameters = DispersionParameters()
 
 
 # Max conc distance calculation class.
 class MaxConcDistanceCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # UDM scalar outputs
@@ -3390,48 +3445,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             maxConcDistanceCalculationResponse = MaxConcDistanceCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                maxConcDistanceCalculationResponse.initialiseFromDictionary(jsonDoc)
+                maxConcDistanceCalculationResponse.initialiseFromDictionary(json)
 
                 self.concUsed = maxConcDistanceCalculationResponse.concUsed
                 self.concentrationRecords = maxConcDistanceCalculationResponse.concentrationRecords
                 self.resultCode = maxConcDistanceCalculationResponse.resultCode
                 self.messages = maxConcDistanceCalculationResponse.messages
                 self.calculationElapsedTime = maxConcDistanceCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the MaxConcDistance calculation object to print itself.
     def print(self):
 
@@ -3501,25 +3556,27 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Concentration of interest
         self.concUsed = float(data['concUsed'])
 
         # Array of maximum concentration at x, y, z coordinates
-        for dataItem in data['concentrationRecords']:
-            concentrationRecord = ConcentrationRecord()
-            concentrationRecord.initialiseFromDictionary(dataItem)
-            self.concentrationRecords.append(concentrationRecord)
+        if data['concentrationRecords'] != None:
+            for dataItem in data['concentrationRecords']:
+                concentrationRecord = ConcentrationRecord()
+                concentrationRecord.initialiseFromDictionary(dataItem)
+                self.concentrationRecords.append(concentrationRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a mixture constant properties calculation.
 class MixtureConstantPropertiesCalculationRequest(object):
@@ -3530,15 +3587,15 @@
         # User-defined input material (max 20 components)
         self.material = Material()
 
 
 # Mixture constant properties calculation class.
 class MixtureConstantPropertiesCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # User-defined input material (max 20 components)
@@ -3573,47 +3630,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             mixtureConstantPropertiesCalculationResponse = MixtureConstantPropertiesCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                mixtureConstantPropertiesCalculationResponse.initialiseFromDictionary(jsonDoc)
+                mixtureConstantPropertiesCalculationResponse.initialiseFromDictionary(json)
 
                 self.mixConstantPropResult = mixtureConstantPropertiesCalculationResponse.mixConstantPropResult
                 self.resultCode = mixtureConstantPropertiesCalculationResponse.resultCode
                 self.messages = mixtureConstantPropertiesCalculationResponse.messages
                 self.calculationElapsedTime = mixtureConstantPropertiesCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the MixtureConstantProperties calculation object to print itself.
     def print(self):
 
@@ -3661,16 +3718,17 @@
         # Constant properties of the mixture
         self.mixConstantPropResult.initialiseFromDictionary(data['mixConstantPropResult'])
 
         # Response code
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a user defined source linked run calculation.
 class UserDefinedSourceLinkedRunCalculationRequest(object):
@@ -3744,15 +3802,15 @@
         # Number of confined explosion sources
         self.explosionConfinedVolumeCount = 0
 
 
 # User defined source linked run calculation class.
 class UserDefinedSourceLinkedRunCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material
@@ -3919,22 +3977,22 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             userDefinedSourceLinkedRunCalculationResponse = UserDefinedSourceLinkedRunCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                userDefinedSourceLinkedRunCalculationResponse.initialiseFromDictionary(jsonDoc)
+                userDefinedSourceLinkedRunCalculationResponse.initialiseFromDictionary(json)
 
                 self.distancesToJetFireRadiation = userDefinedSourceLinkedRunCalculationResponse.distancesToJetFireRadiation
                 self.jetContourPoints = userDefinedSourceLinkedRunCalculationResponse.jetContourPoints
                 self.nJetContourPoints = userDefinedSourceLinkedRunCalculationResponse.nJetContourPoints
                 self.areaContourJet = userDefinedSourceLinkedRunCalculationResponse.areaContourJet
                 self.distancesToFlamConcentration = userDefinedSourceLinkedRunCalculationResponse.distancesToFlamConcentration
                 self.flamConcentrationsUsed = userDefinedSourceLinkedRunCalculationResponse.flamConcentrationsUsed
@@ -3955,31 +4013,31 @@
                 self.poolFireFlameResult = userDefinedSourceLinkedRunCalculationResponse.poolFireFlameResult
                 self.resultCode = userDefinedSourceLinkedRunCalculationResponse.resultCode
                 self.messages = userDefinedSourceLinkedRunCalculationResponse.messages
                 self.calculationElapsedTime = userDefinedSourceLinkedRunCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the UserDefinedSourceLinkedRun calculation object to print itself.
     def print(self):
 
@@ -4207,111 +4265,131 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Distances to jet fire radiation levels
-        for dataItem in data['distancesToJetFireRadiation']:
-            self.distancesToJetFireRadiation.append(float(dataItem))
+        if data['distancesToJetFireRadiation'] != None:
+            for dataItem in data['distancesToJetFireRadiation']:
+                self.distancesToJetFireRadiation.append(float(dataItem))
 
         # Callback function for jet fire radiation contour points
-        for dataItem in data['jetContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.jetContourPoints.append(localPosition)
+        if data['jetContourPoints'] != None:
+            for dataItem in data['jetContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.jetContourPoints.append(localPosition)
 
         # Number of points for jet fire contours per radiation level
-        for dataItem in data['nJetContourPoints']:
+        if data['nJetContourPoints'] != None:
+            for dataItem in data['nJetContourPoints']:
                 self.nJetContourPoints.append(int(dataItem))
 
         # Areas of jet fire contours
-        for dataItem in data['areaContourJet']:
-            self.areaContourJet.append(float(dataItem))
+        if data['areaContourJet'] != None:
+            for dataItem in data['areaContourJet']:
+                self.areaContourJet.append(float(dataItem))
 
         # Distances to concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['distancesToFlamConcentration']:
-            self.distancesToFlamConcentration.append(float(dataItem))
+        if data['distancesToFlamConcentration'] != None:
+            for dataItem in data['distancesToFlamConcentration']:
+                self.distancesToFlamConcentration.append(float(dataItem))
 
         # Concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['flamConcentrationsUsed']:
-            self.flamConcentrationsUsed.append(float(dataItem))
+        if data['flamConcentrationsUsed'] != None:
+            for dataItem in data['flamConcentrationsUsed']:
+                self.flamConcentrationsUsed.append(float(dataItem))
 
         # Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['flamConcContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.flamConcContourPoints.append(localPosition)
+        if data['flamConcContourPoints'] != None:
+            for dataItem in data['flamConcContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.flamConcContourPoints.append(localPosition)
 
         # Number of contour points per concentration level (LFL fraction, LFL and UFL)
-        for dataItem in data['nFlamConcContourPoints']:
+        if data['nFlamConcContourPoints'] != None:
+            for dataItem in data['nFlamConcContourPoints']:
                 self.nFlamConcContourPoints.append(int(dataItem))
 
         # Areas of maximum concentration footprints (LFL fraction, LFL and UFL)
-        for dataItem in data['areaFootprintFlamConc']:
-            self.areaFootprintFlamConc.append(float(dataItem))
+        if data['areaFootprintFlamConc'] != None:
+            for dataItem in data['areaFootprintFlamConc']:
+                self.areaFootprintFlamConc.append(float(dataItem))
 
         # Distances to pool fire radiation levels
-        for dataItem in data['distancesToPoolFireRadiation']:
-            self.distancesToPoolFireRadiation.append(float(dataItem))
+        if data['distancesToPoolFireRadiation'] != None:
+            for dataItem in data['distancesToPoolFireRadiation']:
+                self.distancesToPoolFireRadiation.append(float(dataItem))
 
         # Callback function for pool fire radiation contour points
-        for dataItem in data['poolContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.poolContourPoints.append(localPosition)
+        if data['poolContourPoints'] != None:
+            for dataItem in data['poolContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.poolContourPoints.append(localPosition)
 
         # Number of points for pool fire contours per radiation level
-        for dataItem in data['nPoolContourPoints']:
+        if data['nPoolContourPoints'] != None:
+            for dataItem in data['nPoolContourPoints']:
                 self.nPoolContourPoints.append(int(dataItem))
 
         # Areas of pool fire contours
-        for dataItem in data['areaContourPool']:
-            self.areaContourPool.append(float(dataItem))
+        if data['areaContourPool'] != None:
+            for dataItem in data['areaContourPool']:
+                self.areaContourPool.append(float(dataItem))
 
         # Explosion overpressure results
-        for dataItem in data['explosionOverpressureResults']:
-            explosionOverpressureResult = ExplosionOverpressureResult()
-            explosionOverpressureResult.initialiseFromDictionary(dataItem)
-            self.explosionOverpressureResults.append(explosionOverpressureResult)
+        if data['explosionOverpressureResults'] != None:
+            for dataItem in data['explosionOverpressureResults']:
+                explosionOverpressureResult = ExplosionOverpressureResult()
+                explosionOverpressureResult.initialiseFromDictionary(dataItem)
+                self.explosionOverpressureResults.append(explosionOverpressureResult)
 
         # Distance to concentration of interest (using toxic averaging time)
-        for dataItem in data['distancesToToxicConcentration']:
-            self.distancesToToxicConcentration.append(float(dataItem))
+        if data['distancesToToxicConcentration'] != None:
+            for dataItem in data['distancesToToxicConcentration']:
+                self.distancesToToxicConcentration.append(float(dataItem))
 
         # Concentration of interest
-        for dataItem in data['toxicConcentrationUsed']:
-            self.toxicConcentrationUsed.append(float(dataItem))
+        if data['toxicConcentrationUsed'] != None:
+            for dataItem in data['toxicConcentrationUsed']:
+                self.toxicConcentrationUsed.append(float(dataItem))
 
         # Maximum concentration footprint to concentration of interest (using toxic averaging time)
-        for dataItem in data['toxicConcContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.toxicConcContourPoints.append(localPosition)
+        if data['toxicConcContourPoints'] != None:
+            for dataItem in data['toxicConcContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.toxicConcContourPoints.append(localPosition)
 
         # Number of contour points for maximum concentration footprint to concentration of interest
-        for dataItem in data['nToxicConcContourPoints']:
+        if data['nToxicConcContourPoints'] != None:
+            for dataItem in data['nToxicConcContourPoints']:
                 self.nToxicConcContourPoints.append(int(dataItem))
 
         # Area of maximum concentration footprints to concentration of interest (using toxic averaging time)
-        for dataItem in data['areaFootprintToxicConc']:
-            self.areaFootprintToxicConc.append(float(dataItem))
+        if data['areaFootprintToxicConc'] != None:
+            for dataItem in data['areaFootprintToxicConc']:
+                self.areaFootprintToxicConc.append(float(dataItem))
 
         # Flame results for jet fire
         self.jetFireFlameResult.initialiseFromDictionary(data['jetFireFlameResult'])
 
         # Flame results for pool fire
         self.poolFireFlameResult.initialiseFromDictionary(data['poolFireFlameResult'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a properties dnv p t calculation.
 class PropertiesDnvPTCalculationRequest(object):
@@ -4325,15 +4403,15 @@
         # Range of temperatures and pressures to be considered
         self.range = PTRange()
 
 
 # Properties dnv p t calculation class.
 class PropertiesDnvPTCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Composition (5 max as using spreadsheet entry point)
@@ -4378,49 +4456,49 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             propertiesDnvPTCalculationResponse = PropertiesDnvPTCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                propertiesDnvPTCalculationResponse.initialiseFromDictionary(jsonDoc)
+                propertiesDnvPTCalculationResponse.initialiseFromDictionary(json)
 
                 self.result = propertiesDnvPTCalculationResponse.result
                 self.result2 = propertiesDnvPTCalculationResponse.result2
                 self.result3 = propertiesDnvPTCalculationResponse.result3
                 self.resultCode = propertiesDnvPTCalculationResponse.resultCode
                 self.messages = propertiesDnvPTCalculationResponse.messages
                 self.calculationElapsedTime = propertiesDnvPTCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the PropertiesDnvPT calculation object to print itself.
     def print(self):
 
@@ -4489,16 +4567,17 @@
         # Batch of property results at individial PT values
         self.result3.initialiseFromDictionary(data['result3'])
 
         # Response code
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a u d s set liq frac from temperature calculation.
 class UDSSetLiqFracFromTemperatureCalculationRequest(object):
@@ -4515,15 +4594,15 @@
         # Input temperature
         self.temperature = 0.0
 
 
 # U d s set liq frac from temperature calculation class.
 class UDSSetLiqFracFromTemperatureCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material
@@ -4566,47 +4645,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             udsSetLiqFracFromTemperatureCalculationResponse = UDSSetLiqFracFromTemperatureCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                udsSetLiqFracFromTemperatureCalculationResponse.initialiseFromDictionary(jsonDoc)
+                udsSetLiqFracFromTemperatureCalculationResponse.initialiseFromDictionary(json)
 
                 self.liquidFraction = udsSetLiqFracFromTemperatureCalculationResponse.liquidFraction
                 self.resultCode = udsSetLiqFracFromTemperatureCalculationResponse.resultCode
                 self.messages = udsSetLiqFracFromTemperatureCalculationResponse.messages
                 self.calculationElapsedTime = udsSetLiqFracFromTemperatureCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the UDSSetLiqFracFromTemperature calculation object to print itself.
     def print(self):
 
@@ -4660,16 +4739,17 @@
         # Calculated liquid fraction
         self.liquidFraction = float(data['liquidFraction'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a radiation transect calculation.
 class RadiationTransectCalculationRequest(object):
@@ -4695,15 +4775,15 @@
         # Settings of flammable contours view
         self.flammableOutputConfig = FlammableOutputConfig()
 
 
 # Radiation transect calculation class.
 class RadiationTransectCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Scalar flame results
@@ -4756,47 +4836,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             radiationTransectCalculationResponse = RadiationTransectCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                radiationTransectCalculationResponse.initialiseFromDictionary(jsonDoc)
+                radiationTransectCalculationResponse.initialiseFromDictionary(json)
 
                 self.radiationRecords = radiationTransectCalculationResponse.radiationRecords
                 self.resultCode = radiationTransectCalculationResponse.resultCode
                 self.messages = radiationTransectCalculationResponse.messages
                 self.calculationElapsedTime = radiationTransectCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the RadiationTransect calculation object to print itself.
     def print(self):
 
@@ -4851,25 +4931,27 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Array of radiation results along transect
-        for dataItem in data['radiationRecords']:
-            radiationRecord = RadiationRecord()
-            radiationRecord.initialiseFromDictionary(dataItem)
-            self.radiationRecords.append(radiationRecord)
+        if data['radiationRecords'] != None:
+            for dataItem in data['radiationRecords']:
+                radiationRecord = RadiationRecord()
+                radiationRecord.initialiseFromDictionary(dataItem)
+                self.radiationRecords.append(radiationRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel leak calculation.
 class VesselLeakCalculationRequest(object):
@@ -4886,15 +4968,15 @@
         # Discharge parameters
         self.dischargeParameters = DischargeParameters()
 
 
 # Vessel leak calculation class.
 class VesselLeakCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel (pressurised or atmospheric)
@@ -4943,49 +5025,49 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselLeakCalculationResponse = VesselLeakCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselLeakCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselLeakCalculationResponse.initialiseFromDictionary(json)
 
                 self.exitMaterial = vesselLeakCalculationResponse.exitMaterial
                 self.dischargeResult = vesselLeakCalculationResponse.dischargeResult
                 self.dischargeRecords = vesselLeakCalculationResponse.dischargeRecords
                 self.resultCode = vesselLeakCalculationResponse.resultCode
                 self.messages = vesselLeakCalculationResponse.messages
                 self.calculationElapsedTime = vesselLeakCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselLeak calculation object to print itself.
     def print(self):
 
@@ -5051,25 +5133,27 @@
         # Composition of the released material (may differ from storage composition)
         self.exitMaterial.initialiseFromDictionary(data['exitMaterial'])
 
         # Scalar discharge results
         self.dischargeResult.initialiseFromDictionary(data['dischargeResult'])
 
         # Array of discharge records
-        for dataItem in data['dischargeRecords']:
-            dischargeRecord = DischargeRecord()
-            dischargeRecord.initialiseFromDictionary(dataItem)
-            self.dischargeRecords.append(dischargeRecord)
+        if data['dischargeRecords'] != None:
+            for dataItem in data['dischargeRecords']:
+                dischargeRecord = DischargeRecord()
+                dischargeRecord.initialiseFromDictionary(dataItem)
+                self.dischargeRecords.append(dischargeRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a u d s set temperature from liq frac calculation.
 class UDSSetTemperatureFromLiqFracCalculationRequest(object):
@@ -5086,15 +5170,15 @@
         # Input liquid fraction
         self.liquidFraction = 0.0
 
 
 # U d s set temperature from liq frac calculation class.
 class UDSSetTemperatureFromLiqFracCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material
@@ -5137,47 +5221,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             udsSetTemperatureFromLiqFracCalculationResponse = UDSSetTemperatureFromLiqFracCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                udsSetTemperatureFromLiqFracCalculationResponse.initialiseFromDictionary(jsonDoc)
+                udsSetTemperatureFromLiqFracCalculationResponse.initialiseFromDictionary(json)
 
                 self.temperature = udsSetTemperatureFromLiqFracCalculationResponse.temperature
                 self.resultCode = udsSetTemperatureFromLiqFracCalculationResponse.resultCode
                 self.messages = udsSetTemperatureFromLiqFracCalculationResponse.messages
                 self.calculationElapsedTime = udsSetTemperatureFromLiqFracCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the UDSSetTemperatureFromLiqFrac calculation object to print itself.
     def print(self):
 
@@ -5231,16 +5315,17 @@
         # Calculated temperature
         self.temperature = float(data['temperature'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a calc thermo paths calculation.
 class CalcThermoPathsCalculationRequest(object):
@@ -5254,15 +5339,15 @@
         # Initial pressure and temperature
         self.initialState = State()
 
 
 # Calc thermo paths calculation class.
 class CalcThermoPathsCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Definition of pure component / mixture
@@ -5301,47 +5386,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             calcThermoPathsCalculationResponse = CalcThermoPathsCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                calcThermoPathsCalculationResponse.initialiseFromDictionary(jsonDoc)
+                calcThermoPathsCalculationResponse.initialiseFromDictionary(json)
 
                 self.thermoPathRecords = calcThermoPathsCalculationResponse.thermoPathRecords
                 self.resultCode = calcThermoPathsCalculationResponse.resultCode
                 self.messages = calcThermoPathsCalculationResponse.messages
                 self.calculationElapsedTime = calcThermoPathsCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the CalcThermoPaths calculation object to print itself.
     def print(self):
 
@@ -5386,25 +5471,27 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Callback for individual points along the thermodynamic paths
-        for dataItem in data['thermoPathRecords']:
-            thermoPathRecord = ThermoPathRecord()
-            thermoPathRecord.initialiseFromDictionary(dataItem)
-            self.thermoPathRecords.append(thermoPathRecord)
+        if data['thermoPathRecords'] != None:
+            for dataItem in data['thermoPathRecords']:
+                thermoPathRecord = ThermoPathRecord()
+                thermoPathRecord.initialiseFromDictionary(dataItem)
+                self.thermoPathRecords.append(thermoPathRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a get mass from vessel calculation.
 class GetMassFromVesselCalculationRequest(object):
@@ -5415,15 +5502,15 @@
         # Vessel (pressurised)
         self.vessel = Vessel()
 
 
 # Get mass from vessel calculation class.
 class GetMassFromVesselCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel (pressurised)
@@ -5458,47 +5545,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             getMassFromVesselCalculationResponse = GetMassFromVesselCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                getMassFromVesselCalculationResponse.initialiseFromDictionary(jsonDoc)
+                getMassFromVesselCalculationResponse.initialiseFromDictionary(json)
 
                 self.massInventory = getMassFromVesselCalculationResponse.massInventory
                 self.resultCode = getMassFromVesselCalculationResponse.resultCode
                 self.messages = getMassFromVesselCalculationResponse.messages
                 self.calculationElapsedTime = getMassFromVesselCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the GetMassFromVessel calculation object to print itself.
     def print(self):
 
@@ -5546,16 +5633,17 @@
         # Mass inventory in the vessel (kg)
         self.massInventory = float(data['massInventory'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a u d s temperature limits calculation.
 class UDSTemperatureLimitsCalculationRequest(object):
@@ -5569,15 +5657,15 @@
         # Phase to be released (Vapour, Two-phase or Liquid)
         self.phaseToBeReleased = Phase.VAPOUR
 
 
 # U d s temperature limits calculation class.
 class UDSTemperatureLimitsCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material
@@ -5619,48 +5707,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             udsTemperatureLimitsCalculationResponse = UDSTemperatureLimitsCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                udsTemperatureLimitsCalculationResponse.initialiseFromDictionary(jsonDoc)
+                udsTemperatureLimitsCalculationResponse.initialiseFromDictionary(json)
 
                 self.minTemperature = udsTemperatureLimitsCalculationResponse.minTemperature
                 self.maxTemperature = udsTemperatureLimitsCalculationResponse.maxTemperature
                 self.resultCode = udsTemperatureLimitsCalculationResponse.resultCode
                 self.messages = udsTemperatureLimitsCalculationResponse.messages
                 self.calculationElapsedTime = udsTemperatureLimitsCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the UDSTemperatureLimits calculation object to print itself.
     def print(self):
 
@@ -5720,16 +5808,17 @@
         # Upper temperature limit to ensure consistency
         self.maxTemperature = float(data['maxTemperature'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a weather conversion calculation.
 class WeatherConversionCalculationRequest(object):
@@ -5740,15 +5829,15 @@
         # Input live weather station data
         self.weatherStationData = WeatherStationData()
 
 
 # Weather conversion calculation class.
 class WeatherConversionCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Input live weather station data
@@ -5783,47 +5872,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             weatherConversionCalculationResponse = WeatherConversionCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                weatherConversionCalculationResponse.initialiseFromDictionary(jsonDoc)
+                weatherConversionCalculationResponse.initialiseFromDictionary(json)
 
                 self.weather = weatherConversionCalculationResponse.weather
                 self.resultCode = weatherConversionCalculationResponse.resultCode
                 self.messages = weatherConversionCalculationResponse.messages
                 self.calculationElapsedTime = weatherConversionCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the WeatherConversion calculation object to print itself.
     def print(self):
 
@@ -5871,16 +5960,17 @@
         # Weather data used in our APIs
         self.weather.initialiseFromDictionary(data['weather'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a max conc footprint calculation.
 class MaxConcFootprintCalculationRequest(object):
@@ -5912,15 +6002,15 @@
         # Dispersion parameters
         self.dispersionParameters = DispersionParameters()
 
 
 # Max conc footprint calculation class.
 class MaxConcFootprintCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # UDM scalar outputs
@@ -5984,48 +6074,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             maxConcFootprintCalculationResponse = MaxConcFootprintCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                maxConcFootprintCalculationResponse.initialiseFromDictionary(jsonDoc)
+                maxConcFootprintCalculationResponse.initialiseFromDictionary(json)
 
                 self.concUsed = maxConcFootprintCalculationResponse.concUsed
                 self.contourPoints = maxConcFootprintCalculationResponse.contourPoints
                 self.resultCode = maxConcFootprintCalculationResponse.resultCode
                 self.messages = maxConcFootprintCalculationResponse.messages
                 self.calculationElapsedTime = maxConcFootprintCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the MaxConcFootprint calculation object to print itself.
     def print(self):
 
@@ -6095,25 +6185,27 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Concentration of interest
         self.concUsed = float(data['concUsed'])
 
         # Array of footprint results
-        for dataItem in data['contourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.contourPoints.append(localPosition)
+        if data['contourPoints'] != None:
+            for dataItem in data['contourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.contourPoints.append(localPosition)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a distances to conc levels calculation.
 class DistancesToConcLevelsCalculationRequest(object):
@@ -6148,15 +6240,15 @@
         # Dispersion parameters
         self.dispersionParameters = DispersionParameters()
 
 
 # Distances to conc levels calculation class.
 class DistancesToConcLevelsCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # UDM scalar outputs
@@ -6222,48 +6314,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             distancesToConcLevelsCalculationResponse = DistancesToConcLevelsCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                distancesToConcLevelsCalculationResponse.initialiseFromDictionary(jsonDoc)
+                distancesToConcLevelsCalculationResponse.initialiseFromDictionary(json)
 
                 self.concUsed = distancesToConcLevelsCalculationResponse.concUsed
                 self.distances = distancesToConcLevelsCalculationResponse.distances
                 self.resultCode = distancesToConcLevelsCalculationResponse.resultCode
                 self.messages = distancesToConcLevelsCalculationResponse.messages
                 self.calculationElapsedTime = distancesToConcLevelsCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the DistancesToConcLevels calculation object to print itself.
     def print(self):
 
@@ -6333,27 +6425,30 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Concentrations of interest
-        for dataItem in data['concUsed']:
-            self.concUsed.append(float(dataItem))
+        if data['concUsed'] != None:
+            for dataItem in data['concUsed']:
+                self.concUsed.append(float(dataItem))
 
         # Distances to concentration of interest
-        for dataItem in data['distances']:
-            self.distances.append(float(dataItem))
+        if data['distances'] != None:
+            for dataItem in data['distances']:
+                self.distances.append(float(dataItem))
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a jet fire calculation.
 class JetFireCalculationRequest(object):
@@ -6382,15 +6477,15 @@
         # Flammable parameters
         self.flammableParameters = FlammableParameters()
 
 
 # Jet fire calculation class.
 class JetFireCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material with post-discharge composition
@@ -6450,48 +6545,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             jetFireCalculationResponse = JetFireCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                jetFireCalculationResponse.initialiseFromDictionary(jsonDoc)
+                jetFireCalculationResponse.initialiseFromDictionary(json)
 
                 self.flameResult = jetFireCalculationResponse.flameResult
                 self.flameRecords = jetFireCalculationResponse.flameRecords
                 self.resultCode = jetFireCalculationResponse.resultCode
                 self.messages = jetFireCalculationResponse.messages
                 self.calculationElapsedTime = jetFireCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the JetFire calculation object to print itself.
     def print(self):
 
@@ -6558,25 +6653,27 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Flame scalar results
         self.flameResult.initialiseFromDictionary(data['flameResult'])
 
         # Array of jet fire flame records
-        for dataItem in data['flameRecords']:
-            flameRecord = FlameRecord()
-            flameRecord.initialiseFromDictionary(dataItem)
-            self.flameRecords.append(flameRecord)
+        if data['flameRecords'] != None:
+            for dataItem in data['flameRecords']:
+                flameRecord = FlameRecord()
+                flameRecord.initialiseFromDictionary(dataItem)
+                self.flameRecords.append(flameRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a convert composition mole to mass calculation.
 class ConvertCompositionMoleToMassCalculationRequest(object):
@@ -6593,15 +6690,15 @@
         # Number of components in mixture
         self.compositionMolesCount = 0
 
 
 # Convert composition mole to mass calculation class.
 class ConvertCompositionMoleToMassCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Mixture to have composition converted
@@ -6644,47 +6741,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             convertCompositionMoleToMassCalculationResponse = ConvertCompositionMoleToMassCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                convertCompositionMoleToMassCalculationResponse.initialiseFromDictionary(jsonDoc)
+                convertCompositionMoleToMassCalculationResponse.initialiseFromDictionary(json)
 
                 self.compositionMass = convertCompositionMoleToMassCalculationResponse.compositionMass
                 self.resultCode = convertCompositionMoleToMassCalculationResponse.resultCode
                 self.messages = convertCompositionMoleToMassCalculationResponse.messages
                 self.calculationElapsedTime = convertCompositionMoleToMassCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the ConvertCompositionMoleToMass calculation object to print itself.
     def print(self):
 
@@ -6731,23 +6828,25 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Output composition of mixture in mass basis
-        for dataItem in data['compositionMass']:
-            self.compositionMass.append(float(dataItem))
+        if data['compositionMass'] != None:
+            for dataItem in data['compositionMass']:
+                self.compositionMass.append(float(dataItem))
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a fireball calculation.
 class FireballCalculationRequest(object):
@@ -6773,15 +6872,15 @@
         # Weather
         self.weather = Weather()
 
 
 # Fireball calculation class.
 class FireballCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material with post-discharge composition
@@ -6837,48 +6936,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             fireballCalculationResponse = FireballCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                fireballCalculationResponse.initialiseFromDictionary(jsonDoc)
+                fireballCalculationResponse.initialiseFromDictionary(json)
 
                 self.flameResult = fireballCalculationResponse.flameResult
                 self.flameRecords = fireballCalculationResponse.flameRecords
                 self.resultCode = fireballCalculationResponse.resultCode
                 self.messages = fireballCalculationResponse.messages
                 self.calculationElapsedTime = fireballCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the Fireball calculation object to print itself.
     def print(self):
 
@@ -6942,25 +7041,27 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Flame scalar result
         self.flameResult.initialiseFromDictionary(data['flameResult'])
 
         # Array of fireball flame records
-        for dataItem in data['flameRecords']:
-            flameRecord = FlameRecord()
-            flameRecord.initialiseFromDictionary(dataItem)
-            self.flameRecords.append(flameRecord)
+        if data['flameRecords'] != None:
+            for dataItem in data['flameRecords']:
+                flameRecord = FlameRecord()
+                flameRecord.initialiseFromDictionary(dataItem)
+                self.flameRecords.append(flameRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a properties dippr p t calculation.
 class PropertiesDipprPTCalculationRequest(object):
@@ -6974,15 +7075,15 @@
         # Range of temperatures and pressures to be considered
         self.range = PTRange()
 
 
 # Properties dippr p t calculation class.
 class PropertiesDipprPTCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Composition (5 max as using spreadsheet entry point)
@@ -7027,49 +7128,49 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             propertiesDipprPTCalculationResponse = PropertiesDipprPTCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                propertiesDipprPTCalculationResponse.initialiseFromDictionary(jsonDoc)
+                propertiesDipprPTCalculationResponse.initialiseFromDictionary(json)
 
                 self.result = propertiesDipprPTCalculationResponse.result
                 self.result2 = propertiesDipprPTCalculationResponse.result2
                 self.result3 = propertiesDipprPTCalculationResponse.result3
                 self.resultCode = propertiesDipprPTCalculationResponse.resultCode
                 self.messages = propertiesDipprPTCalculationResponse.messages
                 self.calculationElapsedTime = propertiesDipprPTCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the PropertiesDipprPT calculation object to print itself.
     def print(self):
 
@@ -7138,16 +7239,17 @@
         # Set of property result arrays at individial PT values
         self.result3.initialiseFromDictionary(data['result3'])
 
         # Response code
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a flare stack designer calculation.
 class FlareStackDesignerCalculationRequest(object):
@@ -7176,15 +7278,15 @@
         # Defines the flammable results of interest
         self.flammableOutputConfig = FlammableOutputConfig()
 
 
 # Flare stack designer calculation class.
 class FlareStackDesignerCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Flare stack asset
@@ -7243,47 +7345,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             flareStackDesignerCalculationResponse = FlareStackDesignerCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                flareStackDesignerCalculationResponse.initialiseFromDictionary(jsonDoc)
+                flareStackDesignerCalculationResponse.initialiseFromDictionary(json)
 
                 self.designSolution = flareStackDesignerCalculationResponse.designSolution
                 self.resultCode = flareStackDesignerCalculationResponse.resultCode
                 self.messages = flareStackDesignerCalculationResponse.messages
                 self.calculationElapsedTime = flareStackDesignerCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the FlareStackDesigner calculation object to print itself.
     def print(self):
 
@@ -7349,16 +7451,17 @@
         # Value of design variable that satisfies the design target
         self.designSolution = float(data['designSolution'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a lethality distance calculation.
 class LethalityDistanceCalculationRequest(object):
@@ -7390,15 +7493,15 @@
         # Dispersion parameters
         self.dispersionParameters = DispersionParameters()
 
 
 # Lethality distance calculation class.
 class LethalityDistanceCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material with post-discharge composition
@@ -7459,47 +7562,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             lethalityDistanceCalculationResponse = LethalityDistanceCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                lethalityDistanceCalculationResponse.initialiseFromDictionary(jsonDoc)
+                lethalityDistanceCalculationResponse.initialiseFromDictionary(json)
 
                 self.toxicRecords = lethalityDistanceCalculationResponse.toxicRecords
                 self.resultCode = lethalityDistanceCalculationResponse.resultCode
                 self.messages = lethalityDistanceCalculationResponse.messages
                 self.calculationElapsedTime = lethalityDistanceCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the LethalityDistance calculation object to print itself.
     def print(self):
 
@@ -7560,25 +7663,27 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Array of toxic results
-        for dataItem in data['toxicRecords']:
-            toxicRecord = ToxicRecord()
-            toxicRecord.initialiseFromDictionary(dataItem)
-            self.toxicRecords.append(toxicRecord)
+        if data['toxicRecords'] != None:
+            for dataItem in data['toxicRecords']:
+                toxicRecord = ToxicRecord()
+                toxicRecord.initialiseFromDictionary(dataItem)
+                self.toxicRecords.append(toxicRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a dispersion calculation.
 class DispersionCalculationRequest(object):
@@ -7610,15 +7715,15 @@
         # Concentration at which the dispersion calculations will terminate (v/v fraction)
         self.endPointConcentration = 0.0
 
 
 # Dispersion calculation class.
 class DispersionCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Material with post-discharge composition
@@ -7685,49 +7790,49 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             dispersionCalculationResponse = DispersionCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                dispersionCalculationResponse.initialiseFromDictionary(jsonDoc)
+                dispersionCalculationResponse.initialiseFromDictionary(json)
 
                 self.scalarUdmOutputs = dispersionCalculationResponse.scalarUdmOutputs
                 self.dispersionRecords = dispersionCalculationResponse.dispersionRecords
                 self.poolRecords = dispersionCalculationResponse.poolRecords
                 self.resultCode = dispersionCalculationResponse.resultCode
                 self.messages = dispersionCalculationResponse.messages
                 self.calculationElapsedTime = dispersionCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the Dispersion calculation object to print itself.
     def print(self):
 
@@ -7803,31 +7908,34 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # UDM scalar outputs
         self.scalarUdmOutputs.initialiseFromDictionary(data['scalarUdmOutputs'])
 
         # Array of Dispersion records
-        for dataItem in data['dispersionRecords']:
-            dispersionRecord = DispersionRecord()
-            dispersionRecord.initialiseFromDictionary(dataItem)
-            self.dispersionRecords.append(dispersionRecord)
+        if data['dispersionRecords'] != None:
+            for dataItem in data['dispersionRecords']:
+                dispersionRecord = DispersionRecord()
+                dispersionRecord.initialiseFromDictionary(dataItem)
+                self.dispersionRecords.append(dispersionRecord)
 
         # Array of Pool records
-        for dataItem in data['poolRecords']:
-            poolRecord = PoolRecord()
-            poolRecord.initialiseFromDictionary(dataItem)
-            self.poolRecords.append(poolRecord)
+        if data['poolRecords'] != None:
+            for dataItem in data['poolRecords']:
+                poolRecord = PoolRecord()
+                poolRecord.initialiseFromDictionary(dataItem)
+                self.poolRecords.append(poolRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a set u d s for linked run calculation.
 class SetUDSForLinkedRunCalculationRequest(object):
@@ -7868,15 +7976,15 @@
         # Release angle
         self.releaseAngle = 0.0
 
 
 # Set u d s for linked run calculation class.
 class SetUDSForLinkedRunCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel material
@@ -7954,48 +8062,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             setUDSForLinkedRunCalculationResponse = SetUDSForLinkedRunCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                setUDSForLinkedRunCalculationResponse.initialiseFromDictionary(jsonDoc)
+                setUDSForLinkedRunCalculationResponse.initialiseFromDictionary(json)
 
                 self.dischargeResult = setUDSForLinkedRunCalculationResponse.dischargeResult
                 self.dischargeRecords = setUDSForLinkedRunCalculationResponse.dischargeRecords
                 self.resultCode = setUDSForLinkedRunCalculationResponse.resultCode
                 self.messages = setUDSForLinkedRunCalculationResponse.messages
                 self.calculationElapsedTime = setUDSForLinkedRunCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the SetUDSForLinkedRun calculation object to print itself.
     def print(self):
 
@@ -8076,25 +8184,27 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Discharge result
         self.dischargeResult.initialiseFromDictionary(data['dischargeResult'])
 
         # Discharge records
-        for dataItem in data['dischargeRecords']:
-            dischargeRecord = DischargeRecord()
-            dischargeRecord.initialiseFromDictionary(dataItem)
-            self.dischargeRecords.append(dischargeRecord)
+        if data['dischargeRecords'] != None:
+            for dataItem in data['dischargeRecords']:
+                dischargeRecord = DischargeRecord()
+                dischargeRecord.initialiseFromDictionary(dataItem)
+                self.dischargeRecords.append(dischargeRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a concentration at point calculation.
 class ConcentrationAtPointCalculationRequest(object):
@@ -8126,15 +8236,15 @@
         # Dispersion parameters
         self.dispersionParameters = DispersionParameters()
 
 
 # Concentration at point calculation class.
 class ConcentrationAtPointCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # UDM scalar outputs
@@ -8195,47 +8305,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             concentrationAtPointCalculationResponse = ConcentrationAtPointCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                concentrationAtPointCalculationResponse.initialiseFromDictionary(jsonDoc)
+                concentrationAtPointCalculationResponse.initialiseFromDictionary(json)
 
                 self.concentration = concentrationAtPointCalculationResponse.concentration
                 self.resultCode = concentrationAtPointCalculationResponse.resultCode
                 self.messages = concentrationAtPointCalculationResponse.messages
                 self.calculationElapsedTime = concentrationAtPointCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the ConcentrationAtPoint calculation object to print itself.
     def print(self):
 
@@ -8302,16 +8412,17 @@
         # Concentration at a position of interest
         self.concentration = float(data['concentration'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel state calculation.
 class VesselStateCalculationRequest(object):
@@ -8325,15 +8436,15 @@
         # Describes the fluid pressure, temperature, liquid fraction
         self.materialState = State()
 
 
 # Vessel state calculation class.
 class VesselStateCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # User-defined input material, pure component or mixture (max 20 components)
@@ -8375,48 +8486,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselStateCalculationResponse = VesselStateCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselStateCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselStateCalculationResponse.initialiseFromDictionary(json)
 
                 self.vesselConditions = vesselStateCalculationResponse.vesselConditions
                 self.outputState = vesselStateCalculationResponse.outputState
                 self.resultCode = vesselStateCalculationResponse.resultCode
                 self.messages = vesselStateCalculationResponse.messages
                 self.calculationElapsedTime = vesselStateCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselState calculation object to print itself.
     def print(self):
 
@@ -8476,16 +8587,17 @@
         # Describes the fluid pressure, temperature and liquid fraction after the flash calculation
         self.outputState.initialiseFromDictionary(data['outputState'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a distance to radiation calculation.
 class DistanceToRadiationCalculationRequest(object):
@@ -8511,15 +8623,15 @@
         # Settings of flammable contours view
         self.flammableOutputConfig = FlammableOutputConfig()
 
 
 # Distance to radiation calculation class.
 class DistanceToRadiationCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Scalar flame results
@@ -8572,47 +8684,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             distanceToRadiationCalculationResponse = DistanceToRadiationCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                distanceToRadiationCalculationResponse.initialiseFromDictionary(jsonDoc)
+                distanceToRadiationCalculationResponse.initialiseFromDictionary(json)
 
                 self.distance = distanceToRadiationCalculationResponse.distance
                 self.resultCode = distanceToRadiationCalculationResponse.resultCode
                 self.messages = distanceToRadiationCalculationResponse.messages
                 self.calculationElapsedTime = distanceToRadiationCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the DistanceToRadiation calculation object to print itself.
     def print(self):
 
@@ -8673,16 +8785,17 @@
         # Distance to radiation level
         self.distance = float(data['distance'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a convert composition mass to mole calculation.
 class ConvertCompositionMassToMoleCalculationRequest(object):
@@ -8699,15 +8812,15 @@
         # Number of components in mixture
         self.compositionMassCount = 0
 
 
 # Convert composition mass to mole calculation class.
 class ConvertCompositionMassToMoleCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Mixture to have composition converted
@@ -8750,47 +8863,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             convertCompositionMassToMoleCalculationResponse = ConvertCompositionMassToMoleCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                convertCompositionMassToMoleCalculationResponse.initialiseFromDictionary(jsonDoc)
+                convertCompositionMassToMoleCalculationResponse.initialiseFromDictionary(json)
 
                 self.compositionMole = convertCompositionMassToMoleCalculationResponse.compositionMole
                 self.resultCode = convertCompositionMassToMoleCalculationResponse.resultCode
                 self.messages = convertCompositionMassToMoleCalculationResponse.messages
                 self.calculationElapsedTime = convertCompositionMassToMoleCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the ConvertCompositionMassToMole calculation object to print itself.
     def print(self):
 
@@ -8837,23 +8950,25 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Output composition of mixture in mole basis
-        for dataItem in data['compositionMole']:
-            self.compositionMole.append(float(dataItem))
+        if data['compositionMole'] != None:
+            for dataItem in data['compositionMole']:
+                self.compositionMole.append(float(dataItem))
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a long pipe breach calculation.
 class LongPipeBreachCalculationRequest(object):
@@ -8870,15 +8985,15 @@
         # Discharge parameters
         self.dischargeParameters = DischargeParameters()
 
 
 # Long pipe breach calculation class.
 class LongPipeBreachCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Pipe equipment item
@@ -8927,49 +9042,49 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             longPipeBreachCalculationResponse = LongPipeBreachCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                longPipeBreachCalculationResponse.initialiseFromDictionary(jsonDoc)
+                longPipeBreachCalculationResponse.initialiseFromDictionary(json)
 
                 self.exitMaterial = longPipeBreachCalculationResponse.exitMaterial
                 self.dischargeResult = longPipeBreachCalculationResponse.dischargeResult
                 self.dischargeRecords = longPipeBreachCalculationResponse.dischargeRecords
                 self.resultCode = longPipeBreachCalculationResponse.resultCode
                 self.messages = longPipeBreachCalculationResponse.messages
                 self.calculationElapsedTime = longPipeBreachCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the LongPipeBreach calculation object to print itself.
     def print(self):
 
@@ -9035,25 +9150,27 @@
         # Composition of the released material (indentical to storage composition - using PC mode)
         self.exitMaterial.initialiseFromDictionary(data['exitMaterial'])
 
         # Scalar discharge results
         self.dischargeResult.initialiseFromDictionary(data['dischargeResult'])
 
         # Array of discharge records
-        for dataItem in data['dischargeRecords']:
-            dischargeRecord = DischargeRecord()
-            dischargeRecord.initialiseFromDictionary(dataItem)
-            self.dischargeRecords.append(dischargeRecord)
+        if data['dischargeRecords'] != None:
+            for dataItem in data['dischargeRecords']:
+                dischargeRecord = DischargeRecord()
+                dischargeRecord.initialiseFromDictionary(dataItem)
+                self.dischargeRecords.append(dischargeRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel leak linked run calculation.
 class VesselLeakLinkedRunCalculationRequest(object):
@@ -9118,15 +9235,15 @@
         # Number of confined explosion sources
         self.explosionConfinedVolumeCount = 0
 
 
 # Vessel leak linked run calculation class.
 class VesselLeakLinkedRunCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel definition
@@ -9286,22 +9403,22 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselLeakLinkedRunCalculationResponse = VesselLeakLinkedRunCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselLeakLinkedRunCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselLeakLinkedRunCalculationResponse.initialiseFromDictionary(json)
 
                 self.dischargeRecord = vesselLeakLinkedRunCalculationResponse.dischargeRecord
                 self.distancesToJetFireRadiation = vesselLeakLinkedRunCalculationResponse.distancesToJetFireRadiation
                 self.jetContourPoints = vesselLeakLinkedRunCalculationResponse.jetContourPoints
                 self.nJetCountourPoints = vesselLeakLinkedRunCalculationResponse.nJetCountourPoints
                 self.areaEllipseJet = vesselLeakLinkedRunCalculationResponse.areaEllipseJet
                 self.distancesToFlamConcentration = vesselLeakLinkedRunCalculationResponse.distancesToFlamConcentration
@@ -9323,31 +9440,31 @@
                 self.poolFireFlameResult = vesselLeakLinkedRunCalculationResponse.poolFireFlameResult
                 self.resultCode = vesselLeakLinkedRunCalculationResponse.resultCode
                 self.messages = vesselLeakLinkedRunCalculationResponse.messages
                 self.calculationElapsedTime = vesselLeakLinkedRunCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselLeakLinkedRun calculation object to print itself.
     def print(self):
 
@@ -9577,111 +9694,131 @@
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Discharge data for table
         self.dischargeRecord.initialiseFromDictionary(data['dischargeRecord'])
 
         # Distances to jet fire radiation levels
-        for dataItem in data['distancesToJetFireRadiation']:
-            self.distancesToJetFireRadiation.append(float(dataItem))
+        if data['distancesToJetFireRadiation'] != None:
+            for dataItem in data['distancesToJetFireRadiation']:
+                self.distancesToJetFireRadiation.append(float(dataItem))
 
         # Ellipses to jet fire radiation levels
-        for dataItem in data['jetContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.jetContourPoints.append(localPosition)
+        if data['jetContourPoints'] != None:
+            for dataItem in data['jetContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.jetContourPoints.append(localPosition)
 
         # Number of contour points for jet fire ellipses per radiation level
-        for dataItem in data['nJetCountourPoints']:
+        if data['nJetCountourPoints'] != None:
+            for dataItem in data['nJetCountourPoints']:
                 self.nJetCountourPoints.append(int(dataItem))
 
         # Areas of jet fire ellipses
-        for dataItem in data['areaEllipseJet']:
-            self.areaEllipseJet.append(float(dataItem))
+        if data['areaEllipseJet'] != None:
+            for dataItem in data['areaEllipseJet']:
+                self.areaEllipseJet.append(float(dataItem))
 
         # Distances to concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['distancesToFlamConcentration']:
-            self.distancesToFlamConcentration.append(float(dataItem))
+        if data['distancesToFlamConcentration'] != None:
+            for dataItem in data['distancesToFlamConcentration']:
+                self.distancesToFlamConcentration.append(float(dataItem))
 
         # Concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['flamConcentrationsUsed']:
-            self.flamConcentrationsUsed.append(float(dataItem))
+        if data['flamConcentrationsUsed'] != None:
+            for dataItem in data['flamConcentrationsUsed']:
+                self.flamConcentrationsUsed.append(float(dataItem))
 
         # Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL)
-        for dataItem in data['flamConcContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.flamConcContourPoints.append(localPosition)
+        if data['flamConcContourPoints'] != None:
+            for dataItem in data['flamConcContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.flamConcContourPoints.append(localPosition)
 
         # Number of contour points per concentration level (LFL fraction, LFL and UFL)
-        for dataItem in data['nFlamConcCountourPoints']:
+        if data['nFlamConcCountourPoints'] != None:
+            for dataItem in data['nFlamConcCountourPoints']:
                 self.nFlamConcCountourPoints.append(int(dataItem))
 
         # Areas of maximum concentration footprints (LFL fraction, LFL and UFL)
-        for dataItem in data['areaFootprintFlamConc']:
-            self.areaFootprintFlamConc.append(float(dataItem))
+        if data['areaFootprintFlamConc'] != None:
+            for dataItem in data['areaFootprintFlamConc']:
+                self.areaFootprintFlamConc.append(float(dataItem))
 
         # Distances to pool fire radiation levels
-        for dataItem in data['distancesToPoolFireRadiation']:
-            self.distancesToPoolFireRadiation.append(float(dataItem))
+        if data['distancesToPoolFireRadiation'] != None:
+            for dataItem in data['distancesToPoolFireRadiation']:
+                self.distancesToPoolFireRadiation.append(float(dataItem))
 
         # Ellipses to pool fire radiation levels
-        for dataItem in data['poolContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.poolContourPoints.append(localPosition)
+        if data['poolContourPoints'] != None:
+            for dataItem in data['poolContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.poolContourPoints.append(localPosition)
 
         # Number of contour points for pool fire ellipses per radiation level
-        for dataItem in data['nPoolCountourPoints']:
+        if data['nPoolCountourPoints'] != None:
+            for dataItem in data['nPoolCountourPoints']:
                 self.nPoolCountourPoints.append(int(dataItem))
 
         # Areas of pool fire ellipses
-        for dataItem in data['areaEllipsePool']:
-            self.areaEllipsePool.append(float(dataItem))
+        if data['areaEllipsePool'] != None:
+            for dataItem in data['areaEllipsePool']:
+                self.areaEllipsePool.append(float(dataItem))
 
         # Explosion overpressure results
-        for dataItem in data['explosionOverpressureResults']:
-            explosionOverpressureResult = ExplosionOverpressureResult()
-            explosionOverpressureResult.initialiseFromDictionary(dataItem)
-            self.explosionOverpressureResults.append(explosionOverpressureResult)
+        if data['explosionOverpressureResults'] != None:
+            for dataItem in data['explosionOverpressureResults']:
+                explosionOverpressureResult = ExplosionOverpressureResult()
+                explosionOverpressureResult.initialiseFromDictionary(dataItem)
+                self.explosionOverpressureResults.append(explosionOverpressureResult)
 
         # Distance to concentration of interest (using toxic averaging time)
-        for dataItem in data['distancesToToxicConcentration']:
-            self.distancesToToxicConcentration.append(float(dataItem))
+        if data['distancesToToxicConcentration'] != None:
+            for dataItem in data['distancesToToxicConcentration']:
+                self.distancesToToxicConcentration.append(float(dataItem))
 
         # Concentration of interest
-        for dataItem in data['toxicConcentrationUsed']:
-            self.toxicConcentrationUsed.append(float(dataItem))
+        if data['toxicConcentrationUsed'] != None:
+            for dataItem in data['toxicConcentrationUsed']:
+                self.toxicConcentrationUsed.append(float(dataItem))
 
         # Maximum concentration footprint to concentration of interest (using toxic averaging time)
-        for dataItem in data['toxicConcContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.toxicConcContourPoints.append(localPosition)
+        if data['toxicConcContourPoints'] != None:
+            for dataItem in data['toxicConcContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.toxicConcContourPoints.append(localPosition)
 
         # Number of contour points for maximum concentration footprint to concentration of interest
-        for dataItem in data['nToxicConcCountourPoints']:
+        if data['nToxicConcCountourPoints'] != None:
+            for dataItem in data['nToxicConcCountourPoints']:
                 self.nToxicConcCountourPoints.append(int(dataItem))
 
         # Area of maximum concentration footprints to concentration of interest (using toxic averaging time)
-        for dataItem in data['areaFootprintToxicConc']:
-            self.areaFootprintToxicConc.append(float(dataItem))
+        if data['areaFootprintToxicConc'] != None:
+            for dataItem in data['areaFootprintToxicConc']:
+                self.areaFootprintToxicConc.append(float(dataItem))
 
         # Flame results for jet fire
         self.jetFireFlameResult.initialiseFromDictionary(data['jetFireFlameResult'])
 
         # Flame results for pool fire
         self.poolFireFlameResult.initialiseFromDictionary(data['poolFireFlameResult'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a set phase to release for leak scenario calculation.
 class SetPhaseToReleaseForLeakScenarioCalculationRequest(object):
@@ -9698,15 +9835,15 @@
         # Vessel definition input
         self.vessel = Vessel()
 
 
 # Set phase to release for leak scenario calculation class.
 class SetPhaseToReleaseForLeakScenarioCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Requested fluid phase to release
@@ -9752,48 +9889,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             setPhaseToReleaseForLeakScenarioCalculationResponse = SetPhaseToReleaseForLeakScenarioCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                setPhaseToReleaseForLeakScenarioCalculationResponse.initialiseFromDictionary(jsonDoc)
+                setPhaseToReleaseForLeakScenarioCalculationResponse.initialiseFromDictionary(json)
 
                 self.zCoordUpdated = setPhaseToReleaseForLeakScenarioCalculationResponse.zCoordUpdated
                 self.holeHeightFractionUpdated = setPhaseToReleaseForLeakScenarioCalculationResponse.holeHeightFractionUpdated
                 self.resultCode = setPhaseToReleaseForLeakScenarioCalculationResponse.resultCode
                 self.messages = setPhaseToReleaseForLeakScenarioCalculationResponse.messages
                 self.calculationElapsedTime = setPhaseToReleaseForLeakScenarioCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the SetPhaseToReleaseForLeakScenario calculation object to print itself.
     def print(self):
 
@@ -9856,16 +9993,17 @@
         # Updated hole height fraction to accommodate requested phase to release
         self.holeHeightFractionUpdated = float(data['holeHeightFractionUpdated'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel leak flammable linked run h2 calculation.
 class VesselLeakFlammableLinkedRunH2CalculationRequest(object):
@@ -9924,15 +10062,15 @@
         # Number of confined explosion sources
         self.explosionConfinedVolumeCount = 0
 
 
 # Vessel leak flammable linked run h2 calculation class.
 class VesselLeakFlammableLinkedRunH2Calculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel definition
@@ -10077,22 +10215,22 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselLeakFlammableLinkedRunH2CalculationResponse = VesselLeakFlammableLinkedRunH2CalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselLeakFlammableLinkedRunH2CalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselLeakFlammableLinkedRunH2CalculationResponse.initialiseFromDictionary(json)
 
                 self.dischargeRecord = vesselLeakFlammableLinkedRunH2CalculationResponse.dischargeRecord
                 self.exitMaterial = vesselLeakFlammableLinkedRunH2CalculationResponse.exitMaterial
                 self.dischargeResult = vesselLeakFlammableLinkedRunH2CalculationResponse.dischargeResult
                 self.distancesToJetFireRadiation = vesselLeakFlammableLinkedRunH2CalculationResponse.distancesToJetFireRadiation
                 self.jetContourPoints = vesselLeakFlammableLinkedRunH2CalculationResponse.jetContourPoints
                 self.nJetCountourPoints = vesselLeakFlammableLinkedRunH2CalculationResponse.nJetCountourPoints
@@ -10111,31 +10249,31 @@
                 self.poolFireFlameResult = vesselLeakFlammableLinkedRunH2CalculationResponse.poolFireFlameResult
                 self.resultCode = vesselLeakFlammableLinkedRunH2CalculationResponse.resultCode
                 self.messages = vesselLeakFlammableLinkedRunH2CalculationResponse.messages
                 self.calculationElapsedTime = vesselLeakFlammableLinkedRunH2CalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselLeakFlammableLinkedRunH2 calculation object to print itself.
     def print(self):
 
@@ -10345,89 +10483,104 @@
         # Description for entry point parameter exitMaterial not found.
         self.exitMaterial.initialiseFromDictionary(data['exitMaterial'])
 
         # Description for entry point parameter dischargeResult not found.
         self.dischargeResult.initialiseFromDictionary(data['dischargeResult'])
 
         # Distances to jet fire radiation levels
-        for dataItem in data['distancesToJetFireRadiation']:
-            self.distancesToJetFireRadiation.append(float(dataItem))
+        if data['distancesToJetFireRadiation'] != None:
+            for dataItem in data['distancesToJetFireRadiation']:
+                self.distancesToJetFireRadiation.append(float(dataItem))
 
         # Ellipses to jet fire radiation levels
-        for dataItem in data['jetContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.jetContourPoints.append(localPosition)
+        if data['jetContourPoints'] != None:
+            for dataItem in data['jetContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.jetContourPoints.append(localPosition)
 
         # Number of contour points for jet fire ellipses per radiation level
-        for dataItem in data['nJetCountourPoints']:
+        if data['nJetCountourPoints'] != None:
+            for dataItem in data['nJetCountourPoints']:
                 self.nJetCountourPoints.append(int(dataItem))
 
         # Areas of jet fire ellipses
-        for dataItem in data['areaEllipseJet']:
-            self.areaEllipseJet.append(float(dataItem))
+        if data['areaEllipseJet'] != None:
+            for dataItem in data['areaEllipseJet']:
+                self.areaEllipseJet.append(float(dataItem))
 
         # Distances to concentration levels
-        for dataItem in data['distancesToConcentration']:
-            self.distancesToConcentration.append(float(dataItem))
+        if data['distancesToConcentration'] != None:
+            for dataItem in data['distancesToConcentration']:
+                self.distancesToConcentration.append(float(dataItem))
 
         # Concentration levels
-        for dataItem in data['concentrationsUsed']:
-            self.concentrationsUsed.append(float(dataItem))
+        if data['concentrationsUsed'] != None:
+            for dataItem in data['concentrationsUsed']:
+                self.concentrationsUsed.append(float(dataItem))
 
         # Maximum concentration footprints at given concentration levels
-        for dataItem in data['concContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.concContourPoints.append(localPosition)
+        if data['concContourPoints'] != None:
+            for dataItem in data['concContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.concContourPoints.append(localPosition)
 
         # Number of contour points per concentration level
-        for dataItem in data['nConcCountourPoints']:
+        if data['nConcCountourPoints'] != None:
+            for dataItem in data['nConcCountourPoints']:
                 self.nConcCountourPoints.append(int(dataItem))
 
         # Areas of maximum concentration footprints
-        for dataItem in data['areaFootprintConc']:
-            self.areaFootprintConc.append(float(dataItem))
+        if data['areaFootprintConc'] != None:
+            for dataItem in data['areaFootprintConc']:
+                self.areaFootprintConc.append(float(dataItem))
 
         # Distances to pool fire radiation levels
-        for dataItem in data['distancesToPoolFireRadiation']:
-            self.distancesToPoolFireRadiation.append(float(dataItem))
+        if data['distancesToPoolFireRadiation'] != None:
+            for dataItem in data['distancesToPoolFireRadiation']:
+                self.distancesToPoolFireRadiation.append(float(dataItem))
 
         # Ellipses to pool fire radiation levels
-        for dataItem in data['poolContourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.poolContourPoints.append(localPosition)
+        if data['poolContourPoints'] != None:
+            for dataItem in data['poolContourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.poolContourPoints.append(localPosition)
 
         # Number of contour points for pool fire ellipses per radiation level
-        for dataItem in data['nPoolCountourPoints']:
+        if data['nPoolCountourPoints'] != None:
+            for dataItem in data['nPoolCountourPoints']:
                 self.nPoolCountourPoints.append(int(dataItem))
 
         # Areas of pool fire ellipses
-        for dataItem in data['areaEllipsePool']:
-            self.areaEllipsePool.append(float(dataItem))
+        if data['areaEllipsePool'] != None:
+            for dataItem in data['areaEllipsePool']:
+                self.areaEllipsePool.append(float(dataItem))
 
         # Explosion overpressure results
-        for dataItem in data['explosionOverpressureResults']:
-            explosionOverpressureResult = ExplosionOverpressureResult()
-            explosionOverpressureResult.initialiseFromDictionary(dataItem)
-            self.explosionOverpressureResults.append(explosionOverpressureResult)
+        if data['explosionOverpressureResults'] != None:
+            for dataItem in data['explosionOverpressureResults']:
+                explosionOverpressureResult = ExplosionOverpressureResult()
+                explosionOverpressureResult.initialiseFromDictionary(dataItem)
+                self.explosionOverpressureResults.append(explosionOverpressureResult)
 
         # Flame results for jet fire
         self.jetFireFlameResult.initialiseFromDictionary(data['jetFireFlameResult'])
 
         # Flame results for pool fire
         self.poolFireFlameResult.initialiseFromDictionary(data['poolFireFlameResult'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a load mass inventory vessel for leak scenario calculation.
 class LoadMassInventoryVesselForLeakScenarioCalculationRequest(object):
@@ -10456,15 +10609,15 @@
         # Release angle
         self.releaseAngle = 0.0
 
 
 # Load mass inventory vessel for leak scenario calculation class.
 class LoadMassInventoryVesselForLeakScenarioCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel material
@@ -10526,48 +10679,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             loadMassInventoryVesselForLeakScenarioCalculationResponse = LoadMassInventoryVesselForLeakScenarioCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                loadMassInventoryVesselForLeakScenarioCalculationResponse.initialiseFromDictionary(jsonDoc)
+                loadMassInventoryVesselForLeakScenarioCalculationResponse.initialiseFromDictionary(json)
 
                 self.vessel = loadMassInventoryVesselForLeakScenarioCalculationResponse.vessel
                 self.leak = loadMassInventoryVesselForLeakScenarioCalculationResponse.leak
                 self.resultCode = loadMassInventoryVesselForLeakScenarioCalculationResponse.resultCode
                 self.messages = loadMassInventoryVesselForLeakScenarioCalculationResponse.messages
                 self.calculationElapsedTime = loadMassInventoryVesselForLeakScenarioCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the LoadMassInventoryVesselForLeakScenario calculation object to print itself.
     def print(self):
 
@@ -10642,16 +10795,17 @@
         # Leak scenario
         self.leak.initialiseFromDictionary(data['leak'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a max distance to conc calculation.
 class MaxDistanceToConcCalculationRequest(object):
@@ -10683,15 +10837,15 @@
         # Material with post-discharge composition
         self.material = Material()
 
 
 # Max distance to conc calculation class.
 class MaxDistanceToConcCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # UDM scalar outputs
@@ -10755,48 +10909,48 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             maxDistanceToConcCalculationResponse = MaxDistanceToConcCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                maxDistanceToConcCalculationResponse.initialiseFromDictionary(jsonDoc)
+                maxDistanceToConcCalculationResponse.initialiseFromDictionary(json)
 
                 self.concUsed = maxDistanceToConcCalculationResponse.concUsed
                 self.distance = maxDistanceToConcCalculationResponse.distance
                 self.resultCode = maxDistanceToConcCalculationResponse.resultCode
                 self.messages = maxDistanceToConcCalculationResponse.messages
                 self.calculationElapsedTime = maxDistanceToConcCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the MaxDistanceToConc calculation object to print itself.
     def print(self):
 
@@ -10872,16 +11026,17 @@
         # Maximum distance to concentration of interest
         self.distance = float(data['distance'])
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a vessel catastrophic rupture calculation.
 class VesselCatastrophicRuptureCalculationRequest(object):
@@ -10898,15 +11053,15 @@
         # Discharge parameters
         self.dischargeParameters = DischargeParameters()
 
 
 # Vessel catastrophic rupture calculation class.
 class VesselCatastrophicRuptureCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Vessel (pressurised or atmospheric)
@@ -10955,49 +11110,49 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             vesselCatastrophicRuptureCalculationResponse = VesselCatastrophicRuptureCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                vesselCatastrophicRuptureCalculationResponse.initialiseFromDictionary(jsonDoc)
+                vesselCatastrophicRuptureCalculationResponse.initialiseFromDictionary(json)
 
                 self.exitMaterial = vesselCatastrophicRuptureCalculationResponse.exitMaterial
                 self.dischargeResult = vesselCatastrophicRuptureCalculationResponse.dischargeResult
                 self.dischargeRecords = vesselCatastrophicRuptureCalculationResponse.dischargeRecords
                 self.resultCode = vesselCatastrophicRuptureCalculationResponse.resultCode
                 self.messages = vesselCatastrophicRuptureCalculationResponse.messages
                 self.calculationElapsedTime = vesselCatastrophicRuptureCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the VesselCatastrophicRupture calculation object to print itself.
     def print(self):
 
@@ -11063,25 +11218,27 @@
         # Composition of the released material (indentical to storage composition)
         self.exitMaterial.initialiseFromDictionary(data['exitMaterial'])
 
         # Scalar discharge results
         self.dischargeResult.initialiseFromDictionary(data['dischargeResult'])
 
         # Array of discharge record
-        for dataItem in data['dischargeRecords']:
-            dischargeRecord = DischargeRecord()
-            dischargeRecord.initialiseFromDictionary(dataItem)
-            self.dischargeRecords.append(dischargeRecord)
+        if data['dischargeRecords'] != None:
+            for dataItem in data['dischargeRecords']:
+                dischargeRecord = DischargeRecord()
+                dischargeRecord.initialiseFromDictionary(dataItem)
+                self.dischargeRecords.append(dischargeRecord)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
 
 
 # Request object for a radiation contour calculation.
 class RadiationContourCalculationRequest(object):
@@ -11107,15 +11264,15 @@
         # Settings of flammable contours view
         self.flammableOutputConfig = FlammableOutputConfig()
 
 
 # Radiation contour calculation class.
 class RadiationContourCalculation(Calculation):
 
-    	# Constructor.
+    # Constructor.
     def __init__(self):
 
         Calculation.__init__(self)
 
         # Calculation inputs.
 
         # Scalar flame results
@@ -11168,47 +11325,47 @@
 
         self.resultCode = ResultCode.UNEXPECTED_APPLICATION_ERROR
 
         response = Calculation.post_request(self, url, requestJson, getAccessToken())
 
         if response.ok:
 
-            jsonDoc = jsons.loads(response.text)
-            self.resultCode = ResultCode(jsonDoc['resultCode'])
+            json = jsons.loads(response.text)
+            self.resultCode = ResultCode(json['resultCode'])
 
             radiationContourCalculationResponse = RadiationContourCalculationResponse()
 
             if (self.resultCode == ResultCode.SUCCESS):
 
-                radiationContourCalculationResponse.initialiseFromDictionary(jsonDoc)
+                radiationContourCalculationResponse.initialiseFromDictionary(json)
 
                 self.contourPoints = radiationContourCalculationResponse.contourPoints
                 self.resultCode = radiationContourCalculationResponse.resultCode
                 self.messages = radiationContourCalculationResponse.messages
                 self.calculationElapsedTime = radiationContourCalculationResponse.calculationElapsedTime
 
             else:
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
         else:
 
             try:
 
-                jsonDoc = jsons.loads(response.text)
-                self.resultCode = ResultCode(jsonDoc['resultCode'])
+                json = jsons.loads(response.text)
+                self.resultCode = ResultCode(json['resultCode'])
 
-                for message in jsonDoc['messages']:
+                for message in json['messages']:
                     self.messages.append(message)
 
             except:
                 self.messages.append("No additional error information available")
 
-        self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
+            self.messages.append("%s (Status code: %3d)" % (response.reason, response.status_code))
 
         return self.resultCode
 
 
     # Utility method to get the RadiationContour calculation object to print itself.
     def print(self):
 
@@ -11263,23 +11420,25 @@
         self.calculationElapsedTime = 0.0
 
 
     # Initialise response with data from a dictionary.
     def initialiseFromDictionary(self, data: dict):
 
         # Array of contour points
-        for dataItem in data['contourPoints']:
-            localPosition = LocalPosition()
-            localPosition.initialiseFromDictionary(dataItem)
-            self.contourPoints.append(localPosition)
+        if data['contourPoints'] != None:
+            for dataItem in data['contourPoints']:
+                localPosition = LocalPosition()
+                localPosition.initialiseFromDictionary(dataItem)
+                self.contourPoints.append(localPosition)
 
         # Error code (0 = OK, < 0 data input error, > 0 execution error)
         self.resultCode = ResultCode(data['resultCode'])
 
         # Messages generated by the calculation.
-        for dataItem in data['messages']:
-            self.messages.append(dataItem)
+        if data['messages'] != None:
+            for dataItem in data['messages']:
+                self.messages.append(dataItem)
 
         # Time taken to run the calculation.
         self.calculationElapsedTime = float(data['calculationElapsedTime'])
```

### Comparing `pypws-2.5.6.0/src/pypws/constants.py` & `pypws-2.5.9.0/src/pypws/constants.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 #
 # This code has been auto-generated by the MDE Workbench
-# Version: 3.1.24.
+# Version: 3.1.28.
 #
 # File: constants.py
-# Date: 2023-03-16 16:04
-# Time: 16:04
+# Date: 2023-04-04 12:37
+# Time: 12:37
 #
 
 
 # Explosion located at the cloud front (LFL fraction)
 EXPL_LOCATION = 0
 
 # Uniform confined Multi Energy explosion method
```

### Comparing `pypws-2.5.6.0/src/pypws/enums.py` & `pypws-2.5.9.0/src/pypws/enums.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,259 +1,259 @@
 #
 # This code has been auto-generated by the MDE Workbench
-# Version: 3.1.24.
+# Version: 3.1.28.
 #
 # File: enums.py
-# Date: 2023-03-16 16:04
-# Time: 16:04
+# Date: 2023-04-04 12:37
+# Time: 12:37
 #
 
 
 from enum import IntEnum, unique
 
 
 # The vessel conditions expected by the user (Pure Gas = 1, NOT IN USE = 2, Stratified Two-Phase = 3 or Pressurised liquid = 4)
 @unique
 class VesselConditions(IntEnum):
 
-	# Pressurised gas vessel
+    # Pressurised gas vessel
 	PURE_GAS = 1
 
-	# Two phase vessel
+    # Two phase vessel
 	STRATIFIED_TWO_PHASE_VESSEL = 3
 
-	# Pressurised liquid vessel
+    # Pressurised liquid vessel
 	PRESSURIZED_LIQUID_VESSEL = 4
 
 
 # Fluid state specification
 @unique
 class FluidSpec(IntEnum):
 
-	# Specify all of P,T,LF
+    # Specify all of P,T,LF
 	PT_LF = 0
 
-	# Specify temperature and pressure
+    # Specify temperature and pressure
 	TP = 1
 
-	# Bubble point at fixed temperature
+    # Bubble point at fixed temperature
 	T_BUB = 2
 
-	# Bubble point at fixed pressure
+    # Bubble point at fixed pressure
 	P_BUB = 3
 
-	# Dew point at fixed temperature
+    # Dew point at fixed temperature
 	T_DEW = 4
 
-	# Dew point at fixed pressure
+    # Dew point at fixed pressure
 	P_DEW = 5
 
-	# Fixed pressure and liquid fraction
+    # Fixed pressure and liquid fraction
 	P_LF = 6
 
-	# Fixed temperature and liquid fraction
+    # Fixed temperature and liquid fraction
 	T_LF = 7
 
 # Luminous smoky flam
 @unique
 class LuminousSmokyFlame(IntEnum):
 
-	# Non flammable
+    # Non flammable
 	NON_FLAMMABLE = -1
 
-	# Luminous flame
+    # Luminous flame
 	LUMINOUS = 0
 
-	# Smoky flame
+    # Smoky flame
 	SMOKY = 1
 
-	# General type flame
+    # General type flame
 	GENERAL = 2
 
 # Vessel shape
 @unique
 class VesselShape(IntEnum):
 
-	# Vertical cylinder
+    # Vertical cylinder
 	VERTICAL_CYLINDER = 1
 
-	# Horizontal cylinder
+    # Horizontal cylinder
 	HORIZONTAL_CYLINDER = 2
 
-	# Sphere
+    # Sphere
 	VESSEL_SPHERE = 3
 
-	# Cuboid
+    # Cuboid
 	VESSEL_CUBOID = 4
 
 # Allow phase change upstream of orifice
 @unique
 class FlashAtOrifice(IntEnum):
 
-	# No phase change to the orifice
+    # No phase change to the orifice
 	NO_FLASH_AT_ORIFICE = 0
 
-	# Flashing allowed to the orifice
+    # Flashing allowed to the orifice
 	FLASH_ALLOWED = 1
 
-	# No flashing of liquid (metastable liquid)
+    # No flashing of liquid (metastable liquid)
 	DISALLOW_LIQUID_FLASH = 2
 
 # Fire type (NoFire = 0, Fireball = 1, Pool fire = 2, NOT IN USE = 3, Jet fire = 4, Multi-point source jet fire = 10)
 @unique
 class FireType(IntEnum):
 
-	# No fire
+    # No fire
 	NO_FIRE = 0
 
-	# Fireball
+    # Fireball
 	FIRE__BALL = 1
 
-	# Pool fire
+    # Pool fire
 	POOL = 2
 
-	# Cone jet fire
+    # Cone jet fire
 	CONE_JET = 4
 
-	# Multi-point [e.g. Miller] source jet fire model
+    # Multi-point [e.g. Miller] source jet fire model
 	MULTI_POINT_SOURCE_JET = 10
 
 # Flag to indicate if the material is flammable, toxic, both or inert
 @unique
 class FlammableToxic(IntEnum):
 
-	# Inert
+    # Inert
 	INERT = -2
 
-	# Toxic
+    # Toxic
 	TOXIC = -1
 
-	# Both
+    # Both
 	BOTH = 0
 
-	# Flammable
+    # Flammable
 	FLAMMABLE = 1
 
 # Type of release or cloud
 @unique
 class DynamicType(IntEnum):
 
-	# Unset.
+    # Unset.
 	UNSET = 0
 
-	# Instantaneous
+    # Instantaneous
 	INSTANTANEOUS = 1
 
-	# Continuous
+    # Continuous
 	CONTINUOUS = 2
 
-	# Time-varying
+    # Time-varying
 	TIME_VARYING = 3
 
 # Type of contour plot or grid
 @unique
 class ContourType(IntEnum):
 
-	# Footprint (XY plane)
+    # Footprint (XY plane)
 	FOOTPRINT = 1
 
-	# Footprint (XY plane) at given time
+    # Footprint (XY plane) at given time
 	FOOTPRINT_AT_TIME = 2
 
-	# Footprint ellipse (XY plane)
+    # Footprint ellipse (XY plane)
 	FOOTPRINT_ELLIPSE = 3
 
-	# Sideview (XZ plane)
+    # Sideview (XZ plane)
 	SIDEVIEW = 4
 
-	# Crosswind (YZ plane)
+    # Crosswind (YZ plane)
 	CROSSWIND = 5
 
-	# Flame shape footprint (XY plane)
+    # Flame shape footprint (XY plane)
 	FLAME_FOOTPRINT = 6
 
-	# Flame shape side view (XZ plane)
+    # Flame shape side view (XZ plane)
 	FLAME_SIDEVIEW = 7
 
-	# Flame shape crosswind (YZ plane)
+    # Flame shape crosswind (YZ plane)
 	FLAME_CROSSWIND = 8
 
 # Method for modelling a mixture (Pseudo component = 0, Multi-component with single aerosol = 1, NOT IN USE = 2, Multi-component with multiple aerosol = 3)
 @unique
 class MixtureModelling(IntEnum):
 
-	# Pseudo-component treatment of mixtures
+    # Pseudo-component treatment of mixtures
 	PC = 0
 
-	# Multi-component single aerosol 
+    # Multi-component single aerosol 
 	MC___SINGLE_AEROSOL = 1
 
-	# Multi-component multiple aerosol hybrid method
+    # Multi-component multiple aerosol hybrid method
 	MC___MULTIPLE_AEROSOL = 3
 
 # Surface type for pools and bunds
 @unique
 class PoolSurfaceType(IntEnum):
 
-	# Wet soil
+    # Wet soil
 	WET_SOIL = 1
 
-	# Dry soil
+    # Dry soil
 	DRY_SOIL = 2
 
-	# Concrete
+    # Concrete
 	CONCRETE = 3
 
-	# Insulated concrete
+    # Insulated concrete
 	INSULATED_CONCRETE = 4
 
-	# Deep open water
+    # Deep open water
 	DEEP_OPEN_WATER = 5
 
-	# Shallow open water
+    # Shallow open water
 	SHALLOW_OPEN_WATER = 6
 
-	# Deep river
+    # Deep river
 	DEEP_RIVER = 7
 
-	# Shallow river
+    # Shallow river
 	SHALLOW_RIVER = 8
 
 # Result codes returned from calls to the MDE.
 @unique
 class ResultCode(IntEnum):
 
-	# Validation fail
+    # Validation fail
 	FAIL___VALIDATION = -1
 
-	# Success
+    # Success
 	SUCCESS = 0
 
-	# Execution fail
+    # Execution fail
 	FAIL___EXECUTION = 1
 
-	# Unexpected application error encountered.
+    # Unexpected application error encountered.
 	UNEXPECTED_APPLICATION_ERROR = 21001
 
-	# Missing parameters.
+    # Missing parameters.
 	MISSING_PARAMETERS_ERROR = 21002
 
-	# No or invalid working directory specified.
+    # No or invalid working directory specified.
 	INVALID_WORKING_DIRECTORY_ERROR = 21003
 
-	# No or invalid application root directory specified.
+    # No or invalid application root directory specified.
 	INVALID_APP_ROOT_DIRECTORY_ERROR = 21004
 
-	# No or invalid MDE models directory specified.
+    # No or invalid MDE models directory specified.
 	INVALID_MDE_MODELS_DIRECTORY_ERROR = 21005
 
-	# MDE directory was correctly specified but the directory does not exist.
+    # MDE directory was correctly specified but the directory does not exist.
 	MDE_MODEL_DIRECTORY_NOT_FOUND_ERROR = 21006
 
-	# No or invalid physical properties directory specified.
+    # No or invalid physical properties directory specified.
 	INVALID_PROPERTY_SYSTEM_DIRECTORY_ERROR = 21007
 
 	INPUT_FILE_NOT_SPECIFIED_ERROR = 21008
 
 	INPUT_FILE_NOT_FOUND_ERROR = 21009
 
 	OUTPUT_FILE_NOT_SPECIFIED_ERROR = 21010
@@ -363,283 +363,283 @@
 	NO_DISPERSION_RECORDS_GENERATED_WARNING = 63002
 
 
 # Rainout and thermodynamic modelling
 @unique
 class RainoutThermoFlag(IntEnum):
 
-	# No rainout, equilibrium
+    # No rainout, equilibrium
 	NO_RAINOUT_EQUILIBRIUM = -1
 
-	# Rainout, equilibrium
+    # Rainout, equilibrium
 	RAINOUT_EQUILIBRIUM = 1
 
-	# Rainout, non-equilibrium
+    # Rainout, non-equilibrium
 	RAINOUT_NON_EQUILIBRIUM = 2
 
 # Determines whether an entity is globally or workspace scoped.
 @unique
 class Scope(IntEnum):
 
-	# Entity has global scope.
+    # Entity has global scope.
 	GLOBAL = 1
 
-	# Entity has workspace scope.
+    # Entity has workspace scope.
 	WORKSPACE = 2
 
 # Choice of input to vary to achieve target design
 @unique
 class DesignVariable(IntEnum):
 
-	# The length of the flare stack
+    # The length of the flare stack
 	PIPE_LENGTH = 1
 
-	# The diameter of the flare stack
+    # The diameter of the flare stack
 	PIPE_DIAMETER = 2
 
-	# The driving pressure in the tank feeding the flare stack
+    # The driving pressure in the tank feeding the flare stack
 	OPERATING_PRESSURE = 3
 
 # Dynamic modelling of leaks and lines
 @unique
 class TimeVaryingOption(IntEnum):
 
-	# Use initial rate
+    # Use initial rate
 	INITIAL_RATE = 1
 
-	# Use time-varying rates
+    # Use time-varying rates
 	TIME_VARYING_RATE = 2
 
 # MEConfinedMethod
 @unique
 class MEConfinedMethod(IntEnum):
 
-	# User defined method
+    # User defined method
 	USER_DEFINED = 1
 
-	# Uniform confined method
+    # Uniform confined method
 	UNIFORM_CONFINED = 3
 
 # Type of toxic result
 @unique
 class ToxicResultType(IntEnum):
 
-	# Toxic result type not set.
+    # Toxic result type not set.
 	UNSET = 0
 
-	# Probability of death
+    # Probability of death
 	TOXIC_LETHALITY = 1
 
-	# Toxic probit number
+    # Toxic probit number
 	TOXIC_PROBIT = 2
 
-	# Toxic dose
+    # Toxic dose
 	TOXIC_DOSE = 3
 
 # Pool fire type
 @unique
 class PoolFireType(IntEnum):
 
-	# Immediate pool fire
+    # Immediate pool fire
 	IMMEDIATE = 0
 
-	# Early pool fire
+    # Early pool fire
 	EARLY = 1
 
-	# Late pool fire
+    # Late pool fire
 	LATE = 2
 
 # Flag for whether we want to deploy (=1) or disable (=0) solid modelling. In addition to this flag, each component has its own allowSolids flag.
 @unique
 class SolidModelling(IntEnum):
 
-	# Solid modelling will not be used, even if it is allowed by the component in question
+    # Solid modelling will not be used, even if it is allowed by the component in question
 	DISABLE_SOLID_MODELLING = 0
 
-	# Solid modelling will be deployed if it is supported by the component in question
+    # Solid modelling will be deployed if it is supported by the component in question
 	DEPLOY_SOLID_MODELLING = 1
 
 # Type of result for design constraint
 @unique
 class TargetVariable(IntEnum):
 
-	# Specify a target mass flow rate
+    # Specify a target mass flow rate
 	MASS_FLOW_RATE = 1
 
-	# Specify a target expanded release velocity
+    # Specify a target expanded release velocity
 	EXPANDED_RELEASE_VELOCITY = 2
 
-	# Specify a target pipe exit pressure
+    # Specify a target pipe exit pressure
 	PIPE_EXIT_PRESSURE = 3
 
-	# Specify a target radiation level at the endpoint of the radiation transect
+    # Specify a target radiation level at the endpoint of the radiation transect
 	RADIATION_LEVEL_TRANSECT_ENDPOINT = 4
 
 # Concentrations of interest
 @unique
 class SpecialConcentration(IntEnum):
 
-	# Not Defined
+    # Not Defined
 	NOT_DEFINED = 0
 
-	# LFL Fraction
+    # LFL Fraction
 	LFL_FRACTION = 1
 
-	# LFL
+    # LFL
 	LFL = 2
 
-	# UFL
+    # UFL
 	UFL = 3
 
-	# Minimum concentration
+    # Minimum concentration
 	MIN = 4
 
 # Output resolution (and performance)
 @unique
 class Resolution(IntEnum):
 
-	# High
+    # High
 	HIGH = 1
 
-	# Medium
+    # Medium
 	MEDIUM = 2
 
-	# Low
+    # Low
 	LOW = 3
 
-	# Very high
+    # Very high
 	VERY_HIGH = 4
 
-	# Extremely high
+    # Extremely high
 	EXTREME = 5
 
 # Fluid phase (vapour, liquid or two-phase)
 @unique
 class Phase(IntEnum):
 
-	# Unset.
+    # Unset.
 	UNSET = 0
 
-	# Vapour
+    # Vapour
 	VAPOUR = 1
 
-	# Two-phase
+    # Two-phase
 	TWO_PHASE = 2
 
-	# Liquid
+    # Liquid
 	LIQUID = 3
 
 # Flag to indicate wheather we are in day or nightime
 @unique
 class DayNight(IntEnum):
 
-	# Day/night flag not set.
+    # Day/night flag not set.
 	UNSET = 0
 
-	# Day
+    # Day
 	DAY = 1
 
-	# Night
+    # Night
 	NIGHT = 2
 
 # Dispersing surface type (land or water)
 @unique
 class SurfaceType(IntEnum):
 
-	# Dispersion over land
+    # Dispersion over land
 	LAND = 1
 
-	# Dispersion over water
+    # Dispersion over water
 	WATER = 2
 
 # Release direction
 @unique
 class ReleaseDirection(IntEnum):
 
-	# Horizontal
+    # Horizontal
 	HORIZONTAL = 0
 
-	# Vertical
+    # Vertical
 	VERTICAL = 1
 
 # Radiation type
 @unique
 class RadiationType(IntEnum):
 
-	# Radiation type not set.
+    # Radiation type not set.
 	UNSET = 0
 
-	# Radiation dose
+    # Radiation dose
 	DOSE = 1
 
-	# Radiation probit
+    # Radiation probit
 	PROBIT = 2
 
-	# Radiation lethality
+    # Radiation lethality
 	LETHALITY = 3
 
-	# View factor
+    # View factor
 	VIEW_FACTOR = 4
 
-	# Radiation intensity
+    # Radiation intensity
 	INTENSITY = 5
 
 # Choice of property template
 @unique
 class PropertyTemplate(IntEnum):
 
-	# The PhastMC is the default Phast template
+    # The PhastMC is the default Phast template
 	PHAST_MC = 100
 
-	# Old default Phast property template
+    # Old default Phast property template
 	PHAST_64 = 101
 
-	# Acid association template for modelling reactive Hydrogen Fluoride
+    # Acid association template for modelling reactive Hydrogen Fluoride
 	ACID_ASSOCIATION = 102
 
-	# Template using the Soave-Redlich-Kwong cubic equation of state
+    # Template using the Soave-Redlich-Kwong cubic equation of state
 	SOAVE_REDLICK_KWONG = 103
 
-	# Template using the Peng-Robinson cubic equation of state
+    # Template using the Peng-Robinson cubic equation of state
 	PENG_ROBINSON = 104
 
-	# The Peng-Robinson template but with ideal fugacities for improved robustness
+    # The Peng-Robinson template but with ideal fugacities for improved robustness
 	PR_IDEAL_FUGACITY = 106
 
-	# The Soave-Redlich-Kwong template but with ideal fugacities for improved robustness
+    # The Soave-Redlich-Kwong template but with ideal fugacities for improved robustness
 	SRK_IDEAL_FUGACITY = 107
 
 # Atmospheric stability classes.
 @unique
 class AtmosphericStabilityClass(IntEnum):
 
-	# A
+    # A
 	STABILITY_A = 1
 
-	# A/B
+    # A/B
 	STABILITY_AB = 2
 
-	# B
+    # B
 	STABILITY_B = 3
 
-	# B/C
+    # B/C
 	STABILITY_BC = 4
 
-	# C
+    # C
 	STABILITY_C = 5
 
-	# C/D
+    # C/D
 	STABILITY_CD = 6
 
-	# D
+    # D
 	STABILITY_D = 7
 
-	# E
+    # E
 	STABILITY_E = 8
 
-	# F
+    # F
 	STABILITY_F = 9
 
-	# G
+    # G
 	STABILITY_G = 10
```

### Comparing `pypws-2.5.6.0/src/pypws/utilities.py` & `pypws-2.5.9.0/src/pypws/utilities.py`

 * *Files 3% similar despite different names*

```diff
@@ -41,33 +41,46 @@
     if (accessTokenFileName == None):
         print("Unable to obtain the license file.")
         sys.exit()
 
     return accessTokenFileName
 
 # Post json to url and time the call
-def postRequest(url, json) -> Response:
+def postRequest(url, data) -> Response:
 
     headers = {
         'Content-Type': 'application/json',
         'Authorization': 'Bearer {}'.format(getAccessToken())
     }
 
-    response = requests.post(url, json=json, headers=headers, verify=True)
+    response = requests.post(url, data=data, headers=headers, verify= 'localhost' not in url)
+
+    return response
+
+
+# Post json to url and time the call
+def putRequest(url, data) -> Response:
+
+    headers = {
+        'Content-Type': 'application/json',
+        'Authorization': 'Bearer {}'.format(getAccessToken())
+    }
+
+    response = requests.put(url, data=data, headers=headers, verify= 'localhost' not in url)
 
     return response
 
 def getRequest(url) -> Response:
 
     headers = {
         'Content-Type': 'application/json',
         'Authorization': 'Bearer {}'.format(getAccessToken())
     }
 
-    response = requests.get(url, headers=headers, verify=True)
+    response = requests.get(url, headers=headers, verify = 'localhost' not in url)
 
     return response
 
 def getAccessToken():
 
     print('Looking for access token in PYPWS_ACCESS_TOKEN environment variable')
     
@@ -200,15 +213,15 @@
 
     analyticsApiRoot = f'{getApiRoot()}analytics/v{getApiVersion()}/'
     print (f'Using Analytics API: {analyticsApiRoot}')
     return analyticsApiRoot
 
 def getMaterialsApiTarget() -> str:
 
-    materialsApiRoot = f'{getApiRoot()}materials/v{getApiVersion()}/'
+    materialsApiRoot = f'{getApiRoot()}materials-storage/v{getApiVersion()}/'
     print (f'Using Materials API: {materialsApiRoot}')
     return materialsApiRoot
 
 def getClientAliasId() -> str:
  
     clientAliasId = os.getenv('PYPWS_CLIENT_ALIAS_ID')
```

### Comparing `pypws-2.5.6.0/tests/Bund_avg_time.py` & `pypws-2.5.9.0/tests/Bund_avg_time.py`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/tests/flash_ammonia.py` & `pypws-2.5.9.0/tests/flash_ammonia.py`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/tests/flash_ammonia.zip` & `pypws-2.5.9.0/tests/flash_ammonia.zip`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/tests/test_peteABS_mod.py` & `pypws-2.5.9.0/tests/test_peteABS_mod.py`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/tests/test_workflow1.py` & `pypws-2.5.9.0/tests/test_workflow1.py`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/.gitignore` & `pypws-2.5.9.0/.gitignore`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/LICENSE` & `pypws-2.5.9.0/LICENSE`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/README.md` & `pypws-2.5.9.0/README.md`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/pyproject.toml` & `pypws-2.5.9.0/pyproject.toml`

 * *Files identical despite different names*

### Comparing `pypws-2.5.6.0/PKG-INFO` & `pypws-2.5.9.0/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pypws
-Version: 2.5.6.0
+Version: 2.5.9.0
 Summary: Python library supporting Phast Web Services
 Project-URL: Homepage, https://phastwebservices.dnv.com
 Project-URL: Phast Desktop, https://www.dnv.com/software/services/plant/consequence-analysis.html
 Project-URL: Reference help, https://pwsassets.blob.core.windows.net/prod/PyPws.pdf
 Author-email: DNV <software.support@dnv.com>
 License-File: LICENSE
 Keywords: CPQRA,Consequence Analysis,DNV,Discharge,Dispersion,Explosion,Fire,Flammable,Gas,Hazard,Phast,QRA,Toxic
```

